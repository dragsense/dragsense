window["AlloyEditor"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/adapter/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.8.5
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' ||
  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;
    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;
          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;
              default:
                return $$typeof;
            }
        }
      case REACT_LAZY_TYPE:
      case REACT_MEMO_TYPE:
      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
}

// AsyncMode is deprecated along with isAsyncMode
var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;

var hasWarnedAboutDeprecatedIsAsyncMode = false;

// AsyncMode should be deprecated
function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true;
      lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }
  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.typeOf = typeOf;
exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isValidElementType = isValidElementType;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./src/adapter/core.js":
/*!*****************************!*\
  !*** ./src/adapter/core.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

__webpack_require__(/*! ../core */ "./src/core/index.js");

__webpack_require__(/*! ../plugins */ "./src/plugins/index.js");

__webpack_require__(/*! ../components/uibridge */ "./src/components/uibridge/index.js");

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _commands = __webpack_require__(/*! ../commands */ "./src/commands/index.js");

var _main = __webpack_require__(/*! ../components/main.jsx */ "./src/components/main.jsx");

var _main2 = _interopRequireDefault(_main);

var _base = __webpack_require__(/*! ../oop/base */ "./src/oop/base.js");

var _base2 = _interopRequireDefault(_base);

var _lang = __webpack_require__(/*! ../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _oop = __webpack_require__(/*! ../oop/oop */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

var _selections = __webpack_require__(/*! ../selections/selections */ "./src/selections/selections.js");

var _selections2 = _interopRequireDefault(_selections);

var _editorContext = __webpack_require__(/*! ./editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var EMBED_VIDEO_WIDTH = 560;
var EMBED_VIDEO_HEIGHT = 315;

/**
 * AlloyEditor main class. Creates instance of the editor and provides the user configuration
 * to the UI.
 *
 * @class Core
 * @constructor
 * @param {Object} config The configuration to be used.
 */
function Core(config) {
	Core.superclass.constructor.call(this, config);
}

(0, _oop2.default)(Core, _base2.default, {
	/**
  * Initializer lifecycle implementation for the AlloyEditor class. Creates a CKEditor
  * instance, passing it the provided configuration attributes.
  *
  * @memberof Core
  * @instance
  * @protected
  * @method initializer
  * @param {Object} config Configuration object literal for the editor.
  */
	initializer: function initializer(config) {
		var _this = this;

		var node = this.get('srcNode');

		if (this.get('enableContentEditable')) {
			node.setAttribute('contenteditable', 'true');
		}

		var editor = CKEDITOR.inline(node);

		editor.config.allowedContent = this.get('allowedContent');

		editor.config.toolbars = this.get('toolbars');

		editor.config.removePlugins = this.get('removePlugins');

		editor.config.extraPlugins = this.get('extraPlugins');

		editor.config.embedProviders = this.get('embedProviders');

		editor.config.placeholderClass = this.get('placeholderClass');

		editor.config.pasteFromWordRemoveStyles = false;
		editor.config.pasteFromWordRemoveFontStyles = false;

		editor.config.selectionKeystrokes = this.get('selectionKeystrokes');

		editor.config.spritemap = this.get('spritemap');

		_lang2.default.mix(editor.config, config);

		if (CKEDITOR.env.ie && !CKEDITOR.env.edge) {
			var plugin = 'ae_dragresize_ie11';

			editor.config.extraPlugins = editor.config.extraPlugins.replace('ae_dragresize', plugin);
			editor.config.removePlugins = editor.config.removePlugins.replace('ae_dragresize', plugin);
		}

		editor.once('contentDom', function () {
			_this._addReadOnlyLinkClickListener(editor);

			var editable = editor.editable();

			var extraCommands = _this.get('extraCommands');

			var extraCommandKeys = Object.keys(extraCommands);
			for (var i = 0; i < extraCommandKeys.length; i++) {
				var commandName = extraCommandKeys[i];

				if (editor.commands[commandName]) {
					continue;
				}

				editor.addCommand(commandName, extraCommands[commandName]);
			}

			editable.addClass('ae-editable');
		});

		this._editor = editor;

		AlloyEditor.loadLanguageResources(this._renderUI.bind(this));
	},


	/**
  * Destructor lifecycle implementation for the AlloyEdtor class. Destroys the CKEditor
  * instance and destroys all created toolbars.
  *
  * @memberof Core
  * @instance
  * @protected
  * @method destructor
  */
	destructor: function destructor() {
		this._destroyed = true;

		if (this._editorUIElement) {
			_reactDom2.default.unmountComponentAtNode(this._editorUIElement);
			this._editorUIElement.parentNode.removeChild(this._editorUIElement);
		}

		var nativeEditor = this.get('nativeEditor');

		if (nativeEditor) {
			var editable = nativeEditor.editable();

			if (editable) {
				editable.removeClass('ae-editable');

				if (this.get('enableContentEditable')) {
					this.get('srcNode').setAttribute('contenteditable', 'false');
				}
			}

			this._clearSelections();

			nativeEditor.destroy();
		}
	},


	/**
  * Clear selections from window object
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _clearSelections
  */
	_clearSelections: function _clearSelections() {
		var nativeEditor = this.get('nativeEditor');
		var isMSSelection = typeof window.getSelection != 'function';

		if (nativeEditor.document) {
			if (isMSSelection) {
				nativeEditor.document.$.selection.empty();
			} else {
				nativeEditor.document.getWindow().$.getSelection().removeAllRanges();
			}
		}
	},


	/**
  * Method to set default link behavior
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _addReadOnlyLinkClickListener
  * @param {Object} editor
  */
	_addReadOnlyLinkClickListener: function _addReadOnlyLinkClickListener(editor) {
		editor.editable().on('click', this._defaultReadOnlyClickFn, this, {
			editor: editor
		});
	},


	/**
  * Called on `click` event when the editor is in read only mode. Navigates to link's URL or opens
  * the link in a new window.
  *
  * @memberof Core
  * @instance
  * @event readOnlyClick
  * @protected
  * @method _defaultReadOnlyClickFn
  * @param {Object} event The fired `click` event payload
  */
	_defaultReadOnlyClickFn: function _defaultReadOnlyClickFn(event) {
		var mouseEvent = event.data.$;
		var hasCtrlKey = mouseEvent.ctrlKey || mouseEvent.metaKey;
		var shouldOpen = this._editor.config.readOnly || hasCtrlKey;

		mouseEvent.preventDefault();

		if (!shouldOpen) {
			return;
		}

		if (event.listenerData.editor.editable().editor.fire('readOnlyClick', event.data) !== false) {
			var ckElement = new CKEDITOR.dom.elementPath(event.data.getTarget(), this);
			var link = ckElement.lastElement;

			if (link) {
				var href = link.$.attributes.href ? link.$.attributes.href.value : null;
				var target = hasCtrlKey ? '_blank' : link.$.attributes.target ? link.$.attributes.target.value : null;
				this._redirectLink(href, target);
			}
		}
	},


	/**
  * Retrieves the native CKEditor instance. Having this, the developer may use the API of CKEditor OOTB.
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _getNativeEditor
  * @return {Object} The current instance of CKEditor.
  */
	_getNativeEditor: function _getNativeEditor() {
		return this._editor;
	},


	/**
  * Redirects the browser to a given link
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _redirectLink
  * @param {string} href The href to take the browser to
  * @param {string=} target Specifies where to display the link
  */
	_redirectLink: function _redirectLink(href, target) {
		if (target && href) {
			window.open(href, target);
		} else if (href) {
			window.location.href = href;
		}
	},


	/**
  * Renders the specified from the user toolbars.
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _renderUI
  */
	_renderUI: function _renderUI() {
		var _this2 = this;

		if (!this._destroyed) {
			var editorUIElement = document.createElement('div');
			editorUIElement.className = 'ae-ui';

			var uiNode = this.get('uiNode') || document.body;

			uiNode.appendChild(editorUIElement);

			var callbackRef = function callbackRef(element) {
				if (!_this2._mainUI && element) {
					_this2._mainUI = element;
					_this2.get('nativeEditor').fire('uiReady');
				}
			};

			_reactDom2.default.render(_react2.default.createElement(
				_editorContext2.default.Provider,
				{ value: { editor: this } },
				_react2.default.createElement(_main2.default, {
					eventsDelay: this.get('eventsDelay'),
					ref: callbackRef,
					toolbars: this.get('toolbars')
				})
			), editorUIElement);

			this._editorUIElement = editorUIElement;
		}
	},


	/**
  * The function returns an HTML element from the passed value. If the passed value is a string, it should be
  * the Id of the element which have to be retrieved from the DOM.
  * If an HTML Element is passed, the element itself will be returned.
  *
  * @memberof Core
  * @instance
  * @method _toElement
  * @protected
  * @param {!(String|HTMLElement)} value String, which have to correspond to an HTML element from the DOM,
  * or the HTML element itself. If Id is passed, the HTML element will be retrieved from the DOM.
  * @return {HTMLElement} An HTML element.
  */
	_toElement: function _toElement(value) {
		if (_lang2.default.isString(value)) {
			value = document.getElementById(value);
		}

		return value;
	},


	/**
  * Validates the allowed content attribute. Look
  * [here](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-allowedContent) for more information about the
  * supported values.
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _validateAllowedContent
  * @param {Any} value The value to be checked
  * @return {Boolean} True if the current value is valid configuration, false otherwise
  */
	_validateAllowedContent: function _validateAllowedContent(value) {
		return _lang2.default.isString(value) || _lang2.default.isObject(value) || _lang2.default.isBoolean(value);
	},


	/**
  * Validates the value of toolbars attribute
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _validateToolbars
  * @param {Any} value The value to be checked
  * @return {Boolean} True if the current value is valid toolbars configuration, false otherwise
  */
	_validateToolbars: function _validateToolbars(value) {
		return _lang2.default.isObject(value) || _lang2.default.isNull(value);
	}
}, {
	ATTRS: {
		/**
   * Configures the allowed content for the current instance of AlloyEditor.
   * Look on the [official CKEditor API](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-allowedContent)
   * for more information about the valid values.
   *
   * @memberof Core
   * @instance
   * @property allowedContent
   * @default true
   * @writeOnce
   * @type {Boolean, String, Object}
   */
		allowedContent: {
			validator: '_validateAllowedContent',
			value: true,
			writeOnce: true
		},

		/**
   * Callback to be invoked when clicking on the
   * <code>src/components/buttons/button-link-edit-browse.jsx</code>
   * component.
   *
   * @memberof Core
   * @instance
   * @propety documentBrowseLinkCallback
   * @default undefined
   * @type {Function|undefined}
   */
		documentBrowseLinkCallback: {
			validator: _lang2.default.isFunction,
			value: undefined
		},

		/**
   * Configuration for the
   * <code>src/components/buttons/button-link-edit-browse.jsx</code>
   * component.
   *
   * @memberof Core
   * @instance
   * @propety documentBrowseLinkUrl
   * @default undefined
   * @type {String|undefined}
   */
		documentBrowseLinkUrl: {
			validator: _lang2.default.isString,
			value: undefined
		},

		/**
   * List of embed providers for videos
   *
   * @memberof Core
   * @instance
   * @property embedProviders
   * @default []
   * @type Array}
   */
		embedProviders: {
			validator: _lang2.default.isArray,
			value: [{
				id: 'facebook',
				tpl: '<iframe allowFullScreen="true" allowTransparency="true"\n\t\t\t\t\t\t\t\t\t\t\t\t frameborder="0" height="' + EMBED_VIDEO_HEIGHT + '"\n\t\t\t\t\t\t\t\t\t\t\t\t src="https://www.facebook.com/plugins/video.php?href={embedId}\'\n\t\t\t\t\t\t\t\t\t\t\t\t &show_text=0&width=' + EMBED_VIDEO_WIDTH + '&height=' + EMBED_VIDEO_HEIGHT + '" scrolling="no"\n\t\t\t\t\t\t\t\t\t\t\t\t style="border:none;overflow:hidden" width="' + EMBED_VIDEO_WIDTH + '}"></iframe>',
				type: 'video',
				urlSchemes: ['(https?:\\/\\/(?:www\\.)?facebook.com\\/\\S*\\/videos\\/\\S*)']
			}, {
				id: 'twitch',
				tpl: '<iframe allowfullscreen="true" frameborder="0"\n\t\t\t\t\t\t\t\t\t\t\t\t height="' + EMBED_VIDEO_HEIGHT + '"\n\t\t\t\t\t\t\t\t\t\t\t\t src="https://player.twitch.tv/?autoplay=false&video={embedId}"\n\t\t\t\t\t\t\t\t\t\t\t\t scrolling="no" width="' + EMBED_VIDEO_WIDTH + '"></iframe>',
				type: 'video',
				urlSchemes: ['https?:\\/\\/(?:www\\.)?twitch.tv\\/videos\\/(\\S*)$']
			}, {
				id: 'vimeo',
				tpl: '<iframe allowfullscreen frameborder="0" height="' + EMBED_VIDEO_HEIGHT + '"\n\t\t\t\t\t\t\t\t\t\t\t\t mozallowfullscreen src="https://player.vimeo.com/video/{embedId}"\n\t\t\t\t\t\t\t\t\t\t\t\t webkitallowfullscreen width="' + EMBED_VIDEO_WIDTH + '"></iframe>',
				type: 'video',
				urlSchemes: ['https?:\\/\\/(?:www\\.)?vimeo\\.com\\/album\\/.*\\/video\\/(\\S*)', 'https?:\\/\\/(?:www\\.)?vimeo\\.com\\/channels\\/.*\\/(\\S*)', 'https?:\\/\\/(?:www\\.)?vimeo\\.com\\/groups\\/.*\\/videos\\/(\\S*)', 'https?:\\/\\/(?:www\\.)?vimeo\\.com\\/(\\S*)$']
			}, {
				id: 'youtube',
				tpl: '<iframe allow="autoplay; encrypted-media" allowfullscreen\n\t\t\t\t\t\t\t\t\t\t\t\t height="' + EMBED_VIDEO_HEIGHT + '" frameborder="0"\n\t\t\t\t\t\t\t\t\t\t\t\t src="https://www.youtube.com/embed/{embedId}?rel=0"\n\t\t\t\t\t\t\t\t\t\t\t\t width="' + EMBED_VIDEO_WIDTH + '"></iframe>',
				type: 'video',
				urlSchemes: ['https?:\\/\\/(?:www\\.)?youtube.com\\/watch\\?v=(\\S*)$']
			}]
		},

		/**
   * Specifies whether AlloyEditor set the contenteditable attribute
   * to "true" on its srcNode.
   *
   * @memberof Core
   * @instance
   * @property enableContentEditable
   * @type Boolean
   * @default true
   * @writeOnce
   */
		enableContentEditable: {
			validator: _lang2.default.isBoolean,
			value: true,
			writeOnce: true
		},

		/**
   * The delay (timeout), in ms, after which events such like key or mouse events will be processed.
   *
   * @memberof Core
   * @instance
   * @property eventsDelay
   * @type {Number}
   */
		eventsDelay: {
			validator: _lang2.default.isNumber,
			value: 100
		},

		/**
   * The list of extra commands to be added to the editor.
   *
   * @memberof Core
   * @instance
   * @property extraCommands
   * @type {Object}
   */
		extraCommands: {
			validator: _lang2.default.isObject,
			value: {
				removeImage: _commands.removeImageCommand
			},
			writeOnce: true
		},

		/**
   * Specifies the extra plugins which have to be loaded to the current CKEditor instance in order to
   * make AlloyEditor to work properly.
   *
   * @memberof Core
   * @instance
   * @property extraPlugins
   * @default 'uicore,selectionregion,dragresize,addimages,placeholder,tabletools,tableresize,autolink'
   * @writeOnce
   * @type {String}
   */
		extraPlugins: {
			validator: _lang2.default.isString,
			value: 'ae_uicore,ae_selectionregion,ae_selectionkeystrokes,ae_imagealignment,ae_addimages,ae_placeholder,' + 'ae_tabletools,ae_tableresize,ae_autolink,ae_embed,ae_autolist,ae_dragresize,' + 'ae_uibridge,ae_richcombobridge,ae_panelmenubuttonbridge,ae_menubridge,ae_menubuttonbridge,ae_buttonbridge,font,colorbutton',
			writeOnce: true
		},

		/**
   * Specifies the "mode" for alloy editor
   * @memberof Core
   * @instance
   * @property mode
   * @default 'simple'
   * @writeOnce
   * @type {String}
   */
		mode: {
			validator: _lang2.default.isString,
			value: 'simple'
		},

		/**
   * Retrieves the native CKEditor instance. Having this, the developer may use the full API of CKEditor.
   *
   * @memberof Core
   * @instance
   * @property nativeEditor
   * @readOnly
   * @type {Object}
   */
		nativeEditor: {
			getter: '_getNativeEditor',
			readOnly: true
		},

		/**
   * Specifies the class, which should be added by Placeholder plugin
   * {{#crossLink "CKEDITOR.plugins.ae_placeholder}}{{/crossLink}}
   * when editor is not focused.
   *
   * @memberof Core
   * @instance
   * @property placeholderClass
   * @default 'ae-placeholder'
   * @writeOnce
   * @type {String}
   */
		placeholderClass: {
			validator: _lang2.default.isString,
			value: 'ae-placeholder',
			writeOnce: true
		},

		/**
   * Specifies the plugins, which come by default with CKEditor, but which are not needed by AlloyEditor.
   * These plugins add the default UI for CKeditor, which is no more needed. Please note that AlloyEdtor
   * comes with its own highly optimized copy of CKEditor (just customized via their official download page).
   * This version does not come with the unneeded plugins, so the value of this property won't be needed.
   * However, if you decide to go with the OOTB version of CKEditor, you will have to remove some of the
   * plugins if you decide to use AlloyEditor. Keep in mind that removing these plugins doesn't remove them
   * entirely from CKEditor. It just removes them from its current instance, in which you will use different
   * UI - those of AlloyEditor. You will be fully able to use both OOTB CKEditor and AlloyEditor on the same
   * page!
   *
   * @memberof Core
   * @instance
   * @property removePlugins
   * @default 'contextmenu,toolbar,elementspath,resize,liststyle,link'
   * @writeOnce
   * @type {String}
   */
		removePlugins: {
			validator: _lang2.default.isString,
			value: 'contextmenu,toolbar,elementspath,resize,liststyle,link',
			writeOnce: true
		},

		/**
   * Array of manual selection triggers. They can be configured to manually show a specific selection toolbar
   * by forcing the selection type. A selectionKeystroke item consists of a keys property with a [CKEditor keystroke
   * definition](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-keystrokes) and a selection property with
   * the selection name to trigger.
   *
   * @memberof Core
   * @instance
   * @property selectionKeystrokes
   * @type {Array}
   */
		selectionKeystrokes: {
			validator: _lang2.default.isArray,
			value: [{
				keys: CKEDITOR.CTRL + 76 /* L*/
				, selection: 'link'
			}, {
				keys: CKEDITOR.CTRL + CKEDITOR.SHIFT + 76 /* L*/
				, selection: 'embed'
			}]
		},

		/**
   * The path to the spritemap SVG used for icons
   *
   * @memberof Core
   * @instance
   * @property spritemap
   * @type String
   * @writeOnce
   */
		spritemap: {
			validator: _lang2.default.isString,
			value: (window.ALLOYEDITOR_BASEPATH || 'alloy-editor/') + 'assets/icons/icons.svg',
			writeOnce: true
		},

		/**
   * The Node ID or HTMl node, which AlloyEditor should use as an editable area.
   *
   * @memberof Core
   * @instance
   * @property srcNode
   * @type String | Node
   * @writeOnce
   */
		srcNode: {
			setter: '_toElement',
			writeOnce: true
		},

		/**
   * The toolbars configuration for this editor instance
   *
   * @memberof Core
   * @instance
   * @property {Object} toolbars
   */
		toolbars: {
			validator: '_validateToolbars',
			value: {
				add: {
					buttons: ['imageFromFile', 'embed', 'camera', 'hline', 'table'],
					tabIndex: 2
				},
				styles: {
					selections: _selections2.default,
					tabIndex: 1
				}
			}
		},

		/**
   * The Node ID or HTMl node, where AlloyEditor's UI should be rendered.
   *
   * @memberof Core
   * @instance
   * @property uiNode
   * @type String | Node
   * @writeOnce
   */
		uiNode: {
			setter: '_toElement',
			writeOnce: true
		}
	}
});

CKEDITOR.event.implementOn(Core);

exports.default = Core;

/***/ }),

/***/ "./src/adapter/editor-context.js":
/*!***************************************!*\
  !*** ./src/adapter/editor-context.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**
                                                                                                                                                                                                                                                                   * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                   * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                   */

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * React context to avoid explicitly passing the editor instance all
 * through the component hierarchy via props.
 */
var EditorContext = _react2.default.createContext({});

/**
 * Helper that passes the editor context in via a prop.
 *
 * Context can only be accessed in `render()` and in lifecycle methods
 * (`componentDidMount()` etc). If a component needs to access context
 * elsewhere, such as in a constructor, the context needs to be passed
 * in via a prop.
 */
EditorContext.toProps = function (Component) {
  var forwardingComponent = _react2.default.forwardRef(function (props, ref) {
    return _react2.default.createElement(
      EditorContext.Consumer,
      null,
      function (context) {
        return _react2.default.createElement(Component, _extends({}, props, { context: context, ref: ref }));
      }
    );
  });
  forwardingComponent.key = Component.key;

  return forwardingComponent;
};

exports.default = EditorContext;

/***/ }),

/***/ "./src/adapter/main.js":
/*!*****************************!*\
  !*** ./src/adapter/main.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.registerBridgeButton = exports.regexBasePath = exports.loadLanguageResources = exports.implementEventTarget = exports.getUrl = exports.getButtons = exports.getBasePath = exports.editable = exports.Toolbars = exports.Selections = exports.SelectionTest = exports.SelectionSetPosition = exports.SelectionGetArrowBoxClasses = exports.OOP = exports.Lang = exports.Core = exports.Compat = exports.Buttons = exports.Base = exports.Attribute = undefined;

var _base = __webpack_require__(/*! ../components/base */ "./src/components/base/index.js");

var Base = _interopRequireWildcard(_base);

var _buttons = __webpack_require__(/*! ../components/buttons */ "./src/components/buttons/index.js");

var _buttons2 = _interopRequireDefault(_buttons);

var _compat = __webpack_require__(/*! ../components/compat */ "./src/components/compat/index.js");

var Compat = _interopRequireWildcard(_compat);

var _toolbars = __webpack_require__(/*! ../components/toolbars */ "./src/components/toolbars/index.js");

var _toolbars2 = _interopRequireDefault(_toolbars);

var _attribute = __webpack_require__(/*! ../oop/attribute */ "./src/oop/attribute.js");

var _attribute2 = _interopRequireDefault(_attribute);

var _lang = __webpack_require__(/*! ../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _oop = __webpack_require__(/*! ../oop/oop */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

var _selectionArrowbox = __webpack_require__(/*! ../selections/selection-arrowbox */ "./src/selections/selection-arrowbox.js");

var _selectionArrowbox2 = _interopRequireDefault(_selectionArrowbox);

var _selectionPosition = __webpack_require__(/*! ../selections/selection-position */ "./src/selections/selection-position.js");

var _selectionPosition2 = _interopRequireDefault(_selectionPosition);

var _selectionTest = __webpack_require__(/*! ../selections/selection-test */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

var _selections = __webpack_require__(/*! ../selections/selections */ "./src/selections/selections.js");

var _selections2 = _interopRequireDefault(_selections);

var _core = __webpack_require__(/*! ./core */ "./src/adapter/core.js");

var _core2 = _interopRequireDefault(_core);

__webpack_require__(/*! ../plugins */ "./src/plugins/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// An object containing all currently registered plugins in AlloyEditor.

var BRIDGE_BUTTONS = {};

/**
 * Creates an instance of AlloyEditor.
 *
 * @memberof AlloyEditor
 * @method editable
 * @static
 * @param {String|Node} node The Node ID or HTMl node, which AlloyEditor should use as an editable area.
 * @param {Object} config Configuration attributes for the current instance of AlloyEditor.
 * @return {Object} An instance of {{#crossLink "Core"}}{{/crossLink}}
 */
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var editable = function editable(node, config) {
	config = config || {};
	config.srcNode = node;

	AlloyEditor.implementEventTarget();

	return new _core2.default(config);
};

/**
 * The full URL for the AlloyEditor installation directory.
 * It is possible to manually provide the base path by setting a
 * global variable named `ALLOYEDITOR_BASEPATH`. This global variable
 * must be set **before** the editor script loading.
 *
 * @memberof AlloyEditor
 * @method getBasePath
 * @static
 * @return {String} The found base path
 */
var getBasePath = function getBasePath() {
	// Find out the editor directory path, based on its <script> tag.

	var path = window.ALLOYEDITOR_BASEPATH || '';

	if (!path) {
		var scripts = document.getElementsByTagName('script');

		for (var i = 0; i < scripts.length; i++) {
			var match = scripts[i].src.match(AlloyEditor.regexBasePath);

			if (match) {
				path = match[1];
				break;
			}
		}
	}

	// In IE (only) the script.src string is the raw value entered in the
	// HTML source. Other browsers return the full resolved URL instead.

	if (path.indexOf(':/') === -1 && path.slice(0, 2) !== '//') {
		// Absolute path.

		if (path.indexOf('/') === 0) {
			path = location.href.match(/^.*?:\/\/[^/]*/)[0] + path;
		}

		// Relative path.
		else {
				path = location.href.match(/^[^?]*\/(?:)/)[0] + path;
			}
	}

	if (!path) {
		throw new Error('The AlloyEditor installation path could not be automatically detected. Please set the global variable "ALLOYEDITOR_BASEPATH" before creating editor instances.');
	}

	return path;
};

/**
 * Detects and load the corresponding language file if AlloyEditor language strings are not already present.
 * The function fires a {{#crossLink "AlloyEditor/languageResourcesLoaded:event"}}{{/crossLink}} event
 *
 * @memberof AlloyEditor
 * @method loadLanguageResources
 * @static
 * @param {Function} callback Optional callback to be called when AlloyEditor loads the language resource.
 */
var loadLanguageResources = function loadLanguageResources(callback) {
	AlloyEditor.implementEventTarget();

	if (_lang2.default.isFunction(callback)) {
		if (AlloyEditor.Strings) {
			setTimeout(callback, 0);
		} else {
			AlloyEditor.once('languageResourcesLoaded', function () {
				setTimeout(callback, 0);
			});
		}
	}

	if (!AlloyEditor._langResourceRequested) {
		AlloyEditor._langResourceRequested = true;

		var languages = ['af', 'ar', 'bg', 'bn', 'bs', 'ca', 'cs', 'cy', 'da', 'de', 'el', 'en-au', 'en-ca', 'en-gb', 'en', 'eo', 'es', 'et', 'eu', 'fa', 'fi', 'fo', 'fr-ca', 'fr', 'gl', 'gu', 'he', 'hi', 'hr', 'hu', 'id', 'is', 'it', 'ja', 'ka', 'km', 'ko', 'ku', 'lt', 'lv', 'mk', 'mn', 'ms', 'nb', 'nl', 'no', 'pl', 'pt-br', 'pt', 'ro', 'ru', 'si', 'sk', 'sl', 'sq', 'sr-latn', 'sr', 'sv', 'th', 'tr', 'tt', 'ug', 'uk', 'vi', 'zh-cn', 'zh'];

		var userLanguage = navigator.language || navigator.userLanguage || 'en';

		var parts = userLanguage.toLowerCase().match(/([a-z]+)(?:-([a-z]+))?/);
		var lang = parts[1];
		var locale = parts[2];

		if (languages.indexOf(lang + '-' + locale) >= 0) {
			lang = lang + '-' + locale;
		} else if (languages.indexOf(lang) === -1) {
			lang = 'en';
		}

		CKEDITOR.scriptLoader.load(AlloyEditor.getUrl('lang/alloy-editor/' + lang + '.js'), function (loaded) {
			if (loaded) {
				AlloyEditor.fire('languageResourcesLoaded');
			}
		},
		/* eslint-disable no-invalid-this */
		this // Always `AlloyEditor`.
		/* eslint-enable no-invalid-this */
		);
	}
};

/**
 * Gets the full URL for AlloyEditor resources. By default, URLs
 * returned by this function contain a querystring parameter ("t")
 * set to the {@link CKEDITOR#timestamp} value.
 *
 * @memberof AlloyEditor
 * @method getUrl
 * @static
 * @param {String} resource The resource whose full URL we want to get.
 * It may be a full, absolute, or relative URL.
 * @return {String} The full URL.
 */
var getUrl = function getUrl(resource) {
	var basePath = AlloyEditor.getBasePath();

	// If this is not a full or absolute path.

	if (resource.indexOf(':/') === -1 && resource.indexOf('/') !== 0) {
		resource = basePath + resource;
	}

	// Add the timestamp, except for directories.

	if (CKEDITOR.timestamp && resource.charAt(resource.length - 1) !== '/' && !/[&?]t=/.test(resource)) {
		resource += (resource.indexOf('?') >= 0 ? '&' : '?') + 't=' + CKEDITOR.timestamp;
	}

	return resource;
};

/**
 * Implements event firing and subscribing via CKEDITOR.event.
 *
 * @memberof AlloyEditor
 * @method implementEventTarget
 * @static
 */
var implementEventTarget = function implementEventTarget() {
	if (!AlloyEditor.fire && !AlloyEditor.on) {
		CKEDITOR.event.implementOn(AlloyEditor);
	}
};

/**
 * Regular expression which should match the script which have been used to load AlloyEditor.
 *
 * @memberof AlloyEditor
 * @property regexBasePath
 * @type {RegExp}
 * @static
 */
var regexBasePath = /(^|.*[\\/])(?:alloy-editor[^/]+|alloy-editor)\.js(?:\?.*|;.*)?$/i;

/**
 * Fired when AlloyEditor detects the browser language and loads the corresponding language file. Once this event
 * is fired, AlloyEditor.Strings will be populated with data.
 *
 * @event languageResourcesLoaded
 */

/**
 * Returns the required plugin names needed for a given plugin
 * if it is already registered or an empty array.
 *
 * @memberof AlloyEditor
 * @method getButtons
 * @param {Array} buttons An array of buttons or plugin names.
 * @return {Function} A function that can be invoked to resolve the requested button names.
 * @static
 */
var getButtons = function getButtons(buttons) {
	return function () {
		return buttons.reduce(function (acc, val) {
			val = BRIDGE_BUTTONS[val] || [val];

			return acc.concat(val);
		}, []);
	};
};

/**
 * Register a button and try to get its required plugins.
 *
 * @memberof AlloyEditor
 * @method registerBridgeButton
 * @param {String} buttonName The name of the button.
 * @param {String} pluginName The name of the plugin that registers the button.
 * @static
 */
var registerBridgeButton = function registerBridgeButton(buttonName, pluginName) {
	if (!BRIDGE_BUTTONS[pluginName]) {
		BRIDGE_BUTTONS[pluginName] = [];
	}

	BRIDGE_BUTTONS[pluginName].push(buttonName);
};

/**
 * @method OOP
 * @memberof AlloyEditor
 */
var OOP = {
	extend: _oop2.default
};

exports.Attribute = _attribute2.default;
exports.Base = Base;
exports.Buttons = _buttons2.default;
exports.Compat = Compat;
exports.Core = _core2.default;
exports.Lang = _lang2.default;
exports.OOP = OOP;
exports.SelectionGetArrowBoxClasses = _selectionArrowbox2.default;
exports.SelectionSetPosition = _selectionPosition2.default;
exports.SelectionTest = _selectionTest2.default;
exports.Selections = _selections2.default;
exports.Toolbars = _toolbars2.default;
exports.editable = editable;
exports.getBasePath = getBasePath;
exports.getButtons = getButtons;
exports.getUrl = getUrl;
exports.implementEventTarget = implementEventTarget;
exports.loadLanguageResources = loadLanguageResources;
exports.regexBasePath = regexBasePath;
exports.registerBridgeButton = registerBridgeButton;

/***/ }),

/***/ "./src/commands/index.js":
/*!*******************************!*\
  !*** ./src/commands/index.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeImageCommand = undefined;

var _removeImage = __webpack_require__(/*! ./remove-image */ "./src/commands/remove-image.js");

var _removeImage2 = _interopRequireDefault(_removeImage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.removeImageCommand = _removeImage2.default; /**
                                                     * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                     * SPDX-License-Identifier: LGPL-3.0-or-later
                                                     */

/***/ }),

/***/ "./src/commands/remove-image.js":
/*!**************************************!*\
  !*** ./src/commands/remove-image.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var removeImageCommand = {
	exec: function exec(editor) {
		var selection = editor.getSelection();

		if (selection) {
			var ranges = selection.getRanges();
			var startContainer = ranges[0].startContainer;

			var nextRange = new CKEDITOR.dom.range(startContainer);
			nextRange.setStart(startContainer, 0);
			nextRange.setEnd(startContainer, 0);

			var selectedElement = selection.getSelectedElement();

			if (selectedElement && selectedElement.getName() === 'img') {
				var native = selection.getNative();
				if (native) {
					native.removeAllRanges();
				}

				selection.selectRanges([nextRange]);

				selectedElement.remove();
			}
		}
	}
};

exports.default = removeImageCommand;

/***/ }),

/***/ "./src/components/base/button-action-style.js":
/*!****************************************************!*\
  !*** ./src/components/base/button-action-style.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ButtonActionStyle is a mixin that provides applying style implementation for a
 * button based on the `applyStyle` and `removeStyle` API of CKEDITOR.
 *
 * To execute properly, the component has to expose the following methods which can be obtained
 * out of the box using the {{#crossLink "ButtonStyle"}}{{/crossLink}} mixin:
 * - `Function` {{#crossLink "ButtonStyle/isActive"}}{{/crossLink}} to check the active state
 * - `Function` {{#crossLink "ButtonStyle/getStyle"}}{{/crossLink}} to return the style that should be applied
 *
 * @class ButtonActionStyle
 */
exports.default = function (WrappedComponent) {
	var _class, _temp2;

	return _temp2 = _class = function (_WrappedComponent) {
		_inherits(ButtonActionStyle, _WrappedComponent);

		function ButtonActionStyle() {
			var _ref;

			var _temp, _this, _ret;

			_classCallCheck(this, ButtonActionStyle);

			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonActionStyle.__proto__ || Object.getPrototypeOf(ButtonActionStyle)).call.apply(_ref, [this].concat(args))), _this), _this.applyStyle = function () {
				if (_lang2.default.isFunction(_this.isActive) && _lang2.default.isFunction(_this.getStyle)) {
					var editor = _this.context.editor.get('nativeEditor');

					editor.getSelection().lock();

					if (_this.isActive()) {
						editor.removeStyle(_this.getStyle());
					} else {
						editor.applyStyle(_this.getStyle());
					}

					editor.getSelection().unlock();

					editor.fire('actionPerformed', _this);
				}
			}, _temp), _possibleConstructorReturn(_this, _ret);
		}

		/**
   * Removes or applies the component style to the current selection.
   *
   * @instance
   * @memberof ButtonActionStyle
   * @method applyStyle
   */


		return ButtonActionStyle;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp2;
};

/***/ }),

/***/ "./src/components/base/button-command-active.js":
/*!******************************************************!*\
  !*** ./src/components/base/button-command-active.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ButtonCommandActive is a mixin that provides an `isActive` method to determine if
 * a context-aware command is currently in an active state.
 *
 * @class ButtonCommandActive
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(ButtonCommandActive, _WrappedComponent);

		function ButtonCommandActive() {
			_classCallCheck(this, ButtonCommandActive);

			return _possibleConstructorReturn(this, (ButtonCommandActive.__proto__ || Object.getPrototypeOf(ButtonCommandActive)).apply(this, arguments));
		}

		_createClass(ButtonCommandActive, [{
			key: 'isActive',


			/**
    * Checks if the command is active in the current selection.
    *
    * @instance
    * @memberof ButtonCommandActive
    * @method isActive
    * @return {Boolean} True if the command is active, false otherwise.
    */
			value: function isActive() {
				var editor = this.context.editor.get('nativeEditor');

				var command = editor.getCommand(this.props.command);

				return command ? command.state === CKEDITOR.TRISTATE_ON : false;
			}
		}]);

		return ButtonCommandActive;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp;
};

/***/ }),

/***/ "./src/components/base/button-command.js":
/*!***********************************************!*\
  !*** ./src/components/base/button-command.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ButtonCommand is a mixin that executes a command via CKEDITOR's API.
 *
 * @class ButtonCommand
 */
exports.default = function (WrappedComponent) {
	var _class, _temp2;

	return _temp2 = _class = function (_WrappedComponent) {
		_inherits(ButtonCommand, _WrappedComponent);

		function ButtonCommand() {
			var _ref;

			var _temp, _this, _ret;

			_classCallCheck(this, ButtonCommand);

			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonCommand.__proto__ || Object.getPrototypeOf(ButtonCommand)).call.apply(_ref, [this].concat(args))), _this), _this.execCommand = function (data) {
				var editor = _this.context.editor.get('nativeEditor');

				editor.execCommand(_this.props.command, data);

				editor.fire('actionPerformed', _this);
			}, _temp), _possibleConstructorReturn(_this, _ret);
		}

		/**
   * Executes a CKEditor command and fires `actionPerformed` event.
   *
   * @instance
   * @memberof ButtonCommand
   * @param {Object=} data Optional data to be passed to CKEDITOR's `execCommand` method.
   * @method execCommand
   */


		return ButtonCommand;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp2;
};

/***/ }),

/***/ "./src/components/base/button-keystroke.js":
/*!*************************************************!*\
  !*** ./src/components/base/button-keystroke.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ButtonKeystroke is a mixin that provides a `keystroke` prop that allows configuring
 * a function of the instance to be invoked upon the keystroke activation.
 *
 * @class ButtonKeystroke
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(ButtonKeystroke, _WrappedComponent);

		function ButtonKeystroke() {
			_classCallCheck(this, ButtonKeystroke);

			return _possibleConstructorReturn(this, (ButtonKeystroke.__proto__ || Object.getPrototypeOf(ButtonKeystroke)).apply(this, arguments));
		}

		_createClass(ButtonKeystroke, [{
			key: 'componentWillMount',


			/**
    * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
    *
    * @instance
    * @memberof ButtonKeystroke
    * @method componentWillMount
    */
			value: function componentWillMount() {
				if (_lang2.default.isFunction(_get(ButtonKeystroke.prototype.__proto__ || Object.getPrototypeOf(ButtonKeystroke.prototype), 'componentWillMount', this))) {
					_get(ButtonKeystroke.prototype.__proto__ || Object.getPrototypeOf(ButtonKeystroke.prototype), 'componentWillMount', this).call(this);
				}

				var nativeEditor = this.context.editor.get('nativeEditor');
				var keystroke = this.props.keystroke;

				var commandName = 'keystroke:' + keystroke.name;

				var command = nativeEditor.getCommand(commandName);

				if (!command) {
					command = new CKEDITOR.command(nativeEditor, {
						exec: function (editor) {
							var keystrokeFn = keystroke.fn;

							if (_lang2.default.isString(keystrokeFn)) {
								this[keystrokeFn].call(this, editor);
							} else if (_lang2.default.isFunction(keystrokeFn)) {
								keystrokeFn.call(this, editor);
							}
						}.bind(this)
					});

					nativeEditor.addCommand(commandName, command);
				}

				this._defaultKeystrokeCommand = nativeEditor.keystrokeHandler.keystrokes[keystroke.keys];

				nativeEditor.setKeystroke(keystroke.keys, commandName);
			}

			/**
    * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
    *
    * @instance
    * @memberof ButtonKeystroke
    * @method componentWillUnmount
    */

		}, {
			key: 'componentWillUnmount',
			value: function componentWillUnmount() {
				if (_lang2.default.isFunction(_get(ButtonKeystroke.prototype.__proto__ || Object.getPrototypeOf(ButtonKeystroke.prototype), 'componentWillUnmount', this))) {
					_get(ButtonKeystroke.prototype.__proto__ || Object.getPrototypeOf(ButtonKeystroke.prototype), 'componentWillUnmount', this).call(this);
				}

				this.context.editor.get('nativeEditor').setKeystroke(this.props.keystroke.keys, this._defaultKeystrokeCommand);
			}
		}]);

		return ButtonKeystroke;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp;
};

/***/ }),

/***/ "./src/components/base/button-props.js":
/*!*********************************************!*\
  !*** ./src/components/base/button-props.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ButtonCfgProps is a class that provides a mergeButtonCfgProps method for
 * merging React props and the native CKEDITOR's buttonCfg.
 *
 * @class ButtonProps
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(ButtonProps, _WrappedComponent);

		function ButtonProps() {
			_classCallCheck(this, ButtonProps);

			return _possibleConstructorReturn(this, (ButtonProps.__proto__ || Object.getPrototypeOf(ButtonProps)).apply(this, arguments));
		}

		_createClass(ButtonProps, [{
			key: 'mergeButtonCfgProps',


			/**
    * Merges the properties, passed to the current component with user's configuration
    * via `buttonCfg` property.
    *
    * @instance
    * @memberof ButtonProps
    * @method mergeButtonCfgProps
    * @param {Object} props The properties to be merged with the provided configuration for this
    * button. If not passed, the user configuration will be merged with `this.props`
    * @return {Object} The merged properties
    */
			value: function mergeButtonCfgProps() {
				var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

				var nativeEditor = this.context.editor.get('nativeEditor');
				var buttonCfg = nativeEditor.config.buttonCfg || {};

				return CKEDITOR.tools.merge(props, buttonCfg['linkEdit']);
			}
		}]);

		return ButtonProps;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp;
};

/***/ }),

/***/ "./src/components/base/button-state-classes.js":
/*!*****************************************************!*\
  !*** ./src/components/base/button-state-classes.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ButtonStateClasses is a mixin that decorates the domElement of a component
 * with different CSS classes based on the current state of the element.
 *
 * To check for state, the component can expose the following methods:
 * - `Function` **isActive** to check the active state
 *
 * @class ButtonStateClasses
 */
exports.default = function (WrappedComponent) {
	return function (_WrappedComponent) {
		_inherits(ButtonStateClasses, _WrappedComponent);

		function ButtonStateClasses() {
			_classCallCheck(this, ButtonStateClasses);

			return _possibleConstructorReturn(this, (ButtonStateClasses.__proto__ || Object.getPrototypeOf(ButtonStateClasses)).apply(this, arguments));
		}

		_createClass(ButtonStateClasses, [{
			key: 'getStateClasses',

			/**
    * Returns the list of state classes associated to the current element's state, according
    * to the results of the isActive method.
    *
    * @instance
    * @memberof ButtonStateClasses
    * @method getStateClasses
    * @return {String} A string with the state CSS classes.
    */
			value: function getStateClasses() {
				var stateClasses = '';

				// Check for active state

				if (_lang2.default.isFunction(this.isActive) && this.isActive()) {
					stateClasses += 'ae-button-pressed';
				}

				return stateClasses;
			}
		}]);

		return ButtonStateClasses;
	}(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-style.js":
/*!*********************************************!*\
  !*** ./src/components/base/button-style.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ButtonStyle is a mixin that provides a style prop and some methods to apply the resulting
 * style and checking if it is present in a given path or selection.
 *
 * @class ButtonStyle
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(ButtonStyle, _WrappedComponent);

		function ButtonStyle() {
			_classCallCheck(this, ButtonStyle);

			return _possibleConstructorReturn(this, (ButtonStyle.__proto__ || Object.getPrototypeOf(ButtonStyle)).apply(this, arguments));
		}

		_createClass(ButtonStyle, [{
			key: 'componentWillMount',


			/**
    * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
    *
    * @instance
    * @memberof ButtonStyle
    * @method componentWillMount
    */
			value: function componentWillMount() {
				if (_lang2.default.isFunction(_get(ButtonStyle.prototype.__proto__ || Object.getPrototypeOf(ButtonStyle.prototype), 'componentWillMount', this))) {
					_get(ButtonStyle.prototype.__proto__ || Object.getPrototypeOf(ButtonStyle.prototype), 'componentWillMount', this).call(this);
				}

				var style = this.props.style;

				if (_lang2.default.isString(style)) {
					var parts = style.split('.');
					var currentMember = this.context.editor.get('nativeEditor').config;
					var property = parts.shift();

					while (property && _lang2.default.isObject(currentMember) && _lang2.default.isObject(currentMember[property])) {
						currentMember = currentMember[property];
						property = parts.shift();
					}

					if (_lang2.default.isObject(currentMember)) {
						style = currentMember;
					}
				}

				this._style = new CKEDITOR.style(style);
			}

			/**
    * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
    *
    * @instance
    * @memberof ButtonStyle
    * @method componentWillUnmount
    */

		}, {
			key: 'componentWillUnmount',
			value: function componentWillUnmount() {
				if (_lang2.default.isFunction(_get(ButtonStyle.prototype.__proto__ || Object.getPrototypeOf(ButtonStyle.prototype), 'componentWillUnmount', this))) {
					_get(ButtonStyle.prototype.__proto__ || Object.getPrototypeOf(ButtonStyle.prototype), 'componentWillUnmount', this).call(this);
				}

				this._style = null;
			}

			/**
    * Returns instance of CKEDITOR.style which represents the current button style.
    *
    * @instance
    * @memberof ButtonStyle
    * @method getStyle
    * @return {CKEDITOR.style} The current style representation.
    */

		}, {
			key: 'getStyle',
			value: function getStyle() {
				return this._style;
			}

			/**
    * Checks if style is active in the current selection.
    *
    * @instance
    * @memberof ButtonStyle
    * @method isActive
    * @return {Boolean} True if style is active, false otherwise.
    */

		}, {
			key: 'isActive',
			value: function isActive() {
				var editor = this.context.editor.get('nativeEditor');
				var elementPath = editor.elementPath();

				return this.getStyle().checkActive(elementPath, editor);
			}
		}]);

		return ButtonStyle;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp;
};

/***/ }),

/***/ "./src/components/base/index.js":
/*!**************************************!*\
  !*** ./src/components/base/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _buttonActionStyle = __webpack_require__(/*! ./button-action-style */ "./src/components/base/button-action-style.js");

Object.defineProperty(exports, 'ButtonActionStyle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonActionStyle).default;
  }
});

var _buttonCommandActive = __webpack_require__(/*! ./button-command-active */ "./src/components/base/button-command-active.js");

Object.defineProperty(exports, 'ButtonCommandActive', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonCommandActive).default;
  }
});

var _buttonCommand = __webpack_require__(/*! ./button-command */ "./src/components/base/button-command.js");

Object.defineProperty(exports, 'ButtonCommand', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonCommand).default;
  }
});

var _buttonKeystroke = __webpack_require__(/*! ./button-keystroke */ "./src/components/base/button-keystroke.js");

Object.defineProperty(exports, 'ButtonKeystroke', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonKeystroke).default;
  }
});

var _buttonProps = __webpack_require__(/*! ./button-props */ "./src/components/base/button-props.js");

Object.defineProperty(exports, 'ButtonProps', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonProps).default;
  }
});

var _buttonStateClasses = __webpack_require__(/*! ./button-state-classes */ "./src/components/base/button-state-classes.js");

Object.defineProperty(exports, 'ButtonStateClasses', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonStateClasses).default;
  }
});

var _buttonStyle = __webpack_require__(/*! ./button-style */ "./src/components/base/button-style.js");

Object.defineProperty(exports, 'ButtonStyle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonStyle).default;
  }
});

var _toolbarButtons = __webpack_require__(/*! ./toolbar-buttons */ "./src/components/base/toolbar-buttons.js");

Object.defineProperty(exports, 'ToolbarButtons', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_toolbarButtons).default;
  }
});

var _widgetDropdown = __webpack_require__(/*! ./widget-dropdown */ "./src/components/base/widget-dropdown.js");

Object.defineProperty(exports, 'WidgetDropdown', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetDropdown).default;
  }
});

var _widgetExclusive = __webpack_require__(/*! ./widget-exclusive */ "./src/components/base/widget-exclusive.js");

Object.defineProperty(exports, 'WidgetExclusive', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetExclusive).default;
  }
});

var _widgetFocusManager = __webpack_require__(/*! ./widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

Object.defineProperty(exports, 'WidgetFocusManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetFocusManager).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./src/components/base/toolbar-buttons.js":
/*!************************************************!*\
  !*** ./src/components/base/toolbar-buttons.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * ToolbarButtons provides a list of buttons which have to be displayed
 * on the current toolbar depending on user preferences and given state.
 *
 * @class ToolbarButtons
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(ToolbarButtons, _WrappedComponent);

		function ToolbarButtons() {
			_classCallCheck(this, ToolbarButtons);

			return _possibleConstructorReturn(this, (ToolbarButtons.__proto__ || Object.getPrototypeOf(ToolbarButtons)).apply(this, arguments));
		}

		_createClass(ToolbarButtons, [{
			key: 'cancelAnimation',


			/**
    * Cancels an scheduled animation frame.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method cancelAnimation
    */
			value: function cancelAnimation() {
				if (this._animationFrameId) {
					window.cancelAnimationFrame(this._animationFrameId);
				}
			}

			/**
    * Provides functionality for displaying toolbar Arrow box on top or on bottom of the toolbar
    * depending on the point of user interaction with the editor.
    * Returns the list of arrow box classes associated to the current element's state. It relies
    * on the getInteractionPoint method to calculate the selection direction.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method getArrowBoxClasses
    * @return {String} A string with the arrow box CSS classes.
    */


			/**
    * Lifecycle. Returns the default values of the properties used in the
    * toolbar.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method getDefaultProps
    */

		}, {
			key: 'getArrowBoxClasses',
			value: function getArrowBoxClasses() {
				var arrowBoxClasses = 'ae-arrow-box';

				if (this.getInteractionPoint().direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
					arrowBoxClasses += ' ae-arrow-box-top';
				} else {
					arrowBoxClasses += ' ae-arrow-box-bottom';
				}

				return arrowBoxClasses;
			}

			/**
    * Returns an object which contains the position of the element in page coordinates,
    * restricted to fit to given viewport.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method getConstrainedPosition
    * @param {Object} attrs The following properties, provided as numbers:
    * - height
    * - left
    * - top
    * - width
    * @param {Object} viewPaneSize Optional. If not provided, the current viewport will be used. Should contain at least these properties:
    * - width
    * @return {Object} An object with `x` and `y` properties, which represent the constrained position of the
    * element.
    */

		}, {
			key: 'getConstrainedPosition',
			value: function getConstrainedPosition(attrs, viewPaneSize) {
				viewPaneSize = viewPaneSize || new CKEDITOR.dom.window(window).getViewPaneSize();

				var x = attrs.left;
				var y = attrs.top;

				if (attrs.left + attrs.width > viewPaneSize.width) {
					x -= attrs.left + attrs.width - viewPaneSize.width;
				}

				if (y < 0) {
					y = 0;
				}

				return {
					x: x,
					y: y
				};
			}

			/**
    * Returns the position, in page coordinates, according to which a toolbar should appear.
    * Depending on the direction of the selection, the wdiget may appear above of or on bottom of the selection.
    *
    * It depends on the props editorEvent to analyze the following user-interaction parameters:
    * - {Object} selectionData The data about the selection in the editor as returned from
    * {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
    * - {Number} pos Contains the coordinates of the position, considered as most appropriate.
    * This may be the point where the user released the mouse, or just the beginning or the end of
    * the selection.
    *
    * @instance
    * @method getInteractionPoint
    * @return {Object} An Object which contains the following properties:
    * direction, x, y, where x and y are in page coordinates and direction can be one of these:
    * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
    */

		}, {
			key: 'getInteractionPoint',
			value: function getInteractionPoint() {
				var eventPayload = this.props.editorEvent ? this.props.editorEvent.data : null;

				if (!eventPayload) {
					return;
				}

				var selectionData = eventPayload.selectionData;

				var nativeEvent = eventPayload.nativeEvent;

				var pos = {
					x: eventPayload.nativeEvent.pageX,
					y: selectionData.region.top
				};

				var direction = selectionData.region.direction;

				var endRect = selectionData.region.endRect;

				var startRect = selectionData.region.startRect;

				if (endRect && startRect && startRect.top === endRect.top) {
					direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
				}

				var x = void 0;
				var y = void 0;

				// If we have the point where user released the mouse, show Toolbar at this point
				// otherwise show it on the middle of the selection.

				if (pos.x && pos.y) {
					x = this._getXPoint(selectionData, pos.x);

					if (direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
						y = Math.min(pos.y, selectionData.region.top);
					} else {
						y = Math.max(pos.y, this._getYPoint(selectionData, nativeEvent));
					}
				} else {
					x = selectionData.region.left + selectionData.region.width / 2;

					if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
						y = this._getYPoint(selectionData, nativeEvent);
					} else {
						y = selectionData.region.top;
					}
				}

				return {
					direction: direction,
					x: x,
					y: y
				};
			}

			/**
    * Returns the position of the toolbar.
    *
    * @instance
    * @method _getXPoint
    * @param {Object} eventX The X coordinate received from the native event (mouseup).
    * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
    * @protected
    * @return {Number} The calculated X point in page coordinates.
    */

		}, {
			key: '_getXPoint',
			value: function _getXPoint(selectionData, eventX) {
				var region = selectionData.region;

				var left = region.startRect ? region.startRect.left : region.left;
				var right = region.endRect ? region.endRect.right : region.right;

				var x = void 0;

				if (left < eventX && right > eventX) {
					x = eventX;
				} else {
					var leftDist = Math.abs(left - eventX);
					var rightDist = Math.abs(right - eventX);

					if (leftDist < rightDist) {
						// user raised the mouse on left on the selection

						x = left;
					} else {
						x = right;
					}
				}

				return x;
			}

			/**
    * Returns the position of the toolbar.
    *
    * @instance
    * @method _getYPoint
    * @param {Object} nativeEvent The data about event is fired
    * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
    * @protected
    * @return {Number} The calculated Y point in page coordinates.
    */

		}, {
			key: '_getYPoint',
			value: function _getYPoint(selectionData, nativeEvent) {
				var y = 0;

				if (selectionData && nativeEvent) {
					var elementTarget = new CKEDITOR.dom.element(nativeEvent.target);

					if (elementTarget.$ && elementTarget.getStyle('overflow') === 'auto') {
						y = nativeEvent.target.offsetTop + nativeEvent.target.offsetHeight;
					} else {
						y = selectionData.region.bottom;
					}
				}

				return y;
			}

			/**
    * Returns the position of the toolbar taking in consideration the
    * {{#crossLink "ToolbarButtons/gutter:attribute"}}{{/crossLink}} attribute.
    *
    * @instance
    * @memberof ToolbarButtons
    * @protected
    * @method  getWidgetXYPoint
    * @param {Number} left The left offset in page coordinates where Toolbar should be shown.
    * @param {Number} top The top offset in page coordinates where Toolbar should be shown.
    * @param {Number} direction The direction of the selection. May be one of the following:
    * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
    * @return {Array} An Array with left and top offsets in page coordinates.
    */

		}, {
			key: 'getWidgetXYPoint',
			value: function getWidgetXYPoint(left, top, direction) {
				var domNode = _reactDom2.default.findDOMNode(this);

				var gutter = this.props.gutter;

				if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM || direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
					left = left - gutter.left - domNode.offsetWidth / 2;

					top = direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM ? top + gutter.top : top - domNode.offsetHeight - gutter.top;
				} else if (direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT || direction === CKEDITOR.SELECTION_RIGHT_TO_LEFT) {
					left = direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT ? left + gutter.left + domNode.offsetHeight / 2 : left - 3 * domNode.offsetHeight / 2 - gutter.left;

					top = top - gutter.top - domNode.offsetHeight / 2;
				}

				if (left < 0) {
					left = 0;
				}

				if (top < 0) {
					top = 0;
				}

				return [left, top];
			}

			/**
    * Returns true if the toolbar is visible, false otherwise
    *
    * @instance
    * @memberof ToolbarButtons
    * @method isVisible
    * @return {Boolean} True if the toolbar is visible, false otherwise
    */

		}, {
			key: 'isVisible',
			value: function isVisible() {
				var domNode = _reactDom2.default.findDOMNode(this);

				if (domNode) {
					var domElement = new CKEDITOR.dom.element(domNode);

					return domElement.hasClass('alloy-editor-visible');
				}

				return false;
			}

			/**
    * Moves a toolbar from a starting point to a destination point.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method moveToPoint
    * @param  {Object} startPoint The starting point for the movement.
    * @param  {Object} endPoint The destination point for the movement.
    */

		}, {
			key: 'moveToPoint',
			value: function moveToPoint(startPoint, endPoint) {
				var domElement = new CKEDITOR.dom.element(_reactDom2.default.findDOMNode(this));

				domElement.setStyles({
					left: startPoint[0] + 'px',
					top: startPoint[1] + 'px',
					opacity: 0,
					pointerEvents: 'none'
				});

				domElement.removeClass('alloy-editor-invisible');

				this._animationFrameId = window.requestAnimationFrame(function () {
					domElement.addClass('ae-toolbar-transition');
					domElement.addClass('alloy-editor-visible');
					domElement.setStyles({
						left: endPoint[0] + 'px',
						top: endPoint[1] + 'px',
						opacity: 1
					});

					// 150ms to match transition-duration for .ae-toolbar-transition:

					setTimeout(function () {
						domElement.setStyles({
							pointerEvents: ''
						});
					}, 150);
				});
			}

			/**
    * Shows the toolbar with the default animation transition.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method show
    */

		}, {
			key: 'show',
			value: function show() {
				var domNode = _reactDom2.default.findDOMNode(this);
				var uiNode = this.context.editor.get('uiNode');

				var scrollTop = uiNode ? uiNode.scrollTop : 0;

				if (!this.isVisible() && domNode) {
					var interactionPoint = this.getInteractionPoint();

					if (interactionPoint) {
						var domElement = new CKEDITOR.dom.element(domNode);

						var finalX = void 0;
						var finalY = void 0;
						var initialX = void 0;
						var initialY = void 0;

						finalX = initialX = parseFloat(domElement.getStyle('left'));
						finalY = initialY = parseFloat(domElement.getStyle('top'));

						if (this.props.constrainToViewport) {
							var res = this.getConstrainedPosition({
								height: parseFloat(domNode.offsetHeight),
								left: finalX,
								top: finalY,
								width: parseFloat(domNode.offsetWidth)
							});

							finalX = res.x;
							finalY = res.y;
						}

						if (interactionPoint.direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
							initialY = this.props.selectionData.region.bottom + scrollTop;
						} else {
							initialY = this.props.selectionData.region.top + scrollTop;
						}

						this.moveToPoint([initialX, initialY], [finalX, finalY]);
					}
				}
			}

			/**
    * Updates the toolbar position based on the current interaction point.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method updatePosition
    */

		}, {
			key: 'updatePosition',
			value: function updatePosition() {
				var interactionPoint = this.getInteractionPoint();

				var domNode = _reactDom2.default.findDOMNode(this);

				if (interactionPoint && domNode) {
					var uiNode = this.context.editor.get('uiNode') || document.body;
					var uiNodeStyle = getComputedStyle(uiNode);
					var uiNodeMarginLeft = parseInt(uiNodeStyle.getPropertyValue('margin-left'), 10);
					var uiNodeMarginRight = parseInt(uiNodeStyle.getPropertyValue('margin-right'), 10);
					var totalWidth = uiNodeMarginLeft + document.body.clientWidth + uiNodeMarginRight;

					var scrollTop = uiNode.tagName !== 'BODY' ? uiNode.scrollTop : 0;

					var xy = this.getWidgetXYPoint(interactionPoint.x, interactionPoint.y, interactionPoint.direction);
					xy[1] += scrollTop;

					if (xy[0] < 0) {
						xy[0] = 0;
					}
					if (xy[0] > totalWidth - domNode.offsetWidth) {
						xy[0] = totalWidth - domNode.offsetWidth;
					}

					new CKEDITOR.dom.element(domNode).setStyles({
						left: xy[0] + 'px',
						top: xy[1] + 'px'
					});
				}
			}

			/**
    * Analyses the current selection and returns the buttons or button groups to be rendered.
    *
    * @instance
    * @method getToolbarButtonGroups
    * @param {Array} buttons The buttons could be shown, prior to the state filtering.
    * @param {Object} additionalProps Additional props that should be passed down to the buttons.
    * @return {Array} An Array which contains the buttons or button groups that should be rendered.
    */

		}, {
			key: 'getToolbarButtonGroups',
			value: function getToolbarButtonGroups(buttons, additionalProps) {
				var _this2 = this;

				if (_lang2.default.isFunction(buttons)) {
					buttons = buttons.call(this) || [];
				}

				return buttons.reduce(function (list, button) {
					if (Array.isArray(button)) {
						list.push(_this2.getToolbarButtons(button, additionalProps));

						return list;
					} else {
						return _this2.getToolbarButtons(buttons, additionalProps);
					}
				}, []);
			}

			/**
    * Analyzes the current selection and the buttons exclusive mode value to figure out which
    * buttons should be present in a given state.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method getToolbarButtons
    * @param {Array} buttons The buttons could be shown, prior to the state filtering.
    * @param {Object} additionalProps Additional props that should be passed down to the buttons.
    * @return {Array} An Array which contains the buttons that should be rendered.
    */

		}, {
			key: 'getToolbarButtons',
			value: function getToolbarButtons(buttons, additionalProps) {
				var buttonProps = {};

				var nativeEditor = this.context.editor.get('nativeEditor');
				var buttonCfg = nativeEditor.config.buttonCfg || {};

				if (_lang2.default.isFunction(buttons)) {
					buttons = buttons.call(this) || [];
				}

				var toolbarButtons = this.filterExclusive(buttons.filter(function (button) {
					return button && (AlloyEditor.Buttons[button] || AlloyEditor.Buttons[button.name]);
				}).map(function (button) {
					if (_lang2.default.isString(button)) {
						buttonProps[button] = buttonCfg[button];
						button = AlloyEditor.Buttons[button];
					} else if (_lang2.default.isString(button.name)) {
						buttonProps[AlloyEditor.Buttons[button.name].key] = CKEDITOR.tools.merge(buttonCfg[button], button.cfg);
						button = AlloyEditor.Buttons[button.name];
					}

					return button;
				})).map(function (button, index) {
					var props = this.mergeExclusiveProps({
						editor: this.context.editor,
						key: button.key !== 'separator' ? button.key : button.key + '-' + index,
						tabKey: button.key,
						tabIndex: this.props.trigger && this.props.trigger.props.tabKey === button.key ? 0 : -1,
						trigger: this.props.trigger
					}, button.key);

					props = this.mergeDropdownProps(props, button.key);

					if (additionalProps) {
						props = CKEDITOR.tools.merge(props, additionalProps);
					}

					props = CKEDITOR.tools.merge(props, buttonProps[button.key]);

					return _react2.default.createElement(button, props);
				}, this);

				return toolbarButtons;
			}
		}]);

		return ToolbarButtons;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _class.defaultProps = _extends({}, WrappedComponent.defaultProps, {
		gutter: {
			left: 0,
			top: 10
		},
		constrainToViewport: true
	}), _temp;
};

/***/ }),

/***/ "./src/components/base/widget-dropdown.js":
/*!************************************************!*\
  !*** ./src/components/base/widget-dropdown.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * Provides functionality for managing different dropdowns inside a widget.
 *
 * @class WidgetDropdown
 */
exports.default = function (WrappedComponent) {
	return function (_WrappedComponent) {
		_inherits(WidgetDropdown, _WrappedComponent);

		function WidgetDropdown(props) {
			_classCallCheck(this, WidgetDropdown);

			var _this = _possibleConstructorReturn(this, (WidgetDropdown.__proto__ || Object.getPrototypeOf(WidgetDropdown)).call(this, props));

			_this.mergeDropdownProps = function (obj, itemKey) {
				return CKEDITOR.tools.merge(obj, {
					expanded: _this.state.itemDropdown === itemKey ? true : false,
					tabIndex: _this.state.dropdownTrigger === itemKey ? 0 : -1,
					toggleDropdown: _this.toggleDropdown.bind(_this, itemKey)
				});
			};

			_this.toggleDropdown = function (itemDropdown, toggleDirection) {
				_this.setState({
					dropdownTrigger: itemDropdown,
					itemDropdown: itemDropdown !== _this.state.itemDropdown ? itemDropdown : null
				}, function () {
					if (!_this.state.itemDropdown) {
						if (_this.moveFocus) {
							_this.moveFocus(toggleDirection);
						} else {
							_reactDom2.default.findDOMNode(_this).focus();
						}
					}
				});
			};

			_this.state = _extends({}, _this.state, {
				dropdownTrigger: null,
				itemDropdown: null
			});
			return _this;
		}

		/**
   * Lifecycle. Invoked when a component is receiving new props.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof WidgetDropdown
   * @method componentWillReceiveProps
   */


		_createClass(WidgetDropdown, [{
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps) {
				if (_lang2.default.isFunction(_get(WidgetDropdown.prototype.__proto__ || Object.getPrototypeOf(WidgetDropdown.prototype), 'componentWillReceiveProps', this))) {
					_get(WidgetDropdown.prototype.__proto__ || Object.getPrototypeOf(WidgetDropdown.prototype), 'componentWillReceiveProps', this).call(this, nextProps);
				}

				this.setState({
					dropdownTrigger: null,
					itemDropdown: null
				});
			}

			/**
    * Merges the provided object with two more properties:
    * - expanded - boolean flag which indicates if an widget should be rendered exclusively.
    * - toggleDropdown - function, which can be used by an widget in order to obtain exclusive state.
    *
    * @instance
    * @memberof WidgetDropdown
    * @method mergeDropdownProps
    * @param {Object} obj The properties container which should be merged with the properties, related
    *    to dropdown state.
    * @param {Object} itemKey They key of an React Widget which contains the dropdown.
    * @return {Object} The merged object.
    */


			/**
    * Sets the active dropdown of the widget or discards the toggled item from the state.
    *
    * @instance
    * @memberof WidgetDropdown
    * @method toggleDropdown
    * @param {Object} itemDropdown The widget which requests to toggle its dropdown.
    * @param {Number} toggleDirection User movement direction when toggled via keyboard.
    */

		}]);

		return WidgetDropdown;
	}(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-exclusive.js":
/*!*************************************************!*\
  !*** ./src/components/base/widget-exclusive.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * Provides functionality for managing exclusive state of an widget.
 * The exclusive state means that a button may request to be the only rendered
 * widget in its parent container. WidgetExclusive will manage this state by
 * filtering and suppressing the other sibling widgets from displaying.
 *
 * @class WidgetExclusive
 */
exports.default = function (WrappedComponent) {
	return function (_WrappedComponent) {
		_inherits(WidgetExclusive, _WrappedComponent);

		function WidgetExclusive() {
			var _ref;

			var _temp, _this, _ret;

			_classCallCheck(this, WidgetExclusive);

			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = WidgetExclusive.__proto__ || Object.getPrototypeOf(WidgetExclusive)).call.apply(_ref, [this].concat(args))), _this), _this.requestExclusive = function (itemExclusive) {
				_this.setState({
					itemExclusive: itemExclusive
				});
			}, _temp), _possibleConstructorReturn(_this, _ret);
		}

		_createClass(WidgetExclusive, [{
			key: 'cancelExclusive',

			/**
    * Cancels the exclusive state of an widget.
    *
    * @instance
    * @memberof WidgetExclusive
    * @method cancelExclusive
    * @param {Object} itemExclusive The widget which exclusive state should be canceled.
    */
			value: function cancelExclusive(itemExclusive) {
				if (this.state.itemExclusive === itemExclusive) {
					this.setState({
						itemExclusive: null
					});
				}
			}

			/**
    * Lifecycle. Invoked when a component is receiving new props.
    * This method is not called for the initial render.
    * Calling this.setState() within this function will not trigger an additional render.
    *
    * @instance
    * @memberof WidgetExclusive
    * @method componentWillReceiveProps
    * @param {Object} nextProps Object containing the current set of properties.
    */

		}, {
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps) {
				if (_lang2.default.isFunction(_get(WidgetExclusive.prototype.__proto__ || Object.getPrototypeOf(WidgetExclusive.prototype), 'componentWillReceiveProps', this))) {
					_get(WidgetExclusive.prototype.__proto__ || Object.getPrototypeOf(WidgetExclusive.prototype), 'componentWillReceiveProps', this).call(this, nextProps);
				}

				// Receiving properties means that the component is being re-rendered.
				// Re-rendering is triggered by editorInteraction, so we have to
				// reset the exclusive state and render the UI according to the new selection.

				this.setState({
					itemExclusive: null
				});
			}

			/**
    * Filters the items and returns only those with exclusive state.
    *
    * @instance
    * @memberof WidgetExclusive
    * @method filterExclusive
    * @param {Array} items The widgets to be filtered.
    * @return {Array|Object} The item with executive state.
    */

		}, {
			key: 'filterExclusive',
			value: function filterExclusive(items) {
				var _this2 = this;

				return items.filter(function (item) {
					if (_this2.state.itemExclusive) {
						if (_this2.state.itemExclusive === item.key) {
							return item;
						}
					} else {
						return item;
					}
				});
			}

			/**
    * Merges the provided object with three more properties:
    * - cancelExclusive - function, which can be used by a widget in order to cancel executive state.
    * - renderExclusive - boolean flag which indicates if an widget should be rendered exclusively.
    * - requestExclusive - function, which can be used by a widget in order to obtain exclusive state.
    *
    * @instance
    * @memberof WidgetExclusive
    * @method mergeExclusiveProps
    * @param {Object} obj The properties container which should be merged with the properties, related
    *    to exclusive state.
    * @param {Object} itemKey They key of an React Widget which should be rendered exclusively.
    * @return {Object} The merged object.
    */

		}, {
			key: 'mergeExclusiveProps',
			value: function mergeExclusiveProps(obj, itemKey) {
				return CKEDITOR.tools.merge(obj, {
					cancelExclusive: this.cancelExclusive.bind(this, itemKey),
					renderExclusive: this.state.itemExclusive === itemKey,
					requestExclusive: this.requestExclusive.bind(this, itemKey)
				});
			}

			/**
    * Requests and sets exclusive state of an widget.
    *
    * @instance
    * @memberof WidgetExclusive
    * @method requestExclusive
    * @param {Object} itemExclusive The widget which requests exclusive state.
    */

		}]);

		return WidgetExclusive;
	}(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-focus-manager.js":
/*!*****************************************************!*\
  !*** ./src/components/base/widget-focus-manager.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var DIRECTION_NONE = 0;
var DIRECTION_NEXT = 1;
var DIRECTION_PREV = -1;

var ACTION_NONE = 0;
var ACTION_MOVE_FOCUS = 1;
var ACTION_DISMISS_FOCUS = 2;

/**
 * WidgetFocusManager is a mixin that provides keyboard navigation inside a widget. To do this,
 * it exposes the following props and methods:
 *
 * @class WidgetFocusManager
 */

exports.default = function (WrappedComponent) {
	return function (_WrappedComponent) {
		_inherits(WidgetFocusManager, _WrappedComponent);

		function WidgetFocusManager() {
			var _ref;

			var _temp, _this, _ret;

			_classCallCheck(this, WidgetFocusManager);

			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = WidgetFocusManager.__proto__ || Object.getPrototypeOf(WidgetFocusManager)).call.apply(_ref, [this].concat(args))), _this), _this.focus = function (event) {
				if (!event || _this._isValidTarget(event.target)) {
					if (_this._descendants && _this._descendants.length) {
						var activeDescendantEl = _this._descendants[_this._activeDescendant];

						// When user clicks with the mouse, the activeElement is already set and there
						// is no need to focus it. Focusing of the active descendant (usually some button) is required
						// in case of keyboard navigation, because the focused element might be not the first button,
						// but the div element, which contains the button.

						if (document.activeElement !== activeDescendantEl && !_this.props.focusFirstChild) {
							if (_this._descendants.indexOf(document.activeElement) === -1) {
								activeDescendantEl.focus();
							}
						}

						if (event) {
							event.stopPropagation();
							event.preventDefault();
						}
					}
				}
			}, _this.handleKey = function (event) {
				if (_this._isValidTarget(event.target) && _this._descendants) {
					var action = _this._getFocusAction(event);

					if (action.type) {
						event.stopPropagation();
						event.preventDefault();

						if (action.type === ACTION_MOVE_FOCUS) {
							_this._moveFocus(action.direction);
						}

						if (action.type === ACTION_DISMISS_FOCUS) {
							_this.props.onDismiss(action.direction);
						}
					}
				}
			}, _temp), _possibleConstructorReturn(_this, _ret);
		}

		_createClass(WidgetFocusManager, [{
			key: 'componentDidMount',

			/**
    * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method componentDidMount
    */
			value: function componentDidMount() {
				if (_lang2.default.isFunction(_get(WidgetFocusManager.prototype.__proto__ || Object.getPrototypeOf(WidgetFocusManager.prototype), 'componentDidMount', this))) {
					_get(WidgetFocusManager.prototype.__proto__ || Object.getPrototypeOf(WidgetFocusManager.prototype), 'componentDidMount', this).call(this);
				}

				this._refresh();
			}

			/**
    * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
    * Refreshes the descendants list.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method componentDidUpdate
    */

		}, {
			key: 'componentDidUpdate',
			value: function componentDidUpdate() {
				if (_lang2.default.isFunction(_get(WidgetFocusManager.prototype.__proto__ || Object.getPrototypeOf(WidgetFocusManager.prototype), 'componentDidUpdate', this))) {
					_get(WidgetFocusManager.prototype.__proto__ || Object.getPrototypeOf(WidgetFocusManager.prototype), 'componentDidUpdate', this).call(this);
				}

				this._refresh();
			}

			/**
    * Focuses the current active descendant.
    *
    * Several Widgets can be nested in a component hierarchy by attaching this focus method to
    * the widget DOM node, transferring the DOM focus control to the inner FocusManager.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method focus
    */


			/**
    * Handles the key events on a DOM node to execute the appropriate navigation when needed.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @param {Object} event The Keyboard event that was detected on the widget DOM node.
    * @method handleKey
    */

		}, {
			key: 'moveFocus',


			/**
    * Moves the focus among descendants in the especified direction.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method moveFocus
    * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
    */
			value: function moveFocus(direction) {
				direction = _lang2.default.isNumber(direction) ? direction : 0;

				this._moveFocus(direction);
			}

			/**
    * Returns the action, if any, that a keyboard event in the current focus manager state
    * should produce.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _getFocusAction
    * @param {object} event The Keyboard event.
    * @protected
    * @return {Object} An action object with type and direction properties.
    */

		}, {
			key: '_getFocusAction',
			value: function _getFocusAction(event) {
				var action = {
					type: ACTION_NONE
				};

				if (this.props.keys) {
					var direction = this._getFocusMoveDirection(event);

					if (direction) {
						action.direction = direction;
						action.type = ACTION_MOVE_FOCUS;
					}

					var dismissAction = this._getFocusDismissAction(event, direction);

					if (dismissAction.dismiss) {
						action.direction = dismissAction.direction;
						action.type = ACTION_DISMISS_FOCUS;
					}
				}

				return action;
			}

			/**
    * Returns the dismiss action, if any, the focus manager should execute to yield the focus. This
    * will happen in any of these scenarios if a dismiss callback has been specified:
    * - A dismiss key has been pressed
    * - In a non-circular focus manager, when:
    *     - The active descendant is the first one and a prev key has been pressed.
    *     - The active descendant is the last one and a next key has been pressed.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _getFocusDismissAction
    * @param {Number} focusMoveDirection The focus movement direction (if any).
    * @param {Object} event The Keyboard event.
    * @protected
    * @return {Object} A dismiss action with dismiss and direction properties.
    */

		}, {
			key: '_getFocusDismissAction',
			value: function _getFocusDismissAction(event, focusMoveDirection) {
				var dismissAction = {
					direction: focusMoveDirection,
					dismiss: false
				};

				if (this.props.onDismiss) {
					if (this._isValidKey(event.keyCode, this.props.keys.dismiss)) {
						dismissAction.dismiss = true;
					}
					if (this._isValidKey(event.keyCode, this.props.keys.dismissNext)) {
						dismissAction.dismiss = true;
						dismissAction.direction = DIRECTION_NEXT;
					}
					if (this._isValidKey(event.keyCode, this.props.keys.dismissPrev)) {
						dismissAction.dismiss = true;
						dismissAction.direction = DIRECTION_PREV;
					}

					if (!dismissAction.dismiss && !this.props.circular && focusMoveDirection) {
						dismissAction.dismiss = focusMoveDirection === DIRECTION_PREV && this._activeDescendant === 0 || focusMoveDirection === DIRECTION_NEXT && this._activeDescendant === this._descendants.length - 1;
					}
				}

				return dismissAction;
			}

			/**
    * Returns the direction, if any, in which the focus should be moved. In presence of the
    * shift key modifier, the direction of the movement is inverted.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _getFocusMoveDirection
    * @param {Object} event The Keyboard event.
    * @protected
    * @return {Number} The computed direction of the expected focus movement.
    */

		}, {
			key: '_getFocusMoveDirection',
			value: function _getFocusMoveDirection(event) {
				var direction = DIRECTION_NONE;

				if (this._isValidKey(event.keyCode, this.props.keys.next)) {
					direction = DIRECTION_NEXT;
				}
				if (this._isValidKey(event.keyCode, this.props.keys.prev)) {
					direction = DIRECTION_PREV;
				}

				if (event.shifKey) {
					direction *= -1;
				}

				return direction;
			}

			/**
    * Indicates if a given keyCode is valid for the given set of keys.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _isValidKey
    * @param {Array|Number} keys A key set. Can be a number an array of numbers representing the allowed keyCodes.
    * @param {Number} keyCode An event keyCode.
    * @protected
    * @return {Boolean} A boolean value indicating if the key is valid.
    */

		}, {
			key: '_isValidKey',
			value: function _isValidKey(keyCode, keys) {
				return _lang2.default.isArray(keys) ? keys.indexOf(keyCode) !== -1 : keyCode === keys;
			}

			/**
    * Indicates if a given element is valid for focus management. User input elements such as
    * input, select or textarea are excluded.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _isValidKey
    * @param {DOMNode} element A DOM element.
    * @protected
    * @return {Boolean} A boolean value indicating if the element is valid.
    */

		}, {
			key: '_isValidTarget',
			value: function _isValidTarget(element) {
				var tagName = element.tagName.toLowerCase();

				return tagName !== 'input' && tagName !== 'select' && tagName !== 'textarea';
			}

			/**
    * Moves the focus among descendants in the especified direction.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _moveFocus
    * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
    * @protected
    */

		}, {
			key: '_moveFocus',
			value: function _moveFocus(direction) {
				var numDescendants = this._descendants.length;

				var descendant = this._descendants[this._activeDescendant];

				descendant.setAttribute('tabIndex', -1);

				this._activeDescendant += direction;

				if (this.props.circular) {
					// Calculate proper modulo result since remainder operator doesn't behave in the
					// same way for negative numbers

					this._activeDescendant = (this._activeDescendant % numDescendants + numDescendants) % numDescendants;
				} else {
					this._activeDescendant = Math.max(Math.min(this._activeDescendant, numDescendants - 1), 0);
				}

				descendant = this._descendants[this._activeDescendant];

				descendant.setAttribute('tabIndex', 0);
				descendant.focus();
			}

			/**
    * Refreshes the descendants list by executing the CSS selector again and resets the descendants tabIndex.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _refresh
    * @protected
    */

		}, {
			key: '_refresh',
			value: function _refresh() {
				var _this2 = this;

				var domNode = _reactDom2.default.findDOMNode(this);

				if (domNode) {
					var descendants = domNode.querySelectorAll(this.props.descendants);

					var priorityDescendants = [];

					this._descendants = [];

					Array.prototype.slice.call(descendants).forEach(function (item) {
						var dataTabIndex = item.getAttribute('data-tabindex');

						if (dataTabIndex) {
							priorityDescendants.push(item);
						} else {
							_this2._descendants.push(item);
						}
					});

					priorityDescendants = priorityDescendants.sort(function (a, b) {
						return _lang2.default.toInt(a.getAttribute('data-tabindex')) > _lang2.default.toInt(b.getAttribute('data-tabindex'));
					});

					this._descendants = priorityDescendants.concat(this._descendants);

					this._activeDescendant = 0;

					this._descendants.some(function (item, index) {
						if (item.getAttribute('tabindex') === '0') {
							_this2._activeDescendant = index;
							_this2.focus();

							return true;
						}
					});
				}
			}
		}]);

		return WidgetFocusManager;
	}(WrappedComponent);
};

/***/ }),

/***/ "./src/components/buttons/button-accessibility-image-alt.jsx":
/*!*******************************************************************!*\
  !*** ./src/components/buttons/button-accessibility-image-alt.jsx ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonAccessibilityImageAlt class provides functionality for changing text color in a document.
 *
 * @class ButtonAccessibilityImageAlt
 *
 */
var ButtonAccessibilityImageAlt = function (_React$Component) {
	_inherits(ButtonAccessibilityImageAlt, _React$Component);

	function ButtonAccessibilityImageAlt(props) {
		_classCallCheck(this, ButtonAccessibilityImageAlt);

		var _this = _possibleConstructorReturn(this, (ButtonAccessibilityImageAlt.__proto__ || Object.getPrototypeOf(ButtonAccessibilityImageAlt)).call(this, props));

		_this._handleAltChange = function (event) {
			_this.setState({
				imageAlt: event.target.value
			});

			_this._focusAltInput();
		};

		_this._handleKeyDown = function (event) {
			if (event.keyCode === 13) {
				event.preventDefault();

				_this._updateImageAlt();
			}
		};

		_this._requestExclusive = function () {
			_this.props.requestExclusive(ButtonAccessibilityImageAlt.key);
		};

		_this._updateImageAlt = function () {
			var editor = _this.context.editor.get('nativeEditor');

			var imageAlt = _this.refs.refAltInput.value;

			_this.setState({
				imageAlt: imageAlt
			});

			var imageElement = _this._element.findOne('img');
			var image = imageElement ? imageElement : _this._element;

			image.setAttribute('alt', imageAlt);

			editor.fire('actionPerformed', _this);

			// We need to cancelExclusive with the bound parameters in case the button is used
			// inside another in exclusive mode (such is the case of the alt button)

			_this.props.cancelExclusive();
		};

		_this.state = _this._getInitialState();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses on the link input to immediately allow editing. This should only happen if the component
  * is rendered in exclusive mode to prevent aggressive focus stealing.
  *
  * @instance
  * @memberof ButtonAccessibilityImageAlt
  * @method componentDidMount
  */


	_createClass(ButtonAccessibilityImageAlt, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (this.props.renderExclusive || this.props.manualSelection) {
				// We need to wait for the next rendering cycle before focusing to avoid undesired
				// scrolls on the page

				this._focusAltInput();
			}
		}

		/**
   * Lifecycle. Invoked when a component is receiving new props.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ButtonAccessibilityImageAlt
   * @method componentWillReceiveProps
   */

	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps() {
			this.setState(this._getInitialState());
		}

		/**
   * The return value will be used as the initial value of this.state.
   *
   * @instance
   * @memberof ButtonAccessibilityImageAlt
   * @method _getInitialState
   * @protected
   * @return {Object}
   */

	}, {
		key: '_getInitialState',
		value: function _getInitialState() {
			// Can't access context from contructor, so get editor from props.

			var editor = this.props.context.editor;


			var selection = editor.get('nativeEditor').getSelection();

			var element = selection.getSelectedElement() || selection.getStartElement();

			this._element = element;

			var imageElement = this._element.findOne('img');

			var imageAlt = imageElement ? imageElement.getAttribute('alt') : this._element.getAttribute('alt');

			return {
				imageAlt: imageAlt
			};
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			if (this.props.renderExclusive) {
				return _react2.default.createElement(
					'div',
					{ className: 'ae-container-edit-link' },
					_react2.default.createElement(
						'div',
						{ className: 'ae-container-input xxl' },
						_react2.default.createElement('input', {
							'aria-label': 'alt',
							className: 'ae-input',
							onChange: this._handleAltChange,
							onKeyDown: this._handleKeyDown,
							placeholder: 'alt',
							ref: 'refAltInput',
							title: 'alt',
							type: 'text',
							value: this.state.imageAlt
						})
					),
					_react2.default.createElement(
						'button',
						{
							'aria-label': AlloyEditor.Strings.confirm,
							className: 'ae-button',
							onClick: this._updateImageAlt,
							title: AlloyEditor.Strings.confirm },
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'check' })
					)
				);
			} else {
				return _react2.default.createElement(
					'button',
					{
						className: 'ae-button',
						onClick: this._requestExclusive,
						tabIndex: this.props.tabIndex },
					_react2.default.createElement(
						'small',
						{ className: 'ae-icon small' },
						'Alt'
					)
				);
			}
		}

		/**
   * Focuses the user cursor on the widget's input.
   *
   * @protected
   * @method _focusAltInput
   */

	}, {
		key: '_focusAltInput',
		value: function _focusAltInput() {
			var instance = this;

			var focusAltEl = function focusAltEl() {
				_reactDom2.default.findDOMNode(instance.refs.refAltInput).focus();
			};

			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(focusAltEl);
			} else {
				setTimeout(focusAltEl, 0);
			}
		}

		/**
   * Event attached to alt input that fires when its value is changed
   *
   * @protected
   * @method  _handleAltChange
   * @param {MouseEvent} event
   */


		/**
   * Event attached to al tinput that fires when key is down
   * This method check that enter key is pushed to update the componentÂ´s state
   *
   * @protected
   * @method  _handleKeyDown
   * @param {MouseEvent} event
   */


		/**
   * Requests the link button to be rendered in exclusive mode to allow the creation of a link.
   *
   * @protected
   * @method _requestExclusive
   */


		/**
   * Method called by clicking ok button or pushing key enter to update imageAlt state and to update alt property from the image that is selected
   * This method calls cancelExclusive to show the previous toolbar before enter to edit alt property
   *
   * @protected
   * @method  _updateImageAlt
   */

	}]);

	return ButtonAccessibilityImageAlt;
}(_react2.default.Component);

ButtonAccessibilityImageAlt.contextType = _editorContext2.default;
ButtonAccessibilityImageAlt.key = 'imageAlt';
exports.default = _editorContext2.default.toProps(ButtonAccessibilityImageAlt);

/***/ }),

/***/ "./src/components/buttons/button-background-color.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-background-color.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var ButtonBackgroundColor = function (_React$Component) {
	_inherits(ButtonBackgroundColor, _React$Component);

	function ButtonBackgroundColor() {
		_classCallCheck(this, ButtonBackgroundColor);

		return _possibleConstructorReturn(this, (ButtonBackgroundColor.__proto__ || Object.getPrototypeOf(ButtonBackgroundColor)).apply(this, arguments));
	}

	_createClass(ButtonBackgroundColor, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var _this2 = this;

			var activeColor = AlloyEditor.Strings.normal;

			var activeColorClass = '';

			var colors = this._getColors();

			var itemStyle = {
				element: 'span',
				attributes: {
					class: ''
				}
			};

			colors.forEach(function (item) {
				itemStyle.attributes.class = item.styleClass;

				if (_this2._checkActive(itemStyle)) {
					activeColor = item.name;

					activeColorClass = item.style.attributes.class;
				}
			});

			var _props = this.props,
			    expanded = _props.expanded,
			    tabIndex = _props.tabIndex,
			    toggleDropdown = _props.toggleDropdown;


			var buttonStylesProps = {
				activeStyle: activeColor,
				onDismiss: toggleDropdown,
				showRemoveStylesItem: false,
				styles: colors
			};

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': expanded,
						className: 'ae-toolbar-element',
						onClick: toggleDropdown,
						role: 'combobox',
						tabIndex: tabIndex },
					_react2.default.createElement(
						'span',
						{ className: activeColorClass },
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'textbox' })
					)
				),
				expanded && _react2.default.createElement(_buttonStylesList2.default, buttonStylesProps)
			);
		}
	}, {
		key: '_applyStyle',
		value: function _applyStyle(className) {
			var _this3 = this;

			var editor = this.context.editor.get('nativeEditor');

			var styleConfig = {
				element: 'span',
				attributes: {
					class: className
				}
			};

			editor.getSelection().lock();

			this._getColors().forEach(function (item) {
				styleConfig.attributes.class = item.styleClass;

				if (_this3._checkActive(styleConfig)) {
					editor.removeStyle(new CKEDITOR.style(styleConfig));
				}
			});

			styleConfig.attributes.class = className;

			var style = new CKEDITOR.style(styleConfig);

			editor.applyStyle(style);

			editor.getSelection().unlock();

			editor.fire('actionPerformed', this);
		}

		/**
   * Checks if the given color definition is applied to the current selection in the editor.
   *
   * @instance
   * @memberof ButtonBackgroundColor
   * @method _checkActive
   * @param {Object} styleConfig color definition as per http://docs.ckeditor.com/#!/api/CKEDITOR.style.
   * @protected
   * @return {Boolean} Returns true if the color is applied to the selection, false otherwise.
   */

	}, {
		key: '_checkActive',
		value: function _checkActive(styleConfig) {
			var nativeEditor = this.context.editor.get('nativeEditor');

			// Styles with wildcard element (*) won't be considered active by CKEditor. Defaulting
			// to a 'span' element works for most of those cases with no defined element.

			styleConfig = CKEDITOR.tools.merge({ element: 'span' }, styleConfig);

			var style = new CKEDITOR.style(styleConfig);

			return style.checkActive(nativeEditor.elementPath(), nativeEditor);
		}

		/**
   * Returns an array of colors. Each color consists of two properties:
   * - name - the style name, for example "default"
   * - style - an object with one property, called `element` which value
   * represents the style which have to be applied to the element.
   *
   * @instance
   * @memberof ButtonBackgroundColor
   * @method _getColor
   * @protected
   * @return {Array<object>} An array of objects containing the colors.
   */

	}, {
		key: '_getColors',
		value: function _getColors() {
			return this.props.styles || [{
				name: AlloyEditor.Strings.normal,
				style: {
					element: 'span',
					attributes: {
						class: 'text-body'
					}
				},
				styleClass: '',
				styleFn: this._applyStyle.bind(this, '')
			}, {
				name: AlloyEditor.Strings.primary,
				style: {
					element: 'span',
					attributes: {
						class: 'text-primary'
					}
				},
				styleClass: 'bg-primary',
				styleFn: this._applyStyle.bind(this, 'bg-primary')
			}, {
				name: AlloyEditor.Strings.disabled,
				style: {
					element: 'span',
					attributes: {
						class: 'text-secondary'
					}
				},
				styleClass: 'bg-secondary',
				styleFn: this._applyStyle.bind(this, 'bg-secondary')
			}, {
				name: AlloyEditor.Strings.success,
				style: {
					element: 'span',
					attributes: {
						class: 'text-success'
					}
				},
				styleClass: 'bg-success',
				styleFn: this._applyStyle.bind(this, 'bg-success')
			}, {
				name: AlloyEditor.Strings.danger,
				style: {
					element: 'span',
					attributes: {
						class: 'text-danger'
					}
				},
				styleClass: 'bg-danger',
				styleFn: this._applyStyle.bind(this, 'bg-danger')
			}, {
				name: AlloyEditor.Strings.warning,
				style: {
					element: 'span',
					attributes: {
						class: 'text-warning'
					}
				},
				styleClass: 'bg-warning',
				styleFn: this._applyStyle.bind(this, 'bg-warning')
			}, {
				name: AlloyEditor.Strings.info,
				style: {
					element: 'span',
					attributes: {
						class: 'text-info'
					}
				},
				styleClass: 'bg-info',
				styleFn: this._applyStyle.bind(this, 'bg-info')
			}];
		}
	}]);

	return ButtonBackgroundColor;
}(_react2.default.Component);

ButtonBackgroundColor.contextType = _editorContext2.default;
ButtonBackgroundColor.key = 'backgroundColor';
ButtonBackgroundColor.propTypes = {
	/**
  * Indicates whether the styles list is expanded or not.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {Boolean} expanded
  */
	expanded: _propTypes2.default.bool,

	/**
  * The label that should be used for accessibility purposes.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {String} label
  */
	label: _propTypes2.default.string,

	/**
  * Indicates whether the remove styles item should appear in the styles list.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {Boolean} showRemoveStylesItem
  */
	showRemoveStylesItem: _propTypes2.default.bool,

	/**
  * List of the styles the button is able to handle.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {Array} styles
  */
	styles: _propTypes2.default.arrayOf(_propTypes2.default.object),

	/**
  * The tabIndex of the button in its toolbar current state. A value other than -1
  * means that the button has focus and is the active element.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {Number} tabIndex
  */
	tabIndex: _propTypes2.default.number,

	/**
  * Callback provided by the button host to notify when the styles list has been expanded.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {Function} toggleDropdown
  */
	toggleDropdown: _propTypes2.default.func
};
exports.default = ButtonBackgroundColor;

/***/ }),

/***/ "./src/components/buttons/button-bold.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-bold.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonBold class provides functionality for styling an selection with strong (bold) style.
 *
 * @class ButtonBold
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonBold = function (_React$Component) {
	_inherits(ButtonBold, _React$Component);

	function ButtonBold() {
		_classCallCheck(this, ButtonBold);

		return _possibleConstructorReturn(this, (ButtonBold.__proto__ || Object.getPrototypeOf(ButtonBold)).apply(this, arguments));
	}

	_createClass(ButtonBold, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonBold
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonBold
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button  ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.bold,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-bold',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.bold },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'bold' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default bold
   * @memberof ButtonBold
   * @property {String} key
   * @static
   */

	}]);

	return ButtonBold;
}(_react2.default.Component);

ButtonBold.defaultProps = {
	command: 'bold',
	keystroke: {
		fn: 'execCommand',
		keys: CKEDITOR.CTRL + 66 /* B*/
		, name: 'bold'
	},
	style: 'coreStyles_bold'
};
ButtonBold.key = 'bold';
exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonBold))));

/***/ }),

/***/ "./src/components/buttons/button-camera-image.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-camera-image.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonCameraImage class takes photo from camera and inserts it to the content.
 *
 * @class ButtonCameraImage
 */
var ButtonCameraImage = function (_React$Component) {
	_inherits(ButtonCameraImage, _React$Component);

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonCameraImage
  */
	function ButtonCameraImage(props) {
		_classCallCheck(this, ButtonCameraImage);

		var _this = _possibleConstructorReturn(this, (ButtonCameraImage.__proto__ || Object.getPrototypeOf(ButtonCameraImage)).call(this, props));

		_this.takePhoto = function () {
			var videoEl = _this._videoContainerRef.current;
			var canvasEl = _this._canvasContainerRef.current;

			var context = canvasEl.getContext('2d');

			var height = _this._videoHeight;
			var width = _this.props.videoWidth;

			if (width && height) {
				canvasEl.width = width;
				canvasEl.height = height;

				context.drawImage(videoEl, 0, 0, width, height);

				var imgURL = canvasEl.toDataURL('image/png');

				var el = CKEDITOR.dom.element.createFromHtml('<img src="' + imgURL + '">');

				var editor = _this.context.editor.get('nativeEditor');

				editor.insertElement(el);

				_this.props.cancelExclusive();

				editor.fire('actionPerformed', _this);

				editor.fire('imageCameraAdd', el);
			}
		};

		_this._handleStreamError = function (error) {
			window.alert('An error occurred! ' + error);
		};

		_this._handleStreamSuccess = function (stream) {
			var videoEl = _this._videoContainerRef.current;
			var canvasEl = _this._canvasContainerRef.current;

			videoEl.addEventListener('canplay', function () {
				var height = videoEl.videoHeight / (videoEl.videoWidth / _this.props.videoWidth);

				if (isNaN(height)) {
					height = _this.props.videoWidth / (4 / 3);
				}

				videoEl.setAttribute('width', _this.props.videoWidth);
				videoEl.setAttribute('height', height);
				canvasEl.setAttribute('width', _this.props.videoWidth);
				canvasEl.setAttribute('height', height);

				_this._videoHeight = height;
			}, false);

			_this._stream = stream;

			if (navigator.mozGetUserMedia) {
				videoEl.mozSrcObject = stream;
			} else {
				videoEl.srcObject = stream;
			}

			videoEl.play();

			_this._buttonTakePhotoRef.current.disabled = false;
		};

		_this._buttonTakePhotoRef = _react2.default.createRef();
		_this._canvasContainerRef = _react2.default.createRef();
		_this._videoContainerRef = _react2.default.createRef();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses the take photo button.
  *
  * @instance
  * @memberof ButtonCameraImage
  * @method componentDidMount
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default cameraImage
  * @memberof ButtonCameraImage
  * @property {String} key
  * @static
  */


	_createClass(ButtonCameraImage, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this._buttonTakePhotoRef.current.focus();
		}

		/**
   * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
   *
   * @instance
   * @memberof ButtonCameraImage
   * @method componentWillUnmount
   */

	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			if (this._stream) {
				if (this._stream.stop) {
					this._stream.stop();
				} else if (this._stream.getVideoTracks) {
					this._stream.getVideoTracks().forEach(function (track) {
						track.stop();
					});
				}
				this._stream = null;
			}
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonCameraImage
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',


		/**
   * Fired when an image is being taken from the camera and added as an element to the editor.
   *
   * @event ButtonCameraImage#imageCameraAdd
   * @memberof ButtonCameraImage
   * @param {CKEDITOR.dom.element} el The created img element in editor.
   */
		value: function render() {
			var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

			getUserMedia.call(navigator, {
				video: true,
				audio: false
			}, this._handleStreamSuccess, this._handleStreamError);

			return _react2.default.createElement(
				'div',
				{ className: 'ae-camera' },
				_react2.default.createElement(
					'video',
					{ ref: this._videoContainerRef },
					'Video stream not available.'
				),
				_react2.default.createElement(
					'button',
					{
						className: 'ae-camera-shoot',
						onClick: this.takePhoto,
						ref: this._buttonTakePhotoRef },
					'Take photo'
				),
				_react2.default.createElement('canvas', {
					className: 'ae-camera-canvas',
					ref: this._canvasContainerRef
				})
			);
		}

		/**
   * Takes photo from the video stream and inserts in into editor's content.
   *
   * @fires ButtonCameraImage#imageCameraAdd
   * @instance
   * @memberof ButtonCameraImage
   * @method takePhoto
   */


		/**
   * Displays error message in case of video stream capturing failure.
   *
   * @instance
   * @memberof ButtonCameraImage
   * @method _handleStreamError
   * @param {Event} error The fired event in case of error.
   * @protected
   */


		/**
   * Starts streaming video in the video element and sets width/height to the video
   * and canvas elements.
   *
   * @instance
   * @memberof ButtonCameraImage
   * @method _handleStreamSuccess
   * @param {Object} stream The video stream
   * @protected
   */

	}]);

	return ButtonCameraImage;
}(_react2.default.Component);

ButtonCameraImage.contextType = _editorContext2.default;
ButtonCameraImage.defaultProps = {
	videoWidth: 320
};
ButtonCameraImage.key = 'cameraImage';
exports.default = ButtonCameraImage;

/***/ }),

/***/ "./src/components/buttons/button-camera.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-camera.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCameraImage = __webpack_require__(/*! ./button-camera-image.jsx */ "./src/components/buttons/button-camera-image.jsx");

var _buttonCameraImage2 = _interopRequireDefault(_buttonCameraImage);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonCamera class renders in two different ways:
 *
 * - Normal: Just a button that allows to switch to the edition mode.
 * - Exclusive: Renders ButtonCameraImage in order to take photo from the camera.
 *
 * @class ButtonCamera
 */
var ButtonCamera = function (_React$Component) {
	_inherits(ButtonCamera, _React$Component);

	function ButtonCamera() {
		_classCallCheck(this, ButtonCamera);

		return _possibleConstructorReturn(this, (ButtonCamera.__proto__ || Object.getPrototypeOf(ButtonCamera)).apply(this, arguments));
	}

	_createClass(ButtonCamera, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonCamera
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.renderExclusive) {
				return _react2.default.createElement(_buttonCameraImage2.default, this.props);
			} else {
				var disabled = !(navigator.getUserMedia || navigator.webkitGetUserMedia && location.protocol === 'https' || navigator.mozGetUserMedia || navigator.msGetUserMedia);

				var label = disabled ? AlloyEditor.Strings.cameraDisabled : AlloyEditor.Strings.camera;

				return _react2.default.createElement(
					'button',
					{
						'aria-label': label,
						className: 'ae-button',
						'data-type': 'button-image-camera',
						disabled: disabled,
						onClick: this.props.requestExclusive.bind(ButtonCamera.key),
						tabIndex: this.props.tabIndex,
						title: label },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'camera' })
				);
			}
		}
		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default camera
   * @memberof ButtonCamera
   * @property {String} key
   * @static
   */

	}]);

	return ButtonCamera;
}(_react2.default.Component);

ButtonCamera.key = 'camera';
exports.default = ButtonCamera;

/***/ }),

/***/ "./src/components/buttons/button-code.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-code.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonCode class provides wraps a selection in `pre` element.
 *
 * @class ButtonCode
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonCode = function (_React$Component) {
	_inherits(ButtonCode, _React$Component);

	function ButtonCode() {
		_classCallCheck(this, ButtonCode);

		return _possibleConstructorReturn(this, (ButtonCode.__proto__ || Object.getPrototypeOf(ButtonCode)).apply(this, arguments));
	}

	_createClass(ButtonCode, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonCode
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonCode
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.code,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-code',
					onClick: this.applyStyle,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.code },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'code' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default code
   * @memberof ButtonCode
   * @property {String} key
   * @static
   */

	}]);

	return ButtonCode;
}(_react2.default.Component);

ButtonCode.defaultProps = {
	style: {
		element: 'pre'
	}
};
ButtonCode.key = 'code';
exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonCode)));

/***/ }),

/***/ "./src/components/buttons/button-color.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-color.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonColor class provides functionality for changing text color in a document.
 *
 *
 * @class ButtonColor
 */
var ButtonColor = function (_React$Component) {
	_inherits(ButtonColor, _React$Component);

	function ButtonColor() {
		_classCallCheck(this, ButtonColor);

		return _possibleConstructorReturn(this, (ButtonColor.__proto__ || Object.getPrototypeOf(ButtonColor)).apply(this, arguments));
	}

	_createClass(ButtonColor, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var _this2 = this;

			var activeColor = AlloyEditor.Strings.normal;

			var colors = this._getColors();

			colors.some(function (item) {
				if (_this2._checkActive(item.style)) {
					activeColor = item.name;
				}
			});

			var _props = this.props,
			    expanded = _props.expanded,
			    tabIndex = _props.tabIndex,
			    toggleDropdown = _props.toggleDropdown;


			var buttonStylesProps = {
				activeStyle: activeColor,
				onDismiss: toggleDropdown,
				showRemoveStylesItem: false,
				styles: colors
			};

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': expanded,
						className: 'ae-toolbar-element',
						onClick: toggleDropdown,
						role: 'combobox',
						tabIndex: tabIndex },
					_react2.default.createElement(
						'span',
						null,
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'color-picker' })
					)
				),
				expanded && _react2.default.createElement(_buttonStylesList2.default, buttonStylesProps)
			);
		}
	}, {
		key: '_applyStyle',
		value: function _applyStyle(className) {
			var _this3 = this;

			var editor = this.context.editor.get('nativeEditor');

			var styleConfig = {
				element: 'span',
				attributes: {
					class: className
				}
			};

			var style = new CKEDITOR.style(styleConfig);

			editor.getSelection().lock();

			this._getColors().forEach(function (item) {
				if (_this3._checkActive(item.style)) {
					editor.removeStyle(new CKEDITOR.style(item.style));
				}
			});

			editor.applyStyle(style);

			editor.getSelection().unlock();

			editor.fire('actionPerformed', this);
		}

		/**
   * Checks if the given color definition is applied to the current selection in the editor.
   *
   * @instance
   * @memberof ButtonColor
   * @method _checkActive
   * @param {Object} styleConfig Color definition as per http://docs.ckeditor.com/#!/api/CKEDITOR.style.
   * @protected
   * @return {Boolean} Returns true if the color is applied to the selection, false otherwise.
   */

	}, {
		key: '_checkActive',
		value: function _checkActive(styleConfig) {
			var nativeEditor = this.context.editor.get('nativeEditor');

			// Styles with wildcard element (*) won't be considered active by CKEditor. Defaulting
			// to a 'span' element works for most of those cases with no defined element.

			styleConfig = CKEDITOR.tools.merge({ element: 'span' }, styleConfig);

			var style = new CKEDITOR.style(styleConfig);

			return style.checkActive(nativeEditor.elementPath(), nativeEditor);
		}

		/**
   * Returns an array of colors. Each color consists of two properties:
   * - name - The style name, for example "default".
   * - style - An object with one property, called `element` which value
   *          represents the style which have to be applied to the element.
   * - styleFn - The function that is invoked to apply the style to the element.
   *
   * @instance
   * @memberof ButtonColor
   * @method _getColor
   * @protected
   * @return {Array<object>} An array of objects containing the colors.
   */

	}, {
		key: '_getColors',
		value: function _getColors() {
			return this.props.styles || [{
				name: AlloyEditor.Strings.primary,
				style: {
					element: 'span',
					attributes: {
						class: 'text-primary'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-primary')
			}, {
				name: AlloyEditor.Strings.success,
				style: {
					element: 'span',
					attributes: {
						class: 'text-success'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-success')
			}, {
				name: AlloyEditor.Strings.danger,
				style: {
					element: 'span',
					attributes: {
						class: 'text-danger'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-danger')
			}, {
				name: AlloyEditor.Strings.warning,
				style: {
					element: 'span',
					attributes: {
						class: 'text-warning'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-warning')
			}, {
				name: AlloyEditor.Strings.info,
				style: {
					element: 'span',
					attributes: {
						class: 'text-info'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-info')
			}, {
				name: AlloyEditor.Strings.dark,
				style: {
					element: 'span',
					attributes: {
						class: 'text-dark'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-dark')
			}, {
				name: AlloyEditor.Strings.darkGray,
				style: {
					element: 'span',
					attributes: {
						class: 'text-gray-dark'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-gray-dark')
			}, {
				name: AlloyEditor.Strings.secondary,
				style: {
					element: 'span',
					attributes: {
						class: 'text-secondary'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-secondary')
			}, {
				name: AlloyEditor.Strings.light,
				style: {
					element: 'span',
					attributes: {
						class: 'text-dark'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-light')
			}, {
				name: AlloyEditor.Strings.lighter,
				style: {
					element: 'span',
					attributes: {
						class: 'text-dark'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-lighter')
			}, {
				name: AlloyEditor.Strings.white,
				style: {
					element: 'span',
					attributes: {
						class: 'text-dark'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-white')
			}];
		}
	}]);

	return ButtonColor;
}(_react2.default.Component);

ButtonColor.contextType = _editorContext2.default;
ButtonColor.key = 'color';
ButtonColor.propTypes = {
	/**
  * Indicates whether the styles list is expanded or not.
  *
  * @instance
  * @memberof ButtonColor
  * @property {Boolean} expanded
  */
	expanded: _propTypes2.default.bool,

	/**
  * The label that should be used for accessibility purposes.
  *
  * @instance
  * @memberof ButtonColor
  * @property {String} label
  */
	label: _propTypes2.default.string,

	/**
  * Indicates whether the remove styles item should appear in the styles list.
  *
  * @instance
  * @memberof ButtonColor
  * @property {Boolean} showRemoveStylesItem
  */
	showRemoveStylesItem: _propTypes2.default.bool,

	/**
  * List of the styles the button is able to handle.
  *
  * @instance
  * @memberof ButtonColor
  * @property {Array} styles
  */
	styles: _propTypes2.default.arrayOf(_propTypes2.default.object),

	/**
  * The tabIndex of the button in its toolbar current state. A value other than -1
  * means that the button has focus and is the active element.
  *
  * @instance
  * @memberof ButtonColor
  * @property {Number} tabIndex
  */
	tabIndex: _propTypes2.default.number,

	/**
  * Callback provided by the button host to notify when the styles list has been expanded.
  *
  * @instance
  * @memberof ButtonColor
  * @property {Function} toggleDropdown
  */
	toggleDropdown: _propTypes2.default.func
};
exports.default = ButtonColor;

/***/ }),

/***/ "./src/components/buttons/button-command-list-item.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-command-list-item.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonCommandListItem class is a UI class that renders a ButtonCommand that can be used inside
 * a list as an item, with a string representation of its behaviour.
 *
 * @class ButtonCommandListItem
 * @uses ButtonCommand
 */
var ButtonCommandListItem = function (_React$Component) {
	_inherits(ButtonCommandListItem, _React$Component);

	function ButtonCommandListItem() {
		_classCallCheck(this, ButtonCommandListItem);

		return _possibleConstructorReturn(this, (ButtonCommandListItem.__proto__ || Object.getPrototypeOf(ButtonCommandListItem)).apply(this, arguments));
	}

	_createClass(ButtonCommandListItem, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonCommandListItem
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': this.props.description,
					className: this._getClassName(),
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex },
				this.props.description
			);
		}

		/**
   * Returns the class name of Widget.
   *
   * @instance
   * @memberof ButtonCommandListItem
   * @method _getClassName
   * @protected
   * @return {String} The class name of the Widget.
   */

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default buttonCommandListItem
   * @memberof ButtonCommandListItem
   * @property {String} key
   * @static
   */

	}, {
		key: '_getClassName',
		value: function _getClassName() {
			var className = 'ae-container ae-toolbar-element';

			return className;
		}
	}]);

	return ButtonCommandListItem;
}(_react2.default.Component);

ButtonCommandListItem.key = 'buttonCommandListItem';
exports.default = (0, _buttonCommand2.default)(ButtonCommandListItem);

/***/ }),

/***/ "./src/components/buttons/button-commands-list.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-commands-list.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _buttonCommandListItem = __webpack_require__(/*! ./button-command-list-item.jsx */ "./src/components/buttons/button-command-list-item.jsx");

var _buttonCommandListItem2 = _interopRequireDefault(_buttonCommandListItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonCommandsList class provides functionality for showing a list of commands that can be
 * executed to the current selection..
 *
 * @class ButtonCommandsList
 * @uses WidgetFocusManager
 */
var ButtonCommandsList = function (_React$Component) {
	_inherits(ButtonCommandsList, _React$Component);

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonCommandsList
  * @method getDefaultProps
  * @return {Object} The default properties.
  */
	function ButtonCommandsList(props) {
		_classCallCheck(this, ButtonCommandsList);

		var _this = _possibleConstructorReturn(this, (ButtonCommandsList.__proto__ || Object.getPrototypeOf(ButtonCommandsList)).call(this, props));

		_this._ref = _react2.default.createRef();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses on the list node to allow keyboard interaction.
  *
  * @instance
  * @memberof ButtonCommandsList
  * @method componentDidMount
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default buttonCommandsList
  * @memberof ButtonCommandsList
  * @property {String} key
  * @static
  */


	_createClass(ButtonCommandsList, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this._ref.current.focus();
		}

		/**
   * Lifecycle. Renders the UI of the list.
   *
   * @instance
   * @memberof ButtonCommandsList
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{
					className: 'ae-arrow-box ae-arrow-box-top-left ae-dropdown',
					onFocus: this.focus,
					onKeyDown: this.handleKey,
					ref: this._ref,
					tabIndex: '0' },
				_react2.default.createElement(
					'ul',
					{
						className: 'ae-listbox',
						id: this.props.listId,
						role: 'listbox' },
					this._renderActions(this.props.commands)
				)
			);
		}

		/**
   * Renders instances of ButtonCommandListItem with the description of the row action that will be executed.
   *
   * @instance
   * @memberof ButtonCommandsList
   * @method _renderActions
   * @protected
   * @return {Array} Rendered instances of ButtonCommandListItem class
   */

	}, {
		key: '_renderActions',
		value: function _renderActions(commands) {
			var items = void 0;

			if (commands && commands.length) {
				items = commands.map(function (item) {
					return _react2.default.createElement(
						'li',
						{ key: item.command, role: 'option' },
						_react2.default.createElement(_buttonCommandListItem2.default, {
							command: item.command,
							description: typeof item.label === 'string' ? item.label : item.label(),
							icon: item.icon
						})
					);
				});
			}

			return items;
		}
	}]);

	return ButtonCommandsList;
}(_react2.default.Component);

ButtonCommandsList.defaultProps = {
	circular: false,
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	}
};
ButtonCommandsList.key = 'buttonCommandsList';
exports.default = (0, _widgetFocusManager2.default)(ButtonCommandsList);

/***/ }),

/***/ "./src/components/buttons/button-dropdown.jsx":
/*!****************************************************!*\
  !*** ./src/components/buttons/button-dropdown.jsx ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonDropdown class provides markup and keyboard navigation behaviour to a dropdown
 * opened from a button.
 *
 * @class ButtonDropdown
 */
var ButtonDropdown = function (_React$Component) {
	_inherits(ButtonDropdown, _React$Component);

	function ButtonDropdown() {
		_classCallCheck(this, ButtonDropdown);

		return _possibleConstructorReturn(this, (ButtonDropdown.__proto__ || Object.getPrototypeOf(ButtonDropdown)).apply(this, arguments));
	}

	_createClass(ButtonDropdown, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonDropdown
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonDropdown
   * @method getDefaultProps
   */
		value: function render() {
			return _react2.default.createElement(
				'div',
				{
					className: 'ae-arrow-box ae-arrow-box-top-left ae-dropdown',
					onFocus: this.focus,
					onKeyDown: this.handleKey,
					tabIndex: '0' },
				_react2.default.createElement(
					'ul',
					{ className: 'ae-listbox', role: 'listbox' },
					this.props.children
				)
			);
		}

		/**
   * The name which will be used as an alias of the dropdown in the configuration.
   *
   * @default dropdown
   * @memberof ButtonDropdown
   * @property {String} key
   * @static
   */

	}]);

	return ButtonDropdown;
}(_react2.default.Component);

ButtonDropdown.defaultProps = {
	circular: false,
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	}
};
ButtonDropdown.key = 'dropdown';
exports.default = (0, _widgetFocusManager2.default)(ButtonDropdown);

/***/ }),

/***/ "./src/components/buttons/button-embed-edit.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-embed-edit.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var KEY_ENTER = 13;
var KEY_ESC = 27;

/**
 * The ButtonEmbedEdit class provides functionality for creating and editing an embed link in a document.
 * Provides UI for creating and editing an embed link.
 *
 * @class ButtonEmbedEdit
 */

var ButtonEmbedEdit = function (_React$Component) {
	_inherits(ButtonEmbedEdit, _React$Component);

	function ButtonEmbedEdit(props) {
		_classCallCheck(this, ButtonEmbedEdit);

		var _this = _possibleConstructorReturn(this, (ButtonEmbedEdit.__proto__ || Object.getPrototypeOf(ButtonEmbedEdit)).call(this, props));

		_this._clearLink = function () {
			_this.setState({
				linkHref: ''
			});
		};

		_this._embedLink = function () {
			var nativeEditor = _this.context.editor.get('nativeEditor');

			nativeEditor.execCommand('embedUrl', {
				url: _this.state.linkHref
			});

			// We need to cancelExclusive with the bound parameters in case the button is used
			// inside another in exclusive mode (such is the case of the link button)

			_this.props.cancelExclusive();
		};

		_this._focusLinkInput = function () {
			_this.linkInput.current.focus();
		};

		_this._handleKeyDown = function (event) {
			if (event.keyCode === KEY_ENTER || event.keyCode === KEY_ESC) {
				event.preventDefault();
			}

			if (event.keyCode === KEY_ENTER) {
				_this._embedLink();
			} else if (event.keyCode === KEY_ESC) {
				var editor = _this.context.editor.get('nativeEditor');

				// We need to cancelExclusive with the bound parameters in case the button is used
				// inside another in exclusive mode (such is the case of the link button)

				_this.props.cancelExclusive();

				editor.fire('actionPerformed', _this);
			}
		};

		_this._handleLinkHrefChange = function (event) {
			_this.setState({
				linkHref: event.target.value
			});
		};

		_this._removeEmbed = function () {
			var editor = _this.context.editor.get('nativeEditor');

			var embedWrapper = _this.state.element.getAscendant(function (element) {
				return element.hasClass('cke_widget_wrapper');
			});

			embedWrapper.remove();

			editor.fire('actionPerformed', _this);
		};

		_this.linkInput = _react2.default.createRef();
		_this.state = _this.getInitialState();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses on the link input to immediately allow editing. This should only happen if the component
  * is rendered in exclusive mode to prevent aggressive focus stealing.
  *
  * @instance
  * @memberof ButtonEmbedEdit
  * @method componentDidMount
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default embedEdit
  * @memberof ButtonEmbedEdit
  * @property {String} key
  * @static
  */


	_createClass(ButtonEmbedEdit, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (this.props.renderExclusive || this.props.manualSelection) {
				// We need to wait for the next rendering cycle before focusing to avoid undesired
				// scrolls on the page

				if (window.requestAnimationFrame) {
					window.requestAnimationFrame(this._focusLinkInput);
				} else {
					setTimeout(this._focusLinkInput, 0);
				}
			}
		}

		/**
   * Lifecycle. Invoked when a component is receiving new props.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method componentWillReceiveProps
   */

	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps() {
			this.setState(this.getInitialState());
		}

		/**
   * Lifecycle. Invoked once before the component is mounted.
   * The return value will be used as the initial value of this.state.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method getInitialState
   */

	}, {
		key: 'getInitialState',
		value: function getInitialState() {
			// Can't access context from constructor, so get editor from props.

			var editor = this.props.context.editor.get('nativeEditor');
			var embed = void 0;

			var selection = editor.getSelection();

			if (selection) {
				var selectedElement = selection.getSelectedElement();

				if (selectedElement) {
					embed = selectedElement.findOne('[data-widget="ae_embed"]');
				}
			}

			var href = embed ? embed.getAttribute('data-ae-embed-url') : '';

			return {
				element: embed,
				initialLink: {
					href: href
				},
				linkHref: href
			};
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var clearLinkStyle = {
				opacity: this.state.linkHref ? 1 : 0
			};

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-edit-link' },
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.deleteEmbed,
						className: 'ae-button',
						'data-type': 'button-embed-remove',
						disabled: !this.state.element,
						onClick: this._removeEmbed,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.deleteEmbed },
					_react2.default.createElement(_buttonIcon2.default, { className: 'ae-icon-svg-trash', symbol: 'trash' })
				),
				_react2.default.createElement(
					'div',
					{ className: 'ae-container-input xxl' },
					_react2.default.createElement('input', {
						className: 'ae-input',
						onChange: this._handleLinkHrefChange,
						onKeyDown: this._handleKeyDown,
						placeholder: AlloyEditor.Strings.editLink,
						ref: this.linkInput,
						type: 'text',
						value: this.state.linkHref
					}),
					_react2.default.createElement(
						'button',
						{
							'aria-label': AlloyEditor.Strings.clearInput,
							className: 'ae-button ae-button-clear',
							onClick: this._clearLink,
							style: clearLinkStyle,
							title: AlloyEditor.Strings.clear },
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'times-clear' })
					)
				),
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.confirm,
						className: 'ae-button',
						disabled: !this._isValidState(),
						onClick: this._embedLink,
						title: AlloyEditor.Strings.confirm },
					_react2.default.createElement(_buttonIcon2.default, { className: 'ae-icon-svg-check', symbol: 'check' })
				)
			);
		}

		/**
   * Clears the link input. This only changes the component internal state, but does not
   * affect the link element of the editor. Only the _removeLink and _updateLink methods
   * are translated to the editor element.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _clearLink
   * @protected
   */


		/**
   * Triggers the embedUrl command to transform the link into an embed media object
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _embedLink
   * @protected
   */


		/**
   * Focuses the user cursor on the widget's input.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _focusLinkInput
   * @protected
   */


		/**
   * Monitors key interaction inside the input element to respond to the keys:
   * - Enter: Creates/updates the link.
   * - Escape: Discards the changes.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _handleKeyDown
   * @param {SyntheticEvent} event The keyboard event.
   * @protected
   */


		/**
   * Updates the component state when the link input changes on user interaction.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _handleLinkHrefChange
   * @param {SyntheticEvent} event The change event.
   * @protected
   */

	}, {
		key: '_isValidState',


		/**
   * Verifies that the current link state is valid so the user can save the link. A valid state
   * means that we have a non-empty href that's different from the original one.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _isValidState
   * @protected
   * @return {Boolean} True if the state is valid, false otherwise
   */
		value: function _isValidState() {
			var validState = this.state.linkHref && this.state.linkHref !== this.state.initialLink.href;

			return validState;
		}

		/**
   * Removes the embed in the editor element.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _removeEmbed
   * @protected
   */

	}]);

	return ButtonEmbedEdit;
}(_react2.default.Component);

ButtonEmbedEdit.contextType = _editorContext2.default;
ButtonEmbedEdit.key = 'embedEdit';
exports.default = _editorContext2.default.toProps(ButtonEmbedEdit);

/***/ }),

/***/ "./src/components/buttons/button-embed-video-edit.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-embed-video-edit.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var KEY_ENTER = 13;
var KEY_ESC = 27;

/**
 * The ButtonEmbedVideoEdit class provides functionality for changing text color in a document.
 *
 * @uses ButtonIcon
 *
 * @class ButtonEmbedVideoEdit
 */

var ButtonEmbedVideoEdit = function (_React$Component) {
	_inherits(ButtonEmbedVideoEdit, _React$Component);

	function ButtonEmbedVideoEdit(props) {
		_classCallCheck(this, ButtonEmbedVideoEdit);

		var _this = _possibleConstructorReturn(this, (ButtonEmbedVideoEdit.__proto__ || Object.getPrototypeOf(ButtonEmbedVideoEdit)).call(this, props));

		_this._embedVideoURL = function () {
			var nativeEditor = _this.context.editor.get('nativeEditor');

			nativeEditor.execCommand('embedUrl', {
				type: 'video',
				url: _this.state.videoURL
			});

			// We need to cancelExclusive with the bound parameters in case the button is used
			// inside another in exclusive mode (such is the case of the link button)

			_this.props.cancelExclusive();
		};

		_this._focusVideoUrlInput = function () {
			_reactDom2.default.findDOMNode(_this.refs.linkInput).focus();
		};

		_this._handleKeyDown = function (event) {
			if (event.keyCode === KEY_ENTER || event.keyCode === KEY_ESC) {
				event.preventDefault();
			}

			if (event.keyCode === KEY_ENTER) {
				_this._embedVideoURL();
			} else if (event.keyCode === KEY_ESC) {
				_this.props.cancelExclusive();
			}
		};

		_this._handleVideoURLChange = function (event) {
			_this.setState({
				videoURL: event.target.value
			});
		};

		_this.state = _this.getInitialState();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses on the link input to immediately allow editing. This should only happen if the component
  * is rendered in exclusive mode to prevent aggressive focus stealing.
  *
  * @instance
  * @memberof ButtonEmbedVideoEdit
  * @method componentDidMount
  */


	_createClass(ButtonEmbedVideoEdit, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (this.props.renderExclusive || this.props.manualSelection) {
				// We need to wait for the next rendering cycle before focusing to avoid undesired
				// scrolls on the page

				if (window.requestAnimationFrame) {
					window.requestAnimationFrame(this._focusVideoUrlInput);
				} else {
					setTimeout(this._focusVideoUrlInput, 0);
				}
			}
		}

		/**
   * Lifecycle. Invoked when a component is receiving new props.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method componentWillReceiveProps
   */

	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps() {
			var newState = this.getInitialState();

			this.setState({
				all: undefined,
				keys: undefined,
				new: newState,
				old: undefined
			});
		}

		/**
   * Lifecycle. Invoked once before the component is mounted.
   * The return value will be used as the initial value of this.state.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method getInitialState
   */

	}, {
		key: 'getInitialState',
		value: function getInitialState() {
			// Can't access context from constructor, so get editor from props.

			var editor = this.props.context.editor.get('nativeEditor');
			var element = void 0;

			var selection = editor.getSelection();

			if (selection) {
				var selectedElement = selection.getSelectedElement();

				if (selectedElement) {
					element = selectedElement.findOne('[data-widget="videoembed"]');
				}
			}

			var videoURL = element ? element.getAttribute('data-embed-video-url') : '';

			return {
				element: element,
				initialEmbed: {
					videoURL: videoURL
				},
				videoURL: videoURL
			};
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var inputPlaceholder = AlloyEditor.Strings.pasteVideoLink;

			var clearVideoURLStyle = {
				opacity: this.state.videoURL ? 1 : 0
			};

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-embed-video-edit' },
				_react2.default.createElement(
					'div',
					{ className: 'ae-container-input xxl' },
					_react2.default.createElement('input', {
						className: 'ae-input',
						onChange: this._handleVideoURLChange,
						onKeyDown: this._handleKeyDown,
						placeholder: inputPlaceholder,
						ref: 'linkInput',
						type: 'text',
						value: this.state.videoURL
					}),
					_react2.default.createElement('button', {
						'aria-label': AlloyEditor.Strings.clearInput,
						className: 'ae-button ae-icon-remove',
						onClick: this._clearLink,
						style: clearVideoURLStyle,
						title: AlloyEditor.Strings.clear
					})
				),
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.confirm,
						className: 'ae-button',
						disabled: !this._isValidState(),
						onClick: this._embedVideoURL,
						title: AlloyEditor.Strings.confirm },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'check' })
				)
			);
		}

		/**
   * Clears the link input. This only changes the component internal state, but does not
   * affect the link element of the editor. Only the _removeLink and _updateLink methods
   * are translated to the editor element.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method _clearLink
   * @protected
   */

	}, {
		key: '_clearLink',
		value: function _clearLink() {
			this.setState({
				videoURL: ''
			});
		}

		/**
   * Triggers the embedVideoUrl command to transform the link into an embed media object
   *
   * @instance
   * @memberof EmbedVideoEdit
   * @method _embedVideoURL
   * @protected
   */


		/**
   * Focuses the user cursor on the widget's input.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method _focusVideoUrlInput
   * @protected
   */


		/**
   * Monitors key interaction inside the input element to respond to the keys:
   * - Enter: Creates/updates the link.
   * - Escape: Discards the changes.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method _handleKeyDown
   * @param {SyntheticEvent} event The keyboard event.
   * @protected
   */


		/**
   * Updates the component state when the link input changes on user interaction.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method _handleVideoURLChange
   * @param {SyntheticEvent} event The change event.
   * @protected
   */

	}, {
		key: '_isValidState',


		/**
   * Verifies that the current link state is valid so the user can save the link. A valid state
   * means that we have a non-empty videoURL that's different from the original one.
   *
   * @instance
   * @memberof EmbedVideoEdit
   * @method _isValidState
   * @protected
   * @return {Boolean} True if the state is valid, false otherwise
   */
		value: function _isValidState() {
			var validState = this.state.videoURL && this.state.videoURL !== this.state.initialEmbed.videoURL;

			return validState;
		}
	}]);

	return ButtonEmbedVideoEdit;
}(_react2.default.Component);

ButtonEmbedVideoEdit.contextType = _editorContext2.default;
ButtonEmbedVideoEdit.key = 'embedVideoEdit';
exports.default = _editorContext2.default.toProps(ButtonEmbedVideoEdit);

/***/ }),

/***/ "./src/components/buttons/button-embed-video.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-embed-video.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonEmbedVideoEdit = __webpack_require__(/*! ./button-embed-video-edit.jsx */ "./src/components/buttons/button-embed-video-edit.jsx");

var _buttonEmbedVideoEdit2 = _interopRequireDefault(_buttonEmbedVideoEdit);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonEmbedVideo class provides functionality for changing text color in a document.
 *
 * @class ButtonEmbedVideo
 */
var ButtonEmbedVideo = function (_React$Component) {
	_inherits(ButtonEmbedVideo, _React$Component);

	function ButtonEmbedVideo() {
		_classCallCheck(this, ButtonEmbedVideo);

		return _possibleConstructorReturn(this, (ButtonEmbedVideo.__proto__ || Object.getPrototypeOf(ButtonEmbedVideo)).apply(this, arguments));
	}

	_createClass(ButtonEmbedVideo, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.renderExclusive) {
				return _react2.default.createElement(_buttonEmbedVideoEdit2.default, this.props);
			} else {
				return _react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.video,
						className: 'ae-button',
						'data-type': 'button-embed-video',
						onClick: this.props.requestExclusive,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.video },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'video' })
				);
			}
		}
	}]);

	return ButtonEmbedVideo;
}(_react2.default.Component);

ButtonEmbedVideo.key = 'embedVideo';
ButtonEmbedVideo.propTypes = {
	/**
  * The label that should be used for accessibility purposes.
  *
  * @instance
  * @memberof ButtonEmbedVideo
  * @property {String} label
  */
	label: _propTypes2.default.string,

	/**
  * The tabIndex of the button in its toolbar current state. A value other than -1
  * means that the button has focus and is the active element.
  *
  * @instance
  * @memberof ButtonEmbedVideo
  * @property {Number} tabIndex
  */
	tabIndex: _propTypes2.default.number
};
exports.default = ButtonEmbedVideo;

/***/ }),

/***/ "./src/components/buttons/button-embed.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-embed.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonEmbedEdit = __webpack_require__(/*! ./button-embed-edit.jsx */ "./src/components/buttons/button-embed-edit.jsx");

var _buttonEmbedEdit2 = _interopRequireDefault(_buttonEmbedEdit);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonEmbed class provides functionality for creating and editing an embed link in a document.
 * ButtonEmbed renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonEmbedEdit UI with all the link edition controls.
 *
 * @class ButtonEmbed
 * @uses ButtonKeystroke
 */
var ButtonEmbed = function (_React$Component) {
	_inherits(ButtonEmbed, _React$Component);

	function ButtonEmbed() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonEmbed);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonEmbed.__proto__ || Object.getPrototypeOf(ButtonEmbed)).call.apply(_ref, [this].concat(args))), _this), _this._requestExclusive = function () {
			_this.props.requestExclusive(ButtonEmbed.key);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}
	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonEmbed
  * @method getDefaultProps
  * @return {Object} The default properties.
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default embed
  * @memberof ButtonEmbed
  * @property {String} key
  * @static
  */


	_createClass(ButtonEmbed, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonEmbed
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.renderExclusive) {
				return _react2.default.createElement(_buttonEmbedEdit2.default, this.props);
			} else {
				return _react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.link,
						className: 'ae-button',
						'data-type': 'button-embed',
						onClick: this._requestExclusive,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.link },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'plus' })
				);
			}
		}

		/**
   * Requests the link button to be rendered in exclusive mode to allow the embedding of a link.
   *
   * @instance
   * @memberof ButtonEmbed
   * @method _requestExclusive
   * @protected
   */

	}]);

	return ButtonEmbed;
}(_react2.default.Component);

ButtonEmbed.defaultProps = {
	keystroke: {
		fn: '_requestExclusive',
		keys: CKEDITOR.CTRL + CKEDITOR.SHIFT + 76 /* L*/
		, name: 'embed'
	}
};
ButtonEmbed.key = 'embed';
exports.default = (0, _buttonKeystroke2.default)(ButtonEmbed);

/***/ }),

/***/ "./src/components/buttons/button-h1.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-h1.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonH1 class provides wraps a selection in `h1` element.
 *
 * @class ButtonH1
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonH1 = function (_React$Component) {
	_inherits(ButtonH1, _React$Component);

	function ButtonH1() {
		_classCallCheck(this, ButtonH1);

		return _possibleConstructorReturn(this, (ButtonH1.__proto__ || Object.getPrototypeOf(ButtonH1)).apply(this, arguments));
	}

	_createClass(ButtonH1, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonH1
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonH1
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.h1,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-h1',
					onClick: this.applyStyle,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.h1 },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'h1' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default h1
   * @memberof ButtonH1
   * @property {String} key
   * @static
   */

	}]);

	return ButtonH1;
}(_react2.default.Component);

ButtonH1.defaultProps = {
	style: {
		element: 'h1'
	}
};
ButtonH1.key = 'h1';
exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonH1)));

/***/ }),

/***/ "./src/components/buttons/button-h2.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-h2.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonH2 class provides wraps a selection in `h2` element.
 *
 * @class ButtonH2
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonH2 = function (_React$Component) {
	_inherits(ButtonH2, _React$Component);

	function ButtonH2() {
		_classCallCheck(this, ButtonH2);

		return _possibleConstructorReturn(this, (ButtonH2.__proto__ || Object.getPrototypeOf(ButtonH2)).apply(this, arguments));
	}

	_createClass(ButtonH2, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonH2
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonH2
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.h2,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-h2',
					onClick: this.applyStyle,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.h2 },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'h2' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default h2
   * @memberof ButtonH2
   * @property {String} key
   * @static
   */

	}]);

	return ButtonH2;
}(_react2.default.Component);

ButtonH2.defaultProps = {
	style: {
		element: 'h2'
	}
};
ButtonH2.key = 'h2';
exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonH2)));

/***/ }),

/***/ "./src/components/buttons/button-hline.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-hline.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonHline class provides inserts horizontal line.
 *
 * @class ButtonHline
 * @uses ButtonCommand
 */
var ButtonHline = function (_React$Component) {
	_inherits(ButtonHline, _React$Component);

	function ButtonHline() {
		_classCallCheck(this, ButtonHline);

		return _possibleConstructorReturn(this, (ButtonHline.__proto__ || Object.getPrototypeOf(ButtonHline)).apply(this, arguments));
	}

	_createClass(ButtonHline, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonHline
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonHline
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.horizontalrule,
					className: 'ae-button',
					'data-type': 'button-hline',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.horizontalrule },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'hr' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default hline
   * @memberof ButtonHline
   * @property {String} key
   * @static
   */

	}]);

	return ButtonHline;
}(_react2.default.Component);

ButtonHline.defaultProps = {
	command: 'horizontalrule'
};
ButtonHline.key = 'hline';
exports.default = (0, _buttonCommand2.default)(ButtonHline);

/***/ }),

/***/ "./src/components/buttons/button-icon.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-icon.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = ButtonIcon;

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

function ButtonIcon(_ref) {
	var _ref$className = _ref.className,
	    className = _ref$className === undefined ? '' : _ref$className,
	    symbol = _ref.symbol;

	return _react2.default.createElement(
		_editorContext2.default.Consumer,
		null,
		function (_ref2) {
			var editor = _ref2.editor;

			var nativeEditor = editor.get('nativeEditor');
			var spritemap = nativeEditor.config.spritemap || '';
			var path = spritemap + '#' + symbol;
			var classNamePrefix = className ? ' ' + className : '';
			var combinedClassName = 'ae-svg-icon' + classNamePrefix;

			return _react2.default.createElement(
				'svg',
				{ className: combinedClassName, height: '18', width: '18' },
				_react2.default.createElement('use', { href: path })
			);
		}
	);
}

/***/ }),

/***/ "./src/components/buttons/button-image-align-center.jsx":
/*!**************************************************************!*\
  !*** ./src/components/buttons/button-image-align-center.jsx ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonImageAlignCenter class provides functionality for aligning an image in the center.
 *
 * @class ButtonImageAlignCenter
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignCenter = function (_React$Component) {
	_inherits(ButtonImageAlignCenter, _React$Component);

	function ButtonImageAlignCenter() {
		_classCallCheck(this, ButtonImageAlignCenter);

		return _possibleConstructorReturn(this, (ButtonImageAlignCenter.__proto__ || Object.getPrototypeOf(ButtonImageAlignCenter)).apply(this, arguments));
	}

	_createClass(ButtonImageAlignCenter, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonImageAlignCenter
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonImageAlignCenter
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignCenter,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-image-align-center',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignCenter },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-image-center' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default imageCenter
   * @memberof ButtonImageAlignCenter
   * @property {String} key
   * @static
   */

	}]);

	return ButtonImageAlignCenter;
}(_react2.default.Component);

ButtonImageAlignCenter.defaultProps = {
	command: 'justifycenter'
};
ButtonImageAlignCenter.key = 'imageCenter';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignCenter)));

/***/ }),

/***/ "./src/components/buttons/button-image-align-left.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-image-align-left.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonImageAlignLeft class provides functionality for aligning an image on left.
 *
 * @class ButtonImageAlignLeft
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignLeft = function (_React$Component) {
	_inherits(ButtonImageAlignLeft, _React$Component);

	function ButtonImageAlignLeft() {
		_classCallCheck(this, ButtonImageAlignLeft);

		return _possibleConstructorReturn(this, (ButtonImageAlignLeft.__proto__ || Object.getPrototypeOf(ButtonImageAlignLeft)).apply(this, arguments));
	}

	_createClass(ButtonImageAlignLeft, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonImageAlignLeft
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonImageAlignLeft
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignLeft,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-image-align-left',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignLeft },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-image-left' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default imageLeft
   * @memberof ButtonImageAlignLeft
   * @property {String} key
   * @static
   */

	}]);

	return ButtonImageAlignLeft;
}(_react2.default.Component);

ButtonImageAlignLeft.defaultProps = {
	command: 'justifyleft'
};
ButtonImageAlignLeft.key = 'imageLeft';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignLeft)));

/***/ }),

/***/ "./src/components/buttons/button-image-align-right.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-image-align-right.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonImageAlignRight class provides functionality for aligning an image on right.
 *
 * @class ButtonImageAlignRight
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignRight = function (_React$Component) {
	_inherits(ButtonImageAlignRight, _React$Component);

	function ButtonImageAlignRight() {
		_classCallCheck(this, ButtonImageAlignRight);

		return _possibleConstructorReturn(this, (ButtonImageAlignRight.__proto__ || Object.getPrototypeOf(ButtonImageAlignRight)).apply(this, arguments));
	}

	_createClass(ButtonImageAlignRight, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonImageAlignRight
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonImageAlignRight
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignRight,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-image-align-right',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignRight },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-image-right' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default imageRight
   * @memberof ButtonImageAlignRight
   * @property {String} key
   * @static
   */

	}]);

	return ButtonImageAlignRight;
}(_react2.default.Component);

ButtonImageAlignRight.defaultProps = {
	command: 'justifyright'
};
ButtonImageAlignRight.key = 'imageRight';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignRight)));

/***/ }),

/***/ "./src/components/buttons/button-image.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-image.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonImage class inserts an image to the content.
 *
 * @class ButtonImage
 */
var ButtonImage = function (_React$Component) {
	_inherits(ButtonImage, _React$Component);

	function ButtonImage(props) {
		_classCallCheck(this, ButtonImage);

		var _this = _possibleConstructorReturn(this, (ButtonImage.__proto__ || Object.getPrototypeOf(ButtonImage)).call(this, props));

		_this.handleClick = function () {
			_this.fileInput.current.click();
		};

		_this._onInputChange = function () {
			var inputEl = _this.fileInput.current;

			// On IE11 the function might be called with an empty array of
			// files. In such a case, no actions will be taken.

			if (!inputEl.files.length) {
				return;
			}

			var reader = new FileReader();
			var file = inputEl.files[0];

			reader.onload = function (event) {
				var editor = _this.context.editor.get('nativeEditor');

				var result = editor.fire('beforeImageAdd', {
					imageFiles: file
				});

				if (result) {
					var el = CKEDITOR.dom.element.createFromHtml('<img src="' + event.target.result + '">');

					editor.insertElement(el);

					editor.fire('actionPerformed', _this);

					var imageData = {
						el: el,
						file: file
					};

					editor.fire('imageAdd', imageData);
				}
			};

			reader.readAsDataURL(file);

			inputEl.value = '';
		};

		_this.fileInput = _react2.default.createRef();
		return _this;
	}

	/**
  * Lifecycle. Renders the UI of the button.
  *
  * @instance
  * @memberof ButtonImage
  * @method render
  * @return {Object} The content which should be rendered.
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default image
  * @memberof ButtonImage
  * @property {String} key
  * @static
  */


	_createClass(ButtonImage, [{
		key: 'render',
		value: function render() {
			var inputSyle = { display: 'none' };

			return _react2.default.createElement(
				'div',
				null,
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.image,
						className: 'ae-button',
						'data-type': 'button-image',
						onClick: this.handleClick,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.image },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'document-image' })
				),
				_react2.default.createElement('input', {
					accept: 'image/*',
					onChange: this._onInputChange,
					ref: this.fileInput,
					style: inputSyle,
					type: 'file'
				})
			);
		}

		/**
   * Simulates click on the input element. This will open browser's native file open dialog.
   *
   * @instance
   * @memberof ButtonImage
   * @method handleClick
   * @param {SyntheticEvent} event The received click event on the button.
   */


		/**
   * On input change, reads the chosen file and fires an event `beforeImageAdd` with the image which will be added
   * to the content. The image file will be passed in the `imageFiles` property.
   * If any of the listeners returns `false` or cancels the event, the image won't be added to the content.
   * Otherwise, an event `imageAdd` will be fired with the inserted element into the editable area.
   * The passed params will be:
   * - `el` - the created img element
   * - `file` - the original image file from the input element
   *
   * @fires ButtonImage#beforeImageAdd
   * @fires ButtonImage#imageAdd
   * @instance
   * @memberof ButtonImage
   * @method _onInputChange
   * @protected
   */

	}]);

	return ButtonImage;
}(_react2.default.Component);

ButtonImage.contextType = _editorContext2.default;
ButtonImage.key = 'imageFromFile';
exports.default = ButtonImage;

/***/ }),

/***/ "./src/components/buttons/button-indent-block.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-indent-block.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonIndentBlock class provides functionality for indenting the selected blocks.
 *
 * @class ButtonIndentBlock
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonIndentBlock = function (_React$Component) {
	_inherits(ButtonIndentBlock, _React$Component);

	function ButtonIndentBlock() {
		_classCallCheck(this, ButtonIndentBlock);

		return _possibleConstructorReturn(this, (ButtonIndentBlock.__proto__ || Object.getPrototypeOf(ButtonIndentBlock)).apply(this, arguments));
	}

	_createClass(ButtonIndentBlock, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonIndentBlock
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonIndentBlock
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.indent,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-indent-block',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.indent },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'indent-more' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default indentBlock
   * @memberof ButtonIndentBlock
   * @property {String} key
   * @static
   */

	}]);

	return ButtonIndentBlock;
}(_react2.default.Component);

ButtonIndentBlock.defaultProps = {
	command: 'indent'
};
ButtonIndentBlock.key = 'indentBlock';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonIndentBlock)));

/***/ }),

/***/ "./src/components/buttons/button-italic.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-italic.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonItalic class provides functionality for styling an selection with italic (em) style.
 *
 * @class ButtonItalic
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonItalic = function (_React$Component) {
	_inherits(ButtonItalic, _React$Component);

	function ButtonItalic() {
		_classCallCheck(this, ButtonItalic);

		return _possibleConstructorReturn(this, (ButtonItalic.__proto__ || Object.getPrototypeOf(ButtonItalic)).apply(this, arguments));
	}

	_createClass(ButtonItalic, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonItalic
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonItalic
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.italic,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-italic',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.italic },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'italic' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default italic
   * @memberof ButtonItalic
   * @property {String} key
   * @static
   */

	}]);

	return ButtonItalic;
}(_react2.default.Component);

ButtonItalic.defaultProps = {
	command: 'italic',
	keystroke: {
		fn: 'execCommand',
		keys: CKEDITOR.CTRL + 73 /* I*/
		, name: 'italic'
	},
	style: 'coreStyles_italic'
};
ButtonItalic.key = 'italic';
exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonItalic))));

/***/ }),

/***/ "./src/components/buttons/button-item-selector-audio.jsx":
/*!***************************************************************!*\
  !*** ./src/components/buttons/button-item-selector-audio.jsx ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * @class ButtonItemSelectorAudio
 * @uses ButtonCommand
 */
var ButtonItemSelectorAudio = function (_React$Component) {
	_inherits(ButtonItemSelectorAudio, _React$Component);

	function ButtonItemSelectorAudio() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonItemSelectorAudio);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonItemSelectorAudio.__proto__ || Object.getPrototypeOf(ButtonItemSelectorAudio)).call.apply(_ref, [this].concat(args))), _this), _this._handleClick = function () {
			_this.execCommand(null);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(ButtonItemSelectorAudio, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.audio,
					className: 'ae-button',
					'data-type': 'button-audio',
					onClick: this._handleClick,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.audio },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'audio' })
			);
		}
	}]);

	return ButtonItemSelectorAudio;
}(_react2.default.Component);

ButtonItemSelectorAudio.defaultProps = {
	command: 'audioselector'
};
ButtonItemSelectorAudio.key = 'audio';
exports.default = (0, _buttonCommand2.default)(ButtonItemSelectorAudio);

/***/ }),

/***/ "./src/components/buttons/button-item-selector-image.jsx":
/*!***************************************************************!*\
  !*** ./src/components/buttons/button-item-selector-image.jsx ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * @class ButtonItemSelectorImage
 * @uses ButtonCommand
 */
var ButtonItemSelectorImage = function (_React$Component) {
	_inherits(ButtonItemSelectorImage, _React$Component);

	function ButtonItemSelectorImage() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonItemSelectorImage);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonItemSelectorImage.__proto__ || Object.getPrototypeOf(ButtonItemSelectorImage)).call.apply(_ref, [this].concat(args))), _this), _this._handleClick = function () {
			_this.execCommand(null);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(ButtonItemSelectorImage, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.image,
					className: 'ae-button',
					'data-type': 'button-image',
					onClick: this._handleClick,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.image },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'picture' })
			);
		}
	}]);

	return ButtonItemSelectorImage;
}(_react2.default.Component);

ButtonItemSelectorImage.defaultProps = {
	command: 'imageselector'
};
ButtonItemSelectorImage.key = 'image';
exports.default = (0, _buttonCommand2.default)(ButtonItemSelectorImage);

/***/ }),

/***/ "./src/components/buttons/button-item-selector-video.jsx":
/*!***************************************************************!*\
  !*** ./src/components/buttons/button-item-selector-video.jsx ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * @class ButtonItemSelectorVideo
 * @uses ButtonCommand
 */
var ButtonItemSelectorVideo = function (_React$Component) {
	_inherits(ButtonItemSelectorVideo, _React$Component);

	function ButtonItemSelectorVideo() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonItemSelectorVideo);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonItemSelectorVideo.__proto__ || Object.getPrototypeOf(ButtonItemSelectorVideo)).call.apply(_ref, [this].concat(args))), _this), _this._handleClick = function () {
			_this.execCommand(null);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(ButtonItemSelectorVideo, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.video,
					className: 'ae-button',
					'data-type': 'button-video',
					onClick: this._handleClick,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.video },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'document-multimedia' })
			);
		}
	}]);

	return ButtonItemSelectorVideo;
}(_react2.default.Component);

ButtonItemSelectorVideo.defaultProps = {
	command: 'videoselector'
};
ButtonItemSelectorVideo.key = 'video';
exports.default = (0, _buttonCommand2.default)(ButtonItemSelectorVideo);

/***/ }),

/***/ "./src/components/buttons/button-link-autocomplete-list.jsx":
/*!******************************************************************!*\
  !*** ./src/components/buttons/button-link-autocomplete-list.jsx ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonLinkAutocompleteList class provides functionality for showing a list of
 * items that can be selected for the link.
 *
 * @class ButtonLinkAutocompleteList
 * @uses WidgetFocusManager
 */
var ButtonLinkAutocompleteList = function (_React$Component) {
	_inherits(ButtonLinkAutocompleteList, _React$Component);

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonLinkAutocompleteList
  * @method getDefaultProps
  * @return {Object} The default properties.
  */
	function ButtonLinkAutocompleteList(props) {
		_classCallCheck(this, ButtonLinkAutocompleteList);

		var _this = _possibleConstructorReturn(this, (ButtonLinkAutocompleteList.__proto__ || Object.getPrototypeOf(ButtonLinkAutocompleteList)).call(this, props));

		_this.state = {
			items: []
		};
		return _this;
	}

	/**
  * Lifecycle. Invoked when a component is receiving new props.
  * This method is not called for the initial render.
  *
  * @instance
  * @memberof ButtonLinkAutocompleteList
  * @method componentWillReceiveProps
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default buttonLinkAutocompleteList
  * @memberof ButtonLinkAutocompleteList
  * @property {String} key
  * @static
  */


	_createClass(ButtonLinkAutocompleteList, [{
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps(nextProps) {
			if (!nextProps.term || nextProps.term !== this.props.term) {
				clearTimeout(this._timeout);

				if (nextProps.term) {
					this._timeout = setTimeout(this._updateItems, this.props.delay);
				} else {
					this.setState({
						items: []
					});
				}
			}

			if (nextProps.autocompleteSelected) {
				setTimeout(this.focus, 0);
				this.props.setAutocompleteState({
					selected: false
				});
			}
		}

		/**
   * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
   *
   * @instance
   * @memberof ButtonLinkAutocompleteList
   * @method componentWillUnmount
   */

	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			clearTimeout(this._timeout);
		}

		/**
   * Lifecycle. Renders the UI of the list.
   *
   * @instance
   * @memberof ButtonLinkAutocompleteList
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			if (!this.props.expanded || !this.state.items.length) {
				return null;
			}

			return _react2.default.createElement(
				_buttonDropdown2.default,
				null,
				this._renderAutocompleteItems(this.state.items)
			);
		}

		/**
   * Lifecycle. Invoked before rendering when new props or state are being received.
   * This method is not called for the initial render or when forceUpdate is used.
   *
   * @instance
   * @memberof ButtonLinkAutocompleteList
   * @method  shouldComponentUpdate
   * @return {Boolean} Returns false when the transition to the new props and state will not
   * require a component update.
   */

	}, {
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps, nextState) {
			return nextProps.expanded !== this.props.expanded || nextProps.term !== this.props.term || nextState.items !== this.state.items;
		}

		/**
   * Renders a set of list items for the provided items
   *
   * @instance
   * @memberof ButtonLinkAutocompleteList
   * @method _renderAutocompleteItems
   * @param {Array} items List of autocomplete items to render
   * @protected
   * @return {Array} Rendered list item instances
   */

	}, {
		key: '_renderAutocompleteItems',
		value: function _renderAutocompleteItems(items) {
			var _this2 = this;

			items = items || [];

			var handleLinkAutocompleteClick = this.props.handleLinkAutocompleteClick;

			return items.map(function (item) {
				var className = _this2.props.term === item.url ? 'ae-toolbar-element active' : 'ae-toolbar-element';

				return _react2.default.createElement(
					'li',
					{ key: item.url, role: 'option' },
					_react2.default.createElement(
						'button',
						{
							className: className,
							'data-value': item.url,
							onClick: handleLinkAutocompleteClick },
						item.title
					)
				);
			});
		}

		/**
   * Retrieves the data according to {this.props.term} and calls setState() with the returned data
   *
   * @instance
   * @memberof ButtonLinkAutocompleteList
   * @method _updateItems
   * @protected
   */

	}, {
		key: '_updateItems',
		value: function _updateItems() {
			var _this3 = this;

			if (!this.props.term) {
				return;
			}

			var promise = Promise.resolve(this.props.data(this.props.term));

			promise.then(function (items) {
				if (items.length && !_this3.props.expanded) {
					_this3.props.toggleDropdown();
				}

				_this3.setState({
					items: items
				});
			});
		}
	}]);

	return ButtonLinkAutocompleteList;
}(_react2.default.Component);

ButtonLinkAutocompleteList.defaultProps = {
	circular: false,
	data: [],
	delay: 100,
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	}
};
ButtonLinkAutocompleteList.key = 'buttonLinkAutocompleteList';
exports.default = (0, _widgetFocusManager2.default)(ButtonLinkAutocompleteList);

/***/ }),

/***/ "./src/components/buttons/button-link-browse.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-link-browse.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonProps = __webpack_require__(/*! ../base/button-props */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonLinkEditBrowse = __webpack_require__(/*! ./button-link-edit-browse.jsx */ "./src/components/buttons/button-link-edit-browse.jsx");

var _buttonLinkEditBrowse2 = _interopRequireDefault(_buttonLinkEditBrowse);

var _buttonLink = __webpack_require__(/*! ./button-link.jsx */ "./src/components/buttons/button-link.jsx");

var _buttonLink2 = _interopRequireDefault(_buttonLink);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonLinkBrowse class provides functionality for changing text color in a document.
 *
 * @uses ButtonKeystroke
 * @uses ButtonProps
 *
 * @class ButtonLinkBrowse
 */
var ButtonLinkBrowse = function (_React$Component) {
	_inherits(ButtonLinkBrowse, _React$Component);

	function ButtonLinkBrowse() {
		_classCallCheck(this, ButtonLinkBrowse);

		return _possibleConstructorReturn(this, (ButtonLinkBrowse.__proto__ || Object.getPrototypeOf(ButtonLinkBrowse)).apply(this, arguments));
	}

	_createClass(ButtonLinkBrowse, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.renderExclusive) {
				this.props = this.mergeButtonCfgProps();

				return _react2.default.createElement(_buttonLinkEditBrowse2.default, this.props);
			} else {
				return _react2.default.createElement(_buttonLink2.default, this.props);
			}
		}

		/**
   * Requests the link button to be rendered in exclusive mode to allow the creation of a link.
   *
   * @protected
   * @method _requestExclusive
   */

	}, {
		key: '_requestExclusive',
		value: function _requestExclusive() {
			this.props.requestExclusive(ButtonLinkBrowse.key);
		}
	}]);

	return ButtonLinkBrowse;
}(_react2.default.Component);

ButtonLinkBrowse.defaultProps = {
	keystroke: {
		fn: '_requestExclusive',
		keys: CKEDITOR.CTRL + 76 /* L*/
		, name: 'linkBrowse'
	}
};
ButtonLinkBrowse.key = 'linkBrowse';
ButtonLinkBrowse.propTypes = {
	/**
  * The label that should be used for accessibility purposes.
  *
  * @property {String} label
  */
	label: _propTypes2.default.string,

	/**
  * The tabIndex of the button in its toolbar current state. A value other than -1
  * means that the button has focus and is the active element.
  *
  * @property {Number} tabIndex
  */
	tabIndex: _propTypes2.default.number
};
exports.default = (0, _buttonProps2.default)((0, _buttonKeystroke2.default)(ButtonLinkBrowse));

/***/ }),

/***/ "./src/components/buttons/button-link-edit-browse.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-link-edit-browse.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonLinkEdit = __webpack_require__(/*! ./button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The LinkEditBrowse class provides functionality for creating and editing a link in a document,
 * and also allows to link to an existing file in DM.
 * Provides UI for creating, editing and removing a link.
 *
 * @class ButtonLinkEditBrowse
 */
var ButtonLinkEditBrowse = function (_React$Component) {
	_inherits(ButtonLinkEditBrowse, _React$Component);

	/**
  *
  * @inheritDoc
  */
	function ButtonLinkEditBrowse(props) {
		_classCallCheck(this, ButtonLinkEditBrowse);

		var _this = _possibleConstructorReturn(this, (ButtonLinkEditBrowse.__proto__ || Object.getPrototypeOf(ButtonLinkEditBrowse)).call(this, props));

		_this._browseClick = function () {
			var editor = _this.context.editor.get('nativeEditor');
			var url = editor.config.documentBrowseLinkUrl;
			var browseLinkCallback = editor.config.documentBrowseLinkCallback;
			var linkTarget = _this.linkEditButtonRef.current ? _this.linkEditButtonRef.current.state.linkTarget : '';

			var changeLinkCallback = function changeLinkCallback(selectedItem) {
				_this._updateLink(selectedItem.value, linkTarget, selectedItem.title);
			};

			if (_lang2.default.isFunction(browseLinkCallback)) {
				browseLinkCallback.apply(null, [editor, url, changeLinkCallback]);
			}
		};

		_this._updateLink = function (linkHref, linkTarget, linkTitle) {
			var editor = _this.context.editor.get('nativeEditor');
			var linkUtils = new CKEDITOR.Link(editor, { appendProtocol: false });
			var linkAttrs = {
				target: linkTarget
			};
			var modifySelection = { advance: true };

			if (linkHref) {
				if (editor.plugins && editor.plugins.creole && !linkTitle) {
					linkHref = location.origin + linkHref;
				}

				if (_this.state.element) {
					linkAttrs.href = linkHref;

					linkUtils.update(linkAttrs, _this.state.element, modifySelection);
				} else {
					linkUtils.create(linkHref, linkAttrs, modifySelection);
				}

				editor.fire('actionPerformed', _this);
			}
		};

		var link = new CKEDITOR.Link(
		// Can't access context from constructor, so get editor from props.

		_this.props.context.editor.get('nativeEditor')).getFromSelection();

		var href = link ? link.getAttribute('href') : '';

		_this.linkEditButtonRef = _react2.default.createRef();

		_this.state = {
			element: link,
			linkHref: href
		};
		return _this;
	}

	/**
  * Lifecycle. Renders the UI of the button.
  *
  * @method render
  * @return {Object} The content which should be rendered.
  */


	_createClass(ButtonLinkEditBrowse, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-link-edit-browse' },
				_react2.default.createElement(_buttonLinkEdit2.default, _extends({ ref: this.linkEditButtonRef }, this.props)),
				_react2.default.createElement(
					'button',
					{
						'aria-label': 'Browse',
						className: 'ae-button',
						onClick: this._browseClick,
						title: 'browse' },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'folder' })
				)
			);
		}

		/**
   * Opens an item selector dialog.
   *
   * @protected
   * @method _browseClick
   */


		/**
   * Updates the link in the editor element. If the element didn't exist previously, it will
   * create a new <a> element with the href specified in the link input.
   *
   * @protected
   * @method _updateLink
   * @param {String} linkHref href value for the link
   * @param {String} linkTarget target value for the link
   * @param {String} linkTitle if the link is a title that points to a wiki page (only works for creole)
   */

	}]);

	return ButtonLinkEditBrowse;
}(_react2.default.Component);

ButtonLinkEditBrowse.contextType = _editorContext2.default;
ButtonLinkEditBrowse.key = 'linkEditBrowse';
exports.default = _editorContext2.default.toProps(ButtonLinkEditBrowse);

/***/ }),

/***/ "./src/components/buttons/button-link-edit.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-link-edit.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonLinkAutocompleteList = __webpack_require__(/*! ./button-link-autocomplete-list.jsx */ "./src/components/buttons/button-link-autocomplete-list.jsx");

var _buttonLinkAutocompleteList2 = _interopRequireDefault(_buttonLinkAutocompleteList);

var _buttonLinkTargetEdit = __webpack_require__(/*! ./button-link-target-edit.jsx */ "./src/components/buttons/button-link-target-edit.jsx");

var _buttonLinkTargetEdit2 = _interopRequireDefault(_buttonLinkTargetEdit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonLinkEdit class provides functionality for creating and editing a link in a document.
 * Provides UI for creating, editing and removing a link.
 *
 * @class ButtonLinkEdit
 * @uses WidgetDropdown
 * @uses WidgetFocusManager
 */
var ButtonLinkEdit = function (_React$Component) {
	_inherits(ButtonLinkEdit, _React$Component);

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonLinkEdit
  * @method getDefaultProps
  * @return {Object} The default properties.
  */
	function ButtonLinkEdit(props) {
		_classCallCheck(this, ButtonLinkEdit);

		var _this = _possibleConstructorReturn(this, (ButtonLinkEdit.__proto__ || Object.getPrototypeOf(ButtonLinkEdit)).call(this, props));

		_this._clearLink = function () {
			_this.setState({
				linkHref: ''
			});

			_this._focusLinkInput();
		};

		_this._handleKeyDown = function (event) {
			if (event.keyCode === 13 || event.keyCode === 27) {
				event.preventDefault();
			}

			if (event.keyCode === 13) {
				_this._updateLink();
			} else if (event.keyCode === 40) {
				_this.setState({
					autocompleteSelected: true
				});
			} else if (event.keyCode === 27) {
				var editor = _this.context.editor.get('nativeEditor');

				new CKEDITOR.Link(editor).advanceSelection();

				_this.context.editor.get('nativeEditor').fire('actionPerformed', _this);
			}
		};

		_this._handleLinkHrefChange = function (event) {
			_this.setState({
				linkHref: event.target.value
			});

			_this._focusLinkInput();
		};

		_this._handleLinkTargetChange = function (event) {
			_this.setState({
				itemDropdown: null,
				linkTarget: event.target.getAttribute('data-value')
			});

			_this._focusLinkInput();
		};

		_this._removeLink = function () {
			var editor = _this.context.editor.get('nativeEditor');
			var linkUtils = new CKEDITOR.Link(editor);
			var selection = editor.getSelection();
			var bookmarks = selection.createBookmarks();

			linkUtils.remove(_this.state.element, { advance: false });

			selection.selectBookmarks(bookmarks);

			// We need to cancelExclusive with the bound parameters in case the button is used
			// inside another in exclusive mode (such is the case of the link button)

			_this.props.cancelExclusive();

			editor.fire('actionPerformed', _this);
		};

		_this._updateLink = function () {
			var editor = _this.context.editor.get('nativeEditor');
			var linkUtils = new CKEDITOR.Link(editor, {
				appendProtocol: _this.props.appendProtocol
			});
			var linkAttrs = {
				target: _this.state.linkTarget || null
			};
			var modifySelection = { advance: false };

			if (_this.state.linkHref) {
				if (_this.state.element) {
					linkAttrs.href = _this.state.linkHref;

					linkUtils.update(linkAttrs, _this.state.element, modifySelection);
				} else {
					if (!_this.state.linkTarget) {
						linkAttrs = {};
					}

					linkUtils.create(_this.state.linkHref, linkAttrs, modifySelection);
				}

				editor.fire('actionPerformed', _this);
			}

			// We need to cancelExclusive with the bound parameters in case the button is used
			// inside another in exclusive mode (such is the case of the link button)

			_this.props.cancelExclusive();
		};

		_this.linkInput = _react2.default.createRef();
		_this.state = _this._getInitialState();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses on the link input to immediately allow editing. This should only happen if the component
  * is rendered in exclusive mode to prevent aggressive focus stealing.
  *
  * @instance
  * @memberof ButtonLinkEdit
  * @method componentDidMount
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default linkEdit
  * @memberof ButtonLinkEdit
  * @property {String} key
  * @static
  */


	_createClass(ButtonLinkEdit, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (this.props.renderExclusive || this.props.manualSelection) {
				// We need to wait for the next rendering cycle before focusing to avoid undesired
				// scrolls on the page

				this._focusLinkInput();
			}
		}

		/**
   * Lifecycle. Invoked when a component is receiving new props.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method componentWillReceiveProps
   */

	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps() {
			this.setState(this._getInitialState());
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var targetSelector = {
				allowedTargets: this.props.allowedTargets,
				editor: this.context.editor,
				handleLinkTargetChange: this._handleLinkTargetChange,
				selectedTarget: this.state.linkTarget || AlloyEditor.Strings.linkTargetDefault
			};

			targetSelector = this.mergeDropdownProps(targetSelector, _buttonLinkTargetEdit2.default.key);

			var autocompleteDropdown = void 0;

			if (this.props.data) {
				var dataFn = this.props.data;

				if (!_lang2.default.isFunction(dataFn)) {
					var items = this.props.data;

					dataFn = function dataFn() {
						return items;
					};
				}

				var autocompleteDropdownProps = {
					autocompleteSelected: this.state.autocompleteSelected,
					data: dataFn,
					editor: this.context.editor,
					handleLinkAutocompleteClick: this._handleLinkAutocompleteClick,
					onDismiss: this.props.toggleDropdown,
					setAutocompleteState: this._setAutocompleteState,
					term: this.state.linkHref
				};

				autocompleteDropdownProps = this.mergeDropdownProps(autocompleteDropdownProps, _buttonLinkAutocompleteList2.default.key);

				autocompleteDropdown = _react2.default.createElement(_buttonLinkAutocompleteList2.default, autocompleteDropdownProps);
			}

			var buttonClearLink = void 0;

			if (this.state.linkHref) {
				buttonClearLink = _react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.clearInput,
						className: 'ae-button ae-button-clear',
						onClick: this._clearLink,
						title: AlloyEditor.Strings.clear },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'times-circle' })
				);
			}

			var placeholderProp = {};

			if (!CKEDITOR.env.ie && AlloyEditor.Strings) {
				placeholderProp.placeholder = AlloyEditor.Strings.editLink;
			}

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-edit-link' },
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.removeLink,
						className: 'ae-button',
						disabled: !this.state.element,
						onClick: this._removeLink,
						title: AlloyEditor.Strings.remove },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'chain-broken' })
				),
				_react2.default.createElement(
					'div',
					{ className: 'ae-container-input xxl' },
					this.props.showTargetSelector && _react2.default.createElement(_buttonLinkTargetEdit2.default, targetSelector),
					_react2.default.createElement(
						'div',
						{ className: 'ae-container-input' },
						_react2.default.createElement('input', _extends({
							className: 'ae-input',
							onChange: this._handleLinkHrefChange,
							onKeyDown: this._handleKeyDown
						}, placeholderProp, {
							ref: this.linkInput,
							type: 'text',
							value: this.state.linkHref
						})),
						autocompleteDropdown
					),
					buttonClearLink
				),
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.confirm,
						className: 'ae-button',
						disabled: !this._isValidState(),
						onClick: this._updateLink,
						title: AlloyEditor.Strings.confirm },
					_react2.default.createElement(_buttonIcon2.default, { className: 'ae-icon-svg-check', symbol: 'check' })
				)
			);
		}

		/**
   * The return value will be used as the initial value of this.state.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _getInitialState
   * @protected
   * @return {Object}
   */

	}, {
		key: '_getInitialState',
		value: function _getInitialState() {
			// Can't access context from contructor, so get editor from props.

			var editor = this.props.context.editor;
			var defaultLinkTarget = this.props.defaultLinkTarget;


			var link = new CKEDITOR.Link(editor.get('nativeEditor')).getFromSelection();
			var href = link && link.getAttribute('href') || '';
			var target = link && link.getAttribute('target') || defaultLinkTarget;

			return {
				autocompleteSelected: false,
				element: link,
				initialLink: {
					href: href,
					target: target
				},
				linkHref: href,
				linkTarget: target
			};
		}

		/**
   * Clears the link input. This only changes the component internal state, but does not
   * affect the link element of the editor. Only the _removeLink and _updateLink methods
   * are translated to the editor element.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _clearLink
   * @protected
   */

	}, {
		key: '_focusLinkInput',


		/**
   * Focuses the user cursor on the widget's input.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _focusLinkInput
   * @protected
   */
		value: function _focusLinkInput() {
			var instance = this;

			var focusLinkEl = function focusLinkEl() {
				instance.linkInput.current.focus();
			};

			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(focusLinkEl);
			} else {
				setTimeout(focusLinkEl, 0);
			}
		}

		/**
   * Monitors key interaction inside the input element to respond to the keys:
   * - Enter: Creates/updates the link.
   * - Escape: Discards the changes.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _handleKeyDown
   * @param {SyntheticEvent} event The keyboard event.
   * @protected
   */


		/**
   * Updates the component state when the link input changes on user interaction.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _handleLinkHrefChange
   * @param {SyntheticEvent} event The change event.
   * @protected
   */


		/**
   * Updates the component state when the link target changes on user interaction.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _handleLinkTargetChange
   * @param {SyntheticEvent} event The click event.
   * @protected
   */

	}, {
		key: '_handleLinkAutocompleteClick',


		/**
   * Updates the component state when an autocomplete link result is selected by user interaction.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _handleLinkAutocompleteClick
   * @param {SyntheticEvent} event The click event.
   * @protected
   */
		value: function _handleLinkAutocompleteClick(event) {
			this.setState({
				itemDropdown: null,
				linkHref: event.target.getAttribute('data-value')
			});

			this._focusLinkInput();
		}

		/**
   * Verifies that the current link state is valid so the user can save the link. A valid state
   * means that we have a non-empty href and that either that or the link target are different
   * from the original link.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _isValidState
   * @protected
   * @return {Boolean} [description]
   */

	}, {
		key: '_isValidState',
		value: function _isValidState() {
			var validState = this.state.linkHref && (this.state.linkHref !== this.state.initialLink.href || this.state.linkTarget !== this.state.initialLink.target);

			return validState;
		}

		/**
   * Removes the link in the editor element.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _removeLink
   * @protected
   */

	}, {
		key: '_setAutocompleteState',


		/**
   * Update autocompleteSelected state to focus and select autocompleteÂ´s dropdown
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _setAutocompleteState
   * @protected
   */
		value: function _setAutocompleteState(state) {
			this.setState({
				autocompleteSelected: state.selected
			});
		}

		/**
   * Updates the link in the editor element. If the element didn't exist previously, it will
   * create a new <a> element with the href specified in the link input.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _updateLink
   * @protected
   */

	}]);

	return ButtonLinkEdit;
}(_react2.default.Component);

ButtonLinkEdit.contextType = _editorContext2.default;
ButtonLinkEdit.defaultProps = {
	appendProtocol: true,
	autocompleteUrl: '',
	circular: true,
	customIndexStart: true,
	defaultLinkTarget: '',
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	},
	showTargetSelector: true
};
ButtonLinkEdit.key = 'linkEdit';
exports.default = _editorContext2.default.toProps((0, _widgetDropdown2.default)((0, _widgetFocusManager2.default)(ButtonLinkEdit)));

/***/ }),

/***/ "./src/components/buttons/button-link-target-edit.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-link-target-edit.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonTargetList = __webpack_require__(/*! ./button-target-list.jsx */ "./src/components/buttons/button-target-list.jsx");

var _buttonTargetList2 = _interopRequireDefault(_buttonTargetList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonLinkTargetEdit class provides functionality for changing the target of a link
 * in the document.
 *
 * @class ButtonLinkTargetEdit
 */
var ButtonLinkTargetEdit = function (_React$Component) {
	_inherits(ButtonLinkTargetEdit, _React$Component);

	function ButtonLinkTargetEdit() {
		_classCallCheck(this, ButtonLinkTargetEdit);

		return _possibleConstructorReturn(this, (ButtonLinkTargetEdit.__proto__ || Object.getPrototypeOf(ButtonLinkTargetEdit)).apply(this, arguments));
	}

	_createClass(ButtonLinkTargetEdit, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonLinkTargetEdit
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var handleLinkTargetChange = this.props.handleLinkTargetChange;
			var allowedLinkTargets = this.props.allowedTargets;

			return _react2.default.createElement(
				'div',
				{
					className: 'ae-container-dropdown ae-container-dropdown-medium ae-container-edit-link-target ae-has-dropdown',
					tabIndex: '0' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': this.props.selectedTarget,
						className: 'ae-toolbar-element',
						onClick: this.props.toggleDropdown,
						role: 'combobox',
						tabIndex: this.props.tabIndex,
						title: this.props.selectedTarget },
					_react2.default.createElement(
						'div',
						{ className: 'ae-container' },
						_react2.default.createElement(
							'span',
							{ className: 'ae-container-dropdown-selected-item' },
							this.props.selectedTarget
						),
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'caret-bottom' })
					)
				),
				this.props.expanded && _react2.default.createElement(_buttonTargetList2.default, {
					allowedLinkTargets: allowedLinkTargets,
					handleLinkTargetChange: handleLinkTargetChange,
					onDismiss: this.props.toggleDropdown,
					selectedTarget: this.props.selectedTarget
				})
			);
		}

		/**
   * Lifecycle. Invoked before rendering when new props or state are being received.
   * This method is not called for the initial render or when forceUpdate is used.
   *
   * @instance
   * @memberof ButtonLinkTargetEdit
   * @method  shouldComponentUpdate
   * @return {Boolean} Returns false when the transition to the new props and state will not
   * require a component update.
   */

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default linkTargetEdit
   * @memberof ButtonLinkTargetEdit
   * @property {String} key
   * @static
   */

	}, {
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps) {
			return nextProps.expanded !== this.props.expanded || nextProps.selectedTarget !== this.props.selectedTarget;
		}
	}]);

	return ButtonLinkTargetEdit;
}(_react2.default.Component);

ButtonLinkTargetEdit.key = 'linkTargetEdit';
exports.default = ButtonLinkTargetEdit;

/***/ }),

/***/ "./src/components/buttons/button-link.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-link.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonProps = __webpack_require__(/*! ../base/button-props */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonLinkEdit = __webpack_require__(/*! ./button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonLink class provides functionality for creating and editing a link in a document. ButtonLink
 * renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonLinkEdit UI with all the link edition controls.
 *
 * @class ButtonLink
 * @uses ButtonProps
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 */
var ButtonLink = function (_React$Component) {
	_inherits(ButtonLink, _React$Component);

	function ButtonLink() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonLink);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonLink.__proto__ || Object.getPrototypeOf(ButtonLink)).call.apply(_ref, [this].concat(args))), _this), _this._requestExclusive = function () {
			_this.props.requestExclusive(ButtonLink.key);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonLink
  * @method getDefaultProps
  * @return {Object} The default properties.
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default link
  * @memberof ButtonLink
  * @property {String} key
  * @static
  */


	_createClass(ButtonLink, [{
		key: 'isActive',


		/**
   * Checks if the current selection is contained within a link.
   *
   * @instance
   * @memberof ButtonLink
   * @method isActive
   * @return {Boolean} True if the selection is inside a link, false otherwise.
   */
		value: function isActive() {
			return new CKEDITOR.Link(this.context.editor.get('nativeEditor')).getFromSelection() !== null;
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonLink
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			if (this.props.renderExclusive) {
				var props = this.mergeButtonCfgProps();

				return _react2.default.createElement(_buttonLinkEdit2.default, props);
			} else {
				return _react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.link,
						className: cssClass,
						'data-type': 'button-link',
						onClick: this._requestExclusive,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.link },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'link' })
				);
			}
		}

		/**
   * Requests the link button to be rendered in exclusive mode to allow the creation of a link.
   *
   * @instance
   * @memberof ButtonLink
   * @method _requestExclusive
   * @protected
   */

	}]);

	return ButtonLink;
}(_react2.default.Component);

ButtonLink.contextType = _editorContext2.default;
ButtonLink.defaultProps = {
	keystroke: {
		fn: '_requestExclusive',
		keys: CKEDITOR.CTRL + 76 /* L*/
		, name: 'link'
	}
};
ButtonLink.key = 'link';
exports.default = (0, _buttonProps2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)(ButtonLink)));

/***/ }),

/***/ "./src/components/buttons/button-ol.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-ol.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonOrderedList class provides functionality for creating ordered lists in an editor.
 *
 * @class ButtonOrderedList
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonOrderedList = function (_React$Component) {
	_inherits(ButtonOrderedList, _React$Component);

	function ButtonOrderedList() {
		_classCallCheck(this, ButtonOrderedList);

		return _possibleConstructorReturn(this, (ButtonOrderedList.__proto__ || Object.getPrototypeOf(ButtonOrderedList)).apply(this, arguments));
	}

	_createClass(ButtonOrderedList, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonOrderedList
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonOrderedList
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.numberedlist,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-ol',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.numberedlist },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'list-ol' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default ol
   * @memberof ButtonOrderedList
   * @property {String} key
   * @static
   */

	}]);

	return ButtonOrderedList;
}(_react2.default.Component);

ButtonOrderedList.defaultProps = {
	command: 'numberedlist',
	style: {
		element: 'ol'
	}
};
ButtonOrderedList.key = 'ol';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonOrderedList)));

/***/ }),

/***/ "./src/components/buttons/button-outdent-block.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-outdent-block.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonOutdentBlock class provides functionality for outdenting blocks.
 *
 * @class ButtonOutdentBlock
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonOutdentBlock = function (_React$Component) {
	_inherits(ButtonOutdentBlock, _React$Component);

	function ButtonOutdentBlock() {
		_classCallCheck(this, ButtonOutdentBlock);

		return _possibleConstructorReturn(this, (ButtonOutdentBlock.__proto__ || Object.getPrototypeOf(ButtonOutdentBlock)).apply(this, arguments));
	}

	_createClass(ButtonOutdentBlock, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonOutdentBlock
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonOutdentBlock
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.outdent,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-outdent-block',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.outdent },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'indent-less' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default outdentBlock
   * @memberof ButtonOutdentBlock
   * @property {String} key
   * @static
   */

	}]);

	return ButtonOutdentBlock;
}(_react2.default.Component);

ButtonOutdentBlock.defaultProps = {
	command: 'outdent'
};
ButtonOutdentBlock.key = 'outdentBlock';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonOutdentBlock)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-align-left.jsx":
/*!****************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-align-left.jsx ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonParagraphAlignLeft class provides functionality for aligning a paragraph on left.
 *
 * @class ButtonParagraphAlignLeft
 *
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphAlignLeft = function (_React$Component) {
	_inherits(ButtonParagraphAlignLeft, _React$Component);

	function ButtonParagraphAlignLeft() {
		_classCallCheck(this, ButtonParagraphAlignLeft);

		return _possibleConstructorReturn(this, (ButtonParagraphAlignLeft.__proto__ || Object.getPrototypeOf(ButtonParagraphAlignLeft)).apply(this, arguments));
	}

	_createClass(ButtonParagraphAlignLeft, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonParagraphAlignLeft
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonParagraphAlignLeft
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignLeft,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-paragraph-align-left',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignLeft },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-left' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default paragraphLeft
   * @memberof ButtonParagraphAlignLeft
   * @property {String} key
   * @static
   */

	}]);

	return ButtonParagraphAlignLeft;
}(_react2.default.Component);

ButtonParagraphAlignLeft.defaultProps = {
	command: 'justifyleft'
};
ButtonParagraphAlignLeft.key = 'paragraphLeft';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphAlignLeft)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-align-right.jsx":
/*!*****************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-align-right.jsx ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonParagraphAlignRight class provides functionality for aligning a paragraph on right.
 *
 * @class ButtonParagraphAlignRight
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphAlignRight = function (_React$Component) {
	_inherits(ButtonParagraphAlignRight, _React$Component);

	function ButtonParagraphAlignRight() {
		_classCallCheck(this, ButtonParagraphAlignRight);

		return _possibleConstructorReturn(this, (ButtonParagraphAlignRight.__proto__ || Object.getPrototypeOf(ButtonParagraphAlignRight)).apply(this, arguments));
	}

	_createClass(ButtonParagraphAlignRight, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonParagraphAlignRight
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonParagraphAlignRight
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignRight,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-paragraph-align-right',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignRight },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-right' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default paragraphRight
   * @memberof ButtonParagraphAlignRight
   * @property {String} key
   * @static
   */

	}]);

	return ButtonParagraphAlignRight;
}(_react2.default.Component);

ButtonParagraphAlignRight.defaultProps = {
	command: 'justifyright'
};
ButtonParagraphAlignRight.key = 'paragraphRight';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphAlignRight)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-align.jsx":
/*!***********************************************************!*\
  !*** ./src/components/buttons/button-paragraph-align.jsx ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonParagraphAlign class provides functionality to work with table rows.
 *
 * @class ButtonParagraphAlign
 */
var ButtonParagraphAlign = function (_React$Component) {
	_inherits(ButtonParagraphAlign, _React$Component);

	function ButtonParagraphAlign() {
		_classCallCheck(this, ButtonParagraphAlign);

		return _possibleConstructorReturn(this, (ButtonParagraphAlign.__proto__ || Object.getPrototypeOf(ButtonParagraphAlign)).apply(this, arguments));
	}

	_createClass(ButtonParagraphAlign, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonParagraphAlign
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var buttonCommandsList = void 0;
			var buttonCommandsListId = void 0;
			var getCommands = this._getCommands();

			if (this.props.expanded) {
				buttonCommandsListId = ButtonParagraphAlign.key + 'List';
				buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, {
					commands: getCommands,
					inlineIcons: false,
					listId: buttonCommandsListId,
					onDismiss: this.props.toggleDropdown
				});
			}

			var editor = this.context.editor.get('nativeEditor');

			var activeCommand = getCommands.filter(function (alignment) {
				var command = editor.getCommand(alignment.command);

				return command ? command.state === CKEDITOR.TRISTATE_ON : false;
			}).pop();

			activeCommand = activeCommand ? activeCommand : getCommands[0];

			var iconClassName = activeCommand.icon;

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-dropdown ae-container-dropdown-xsmall ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': activeCommand.label,
						'aria-owns': buttonCommandsListId,
						className: 'ae-toolbar-element',
						onClick: this.props.toggleDropdown,
						role: 'combobox',
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.row },
					_react2.default.createElement(
						'div',
						{ className: 'ae-container' },
						_react2.default.createElement(_buttonIcon2.default, { symbol: iconClassName }),
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'caret-bottom' })
					)
				),
				buttonCommandsList
			);
		}

		/**
   * Returns a list of commands. If a list of commands was passed
   * as property `commands`, it will take a precedence over the default ones.
   *
   * @instance
   * @memberof ButtonParagraphAlign
   * @method _getCommands
   * @protected
   * @return {Array} The list of available commands.
   */

	}, {
		key: '_getCommands',
		value: function _getCommands() {
			return this.props.commands || [{
				command: 'justifyleft',
				icon: 'align-left',
				label: AlloyEditor.Strings.alignLeft
			}, {
				command: 'justifycenter',
				icon: 'align-center',
				label: AlloyEditor.Strings.alignCenter
			}, {
				command: 'justifyright',
				icon: 'align-right',
				label: AlloyEditor.Strings.alignRight
			}, {
				command: 'justifyblock',
				icon: 'align-justify',
				label: AlloyEditor.Strings.alignJustify
			}];
		}
	}]);

	return ButtonParagraphAlign;
}(_react2.default.Component);

ButtonParagraphAlign.contextType = _editorContext2.default;
ButtonParagraphAlign.key = 'paragraphAlign';
exports.default = ButtonParagraphAlign;

/***/ }),

/***/ "./src/components/buttons/button-paragraph-center.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-center.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonParagraphCenter class provides functionality for centering a paragraph.
 *
 * @class ButtonParagraphCenter
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphCenter = function (_React$Component) {
	_inherits(ButtonParagraphCenter, _React$Component);

	function ButtonParagraphCenter() {
		_classCallCheck(this, ButtonParagraphCenter);

		return _possibleConstructorReturn(this, (ButtonParagraphCenter.__proto__ || Object.getPrototypeOf(ButtonParagraphCenter)).apply(this, arguments));
	}

	_createClass(ButtonParagraphCenter, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonParagraphCenter
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonParagraphCenter
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignCenter,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-paragraph-center',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignCenter },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-center' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default paragraphCenter
   * @memberof ButtonParagraphCenter
   * @property {String} key
   * @static
   */

	}]);

	return ButtonParagraphCenter;
}(_react2.default.Component);

ButtonParagraphCenter.defaultProps = {
	command: 'justifycenter'
};
ButtonParagraphCenter.key = 'paragraphCenter';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphCenter)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-justify.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-justify.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonParagraphJustify class provides functionality for justfying a paragraph.
 *
 * @class ButtonParagraphJustify
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphJustify = function (_React$Component) {
	_inherits(ButtonParagraphJustify, _React$Component);

	function ButtonParagraphJustify() {
		_classCallCheck(this, ButtonParagraphJustify);

		return _possibleConstructorReturn(this, (ButtonParagraphJustify.__proto__ || Object.getPrototypeOf(ButtonParagraphJustify)).apply(this, arguments));
	}

	_createClass(ButtonParagraphJustify, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonParagraphJustify
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonParagraphJustify
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignJustify,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-paragraph-justify',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignJustify },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-justify' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default paragraphJustify
   * @memberof ButtonParagraphJustify
   * @property {String} key
   * @static
   */

	}]);

	return ButtonParagraphJustify;
}(_react2.default.Component);

ButtonParagraphJustify.defaultProps = {
	command: 'justifyblock'
};
ButtonParagraphJustify.key = 'paragraphJustify';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphJustify)));

/***/ }),

/***/ "./src/components/buttons/button-quote.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-quote.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonQuote class wraps a selection in `blockquote` element.
 *
 * @class ButtonQuote
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonQuote = function (_React$Component) {
	_inherits(ButtonQuote, _React$Component);

	function ButtonQuote() {
		_classCallCheck(this, ButtonQuote);

		return _possibleConstructorReturn(this, (ButtonQuote.__proto__ || Object.getPrototypeOf(ButtonQuote)).apply(this, arguments));
	}

	_createClass(ButtonQuote, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonQuote
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonQuote
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.quote,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-quote',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.quote },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'quote-right' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default quote
   * @memberof ButtonQuote
   * @property {String} key
   * @static
   */

	}]);

	return ButtonQuote;
}(_react2.default.Component);

ButtonQuote.defaultProps = {
	command: 'blockquote',
	style: {
		element: 'blockquote'
	}
};
ButtonQuote.key = 'quote';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonQuote)));

/***/ }),

/***/ "./src/components/buttons/button-remove-format.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-remove-format.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonRemoveFormat class removes style formatting.
 *
 * @class ButtonRemoveFormat
 * @uses ButtonCommand
 */
var ButtonRemoveFormat = function (_React$Component) {
	_inherits(ButtonRemoveFormat, _React$Component);

	function ButtonRemoveFormat() {
		_classCallCheck(this, ButtonRemoveFormat);

		return _possibleConstructorReturn(this, (ButtonRemoveFormat.__proto__ || Object.getPrototypeOf(ButtonRemoveFormat)).apply(this, arguments));
	}

	_createClass(ButtonRemoveFormat, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonRemoveFormat
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonRemoveFormat
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.removeformat,
					className: 'ae-button',
					'data-type': 'button-removeformat',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.removeformat },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'remove-style' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default removeFormat
   * @memberof ButtonRemoveFormat
   * @property {String} key
   * @static
   */

	}]);

	return ButtonRemoveFormat;
}(_react2.default.Component);

ButtonRemoveFormat.defaultProps = {
	command: 'removeFormat'
};
ButtonRemoveFormat.key = 'removeFormat';
exports.default = (0, _buttonCommand2.default)(ButtonRemoveFormat);

/***/ }),

/***/ "./src/components/buttons/button-remove-image.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-remove-image.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonRemoveImage class removes an image using a CKEDITOR.command.
 *
 * @class ButtonRemoveImage
 * @uses ButtonCommand
 */
var ButtonRemoveImage = function (_React$Component) {
	_inherits(ButtonRemoveImage, _React$Component);

	function ButtonRemoveImage() {
		_classCallCheck(this, ButtonRemoveImage);

		return _possibleConstructorReturn(this, (ButtonRemoveImage.__proto__ || Object.getPrototypeOf(ButtonRemoveImage)).apply(this, arguments));
	}

	_createClass(ButtonRemoveImage, [{
		key: 'render',


		/**
   * @inheritDoc
   */
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.removeImage,
					'aria-pressed': false,
					className: 'ae-button',
					onClick: this.execCommand,
					title: AlloyEditor.Strings.removeImage },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'times-circle' })
			);
		}
	}]);

	return ButtonRemoveImage;
}(_react2.default.Component);

ButtonRemoveImage.defaultProps = {
	command: 'removeImage'
};
ButtonRemoveImage.key = 'removeImage';
exports.default = (0, _buttonCommand2.default)(ButtonRemoveImage);

/***/ }),

/***/ "./src/components/buttons/button-separator.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-separator.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The ButtonSeparator function renders a simple separator.
 */
function ButtonSeparator(_props) {
  return _react2.default.createElement('span', { className: 'ae-separator' });
}

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default separator
 * @memberof ButtonSeparator
 * @property {String} key
 * @static
 */
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

ButtonSeparator.key = 'separator';

exports.default = ButtonSeparator;

/***/ }),

/***/ "./src/components/buttons/button-spacing.jsx":
/*!***************************************************!*\
  !*** ./src/components/buttons/button-spacing.jsx ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonSpacing class provides functionality for changing text spacing in a document.
 *
 * @class ButtonSpacing
 */
var ButtonSpacing = function (_React$Component) {
	_inherits(ButtonSpacing, _React$Component);

	function ButtonSpacing() {
		_classCallCheck(this, ButtonSpacing);

		return _possibleConstructorReturn(this, (ButtonSpacing.__proto__ || Object.getPrototypeOf(ButtonSpacing)).apply(this, arguments));
	}

	_createClass(ButtonSpacing, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var _this2 = this;

			var activeSpacing = '1.0x';

			var spacings = this._getSpacings();

			spacings.forEach(function (item) {
				if (_this2._checkActive(item.style)) {
					activeSpacing = item.name;
				}
			});

			var _props = this.props,
			    editor = _props.editor,
			    expanded = _props.expanded,
			    tabIndex = _props.tabIndex,
			    toggleDropdown = _props.toggleDropdown;


			var buttonStylesProps = {
				activeStyle: activeSpacing,
				editor: editor,
				onDismiss: toggleDropdown,
				showRemoveStylesItem: false,
				styles: spacings
			};

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-container-dropdown-small ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': expanded,
						className: 'ae-toolbar-element',
						onClick: toggleDropdown,
						role: 'combobox',
						tabIndex: tabIndex },
					_react2.default.createElement(
						'span',
						null,
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'separator' }),
						'\xA0',
						activeSpacing
					)
				),
				expanded && _react2.default.createElement(_buttonStylesList2.default, buttonStylesProps)
			);
		}
	}, {
		key: '_applyStyle',
		value: function _applyStyle(className) {
			var _this3 = this;

			var editor = this.context.editor.get('nativeEditor');

			var styleConfig = {
				element: 'div',
				attributes: {
					class: className
				}
			};

			var style = new CKEDITOR.style(styleConfig);

			editor.getSelection().lock();

			this._getSpacings().forEach(function (item) {
				if (_this3._checkActive(item.style)) {
					editor.removeStyle(new CKEDITOR.style(item.style));
				}
			});

			editor.applyStyle(style);

			editor.getSelection().unlock();

			editor.fire('actionPerformed', this);
		}

		/**
   * Checks if the given spacing definition is applied to the current selection in the editor.
   *
   * @instance
   * @memberof Spacing
   * @method _checkActive
   * @param {Object} styleConfig Spacing definition as per http://docs.ckeditor.com/#!/api/CKEDITOR.style.
   * @protected
   * @return {Boolean} Returns true if the spacing is applied to the selection, false otherwise.
   */

	}, {
		key: '_checkActive',
		value: function _checkActive(styleConfig) {
			var nativeEditor = this.context.editor.get('nativeEditor');

			var active = true;

			var elementPath = nativeEditor.elementPath();

			if (elementPath && elementPath.lastElement) {
				styleConfig.attributes.class.split(' ').forEach(function (className) {
					active = active && elementPath.lastElement.hasClass(className);
				});
			} else {
				active = false;
			}

			return active;
		}

		/**
   * Returns an array of spacings. Each spacing consists from three properties:
   * - name - the style name, for example "default"
   * - style - an object with one property, called `element` which value
   * represents the style which have to be applied to the element.
   * - styleFn - a function which applies selected style to the editor selection
   *
   * @instance
   * @memberof Spacing
   * @method _getSpacings
   * @protected
   * @return {Array<object>} An array of objects containing the spacings.
   */

	}, {
		key: '_getSpacings',
		value: function _getSpacings() {
			return this.props.styles || [{
				name: '1.0x',
				style: {
					element: 'div',
					attributes: {
						class: ''
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, '')
			}, {
				name: '1.5x',
				style: {
					element: 'div',
					attributes: {
						class: 'mt-1 mb-1'
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, 'mt-1 mb-1')
			}, {
				name: '2.0x',
				style: {
					element: 'div',
					attributes: {
						class: 'mt-2 mb-2'
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, 'mt-2 mb-2')
			}, {
				name: '3.0x',
				style: {
					element: 'div',
					attributes: {
						class: 'mt-3 mb-3'
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, 'mt-3 mb-3')
			}, {
				name: '4.0x',
				style: {
					element: 'div',
					attributes: {
						class: 'mt-4 mb-4'
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, 'mt-4 mb-4')
			}, {
				name: '5.0x',
				style: {
					element: 'div',
					attributes: {
						class: 'mt-5 mb-5'
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, 'mt-5 mb-5')
			}];
		}
	}]);

	return ButtonSpacing;
}(_react2.default.Component);

ButtonSpacing.contextType = _editorContext2.default;
ButtonSpacing.key = 'spacing';
ButtonSpacing.propTypes = {
	/**
  * Indicates whether the styles list is expanded or not.
  *
  * @instance
  * @memberof Spacing
  * @property {Boolean} expanded
  */
	expanded: _propTypes2.default.bool,

	/**
  * The label that should be used for accessibility purposes.
  *
  * @instance
  * @memberof Spacing
  * @property {String} label
  */
	label: _propTypes2.default.string,

	/**
  * Indicates whether the remove styles item should appear in the styles list.
  *
  * @instance
  * @memberof Spacing
  * @property {Boolean} showRemoveStylesItem
  */
	showRemoveStylesItem: _propTypes2.default.bool,

	/**
  * List of the styles the button is able to handle.
  *
  * @instance
  * @memberof Spacing
  * @property {Array} styles
  */
	styles: _propTypes2.default.arrayOf(_propTypes2.default.object),

	/**
  * The tabIndex of the button in its toolbar current state. A value other than -1
  * means that the button has focus and is the active element.
  *
  * @instance
  * @memberof Spacing
  * @property {Number} tabIndex
  */
	tabIndex: _propTypes2.default.number,

	/**
  * Callback provided by the button host to notify when the styles list has been expanded.
  *
  * @instance
  * @memberof Spacing
  * @property {Function} toggleDropdown
  */
	toggleDropdown: _propTypes2.default.func
};
exports.default = ButtonSpacing;

/***/ }),

/***/ "./src/components/buttons/button-strike.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-strike.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonStrike class styles a selection with strike style.
 *
 * @class ButtonStrike
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonStrike = function (_React$Component) {
	_inherits(ButtonStrike, _React$Component);

	function ButtonStrike() {
		_classCallCheck(this, ButtonStrike);

		return _possibleConstructorReturn(this, (ButtonStrike.__proto__ || Object.getPrototypeOf(ButtonStrike)).apply(this, arguments));
	}

	_createClass(ButtonStrike, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   * @instance
   * @memberof ButtonStrike
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonStrike
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.strike,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-strike',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.strike },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'strikethrough' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default strike
   * @memberof ButtonStrike
   * @property {String} key
   * @static
   */

	}]);

	return ButtonStrike;
}(_react2.default.Component);

ButtonStrike.defaultProps = {
	command: 'strike',
	style: 'coreStyles_strike'
};
ButtonStrike.key = 'strike';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonStrike)));

/***/ }),

/***/ "./src/components/buttons/button-styles-list-header.jsx":
/*!**************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-header.jsx ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonsStylesListHeader class provides the header of an list of style items.
 *
 * @class ButtonsStylesListHeader
 */
var ButtonsStylesListHeader = function (_React$Component) {
	_inherits(ButtonsStylesListHeader, _React$Component);

	function ButtonsStylesListHeader() {
		_classCallCheck(this, ButtonsStylesListHeader);

		return _possibleConstructorReturn(this, (ButtonsStylesListHeader.__proto__ || Object.getPrototypeOf(ButtonsStylesListHeader)).apply(this, arguments));
	}

	_createClass(ButtonsStylesListHeader, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonsStylesListHeader
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.styles && this.props.styles.length) {
				return _react2.default.createElement(
					'span',
					{ className: 'ae-list-header' },
					this.props.name
				);
			} else {
				return null;
			}
		}
	}]);

	return ButtonsStylesListHeader;
}(_react2.default.Component);

ButtonsStylesListHeader.key = 'buttonStylesListHeader';
exports.default = ButtonsStylesListHeader;

/***/ }),

/***/ "./src/components/buttons/button-styles-list-item-remove.jsx":
/*!*******************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-item-remove.jsx ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonStylesListItemRemove class provides functionality for previewing a style definition
 * inside a list and applying it to the current editor selection.
 *
 * @class ButtonStylesListItemRemove
 */
var ButtonStylesListItemRemove = function (_React$Component) {
	_inherits(ButtonStylesListItemRemove, _React$Component);

	function ButtonStylesListItemRemove() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonStylesListItemRemove);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonStylesListItemRemove.__proto__ || Object.getPrototypeOf(ButtonStylesListItemRemove)).call.apply(_ref, [this].concat(args))), _this), _this._removeStyles = function () {
			var editor = _this.context.editor.get('nativeEditor');

			editor.execCommand('removeFormat');

			_this.props.removeBlocks.forEach(function (blockItem) {
				var blockStyle = new CKEDITOR.style({ element: blockItem });

				editor.removeStyle(blockStyle);
			});

			editor.fire('actionPerformed', _this);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonStylesListItemRemove
  * @method getDefaultProps
  * @return {Object} The default properties.
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default buttonStylesListItemRemove
  * @memberof ButtonStylesListItemRemove
  * @property {String} key
  * @static
  */


	_createClass(ButtonStylesListItemRemove, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonStylesListItemRemove
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			return _react2.default.createElement(
				'li',
				{ role: 'option' },
				_react2.default.createElement(
					'button',
					{
						className: 'ae-toolbar-element',
						onClick: this._removeStyles,
						tabIndex: this.props.tabIndex },
					AlloyEditor.Strings.normal
				)
			);
		}

		/**
   * Removes all inline styles and configured block elements applied to the current selection.
   *
   * @instance
   * @memberof ButtonStylesListItemRemove
   * @method _removeStyles
   * @protected
   */

	}]);

	return ButtonStylesListItemRemove;
}(_react2.default.Component);

ButtonStylesListItemRemove.contextType = _editorContext2.default;
ButtonStylesListItemRemove.defaultProps = {
	removeBlocks: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'pre']
};
ButtonStylesListItemRemove.key = 'buttonStylesListItemRemove';
exports.default = ButtonStylesListItemRemove;

/***/ }),

/***/ "./src/components/buttons/button-styles-list-item.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-item.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonStylesListItem class provides functionality for previewing a style definition
 * inside a list and applying it to the current editor selection.
 *
 * @class ButtonStylesListItem
 * @uses ButtonActionStyle
 * @uses ButtonStyle
 */
var ButtonStylesListItem = function (_React$Component) {
	_inherits(ButtonStylesListItem, _React$Component);

	function ButtonStylesListItem() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonStylesListItem);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonStylesListItem.__proto__ || Object.getPrototypeOf(ButtonStylesListItem)).call.apply(_ref, [this].concat(args))), _this), _this._onClick = function () {
			if (_this.props.styleFn) {
				_this.props.styleFn();
			} else {
				// Typically, we want the style to be the only one applied to the current selection, so
				// we execute the 'removeFormat' command first. Note that block styles won't be cleaned.
				// However, this is consistent with other editors implementations of this feature.

				_this.context.editor.get('nativeEditor').execCommand('removeFormat');

				_this.applyStyle();
			}
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default buttonStylesListItem
  * @memberof ButtonStylesListItem
  * @property {String} key
  * @static
  */


	_createClass(ButtonStylesListItem, [{
		key: 'componentWillMount',


		/**
   * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
   *
   * @instance
   * @memberof ButtonStylesListItem
   * @method componentWillMount
   */
		value: function componentWillMount() {
			// Styles with wildcard element (*) generate an empty tag in their preview < class="custom-class" />.
			// We default to element span and remove the margins to obtain a more consistent set of previews.

			var styleCfg = {
				element: 'span',
				styles: {
					margin: 0
				}
			};

			styleCfg = CKEDITOR.tools.merge(styleCfg, this.props.style);

			this._preview = new CKEDITOR.style(styleCfg).buildPreview(this.props.name);
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonStylesListItem
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			// We need to use dangerouselySetInnterHTML since we're not in control of the style
			// preview that is generated by CKEditor.

			var className = this.props.name === this.props.activeStyle ? 'ae-toolbar-element active' : 'ae-toolbar-element';

			return _react2.default.createElement('button', {
				className: className,
				dangerouslySetInnerHTML: { __html: this._preview },
				onClick: this._onClick,
				tabIndex: this.props.tabIndex
			});
		}

		/**
   * Applies the item style to the editor selection.
   *
   * @instance
   * @memberof ButtonStylesListItem
   * @method _onClick
   * @protected
   */

	}]);

	return ButtonStylesListItem;
}(_react2.default.Component);

ButtonStylesListItem.contextType = _editorContext2.default;
ButtonStylesListItem.key = 'buttonStylesListItem';
exports.default = (0, _buttonActionStyle2.default)((0, _buttonStyle2.default)(ButtonStylesListItem));

/***/ }),

/***/ "./src/components/buttons/button-styles-list.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-styles-list.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _buttonStylesListHeader = __webpack_require__(/*! ./button-styles-list-header.jsx */ "./src/components/buttons/button-styles-list-header.jsx");

var _buttonStylesListHeader2 = _interopRequireDefault(_buttonStylesListHeader);

var _buttonStylesListItemRemove = __webpack_require__(/*! ./button-styles-list-item-remove.jsx */ "./src/components/buttons/button-styles-list-item-remove.jsx");

var _buttonStylesListItemRemove2 = _interopRequireDefault(_buttonStylesListItemRemove);

var _buttonStylesListItem = __webpack_require__(/*! ./button-styles-list-item.jsx */ "./src/components/buttons/button-styles-list-item.jsx");

var _buttonStylesListItem2 = _interopRequireDefault(_buttonStylesListItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonStylesList class provides functionality for showing a list of styles that can be
 * applied to the current selection..
 *
 * @class ButtonStylesList
 * @uses WidgetFocusManager
 */
var ButtonStylesList = function (_React$Component) {
	_inherits(ButtonStylesList, _React$Component);

	function ButtonStylesList() {
		_classCallCheck(this, ButtonStylesList);

		return _possibleConstructorReturn(this, (ButtonStylesList.__proto__ || Object.getPrototypeOf(ButtonStylesList)).apply(this, arguments));
	}

	_createClass(ButtonStylesList, [{
		key: 'componentDidMount',


		/**
   * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
   *
   * Focuses on the list node to allow keyboard interaction.
   *
   * @instance
   * @memberof ButtonStylesList
   * @method componentDidMount
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonStylesList
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function componentDidMount() {
			_reactDom2.default.findDOMNode(this).focus();
		}

		/**
   * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
   *
   * @instance
   * @memberof ButtonStylesList
   * @method componentWillMount
   */


		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @memberof ButtonStylesList
   * @static
   * @property {String} key
   * @default buttonStylesList
   */

	}, {
		key: 'componentWillMount',
		value: function componentWillMount() {
			var blockStyles = [];
			var inlineStyles = [];
			var objectStyles = [];

			this.props.styles.forEach(function (item) {
				var style = new CKEDITOR.style(item.style);

				if (style.type === CKEDITOR.STYLE_BLOCK) {
					blockStyles.push(item);
				} else if (style.type === CKEDITOR.STYLE_INLINE) {
					inlineStyles.push(item);
				} else if (style.type === CKEDITOR.STYLE_OBJECT) {
					objectStyles.push(item);
				}
			});

			this._blockStyles = blockStyles;
			this._inlineStyles = inlineStyles;
			this._objectStyles = objectStyles;
		}

		/**
   * Lifecycle. Renders the UI of the list.
   *
   * @instance
   * @memberof ButtonStylesList
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var removeStylesItem = void 0;

			if (this.props.showRemoveStylesItem) {
				removeStylesItem = _react2.default.createElement(_buttonStylesListItemRemove2.default, {
					onDismiss: this.props.toggleDropdown
				});
			}

			return _react2.default.createElement(
				_buttonDropdown2.default,
				this.props,
				removeStylesItem,
				_react2.default.createElement(_buttonStylesListHeader2.default, {
					name: AlloyEditor.Strings.blockStyles,
					styles: this._blockStyles
				}),
				this._renderStylesItems(this._blockStyles),
				_react2.default.createElement(_buttonStylesListHeader2.default, {
					name: AlloyEditor.Strings.inlineStyles,
					styles: this._inlineStyles
				}),
				this._renderStylesItems(this._inlineStyles),
				_react2.default.createElement(_buttonStylesListHeader2.default, {
					name: AlloyEditor.Strings.objectStyles,
					styles: this._objectStyles
				}),
				this._renderStylesItems(this._objectStyles)
			);
		}

		/**
   * Renders instances of ButtonStylesListItem with the preview of the correspondent block, inline or object styles.
   *
   * @instance
   * @memberof ButtonStylesList
   * @method _renderStylesItems
   * @param {Array} styles List of styles for which preview should be rendered.
   * @protected
   * @return {Array} Rendered instances of ButtonStylesListItem class
   */

	}, {
		key: '_renderStylesItems',
		value: function _renderStylesItems(styles) {
			var _this2 = this;

			var items = void 0;

			if (styles && styles.length) {
				items = styles.map(function (item) {
					return _react2.default.createElement(
						'li',
						{ key: item.name, role: 'option' },
						_react2.default.createElement(_buttonStylesListItem2.default, {
							activeStyle: _this2.props.activeStyle,
							name: item.name,
							style: item.style,
							styleFn: item.styleFn
						})
					);
				});
			}

			return items;
		}
	}]);

	return ButtonStylesList;
}(_react2.default.Component);

ButtonStylesList.defaultProps = {
	circular: false,
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	},
	showRemoveStylesItem: true
};
ButtonStylesList.key = 'buttonStylesList';
exports.default = (0, _widgetFocusManager2.default)(ButtonStylesList);

/***/ }),

/***/ "./src/components/buttons/button-styles.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-styles.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonStyles class provides functionality for styling a selection with a list of
 * configurable and customizable styles. The allowed styles follow CKEDITOR.Style configuration
 * (http://docs.ckeditor.com/#!/api/CKEDITOR.style)
 *
 * @class ButtonStyles
 */
var ButtonStyles = function (_React$Component) {
	_inherits(ButtonStyles, _React$Component);

	function ButtonStyles() {
		_classCallCheck(this, ButtonStyles);

		return _possibleConstructorReturn(this, (ButtonStyles.__proto__ || Object.getPrototypeOf(ButtonStyles)).apply(this, arguments));
	}

	_createClass(ButtonStyles, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonStyles
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var _this2 = this;

			var activeStyle = AlloyEditor.Strings.normal;

			var styles = this._getStyles();

			styles.forEach(function (item) {
				if (_this2._checkActive(item.style)) {
					activeStyle = item.name;
				}
			});

			var buttonStylesList = void 0;

			if (this.props.expanded) {
				buttonStylesList = _react2.default.createElement(_buttonStylesList2.default, {
					activeStyle: activeStyle,
					onDismiss: this.props.toggleDropdown,
					showRemoveStylesItem: this.props.showRemoveStylesItem,
					styles: styles
				});
			}

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-dropdown ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': AlloyEditor.Strings.styles + ' ' + activeStyle,
						className: 'ae-toolbar-element',
						onClick: this.props.toggleDropdown,
						role: 'combobox',
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.styles + ' ' + activeStyle },
					_react2.default.createElement(
						'div',
						{ className: 'ae-container' },
						_react2.default.createElement(
							'span',
							{ className: 'ae-container-dropdown-selected-item' },
							activeStyle
						),
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'caret-bottom' })
					)
				),
				buttonStylesList
			);
		}

		/**
   * Checks if the given style definition is applied to the current selection in the editor.
   *
   * @instance
   * @memberof ButtonStyles
   * @method _checkActive
   * @param {Object} styleConfig Style definition as per http://docs.ckeditor.com/#!/api/CKEDITOR.style.
   * @protected
   * @return {Boolean} Returns true if the style is applied to the selection, false otherwise.
   */


		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default styles
   * @memberof ButtonStyles
   * @property {String} key
   * @static
   */

	}, {
		key: '_checkActive',
		value: function _checkActive(styleConfig) {
			var nativeEditor = this.context.editor.get('nativeEditor');

			// Styles with wildcard element (*) won't be considered active by CKEditor. Defaulting
			// to a 'span' element works for most of those cases with no defined element.

			styleConfig = CKEDITOR.tools.merge({ element: 'span' }, styleConfig);

			var style = new CKEDITOR.style(styleConfig);

			return style.checkActive(nativeEditor.elementPath(), nativeEditor);
		}

		/**
   * Returns an array of styles. Each style consists from two properties:
   * - name - the style name, for example "h1"
   * - style - an object with one property, called `element` which value
   * represents the style which have to be applied to the element.
   *
   * @instance
   * @memberof ButtonStyles
   * @method _getStyles
   * @protected
   * @return {Array<object>} An array of objects containing the styles.
   */

	}, {
		key: '_getStyles',
		value: function _getStyles() {
			return this.props.styles || [{
				name: AlloyEditor.Strings.h1,
				style: {
					element: 'h1'
				}
			}, {
				name: AlloyEditor.Strings.h2,
				style: {
					element: 'h2'
				}
			}, {
				name: AlloyEditor.Strings.formatted,
				style: {
					element: 'pre'
				}
			}, {
				name: AlloyEditor.Strings.cite,
				style: {
					element: 'cite'
				}
			}, {
				name: AlloyEditor.Strings.code,
				style: {
					element: 'code'
				}
			}];
		}
	}]);

	return ButtonStyles;
}(_react2.default.Component);

ButtonStyles.contextType = _editorContext2.default;
ButtonStyles.key = 'styles';
exports.default = ButtonStyles;

/***/ }),

/***/ "./src/components/buttons/button-subscript.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-subscript.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonSubscript class provides functionality for applying subscript style to a text selection.
 *
 * @class ButtonSubscript
 *
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonSubscript = function (_React$Component) {
	_inherits(ButtonSubscript, _React$Component);

	function ButtonSubscript() {
		_classCallCheck(this, ButtonSubscript);

		return _possibleConstructorReturn(this, (ButtonSubscript.__proto__ || Object.getPrototypeOf(ButtonSubscript)).apply(this, arguments));
	}

	_createClass(ButtonSubscript, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonSubscript
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonSubscript
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.subscript,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-subscript',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.subscript },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'subscript' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default subscript
   * @memberof ButtonSubscript
   * @property {String} key
   * @static
   */

	}]);

	return ButtonSubscript;
}(_react2.default.Component);

ButtonSubscript.defaultProps = {
	command: 'subscript',
	style: 'coreStyles_subscript'
};
ButtonSubscript.key = 'subscript';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonSubscript)));

/***/ }),

/***/ "./src/components/buttons/button-superscript.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-superscript.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonSuperscript class provides functionality for applying superscript style to a text selection.
 *
 * @class ButtonSuperscript
 *
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonSuperscript = function (_React$Component) {
	_inherits(ButtonSuperscript, _React$Component);

	function ButtonSuperscript() {
		_classCallCheck(this, ButtonSuperscript);

		return _possibleConstructorReturn(this, (ButtonSuperscript.__proto__ || Object.getPrototypeOf(ButtonSuperscript)).apply(this, arguments));
	}

	_createClass(ButtonSuperscript, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonSuperscript
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonSuperscript
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.superscript,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-superscript',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.superscript },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'superscript' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default superscript
   * @memberof ButtonSuperscript
   * @property {String} key
   * @static
   */

	}]);

	return ButtonSuperscript;
}(_react2.default.Component);

ButtonSuperscript.defaultProps = {
	command: 'superscript',
	style: 'coreStyles_superscript'
};
ButtonSuperscript.key = 'superscript';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonSuperscript)));

/***/ }),

/***/ "./src/components/buttons/button-table-cell.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-table-cell.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonTableCell class provides functionality to work with table cells.
 *
 * @class ButtonTableCell
 */
var ButtonTableCell = function (_React$Component) {
	_inherits(ButtonTableCell, _React$Component);

	function ButtonTableCell() {
		_classCallCheck(this, ButtonTableCell);

		return _possibleConstructorReturn(this, (ButtonTableCell.__proto__ || Object.getPrototypeOf(ButtonTableCell)).apply(this, arguments));
	}

	_createClass(ButtonTableCell, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableCell
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var buttonCommandsList = void 0;
			var buttonCommandsListId = void 0;

			if (this.props.expanded) {
				buttonCommandsListId = ButtonTableCell.key + 'List';
				buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, {
					commands: this._getCommands(),
					listId: buttonCommandsListId,
					onDismiss: this.props.toggleDropdown
				});
			}

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': AlloyEditor.Strings.cell,
						'aria-owns': buttonCommandsListId,
						className: 'ae-button',
						onClick: this.props.toggleDropdown,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.cell },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'add-cell' })
				),
				buttonCommandsList
			);
		}

		/**
   * Returns a list of commands. If a list of commands was passed
   * as property `commands`, it will take a precedence over the default ones.
   *
   * @instance
   * @memberof ButtonTableCell
   * @method _getCommands
   * @protected
   * @return {Array} The list of available commands.
   */

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default tableCell
   * @memberof ButtonTableCell
   * @property {String} key
   * @static
   */

	}, {
		key: '_getCommands',
		value: function _getCommands() {
			return this.props.commands || [{
				command: 'cellInsertBefore',
				label: AlloyEditor.Strings.cellInsertBefore
			}, {
				command: 'cellInsertAfter',
				label: AlloyEditor.Strings.cellInsertAfter
			}, {
				command: 'cellDelete',
				label: AlloyEditor.Strings.cellDelete
			}, {
				command: 'cellMerge',
				label: AlloyEditor.Strings.cellMerge
			}, {
				command: 'cellMergeDown',
				label: AlloyEditor.Strings.cellMergeDown
			}, {
				command: 'cellMergeRight',
				label: AlloyEditor.Strings.cellMergeRight
			}, {
				command: 'cellHorizontalSplit',
				label: AlloyEditor.Strings.cellSplitHorizontal
			}, {
				command: 'cellVerticalSplit',
				label: AlloyEditor.Strings.cellSplitVertical
			}];
		}
	}]);

	return ButtonTableCell;
}(_react2.default.Component);

ButtonTableCell.key = 'tableCell';
exports.default = ButtonTableCell;

/***/ }),

/***/ "./src/components/buttons/button-table-column.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-table-column.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonTableColumn class provides functionality to work with table columns.
 *
 * @class ButtonTableColumn
 */
var ButtonTableColumn = function (_React$Component) {
	_inherits(ButtonTableColumn, _React$Component);

	function ButtonTableColumn() {
		_classCallCheck(this, ButtonTableColumn);

		return _possibleConstructorReturn(this, (ButtonTableColumn.__proto__ || Object.getPrototypeOf(ButtonTableColumn)).apply(this, arguments));
	}

	_createClass(ButtonTableColumn, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableColumn
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var buttonCommandsList = void 0;
			var buttonCommandsListId = void 0;

			if (this.props.expanded) {
				buttonCommandsListId = ButtonTableColumn.key + 'List';
				buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, {
					commands: this._getCommands(),
					listId: buttonCommandsListId,
					onDismiss: this.props.toggleDropdown
				});
			}

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': AlloyEditor.Strings.column,
						'aria-owns': buttonCommandsListId,
						className: 'ae-button',
						onClick: this.props.toggleDropdown,
						role: 'listbox',
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.column },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'add-column' })
				),
				buttonCommandsList
			);
		}

		/**
   * Returns a list of commands. If a list of commands was passed
   * as property `commands`, it will take a precedence over the default ones.
   *
   * @instance
   * @memberof ButtonTableColumn
   * @method _getCommands
   * @protected
   * @return {Array} The list of available commands.
   */

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default tableColumn
   * @memberof ButtonTableColumn
   * @property {String} key
   * @static
   */

	}, {
		key: '_getCommands',
		value: function _getCommands() {
			return this.props.commands || [{
				command: 'columnInsertBefore',
				label: AlloyEditor.Strings.columnInsertBefore
			}, {
				command: 'columnInsertAfter',
				label: AlloyEditor.Strings.columnInsertAfter
			}, {
				command: 'columnDelete',
				label: AlloyEditor.Strings.columnDelete
			}];
		}
	}]);

	return ButtonTableColumn;
}(_react2.default.Component);

ButtonTableColumn.key = 'tableColumn';
exports.default = ButtonTableColumn;

/***/ }),

/***/ "./src/components/buttons/button-table-edit.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-table-edit.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var KEY_ENTER = 13;
var KEY_ESC = 27;

var INPUT_NAMES = {
	COLS: 'cols',
	ROWS: 'rows'
};

var MINIMUM_GRID_VALUE = 1;

/**
 * The ButtonTableEdit class provides functionality for creating and editing a table in a document.
 * Provides UI for creating a table.
 *
 * @class ButtonTableEdit
 */

var ButtonTableEdit = function (_React$Component) {
	_inherits(ButtonTableEdit, _React$Component);

	/**
  * Lifecycle. Invoked once before the component is mounted.
  *
  * @instance
  * @memberof ButtonTableEdit
  * @method getInitialState
  */


	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonTableEdit
  * @method getDefaultProps
  */
	function ButtonTableEdit(props) {
		_classCallCheck(this, ButtonTableEdit);

		var _this = _possibleConstructorReturn(this, (ButtonTableEdit.__proto__ || Object.getPrototypeOf(ButtonTableEdit)).call(this, props));

		_this._createTable = function () {
			var editor = _this.context.editor.get('nativeEditor');
			var tableUtils = new CKEDITOR.Table(editor);
			var _this$state = _this.state,
			    cols = _this$state.cols,
			    rows = _this$state.rows;


			tableUtils.create({
				attrs: _this.props.tableAttributes,
				cols: Math.max(MINIMUM_GRID_VALUE, cols),
				rows: Math.max(MINIMUM_GRID_VALUE, rows)
			});

			_this.props.cancelExclusive();

			editor.fire('actionPerformed', _this);
		};

		_this._handleChange = function (inputName, event) {
			_this.setState(_defineProperty({}, inputName, event.target.value));
		};

		_this._handleKeyDown = function (event) {
			if (event.keyCode === KEY_ENTER || event.keyCode === KEY_ESC) {
				event.preventDefault();
			}

			if (event.keyCode === KEY_ENTER) {
				_this._createTable();
			} else if (event.keyCode === KEY_ESC) {
				_this.props.cancelExclusive();
			}
		};

		_this.rowsRef = _react2.default.createRef();
		_this.colsRef = _react2.default.createRef();
		_this.state = {
			cols: 3,
			rows: 3
		};
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client (not on the server),
  * immediately after the initial rendering occurs.
  *
  * Focuses on the link input to immediately allow editing.
  *
  * @instance
  * @memberof ButtonTableEdit
  * @method componentDidMount
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default tableEdit
  * @memberof ButtonTableEdit
  * @property {String} key
  * @static
  */


	_createClass(ButtonTableEdit, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.rowsRef.current.focus();
		}

		/**
   * Creates a table.
   *
   * @instance
   * @memberof ButtonTableEdit
   * @method _createTable
   * @protected
   */


		/**
   * Handles a change in input value. Sets the provided value from the user back to the input.
   *
   * @instance
   * @memberof ButtonTableEdit
   * @method _handleChange
   * @param {String} inputName The name of the input which value should be updated.
   * @param {SyntheticEvent} event The provided event.
   * @protected
   */


		/**
   * Monitors key interaction inside the input element to respond to the keys:
   * - Enter: Creates the table.
   * - Escape: Discards the changes.
   *
   * @instance
   * @memberof ButtonTableEdit
   * @method _handleKeyDown
   * @param {SyntheticEvent} event The keyboard event.
   * @protected
   */

	}, {
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableEdit
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var time = Date.now();
			var rowsId = time + INPUT_NAMES.ROWS;
			var colsId = time + INPUT_NAMES.COLS;

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-edit-table' },
				_react2.default.createElement(
					'label',
					{ htmlFor: rowsId },
					AlloyEditor.Strings.rows
				),
				_react2.default.createElement(
					'div',
					{ className: 'ae-container-input small' },
					_react2.default.createElement('input', {
						className: 'ae-input',
						id: rowsId,
						min: MINIMUM_GRID_VALUE,
						onChange: this._handleChange.bind(this, INPUT_NAMES.ROWS),
						onKeyDown: this._handleKeyDown,
						placeholder: 'Rows',
						ref: this.rowsRef,
						type: 'number',
						value: this.state.rows
					})
				),
				_react2.default.createElement(
					'label',
					{ htmlFor: colsId },
					AlloyEditor.Strings.columns
				),
				_react2.default.createElement(
					'div',
					{ className: 'ae-container-input small' },
					_react2.default.createElement('input', {
						className: 'ae-input',
						id: colsId,
						min: MINIMUM_GRID_VALUE,
						onChange: this._handleChange.bind(this, INPUT_NAMES.COLS),
						onKeyDown: this._handleKeyDown,
						placeholder: 'Colums',
						ref: this.colsRef,
						type: 'number',
						value: this.state.cols
					})
				),
				_react2.default.createElement(
					'button',
					{
						'aria-label': 'Confirm',
						className: 'ae-button',
						onClick: this._createTable },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'check' })
				)
			);
		}
	}]);

	return ButtonTableEdit;
}(_react2.default.Component);

ButtonTableEdit.contextType = _editorContext2.default;
ButtonTableEdit.defaultProps = {
	tableAttributes: {
		border: 1,
		cellPadding: 0,
		cellSpacing: 0,
		style: 'table-layout: fixed; width: 100%;'
	}
};
ButtonTableEdit.key = 'tableEdit';
exports.default = ButtonTableEdit;

/***/ }),

/***/ "./src/components/buttons/button-table-heading.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-table-heading.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonTableHeading class provides functionality to work with table heading.
 *
 * @class ButtonTableHeading
 */
var ButtonTableHeading = function (_React$Component) {
	_inherits(ButtonTableHeading, _React$Component);

	function ButtonTableHeading() {
		_classCallCheck(this, ButtonTableHeading);

		return _possibleConstructorReturn(this, (ButtonTableHeading.__proto__ || Object.getPrototypeOf(ButtonTableHeading)).apply(this, arguments));
	}

	_createClass(ButtonTableHeading, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableHeading
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var buttonCommandsList = void 0;
			var buttonCommandsListId = void 0;

			if (this.props.expanded) {
				buttonCommandsListId = ButtonTableHeading.key + 'List';
				buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, {
					commands: this._getCommands(),
					listId: buttonCommandsListId,
					onDismiss: this.props.toggleDropdown
				});
			}

			var activeHeading = new CKEDITOR.Table(this.context.editor.get('nativeEditor')).getHeading();
			var activeHeadingIntro = AlloyEditor.Strings.headers + ':';
			var activeHeadingLabel = AlloyEditor.Strings['headers' + activeHeading];

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-dropdown-xl ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': '',
						className: 'ae-toolbar-element',
						onClick: this.props.toggleDropdown,
						role: 'combobox',
						tabIndex: this.props.tabIndex,
						title: '' },
					_react2.default.createElement(
						'div',
						{ className: 'ae-container' },
						_react2.default.createElement(
							'span',
							{ className: 'ae-container-dropdown-selected-item' },
							activeHeadingIntro,
							' ',
							_react2.default.createElement(
								'strong',
								null,
								activeHeadingLabel
							)
						),
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'caret-bottom' })
					)
				),
				buttonCommandsList
			);
		}

		/**
   * Returns a list of commands. If a list of commands was passed
   * as property `commands`, it will take a precedence over the default ones.
   *
   * @instance
   * @memberof ButtonTableHeading
   * @method _getCommands
   * @protected
   * @return {Array} The list of available commands.
   */


		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default tableRow
   * @memberof ButtonTableHeading
   * @property {String} key
   * @static
   */

	}, {
		key: '_getCommands',
		value: function _getCommands() {
			return this.props.commands || [{
				command: 'tableHeadingNone',
				label: AlloyEditor.Strings.headersNone
			}, {
				command: 'tableHeadingRow',
				label: AlloyEditor.Strings.headersRow
			}, {
				command: 'tableHeadingColumn',
				label: AlloyEditor.Strings.headersColumn
			}, {
				command: 'tableHeadingBoth',
				label: AlloyEditor.Strings.headersBoth
			}];
		}
	}]);

	return ButtonTableHeading;
}(_react2.default.Component);

ButtonTableHeading.contextType = _editorContext2.default;
ButtonTableHeading.key = 'tableHeading';
exports.default = ButtonTableHeading;

/***/ }),

/***/ "./src/components/buttons/button-table-remove.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-table-remove.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonTableRemove class provides functionality for removing a table
 *
 * @class ButtonTableRemove
 */
var ButtonTableRemove = function (_React$Component) {
	_inherits(ButtonTableRemove, _React$Component);

	function ButtonTableRemove() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonTableRemove);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonTableRemove.__proto__ || Object.getPrototypeOf(ButtonTableRemove)).call.apply(_ref, [this].concat(args))), _this), _this._removeTable = function () {
			var editor = _this.context.editor.get('nativeEditor');
			var tableUtils = new CKEDITOR.Table(editor);

			tableUtils.remove();

			editor.fire('actionPerformed', _this);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default tableRemove
  * @memberof ButtonTableRemove
  * @property {String} key
  * @static
  */


	_createClass(ButtonTableRemove, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableRemove
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.deleteTable,
					className: 'ae-button',
					'data-type': 'button-table-remove',
					onClick: this._removeTable,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.deleteTable },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'trash' })
			);
		}

		/**
   * Removes the table in the editor element.
   *
   * @instance
   * @memberof ButtonTableRemove
   * @method _removeTable
   * @protected
   */

	}]);

	return ButtonTableRemove;
}(_react2.default.Component);

ButtonTableRemove.contextType = _editorContext2.default;
ButtonTableRemove.key = 'tableRemove';
exports.default = ButtonTableRemove;

/***/ }),

/***/ "./src/components/buttons/button-table-row.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-table-row.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonTableRow class provides functionality to work with table rows.
 *
 * @class ButtonTableRow
 */
var ButtonTableRow = function (_React$Component) {
	_inherits(ButtonTableRow, _React$Component);

	function ButtonTableRow() {
		_classCallCheck(this, ButtonTableRow);

		return _possibleConstructorReturn(this, (ButtonTableRow.__proto__ || Object.getPrototypeOf(ButtonTableRow)).apply(this, arguments));
	}

	_createClass(ButtonTableRow, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableRow
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var buttonCommandsList = void 0;
			var buttonCommandsListId = void 0;

			if (this.props.expanded) {
				buttonCommandsListId = ButtonTableRow.key + 'List';
				buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, {
					commands: this._getCommands(),
					listId: buttonCommandsListId,
					onDismiss: this.props.toggleDropdown
				});
			}

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': AlloyEditor.Strings.row,
						'aria-owns': buttonCommandsListId,
						className: 'ae-button',
						onClick: this.props.toggleDropdown,
						role: 'combobox',
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.row },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'add-row' })
				),
				buttonCommandsList
			);
		}

		/**
   * Returns a list of commands. If a list of commands was passed
   * as property `commands`, it will take a precedence over the default ones.
   *
   * @instance
   * @memberof ButtonTableRow
   * @method _getCommands
   * @protected
   * @return {Array} The list of available commands.
   */

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default tableRow
   * @memberof ButtonTableRow
   * @property {String} key
   * @static
   */

	}, {
		key: '_getCommands',
		value: function _getCommands() {
			return this.props.commands || [{
				command: 'rowInsertBefore',
				label: AlloyEditor.Strings.rowInsertBefore
			}, {
				command: 'rowInsertAfter',
				label: AlloyEditor.Strings.rowInsertAfter
			}, {
				command: 'rowDelete',
				label: AlloyEditor.Strings.rowDelete
			}];
		}
	}]);

	return ButtonTableRow;
}(_react2.default.Component);

ButtonTableRow.key = 'tableRow';
exports.default = ButtonTableRow;

/***/ }),

/***/ "./src/components/buttons/button-table.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-table.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonTableEdit = __webpack_require__(/*! ./button-table-edit.jsx */ "./src/components/buttons/button-table-edit.jsx");

var _buttonTableEdit2 = _interopRequireDefault(_buttonTableEdit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonTable class provides functionality for creating and editing a table in a document. ButtonTable
 * renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonTableEdit UI with all the table edition controls.
 *
 * @class ButtonTable
 */
var ButtonTable = function (_React$Component) {
	_inherits(ButtonTable, _React$Component);

	function ButtonTable() {
		_classCallCheck(this, ButtonTable);

		return _possibleConstructorReturn(this, (ButtonTable.__proto__ || Object.getPrototypeOf(ButtonTable)).apply(this, arguments));
	}

	_createClass(ButtonTable, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTable
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.renderExclusive) {
				return _react2.default.createElement(_buttonTableEdit2.default, this.props);
			} else {
				return _react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.table,
						className: 'ae-button',
						'data-type': 'button-table',
						onClick: this.props.requestExclusive,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.table },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'table' })
				);
			}
		}
		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default table
   * @memberof ButtonTable
   * @property {String} key
   * @static
   */

	}]);

	return ButtonTable;
}(_react2.default.Component);

ButtonTable.key = 'table';
exports.default = ButtonTable;

/***/ }),

/***/ "./src/components/buttons/button-target-list.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-target-list.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonTargetList class provides functionality for changing the target of a link
 * in the document.
 *
 * @class ButtonTargetList
 * @uses WidgetFocusManager
 */
var ButtonTargetList = function (_React$Component) {
	_inherits(ButtonTargetList, _React$Component);

	function ButtonTargetList() {
		_classCallCheck(this, ButtonTargetList);

		return _possibleConstructorReturn(this, (ButtonTargetList.__proto__ || Object.getPrototypeOf(ButtonTargetList)).apply(this, arguments));
	}

	_createClass(ButtonTargetList, [{
		key: 'componentDidMount',


		/**
   * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
   *
   * @instance
   * @memberof ButtonTargetList
   * @method componentDidMount
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonTargetList
   * @method getDefaultProps
   */
		value: function componentDidMount() {
			_reactDom2.default.findDOMNode(this).focus();
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTargetList
   * @method render
   * @return {Object} The content which should be rendered.
   */


		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default linkTargetEdit
   * @memberof ButtonTargetList
   * @property {String} key
   * @static
   */

	}, {
		key: 'render',
		value: function render() {
			var listTargets = this._renderListTargets();

			return _react2.default.createElement(
				_buttonDropdown2.default,
				this.props,
				listTargets
			);
		}

		/**
   * Returns the the allowed link target items.
   *
   * @instance
   * @memberof ButtonTargetList
   * @method _getAllowedTargetItems
   * @protected
   * @return {Array} The allowed target items.
   */

	}, {
		key: '_getAllowedTargetItems',
		value: function _getAllowedTargetItems() {
			return this.props.allowedLinkTargets || [{
				label: AlloyEditor.Strings.linkTargetDefault,
				value: ''
			}, {
				label: AlloyEditor.Strings.linkTargetSelf,
				value: '_self'
			}, {
				label: AlloyEditor.Strings.linkTargetBlank,
				value: '_blank'
			}, {
				label: AlloyEditor.Strings.linkTargetParent,
				value: '_parent'
			}, {
				label: AlloyEditor.Strings.linkTargetTop,
				value: '_top'
			}];
		}

		/**
   * Renders the allowed link target items.
   *
   * @instance
   * @memberof ButtonTargetList
   * @method _renderListTargets
   * @protected
   * @return {Object} Returns the rendered link items
   */

	}, {
		key: '_renderListTargets',
		value: function _renderListTargets() {
			var _this2 = this;

			var targets = this._getAllowedTargetItems();

			var handleLinkTargetChange = this.props.handleLinkTargetChange;

			targets = targets.map(function (target) {
				var className = _this2.props.selectedTarget === target.value ? 'ae-toolbar-element active' : 'ae-toolbar-element';

				return _react2.default.createElement(
					'li',
					{ key: target.value, role: 'option' },
					_react2.default.createElement(
						'button',
						{
							className: className,
							'data-value': target.value,
							onClick: handleLinkTargetChange },
						target.label
					)
				);
			});

			return targets;
		}
	}]);

	return ButtonTargetList;
}(_react2.default.Component);

ButtonTargetList.defaultProps = {
	circular: true,
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	}
};
ButtonTargetList.key = 'targetList';
exports.default = (0, _widgetFocusManager2.default)(ButtonTargetList);

/***/ }),

/***/ "./src/components/buttons/button-twitter.jsx":
/*!***************************************************!*\
  !*** ./src/components/buttons/button-twitter.jsx ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var MAX_TWEET_LENGTH = 280;

/**
 * The ButtonTwitter class provides functionality for creating a link which
 * allows people to tweet part of the content in the editor.
 *
 * @class ButtonTwitter
 * @uses ButtonStateClasses
 */

var ButtonTwitter = function (_React$Component) {
	_inherits(ButtonTwitter, _React$Component);

	function ButtonTwitter() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonTwitter);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonTwitter.__proto__ || Object.getPrototypeOf(ButtonTwitter)).call.apply(_ref, [this].concat(args))), _this), _this.handleClick = function () {
			var editor = _this.context.editor.get('nativeEditor');

			var linkUtils = new CKEDITOR.Link(editor);

			if (_this.isActive()) {
				linkUtils.remove(linkUtils.getFromSelection());
			} else {
				linkUtils.create(_this._getHref(), {
					class: 'ae-twitter-link',
					target: '_blank'
				});
			}

			editor.fire('actionPerformed', _this);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default twitter
  * @memberof ButtonTwitter
  * @property {String} key
  * @static
  */


	/**
  * Creates or removes the twitter link on the selection.
  *
  * @instance
  * @memberof ButtonTwitter
  * @method handleClick
  */


	_createClass(ButtonTwitter, [{
		key: 'isActive',


		/**
   * Checks if the current selection is contained within a link that points to twitter.com/intent/tweet.
   *
   * @instance
   * @memberof ButtonTwitter
   * @method isActive
   * @return {Boolean} True if the selection is inside a twitter link, false otherwise.
   */
		value: function isActive() {
			var link = new CKEDITOR.Link(this.context.editor.get('nativeEditor')).getFromSelection();

			return link && link.getAttribute('href').indexOf('twitter.com/intent/tweet') !== -1;
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTwitter
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.twitter,
					className: cssClass,
					'data-type': 'button-twitter',
					onClick: this.handleClick,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.twitter },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'twitter' })
			);
		}

		/**
   * Generates the appropriate twitter url based on the selected text and the configuration
   * options received via props.
   *
   * @instance
   * @memberof ButtonTwitter
   * @method _getHref
   * @protected
   * @return {String} A valid twitter url with the selected text and given configuration.
   */

	}, {
		key: '_getHref',
		value: function _getHref() {
			var nativeEditor = this.context.editor.get('nativeEditor');
			var selectedText = nativeEditor.getSelection().getSelectedText().substring(0, MAX_TWEET_LENGTH);
			var url = this.props.url;
			var via = this.props.via;
			var twitterHref = 'https://twitter.com/intent/tweet?text=' + selectedText;

			if (url) {
				twitterHref += '&url=' + url;
			}

			if (via) {
				twitterHref += '&via=' + via;
			}

			return twitterHref;
		}
	}]);

	return ButtonTwitter;
}(_react2.default.Component);

ButtonTwitter.contextType = _editorContext2.default;
ButtonTwitter.key = 'twitter';
exports.default = (0, _buttonStateClasses2.default)(ButtonTwitter);

/***/ }),

/***/ "./src/components/buttons/button-ul.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-ul.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonUnorderedlist class provides functionality for creating unordered lists in an editor.
 *
 * @class ButtonUnorderedlist
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonUnorderedlist = function (_React$Component) {
	_inherits(ButtonUnorderedlist, _React$Component);

	function ButtonUnorderedlist() {
		_classCallCheck(this, ButtonUnorderedlist);

		return _possibleConstructorReturn(this, (ButtonUnorderedlist.__proto__ || Object.getPrototypeOf(ButtonUnorderedlist)).apply(this, arguments));
	}

	_createClass(ButtonUnorderedlist, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonUnorderedlist
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonUnorderedlist
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.bulletedlist,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-ul',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.bulletedlist },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'list-ul' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default ul
   * @memberof ButtonUnorderedlist
   * @property {String} key
   * @static
   */

	}]);

	return ButtonUnorderedlist;
}(_react2.default.Component);

ButtonUnorderedlist.defaultProps = {
	command: 'bulletedlist',
	style: {
		element: 'ul'
	}
};
ButtonUnorderedlist.key = 'ul';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonUnorderedlist)));

/***/ }),

/***/ "./src/components/buttons/button-underline.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-underline.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ButtonUnderline class provides functionality for underlying a text selection.
 *
 * @class ButtonUnderline
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonUnderline = function (_React$Component) {
	_inherits(ButtonUnderline, _React$Component);

	function ButtonUnderline() {
		_classCallCheck(this, ButtonUnderline);

		return _possibleConstructorReturn(this, (ButtonUnderline.__proto__ || Object.getPrototypeOf(ButtonUnderline)).apply(this, arguments));
	}

	_createClass(ButtonUnderline, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonUnderline
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonUnderline
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.underline,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-underline',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.underline },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'underline' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default underline
   * @memberof ButtonUnderline
   * @property {String} key
   * @static
   */

	}]);

	return ButtonUnderline;
}(_react2.default.Component);

ButtonUnderline.defaultProps = {
	command: 'underline',
	keystroke: {
		fn: 'execCommand',
		keys: CKEDITOR.CTRL + 85 /* U*/
		, name: 'underline'
	},
	style: 'coreStyles_underline'
};
ButtonUnderline.key = 'underline';
exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonUnderline))));

/***/ }),

/***/ "./src/components/buttons/index.js":
/*!*****************************************!*\
  !*** ./src/components/buttons/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _ButtonAccessibilityI;

var _buttonAccessibilityImageAlt = __webpack_require__(/*! ./button-accessibility-image-alt.jsx */ "./src/components/buttons/button-accessibility-image-alt.jsx");

var _buttonAccessibilityImageAlt2 = _interopRequireDefault(_buttonAccessibilityImageAlt);

var _buttonBackgroundColor = __webpack_require__(/*! ./button-background-color.jsx */ "./src/components/buttons/button-background-color.jsx");

var _buttonBackgroundColor2 = _interopRequireDefault(_buttonBackgroundColor);

var _buttonBold = __webpack_require__(/*! ./button-bold.jsx */ "./src/components/buttons/button-bold.jsx");

var _buttonBold2 = _interopRequireDefault(_buttonBold);

var _buttonCameraImage = __webpack_require__(/*! ./button-camera-image.jsx */ "./src/components/buttons/button-camera-image.jsx");

var _buttonCameraImage2 = _interopRequireDefault(_buttonCameraImage);

var _buttonCamera = __webpack_require__(/*! ./button-camera.jsx */ "./src/components/buttons/button-camera.jsx");

var _buttonCamera2 = _interopRequireDefault(_buttonCamera);

var _buttonCode = __webpack_require__(/*! ./button-code.jsx */ "./src/components/buttons/button-code.jsx");

var _buttonCode2 = _interopRequireDefault(_buttonCode);

var _buttonColor = __webpack_require__(/*! ./button-color.jsx */ "./src/components/buttons/button-color.jsx");

var _buttonColor2 = _interopRequireDefault(_buttonColor);

var _buttonCommandListItem = __webpack_require__(/*! ./button-command-list-item.jsx */ "./src/components/buttons/button-command-list-item.jsx");

var _buttonCommandListItem2 = _interopRequireDefault(_buttonCommandListItem);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _buttonEmbedEdit = __webpack_require__(/*! ./button-embed-edit.jsx */ "./src/components/buttons/button-embed-edit.jsx");

var _buttonEmbedEdit2 = _interopRequireDefault(_buttonEmbedEdit);

var _buttonEmbedVideoEdit = __webpack_require__(/*! ./button-embed-video-edit.jsx */ "./src/components/buttons/button-embed-video-edit.jsx");

var _buttonEmbedVideoEdit2 = _interopRequireDefault(_buttonEmbedVideoEdit);

var _buttonEmbedVideo = __webpack_require__(/*! ./button-embed-video.jsx */ "./src/components/buttons/button-embed-video.jsx");

var _buttonEmbedVideo2 = _interopRequireDefault(_buttonEmbedVideo);

var _buttonEmbed = __webpack_require__(/*! ./button-embed.jsx */ "./src/components/buttons/button-embed.jsx");

var _buttonEmbed2 = _interopRequireDefault(_buttonEmbed);

var _buttonH = __webpack_require__(/*! ./button-h1.jsx */ "./src/components/buttons/button-h1.jsx");

var _buttonH2 = _interopRequireDefault(_buttonH);

var _buttonH3 = __webpack_require__(/*! ./button-h2.jsx */ "./src/components/buttons/button-h2.jsx");

var _buttonH4 = _interopRequireDefault(_buttonH3);

var _buttonHline = __webpack_require__(/*! ./button-hline.jsx */ "./src/components/buttons/button-hline.jsx");

var _buttonHline2 = _interopRequireDefault(_buttonHline);

var _buttonImageAlignCenter = __webpack_require__(/*! ./button-image-align-center.jsx */ "./src/components/buttons/button-image-align-center.jsx");

var _buttonImageAlignCenter2 = _interopRequireDefault(_buttonImageAlignCenter);

var _buttonImageAlignLeft = __webpack_require__(/*! ./button-image-align-left.jsx */ "./src/components/buttons/button-image-align-left.jsx");

var _buttonImageAlignLeft2 = _interopRequireDefault(_buttonImageAlignLeft);

var _buttonImageAlignRight = __webpack_require__(/*! ./button-image-align-right.jsx */ "./src/components/buttons/button-image-align-right.jsx");

var _buttonImageAlignRight2 = _interopRequireDefault(_buttonImageAlignRight);

var _buttonImage = __webpack_require__(/*! ./button-image.jsx */ "./src/components/buttons/button-image.jsx");

var _buttonImage2 = _interopRequireDefault(_buttonImage);

var _buttonIndentBlock = __webpack_require__(/*! ./button-indent-block.jsx */ "./src/components/buttons/button-indent-block.jsx");

var _buttonIndentBlock2 = _interopRequireDefault(_buttonIndentBlock);

var _buttonItalic = __webpack_require__(/*! ./button-italic.jsx */ "./src/components/buttons/button-italic.jsx");

var _buttonItalic2 = _interopRequireDefault(_buttonItalic);

var _buttonItemSelectorAudio = __webpack_require__(/*! ./button-item-selector-audio.jsx */ "./src/components/buttons/button-item-selector-audio.jsx");

var _buttonItemSelectorAudio2 = _interopRequireDefault(_buttonItemSelectorAudio);

var _buttonItemSelectorImage = __webpack_require__(/*! ./button-item-selector-image.jsx */ "./src/components/buttons/button-item-selector-image.jsx");

var _buttonItemSelectorImage2 = _interopRequireDefault(_buttonItemSelectorImage);

var _buttonItemSelectorVideo = __webpack_require__(/*! ./button-item-selector-video.jsx */ "./src/components/buttons/button-item-selector-video.jsx");

var _buttonItemSelectorVideo2 = _interopRequireDefault(_buttonItemSelectorVideo);

var _buttonLinkAutocompleteList = __webpack_require__(/*! ./button-link-autocomplete-list.jsx */ "./src/components/buttons/button-link-autocomplete-list.jsx");

var _buttonLinkAutocompleteList2 = _interopRequireDefault(_buttonLinkAutocompleteList);

var _buttonLinkBrowse = __webpack_require__(/*! ./button-link-browse.jsx */ "./src/components/buttons/button-link-browse.jsx");

var _buttonLinkBrowse2 = _interopRequireDefault(_buttonLinkBrowse);

var _buttonLinkEditBrowse = __webpack_require__(/*! ./button-link-edit-browse.jsx */ "./src/components/buttons/button-link-edit-browse.jsx");

var _buttonLinkEditBrowse2 = _interopRequireDefault(_buttonLinkEditBrowse);

var _buttonLinkEdit = __webpack_require__(/*! ./button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

var _buttonLinkTargetEdit = __webpack_require__(/*! ./button-link-target-edit.jsx */ "./src/components/buttons/button-link-target-edit.jsx");

var _buttonLinkTargetEdit2 = _interopRequireDefault(_buttonLinkTargetEdit);

var _buttonLink = __webpack_require__(/*! ./button-link.jsx */ "./src/components/buttons/button-link.jsx");

var _buttonLink2 = _interopRequireDefault(_buttonLink);

var _buttonOl = __webpack_require__(/*! ./button-ol.jsx */ "./src/components/buttons/button-ol.jsx");

var _buttonOl2 = _interopRequireDefault(_buttonOl);

var _buttonOutdentBlock = __webpack_require__(/*! ./button-outdent-block.jsx */ "./src/components/buttons/button-outdent-block.jsx");

var _buttonOutdentBlock2 = _interopRequireDefault(_buttonOutdentBlock);

var _buttonParagraphAlignLeft = __webpack_require__(/*! ./button-paragraph-align-left.jsx */ "./src/components/buttons/button-paragraph-align-left.jsx");

var _buttonParagraphAlignLeft2 = _interopRequireDefault(_buttonParagraphAlignLeft);

var _buttonParagraphAlignRight = __webpack_require__(/*! ./button-paragraph-align-right.jsx */ "./src/components/buttons/button-paragraph-align-right.jsx");

var _buttonParagraphAlignRight2 = _interopRequireDefault(_buttonParagraphAlignRight);

var _buttonParagraphAlign = __webpack_require__(/*! ./button-paragraph-align.jsx */ "./src/components/buttons/button-paragraph-align.jsx");

var _buttonParagraphAlign2 = _interopRequireDefault(_buttonParagraphAlign);

var _buttonParagraphCenter = __webpack_require__(/*! ./button-paragraph-center.jsx */ "./src/components/buttons/button-paragraph-center.jsx");

var _buttonParagraphCenter2 = _interopRequireDefault(_buttonParagraphCenter);

var _buttonParagraphJustify = __webpack_require__(/*! ./button-paragraph-justify.jsx */ "./src/components/buttons/button-paragraph-justify.jsx");

var _buttonParagraphJustify2 = _interopRequireDefault(_buttonParagraphJustify);

var _buttonQuote = __webpack_require__(/*! ./button-quote.jsx */ "./src/components/buttons/button-quote.jsx");

var _buttonQuote2 = _interopRequireDefault(_buttonQuote);

var _buttonRemoveFormat = __webpack_require__(/*! ./button-remove-format.jsx */ "./src/components/buttons/button-remove-format.jsx");

var _buttonRemoveFormat2 = _interopRequireDefault(_buttonRemoveFormat);

var _buttonRemoveImage = __webpack_require__(/*! ./button-remove-image.jsx */ "./src/components/buttons/button-remove-image.jsx");

var _buttonRemoveImage2 = _interopRequireDefault(_buttonRemoveImage);

var _buttonSeparator = __webpack_require__(/*! ./button-separator.jsx */ "./src/components/buttons/button-separator.jsx");

var _buttonSeparator2 = _interopRequireDefault(_buttonSeparator);

var _buttonSpacing = __webpack_require__(/*! ./button-spacing.jsx */ "./src/components/buttons/button-spacing.jsx");

var _buttonSpacing2 = _interopRequireDefault(_buttonSpacing);

var _buttonStrike = __webpack_require__(/*! ./button-strike.jsx */ "./src/components/buttons/button-strike.jsx");

var _buttonStrike2 = _interopRequireDefault(_buttonStrike);

var _buttonStylesListHeader = __webpack_require__(/*! ./button-styles-list-header.jsx */ "./src/components/buttons/button-styles-list-header.jsx");

var _buttonStylesListHeader2 = _interopRequireDefault(_buttonStylesListHeader);

var _buttonStylesListItemRemove = __webpack_require__(/*! ./button-styles-list-item-remove.jsx */ "./src/components/buttons/button-styles-list-item-remove.jsx");

var _buttonStylesListItemRemove2 = _interopRequireDefault(_buttonStylesListItemRemove);

var _buttonStylesListItem = __webpack_require__(/*! ./button-styles-list-item.jsx */ "./src/components/buttons/button-styles-list-item.jsx");

var _buttonStylesListItem2 = _interopRequireDefault(_buttonStylesListItem);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

var _buttonStyles = __webpack_require__(/*! ./button-styles.jsx */ "./src/components/buttons/button-styles.jsx");

var _buttonStyles2 = _interopRequireDefault(_buttonStyles);

var _buttonSubscript = __webpack_require__(/*! ./button-subscript.jsx */ "./src/components/buttons/button-subscript.jsx");

var _buttonSubscript2 = _interopRequireDefault(_buttonSubscript);

var _buttonSuperscript = __webpack_require__(/*! ./button-superscript.jsx */ "./src/components/buttons/button-superscript.jsx");

var _buttonSuperscript2 = _interopRequireDefault(_buttonSuperscript);

var _buttonTableCell = __webpack_require__(/*! ./button-table-cell.jsx */ "./src/components/buttons/button-table-cell.jsx");

var _buttonTableCell2 = _interopRequireDefault(_buttonTableCell);

var _buttonTableColumn = __webpack_require__(/*! ./button-table-column.jsx */ "./src/components/buttons/button-table-column.jsx");

var _buttonTableColumn2 = _interopRequireDefault(_buttonTableColumn);

var _buttonTableEdit = __webpack_require__(/*! ./button-table-edit.jsx */ "./src/components/buttons/button-table-edit.jsx");

var _buttonTableEdit2 = _interopRequireDefault(_buttonTableEdit);

var _buttonTableHeading = __webpack_require__(/*! ./button-table-heading.jsx */ "./src/components/buttons/button-table-heading.jsx");

var _buttonTableHeading2 = _interopRequireDefault(_buttonTableHeading);

var _buttonTableRemove = __webpack_require__(/*! ./button-table-remove.jsx */ "./src/components/buttons/button-table-remove.jsx");

var _buttonTableRemove2 = _interopRequireDefault(_buttonTableRemove);

var _buttonTableRow = __webpack_require__(/*! ./button-table-row.jsx */ "./src/components/buttons/button-table-row.jsx");

var _buttonTableRow2 = _interopRequireDefault(_buttonTableRow);

var _buttonTable = __webpack_require__(/*! ./button-table.jsx */ "./src/components/buttons/button-table.jsx");

var _buttonTable2 = _interopRequireDefault(_buttonTable);

var _buttonTargetList = __webpack_require__(/*! ./button-target-list.jsx */ "./src/components/buttons/button-target-list.jsx");

var _buttonTargetList2 = _interopRequireDefault(_buttonTargetList);

var _buttonTwitter = __webpack_require__(/*! ./button-twitter.jsx */ "./src/components/buttons/button-twitter.jsx");

var _buttonTwitter2 = _interopRequireDefault(_buttonTwitter);

var _buttonUl = __webpack_require__(/*! ./button-ul.jsx */ "./src/components/buttons/button-ul.jsx");

var _buttonUl2 = _interopRequireDefault(_buttonUl);

var _buttonUnderline = __webpack_require__(/*! ./button-underline.jsx */ "./src/components/buttons/button-underline.jsx");

var _buttonUnderline2 = _interopRequireDefault(_buttonUnderline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**
                                                                                                                                                                                                                   * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                   * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                   */

exports.default = (_ButtonAccessibilityI = {}, _defineProperty(_ButtonAccessibilityI, _buttonAccessibilityImageAlt2.default.key, _buttonAccessibilityImageAlt2.default), _defineProperty(_ButtonAccessibilityI, _buttonBackgroundColor2.default.key, _buttonBackgroundColor2.default), _defineProperty(_ButtonAccessibilityI, _buttonBold2.default.key, _buttonBold2.default), _defineProperty(_ButtonAccessibilityI, _buttonCameraImage2.default.key, _buttonCameraImage2.default), _defineProperty(_ButtonAccessibilityI, _buttonCamera2.default.key, _buttonCamera2.default), _defineProperty(_ButtonAccessibilityI, _buttonCode2.default.key, _buttonCode2.default), _defineProperty(_ButtonAccessibilityI, _buttonColor2.default.key, _buttonColor2.default), _defineProperty(_ButtonAccessibilityI, _buttonCommandListItem2.default.key, _buttonCommandListItem2.default), _defineProperty(_ButtonAccessibilityI, _buttonCommandsList2.default.key, _buttonCommandsList2.default), _defineProperty(_ButtonAccessibilityI, _buttonDropdown2.default.key, _buttonDropdown2.default), _defineProperty(_ButtonAccessibilityI, _buttonEmbedEdit2.default.key, _buttonEmbedEdit2.default), _defineProperty(_ButtonAccessibilityI, _buttonEmbed2.default.key, _buttonEmbed2.default), _defineProperty(_ButtonAccessibilityI, _buttonEmbedVideoEdit2.default.key, _buttonEmbedVideoEdit2.default), _defineProperty(_ButtonAccessibilityI, _buttonEmbedVideo2.default.key, _buttonEmbedVideo2.default), _defineProperty(_ButtonAccessibilityI, _buttonH2.default.key, _buttonH2.default), _defineProperty(_ButtonAccessibilityI, _buttonH4.default.key, _buttonH4.default), _defineProperty(_ButtonAccessibilityI, _buttonHline2.default.key, _buttonHline2.default), _defineProperty(_ButtonAccessibilityI, _buttonImageAlignCenter2.default.key, _buttonImageAlignCenter2.default), _defineProperty(_ButtonAccessibilityI, _buttonImageAlignLeft2.default.key, _buttonImageAlignLeft2.default), _defineProperty(_ButtonAccessibilityI, _buttonImageAlignRight2.default.key, _buttonImageAlignRight2.default), _defineProperty(_ButtonAccessibilityI, _buttonImage2.default.key, _buttonImage2.default), _defineProperty(_ButtonAccessibilityI, _buttonIndentBlock2.default.key, _buttonIndentBlock2.default), _defineProperty(_ButtonAccessibilityI, _buttonItalic2.default.key, _buttonItalic2.default), _defineProperty(_ButtonAccessibilityI, _buttonItemSelectorAudio2.default.key, _buttonItemSelectorAudio2.default), _defineProperty(_ButtonAccessibilityI, _buttonItemSelectorImage2.default.key, _buttonItemSelectorImage2.default), _defineProperty(_ButtonAccessibilityI, _buttonItemSelectorVideo2.default.key, _buttonItemSelectorVideo2.default), _defineProperty(_ButtonAccessibilityI, _buttonLinkAutocompleteList2.default.key, _buttonLinkAutocompleteList2.default), _defineProperty(_ButtonAccessibilityI, _buttonLinkBrowse2.default.key, _buttonLinkBrowse2.default), _defineProperty(_ButtonAccessibilityI, _buttonLinkEditBrowse2.default.key, _buttonLinkEditBrowse2.default), _defineProperty(_ButtonAccessibilityI, _buttonLinkEdit2.default.key, _buttonLinkEdit2.default), _defineProperty(_ButtonAccessibilityI, _buttonLinkTargetEdit2.default.key, _buttonLinkTargetEdit2.default), _defineProperty(_ButtonAccessibilityI, _buttonLink2.default.key, _buttonLink2.default), _defineProperty(_ButtonAccessibilityI, _buttonOl2.default.key, _buttonOl2.default), _defineProperty(_ButtonAccessibilityI, _buttonOutdentBlock2.default.key, _buttonOutdentBlock2.default), _defineProperty(_ButtonAccessibilityI, _buttonParagraphAlign2.default.key, _buttonParagraphAlign2.default), _defineProperty(_ButtonAccessibilityI, _buttonParagraphAlignLeft2.default.key, _buttonParagraphAlignLeft2.default), _defineProperty(_ButtonAccessibilityI, _buttonParagraphAlignRight2.default.key, _buttonParagraphAlignRight2.default), _defineProperty(_ButtonAccessibilityI, _buttonParagraphCenter2.default.key, _buttonParagraphCenter2.default), _defineProperty(_ButtonAccessibilityI, _buttonParagraphJustify2.default.key, _buttonParagraphJustify2.default), _defineProperty(_ButtonAccessibilityI, _buttonQuote2.default.key, _buttonQuote2.default), _defineProperty(_ButtonAccessibilityI, _buttonRemoveFormat2.default.key, _buttonRemoveFormat2.default), _defineProperty(_ButtonAccessibilityI, _buttonRemoveImage2.default.key, _buttonRemoveImage2.default), _defineProperty(_ButtonAccessibilityI, _buttonSeparator2.default.key, _buttonSeparator2.default), _defineProperty(_ButtonAccessibilityI, _buttonSpacing2.default.key, _buttonSpacing2.default), _defineProperty(_ButtonAccessibilityI, _buttonStrike2.default.key, _buttonStrike2.default), _defineProperty(_ButtonAccessibilityI, _buttonStylesListHeader2.default.key, _buttonStylesListHeader2.default), _defineProperty(_ButtonAccessibilityI, _buttonStylesListItemRemove2.default.key, _buttonStylesListItemRemove2.default), _defineProperty(_ButtonAccessibilityI, _buttonStylesListItem2.default.key, _buttonStylesListItem2.default), _defineProperty(_ButtonAccessibilityI, _buttonStylesList2.default.key, _buttonStylesList2.default), _defineProperty(_ButtonAccessibilityI, _buttonStyles2.default.key, _buttonStyles2.default), _defineProperty(_ButtonAccessibilityI, _buttonSubscript2.default.key, _buttonSubscript2.default), _defineProperty(_ButtonAccessibilityI, _buttonSuperscript2.default.key, _buttonSuperscript2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableCell2.default.key, _buttonTableCell2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableColumn2.default.key, _buttonTableColumn2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableEdit2.default.key, _buttonTableEdit2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableHeading2.default.key, _buttonTableHeading2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableRemove2.default.key, _buttonTableRemove2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableRow2.default.key, _buttonTableRow2.default), _defineProperty(_ButtonAccessibilityI, _buttonTable2.default.key, _buttonTable2.default), _defineProperty(_ButtonAccessibilityI, _buttonTargetList2.default.key, _buttonTargetList2.default), _defineProperty(_ButtonAccessibilityI, _buttonTwitter2.default.key, _buttonTwitter2.default), _defineProperty(_ButtonAccessibilityI, _buttonUl2.default.key, _buttonUl2.default), _defineProperty(_ButtonAccessibilityI, _buttonUnderline2.default.key, _buttonUnderline2.default), _ButtonAccessibilityI);

/***/ }),

/***/ "./src/components/compat/button-action-style.js":
/*!******************************************************!*\
  !*** ./src/components/compat/button-action-style.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * ButtonActionStyle is a mixin that provides applying style
 * implementation for a button based on the `applyStyle` and
 * `removeStyle` API of CKEDITOR.
 *
 * To execute properly, the component has to expose the following
 * methods which can be obtained out of the box using the {{#crossLink
 * "ButtonStyle"}}{{/crossLink}} mixin:
 * - `Function` {{#crossLink "ButtonStyle/isActive"}}{{/crossLink}} to
 *    check the active state
 * - `Function` {{#crossLink "ButtonStyle/getStyle"}}{{/crossLink}} to
 *    return the style that should be applied
 *
 * @class ButtonActionStyle
 */
var ButtonActionStyle = {
	/**
  * Removes or applies the component style to the current selection.
  *
  * @instance
  * @memberof ButtonActionStyle
  * @method applyStyle
  */
	applyStyle: function applyStyle() {
		if (_lang2.default.isFunction(this.isActive) && _lang2.default.isFunction(this.getStyle)) {
			var editor = this.props.editor.get('nativeEditor');

			editor.getSelection().lock();

			if (this.isActive()) {
				editor.removeStyle(this.getStyle());
			} else {
				editor.applyStyle(this.getStyle());
			}

			editor.getSelection().unlock();

			editor.fire('actionPerformed', this);
		}
	}
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = ButtonActionStyle;

/***/ }),

/***/ "./src/components/compat/button-command-active.js":
/*!********************************************************!*\
  !*** ./src/components/compat/button-command-active.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * ButtonCommandActive is a mixin that provides an `isActive` method to
 * determine if a context-aware command is currently in an active state.
 *
 * @class ButtonCommandActive
 */
var ButtonCommandActive = {
	/**
  * Checks if the command is active in the current selection.
  *
  * @instance
  * @memberof ButtonCommandActive
  * @method isActive
  * @return {Boolean} True if the command is active, false otherwise.
  */
	isActive: function isActive() {
		var editor = this.props.editor.get('nativeEditor');

		var command = editor.getCommand(this.props.command);

		return command ? command.state === CKEDITOR.TRISTATE_ON : false;
	}
};

exports.default = ButtonCommandActive;

/***/ }),

/***/ "./src/components/compat/button-command.js":
/*!*************************************************!*\
  !*** ./src/components/compat/button-command.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * ButtonCommand is a mixin that executes a command via CKEDITOR's API.
 *
 * @class ButtonCommand
 */
var ButtonCommand = {
	// Allows validating props being passed to the component.

	propTypes: {
		/**
   * The command that should be executed.
   *
   * @instance
   * @memberof ButtonCommand
   * @property {String} command
   */
		command: _propTypes2.default.string.isRequired,

		/**
   * Indicates that the command may cause the editor to have a different.
   *
   * @instance
   * @memberof ButtonCommand
   * @property {boolean} modifiesSelection
   */
		modifiesSelection: _propTypes2.default.bool
	},

	/**
  * Executes a CKEditor command and fires `actionPerformed` event.
  *
  * @instance
  * @memberof ButtonCommand
  * @param {Object=} data Optional data to be passed to CKEDITOR's `execCommand` method.
  * @method execCommand
  */
	execCommand: function execCommand(data) {
		var editor = this.props.editor.get('nativeEditor');

		editor.execCommand(this.props.command, data);

		if (this.props.modifiesSelection) {
			editor.selectionChange(true);
		}

		editor.fire('actionPerformed', this);
	}
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = ButtonCommand;

/***/ }),

/***/ "./src/components/compat/button-keystroke.js":
/*!***************************************************!*\
  !*** ./src/components/compat/button-keystroke.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * ButtonKeystroke is a mixin that provides a `keystroke` prop that allows configuring
 * a function of the instance to be invoked upon the keystroke activation.
 *
 * @class ButtonKeystroke
 */
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var ButtonKeystroke = {
	// Allows validating props being passed to the component.

	propTypes: {
		/**
   * The keystroke definition. An object with the following properties:
   * - fn: The function to be executed
   * - keys: The keystroke definition, as expected by http://docs.ckeditor.com/#!/api/CKEDITOR.editor-method-setKeystroke
   * - name: The name for the CKEditor command that will be created. If empty,
   * a random name will be created on the fly
   *
   * @instance
   * @memberof ButtonKeystroke
   * @property {Object} keystroke
   */
		keystroke: _propTypes2.default.object.isRequired
	},

	/**
  * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
  *
  * @instance
  * @memberof ButtonKeystroke
  * @method componentWillMount
  */
	componentWillMount: function componentWillMount() {
		var nativeEditor = this.props.editor.get('nativeEditor');
		var keystroke = this.props.keystroke;

		var commandName = keystroke.name || (Math.random() * 1e9 >>> 0).toString();

		var command = nativeEditor.getCommand(commandName);

		if (!command) {
			command = new CKEDITOR.command(nativeEditor, {
				exec: function (editor) {
					var keystrokeFn = keystroke.fn;

					if (_lang2.default.isString(keystrokeFn)) {
						this[keystrokeFn].call(this, editor);
					} else if (_lang2.default.isFunction(keystrokeFn)) {
						keystrokeFn.call(this, editor);
					}
				}.bind(this)
			});

			nativeEditor.addCommand(commandName, command);
		}

		this._defaultKeystrokeCommand = nativeEditor.keystrokeHandler.keystrokes[keystroke.keys];

		nativeEditor.setKeystroke(keystroke.keys, commandName);
	},


	/**
  * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
  *
  * @instance
  * @memberof ButtonKeystroke
  * @method componentWillUnmount
  */
	componentWillUnmount: function componentWillUnmount() {
		this.props.editor.get('nativeEditor').setKeystroke(this.props.keystroke.keys, this._defaultKeystrokeCommand);
	}
};

exports.default = ButtonKeystroke;

/***/ }),

/***/ "./src/components/compat/button-props.js":
/*!***********************************************!*\
  !*** ./src/components/compat/button-props.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _buttonLinkEdit = __webpack_require__(/*! ../buttons/button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * ButtonProps is a mixin that provides a style prop and some methods to apply the resulting
 * style and checking if it is present in a given path or selection.
 *
 * @class ButtonProps
 */
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var ButtonProps = {
	// Allows validating props being passed to the component.

	propTypes: {
		/**
   * The editor instance where the component is being used.
   *
   * @instance
   * @memberof ButtonProps
   * @property {Object} editor
   */
		editor: _propTypes2.default.object.isRequired
	},

	/**
  * Merges the properties, passed to the current component with user's configuration
  * via `buttonCfg` property.
  *
  * @instance
  * @memberof ButtonProps
  * @method mergeButtonCfgProps
  * @param {Object} props The properties to be merged with the provided configuration for this
  * button. If not passed, the user configuration will be merged with `this.props`
  * @return {Object} The merged properties
  */
	mergeButtonCfgProps: function mergeButtonCfgProps(props) {
		props = props || this.props;

		var nativeEditor = this.props.editor.get('nativeEditor');
		var buttonCfg = nativeEditor.config.buttonCfg || {};
		var result = CKEDITOR.tools.merge(props, buttonCfg[_buttonLinkEdit2.default.key]);

		return result;
	}
};

exports.default = ButtonProps;

/***/ }),

/***/ "./src/components/compat/button-state-classes.js":
/*!*******************************************************!*\
  !*** ./src/components/compat/button-state-classes.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * ButtonStateClasses is a mixin that decorates the domElement of a component
 * with different CSS classes based on the current state of the element.
 *
 * To check for state, the component can expose the following methods:
 * - `Function` **isActive** to check the active state
 * - `Function` **isDisabled** to check the disabled state
 *
 * @class ButtonStateClasses
 */
var ButtonStateClasses = {
	/**
  * Returns the list of state classes associated to the current element's state, according
  * to the results of the isActive and isDisabled methods.
  *
  * @instance
  * @memberof ButtonStateClasses
  * @method getStateClasses
  * @return {String} A string with the state CSS classes.
  */
	getStateClasses: function getStateClasses() {
		var stateClasses = '';

		// Check for active state

		if (_lang2.default.isFunction(this.isActive) && this.isActive()) {
			stateClasses += 'ae-button-pressed';
		}

		// Check for disabled state

		if (_lang2.default.isFunction(this.isDisabled) && this.isDisabled()) {
			stateClasses += ' ae-button-disabled';
		}

		return stateClasses;
	}
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = ButtonStateClasses;

/***/ }),

/***/ "./src/components/compat/button-style.js":
/*!***********************************************!*\
  !*** ./src/components/compat/button-style.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * ButtonStyle is a mixin that provides a style prop and some methods to
 * apply the resulting style and checking if it is present in a given
 * path or selection.
 *
 * @class ButtonStyle
 */
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var ButtonStyle = {
	// Allows validating props being passed to the component.

	propTypes: {
		/**
   * The style the button should handle. Allowed values are:
   * - Object as described by
   *   http://docs.ckeditor.com/#!/api/CKEDITOR.style.
   * - String pointing to an object inside the editor instance
   *   configuration. For example, `style = 'coreStyles_bold'` will
   *   try to retrieve the style object from
   *   `editor.config.coreStyles_bold`. Nested properties such as
   *   `style = 'myplugin.myConfig.myStyle'` are also supported
   *   and will try to retrieve the style object from the editor
   *   configuration as well.
   *
   * @instance
   * @memberof ButtonStyle
   * @property {Object|String} style
   */
		style: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.string]),

		/**
   * The style function the button should handle.
   * If specified, style function has higher priority than style property.
   *
   * @instance
   * @memberof ButtonStyle
   * @property {function} styleFn
   */
		styleFn: _propTypes2.default.func
	},

	/**
  * Lifecycle. Invoked once, both on the client and server,
  * immediately before the initial rendering occurs.
  *
  * @instance
  * @memberof ButtonStyle
  * @method componentWillMount
  */
	componentWillMount: function componentWillMount() {
		var style = this.props.style;

		if (_lang2.default.isString(style)) {
			var parts = style.split('.');
			var currentMember = this.props.editor.get('nativeEditor').config;
			var property = parts.shift();

			while (property && _lang2.default.isObject(currentMember) && _lang2.default.isObject(currentMember[property])) {
				currentMember = currentMember[property];
				property = parts.shift();
			}

			if (_lang2.default.isObject(currentMember)) {
				style = currentMember;
			}
		}

		this._style = new CKEDITOR.style(style);
	},


	/**
  * Lifecycle. Invoked immediately before a component is unmounted
  * from the DOM.
  *
  * @instance
  * @memberof ButtonStyle
  * @method componentWillUnmount
  */
	componentWillUnmount: function componentWillUnmount() {
		this._style = null;
	},


	/**
  * Returns instance of CKEDITOR.style which represents the current
  * button style.
  *
  * @instance
  * @memberof ButtonStyle
  * @method getStyle
  * @return {CKEDITOR.style} The current style representation.
  */
	getStyle: function getStyle() {
		return this._style;
	},


	/**
  * Checks if style is active in the current selection.
  *
  * @instance
  * @memberof ButtonStyle
  * @method isActive
  * @return {Boolean} True if style is active, false otherwise.
  */
	isActive: function isActive() {
		var editor = this.props.editor.get('nativeEditor');

		var elementPath = editor.elementPath();

		return this.getStyle().checkActive(elementPath, editor);
	}
};

exports.default = ButtonStyle;

/***/ }),

/***/ "./src/components/compat/index.js":
/*!****************************************!*\
  !*** ./src/components/compat/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _buttonActionStyle = __webpack_require__(/*! ./button-action-style */ "./src/components/compat/button-action-style.js");

Object.defineProperty(exports, 'ButtonActionStyle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonActionStyle).default;
  }
});

var _buttonCommandActive = __webpack_require__(/*! ./button-command-active */ "./src/components/compat/button-command-active.js");

Object.defineProperty(exports, 'ButtonCommandActive', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonCommandActive).default;
  }
});

var _buttonCommand = __webpack_require__(/*! ./button-command */ "./src/components/compat/button-command.js");

Object.defineProperty(exports, 'ButtonCommand', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonCommand).default;
  }
});

var _buttonKeystroke = __webpack_require__(/*! ./button-keystroke */ "./src/components/compat/button-keystroke.js");

Object.defineProperty(exports, 'ButtonKeystroke', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonKeystroke).default;
  }
});

var _buttonProps = __webpack_require__(/*! ./button-props */ "./src/components/compat/button-props.js");

Object.defineProperty(exports, 'ButtonProps', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonProps).default;
  }
});

var _buttonStateClasses = __webpack_require__(/*! ./button-state-classes */ "./src/components/compat/button-state-classes.js");

Object.defineProperty(exports, 'ButtonStateClasses', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonStateClasses).default;
  }
});

var _buttonStyle = __webpack_require__(/*! ./button-style */ "./src/components/compat/button-style.js");

Object.defineProperty(exports, 'ButtonStyle', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_buttonStyle).default;
  }
});

var _toolbarButtons = __webpack_require__(/*! ./toolbar-buttons */ "./src/components/compat/toolbar-buttons.js");

Object.defineProperty(exports, 'ToolbarButtons', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_toolbarButtons).default;
  }
});

var _widgetArrowBox = __webpack_require__(/*! ./widget-arrow-box */ "./src/components/compat/widget-arrow-box.js");

Object.defineProperty(exports, 'WidgetArrowBox', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetArrowBox).default;
  }
});

var _widgetDropdown = __webpack_require__(/*! ./widget-dropdown */ "./src/components/compat/widget-dropdown.js");

Object.defineProperty(exports, 'WidgetDropdown', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetDropdown).default;
  }
});

var _widgetExclusive = __webpack_require__(/*! ./widget-exclusive */ "./src/components/compat/widget-exclusive.js");

Object.defineProperty(exports, 'WidgetExclusive', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetExclusive).default;
  }
});

var _widgetFocusManager = __webpack_require__(/*! ./widget-focus-manager */ "./src/components/compat/widget-focus-manager.js");

Object.defineProperty(exports, 'WidgetFocusManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetFocusManager).default;
  }
});

var _widgetInteractionPoint = __webpack_require__(/*! ./widget-interaction-point */ "./src/components/compat/widget-interaction-point.js");

Object.defineProperty(exports, 'WidgetInteractionPoint', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetInteractionPoint).default;
  }
});

var _widgetPosition = __webpack_require__(/*! ./widget-position */ "./src/components/compat/widget-position.js");

Object.defineProperty(exports, 'WidgetPosition', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_widgetPosition).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./src/components/compat/toolbar-buttons.js":
/*!**************************************************!*\
  !*** ./src/components/compat/toolbar-buttons.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * ToolbarButtons is a mixin which provides a list of buttons which have
 * to be displayed on the current toolbar depending on user preferences
 * and given state.
 *
 * @class ToolbarButtons
 */
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var ToolbarButtons = {
	/**
  * Analyses the current selection and returns the buttons or button
  * groups to be rendered.
  *
  * @instance
  * @method getToolbarButtonGroups
  * @param {Array} buttons The buttons could be shown, prior to the state filtering.
  * @param {Object} additionalProps Additional props that should be passed down to the buttons.
  * @return {Array} An Array which contains the buttons or button groups that should be rendered.
  */
	getToolbarButtonGroups: function getToolbarButtonGroups(buttons, additionalProps) {
		var instance = this;

		if (_lang2.default.isFunction(buttons)) {
			buttons = buttons.call(this) || [];
		}

		return buttons.reduce(function (list, button) {
			if (Array.isArray(button)) {
				list.push(instance.getToolbarButtons(button, additionalProps));

				return list;
			} else {
				return instance.getToolbarButtons(buttons, additionalProps);
			}
		}, []);
	},


	/**
  * Analyzes the current selection and the buttons exclusive mode value to figure out which
  * buttons should be present in a given state.
  *
  * @instance
  * @memberof ToolbarButtons
  * @method getToolbarButtons
  * @param {Array} buttons The buttons could be shown, prior to the state filtering.
  * @param {Object} additionalProps Additional props that should be passed down to the buttons.
  * @return {Array} An Array which contains the buttons that should be rendered.
  */
	getToolbarButtons: function getToolbarButtons(buttons, additionalProps) {
		var buttonProps = {};

		var nativeEditor = this.props.editor.get('nativeEditor');
		var buttonCfg = nativeEditor.config.buttonCfg || {};

		if (_lang2.default.isFunction(buttons)) {
			buttons = buttons.call(this) || [];
		}

		var toolbarButtons = this.filterExclusive(buttons.filter(function (button) {
			return button && (AlloyEditor.Buttons[button] || AlloyEditor.Buttons[button.name]);
		}).map(function (button) {
			if (_lang2.default.isString(button)) {
				buttonProps[button] = buttonCfg[button];
				button = AlloyEditor.Buttons[button];
			} else if (_lang2.default.isString(button.name)) {
				buttonProps[AlloyEditor.Buttons[button.name].key] = CKEDITOR.tools.merge(buttonCfg[button], button.cfg);
				button = AlloyEditor.Buttons[button.name];
			}

			return button;
		})).map(function (button, index) {
			var props = this.mergeExclusiveProps({
				editor: this.props.editor,
				key: button.key !== 'separator' ? button.key : button.key + '-' + index,
				tabKey: button.key,
				tabIndex: this.props.trigger && this.props.trigger.props.tabKey === button.key ? 0 : -1,
				trigger: this.props.trigger
			}, button.key);

			props = this.mergeDropdownProps(props, button.key);

			if (additionalProps) {
				props = CKEDITOR.tools.merge(props, additionalProps);
			}

			props = CKEDITOR.tools.merge(props, buttonProps[button.key]);

			return _react2.default.createElement(button, props);
		}, this);

		return toolbarButtons;
	}
};

exports.default = ToolbarButtons;

/***/ }),

/***/ "./src/components/compat/widget-arrow-box.js":
/*!***************************************************!*\
  !*** ./src/components/compat/widget-arrow-box.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Provides functionality for displaying Widget Arrow box on top or on bottom of the widget
 * depending on the point of user interaction with the editor.
 *
 * @class WidgetArrowBox
 */
var WidgetArrowBox = {
	/**
  * Returns the list of arrow box classes associated to the current element's state. It relies
  * on the getInteractionPoint method to calculate the selection direction.
  *
  * @instance
  * @memberof WidgetArrowBox
  * @method getArrowBoxClasses
  * @return {String} A string with the arrow box CSS classes.
  */
	getArrowBoxClasses: function getArrowBoxClasses() {
		var arrowBoxClasses = 'ae-arrow-box';

		if (_lang2.default.isFunction(this.getInteractionPoint) && this.getInteractionPoint()) {
			if (this.getInteractionPoint().direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
				arrowBoxClasses += ' ae-arrow-box-top';
			} else {
				arrowBoxClasses += ' ae-arrow-box-bottom';
			}
		}

		return arrowBoxClasses;
	}
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = WidgetArrowBox;

/***/ }),

/***/ "./src/components/compat/widget-dropdown.js":
/*!**************************************************!*\
  !*** ./src/components/compat/widget-dropdown.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Provides functionality for managing different dropdowns inside a widget.
 *
 * @class WidgetDropdown
 */
var WidgetDropdown = {
	/**
  * Lifecycle. Invoked when a component is receiving new props.
  * This method is not called for the initial render.
  *
  * @instance
  * @memberof WidgetDropdown
  * @method componentWillReceiveProps
  */
	componentWillReceiveProps: function componentWillReceiveProps(_nextProps) {
		this.setState({
			dropdownTrigger: null,
			itemDropdown: null
		});
	},


	/**
  * Lifecycle. Invoked once before the component is mounted.
  *
  * @instance
  * @memberof WidgetDropdown
  * @method getInitialState
  */
	getInitialState: function getInitialState() {
		return {
			dropdownTrigger: null,
			itemDropdown: null
		};
	},


	/**
  * Merges the provided object with two more properties:
  * - expanded - boolean flag which indicates if an widget should be
  *   rendered exclusively.
  * - toggleDropdown - function, which can be used by an widget in
  *   order to obtain exclusive state.
  *
  * @instance
  * @memberof WidgetDropdown
  * @method mergeDropdownProps
  * @param {Object} obj The properties container which should be merged with the properties, related
  *    to dropdown state.
  * @param {Object} itemKey They key of an React Widget which contains the dropdown.
  * @return {Object} The merged object.
  */
	mergeDropdownProps: function mergeDropdownProps(obj, itemKey) {
		return CKEDITOR.tools.merge(obj, {
			expanded: this.state.itemDropdown === itemKey ? true : false,
			tabIndex: this.state.dropdownTrigger === itemKey ? 0 : -1,
			toggleDropdown: this.toggleDropdown.bind(this, itemKey)
		});
	},


	/**
  * Sets the active dropdown of the widget or discards the toggled
  * item from the state.
  *
  * @instance
  * @memberof WidgetDropdown
  * @method toggleDropdown
  * @param {Object} itemDropdown The widget which requests to toggle its dropdown.
  * @param {Number} toggleDirection User movement direction when toggled via keyboard.
  */
	toggleDropdown: function toggleDropdown(itemDropdown, toggleDirection) {
		this.setState({
			dropdownTrigger: itemDropdown,
			itemDropdown: itemDropdown !== this.state.itemDropdown ? itemDropdown : null
		}, function () {
			if (!this.state.itemDropdown) {
				if (this.moveFocus) {
					this.moveFocus(toggleDirection);
				} else {
					_reactDom2.default.findDOMNode(this).focus();
				}
			}
		});
	}
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = WidgetDropdown;

/***/ }),

/***/ "./src/components/compat/widget-exclusive.js":
/*!***************************************************!*\
  !*** ./src/components/compat/widget-exclusive.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * Provides functionality for managing exclusive state of an widget.
 * The exclusive state means that a button may request to be the only rendered
 * widget in its parent container. WidgetExclusive will manage this state by
 * filtering and suppressing the other sibling widgets from displaying.
 *
 * @class WidgetExclusive
 */
var WidgetExclusive = {
	/**
  * Cancels the exclusive state of an widget.
  *
  * @instance
  * @memberof WidgetExclusive
  * @method cancelExclusive
  * @param {Object} itemExclusive The widget which exclusive state should be canceled.
  */
	cancelExclusive: function cancelExclusive(itemExclusive) {
		if (this.state.itemExclusive === itemExclusive) {
			this.setState({
				itemExclusive: null
			});
		}
	},


	/**
  * Lifecycle. Invoked when a component is receiving new props.
  * This method is not called for the initial render.
  * Calling this.setState() within this function will not trigger an
  * additional render.
  *
  * @instance
  * @memberof WidgetExclusive
  * @method componentWillReceiveProps
  * @param {Object} nextProps Object containing the current set of properties.
  */
	componentWillReceiveProps: function componentWillReceiveProps(_nextProps) {
		// Receiving properties means that the component is being
		// re-rendered.  Re-rendering is triggered by editorInteraction,
		// so we have to reset the exclusive state and render the UI
		// according to the new selection.

		this.setState({
			itemExclusive: null
		});
	},


	/**
  * Filters the items and returns only those with exclusive state.
  *
  * @instance
  * @memberof WidgetExclusive
  * @method filterExclusive
  * @param {Array} items The widgets to be filtered.
  * @return {Array|Object} The item with executive state.
  */
	filterExclusive: function filterExclusive(items) {
		var _this = this;

		return items.filter(function (item) {
			if (_this.state.itemExclusive) {
				if (_this.state.itemExclusive === item.key) {
					return item;
				}
			} else {
				return item;
			}
		});
	},


	/**
  * Merges the provided object with three more properties:
  * - cancelExclusive - function, which can be used by a widget in
  *   order to cancel executive state.
  * - renderExclusive - boolean flag which indicates if an widget
  *   should be rendered exclusively.
  * - requestExclusive - function, which can be used by a widget in
  *   order to obtain exclusive state.
  *
  * @instance
  * @memberof WidgetExclusive
  * @method mergeExclusiveProps
  * @param {Object} obj The properties container which should be merged with the properties, related
  *    to exclusive state.
  * @param {Object} itemKey They key of an React Widget which should be rendered exclusively.
  * @return {Object} The merged object.
  */
	mergeExclusiveProps: function mergeExclusiveProps(obj, itemKey) {
		return CKEDITOR.tools.merge(obj, {
			cancelExclusive: this.cancelExclusive.bind(this, itemKey),
			renderExclusive: this.state.itemExclusive === itemKey,
			requestExclusive: this.requestExclusive.bind(this, itemKey)
		});
	},


	/**
  * Requests and sets exclusive state of an widget.
  *
  * @instance
  * @memberof WidgetExclusive
  * @method requestExclusive
  * @param {Object} itemExclusive The widget which requests exclusive state.
  */
	requestExclusive: function requestExclusive(itemExclusive) {
		this.setState({
			itemExclusive: itemExclusive
		});
	}
};

exports.default = WidgetExclusive;

/***/ }),

/***/ "./src/components/compat/widget-focus-manager.js":
/*!*******************************************************!*\
  !*** ./src/components/compat/widget-focus-manager.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DIRECTION_NONE = 0; /**
                         * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                         * SPDX-License-Identifier: LGPL-3.0-or-later
                         */

var DIRECTION_NEXT = 1;
var DIRECTION_PREV = -1;

var ACTION_NONE = 0;
var ACTION_MOVE_FOCUS = 1;
var ACTION_DISMISS_FOCUS = 2;

/**
 * WidgetFocusManager is a mixin that provides keyboard navigation inside a widget. To do this,
 * it exposes the following props and methods:
 *
 * @class WidgetFocusManager
 */
var WidgetFocusManager = {
	// Allows validating props being passed to the component.

	propTypes: {
		/**
   * Callback method to be invoked when the focus manager is to be dismissed. This happens
   * in the following scenarios if a dismiss callback has been specified:
   * - A dismiss key has been pressed
   * - In a non-circular focus manager, when:
   *     - The active descendant is the first one and a prev key has been pressed.
   *     - The active descendant is the last one and a next key has been pressed.
   *
   * @instance
   * @memberof WidgetFocusManager
   * @property {Function} onDismiss
   */
		onDismiss: _propTypes2.default.func,

		/**
   * Indicates if focus should be set to the first/last descendant when the limits are reached.
   *
   * @instance
   * @memberof WidgetFocusManager
   * @property {boolean} circular
   */
		circular: _propTypes2.default.bool.isRequired,

		/**
   * Indicate if should focus the first child of a container
   * @instance
   * @memberof WidgetFocusManager
   * @property {Boolean} focusFirstChild
   */
		focusFirstChild: _propTypes2.default.bool,

		/**
   * String representing the CSS selector used to define the elements that should be handled.
   *
   * @instance
   * @memberof WidgetFocusManager
   * @property {String} descendants
   */
		descendants: _propTypes2.default.string.isRequired,

		/**
   * Object representing the keys used to navigate between descendants. The format for the prop is:
   * `{dismiss: value, dismissNext: value, dismissPrev: value, next: value, prev: value}` where
   * value can be both a number or an array of numbers with the allowed keyCodes.
   *
   * @instance
   * @memberof WidgetFocusManager
   * @property {Object} keys
   */
		keys: _propTypes2.default.object.isRequired
	},

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method componentDidMount
  */
	componentDidMount: function componentDidMount() {
		this._refresh();
	},


	/**
  * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
  * Refreshes the descendants list.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method componentDidUpdate
  */
	componentDidUpdate: function componentDidUpdate() {
		this._refresh();
	},


	/**
  * Focuses the current active descendant.
  *
  * Several Widgets can be nested in a component hierarchy by attaching this focus method to
  * the widget DOM node, transferring the DOM focus control to the inner FocusManager.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method focus
  */
	focus: function focus(event) {
		if (!event || this._isValidTarget(event.target)) {
			if (this._descendants && this._descendants.length) {
				var activeDescendantEl = this._descendants[this._activeDescendant];

				// When user clicks with the mouse, the activeElement is already set and there
				// is no need to focus it. Focusing of the active descendant (usually some button) is required
				// in case of keyboard navigation, because the focused element might be not the first button,
				// but the div element, which contains the button.

				if (document.activeElement !== activeDescendantEl && !this.props.focusFirstChild) {
					if (this._descendants.indexOf(document.activeElement) === -1) {
						activeDescendantEl.focus();
					}
				}

				if (event) {
					event.stopPropagation();
					event.preventDefault();
				}
			}
		}
	},


	/**
  * Handles the key events on a DOM node to execute the appropriate navigation when needed.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @param {Object} event The Keyboard event that was detected on the widget DOM node.
  * @method handleKey
  */
	handleKey: function handleKey(event) {
		if (this._isValidTarget(event.target) && this._descendants) {
			var action = this._getFocusAction(event);

			if (action.type) {
				event.stopPropagation();
				event.preventDefault();

				if (action.type === ACTION_MOVE_FOCUS) {
					this._moveFocus(action.direction);
				}

				if (action.type === ACTION_DISMISS_FOCUS) {
					this.props.onDismiss(action.direction);
				}
			}
		}
	},


	/**
  * Moves the focus among descendants in the especified direction.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method moveFocus
  * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
  */
	moveFocus: function moveFocus(direction) {
		direction = _lang2.default.isNumber(direction) ? direction : 0;

		this._moveFocus(direction);
	},


	/**
  * Returns the action, if any, that a keyboard event in the current focus manager state
  * should produce.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method _getFocusAction
  * @param {object} event The Keyboard event.
  * @protected
  * @return {Object} An action object with type and direction properties.
  */
	_getFocusAction: function _getFocusAction(event) {
		var action = {
			type: ACTION_NONE
		};

		if (this.props.keys) {
			var direction = this._getFocusMoveDirection(event);

			if (direction) {
				action.direction = direction;
				action.type = ACTION_MOVE_FOCUS;
			}

			var dismissAction = this._getFocusDismissAction(event, direction);

			if (dismissAction.dismiss) {
				action.direction = dismissAction.direction;
				action.type = ACTION_DISMISS_FOCUS;
			}
		}

		return action;
	},


	/**
  * Returns the dismiss action, if any, the focus manager should execute to yield the focus. This
  * will happen in any of these scenarios if a dismiss callback has been specified:
  * - A dismiss key has been pressed
  * - In a non-circular focus manager, when:
  *     - The active descendant is the first one and a prev key has been pressed.
  *     - The active descendant is the last one and a next key has been pressed.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method _getFocusDismissAction
  * @param {Number} focusMoveDirection The focus movement direction (if any).
  * @param {Object} event The Keyboard event.
  * @protected
  * @return {Object} A dismiss action with dismiss and direction properties.
  */
	_getFocusDismissAction: function _getFocusDismissAction(event, focusMoveDirection) {
		var dismissAction = {
			direction: focusMoveDirection,
			dismiss: false
		};

		if (this.props.onDismiss) {
			if (this._isValidKey(event.keyCode, this.props.keys.dismiss)) {
				dismissAction.dismiss = true;
			}
			if (this._isValidKey(event.keyCode, this.props.keys.dismissNext)) {
				dismissAction.dismiss = true;
				dismissAction.direction = DIRECTION_NEXT;
			}
			if (this._isValidKey(event.keyCode, this.props.keys.dismissPrev)) {
				dismissAction.dismiss = true;
				dismissAction.direction = DIRECTION_PREV;
			}

			if (!dismissAction.dismiss && !this.props.circular && focusMoveDirection) {
				dismissAction.dismiss = focusMoveDirection === DIRECTION_PREV && this._activeDescendant === 0 || focusMoveDirection === DIRECTION_NEXT && this._activeDescendant === this._descendants.length - 1;
			}
		}

		return dismissAction;
	},


	/**
  * Returns the direction, if any, in which the focus should be moved. In presence of the
  * shift key modifier, the direction of the movement is inverted.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method _getFocusMoveDirection
  * @param {Object} event The Keyboard event.
  * @protected
  * @return {Number} The computed direction of the expected focus movement.
  */
	_getFocusMoveDirection: function _getFocusMoveDirection(event) {
		var direction = DIRECTION_NONE;

		if (this._isValidKey(event.keyCode, this.props.keys.next)) {
			direction = DIRECTION_NEXT;
		}
		if (this._isValidKey(event.keyCode, this.props.keys.prev)) {
			direction = DIRECTION_PREV;
		}

		if (event.shifKey) {
			direction *= -1;
		}

		return direction;
	},


	/**
  * Indicates if a given keyCode is valid for the given set of keys.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method _isValidKey
  * @param {Array|Number} keys A key set. Can be a number an array of numbers representing the allowed keyCodes.
  * @param {Number} keyCode An event keyCode.
  * @protected
  * @return {Boolean} A boolean value indicating if the key is valid.
  */
	_isValidKey: function _isValidKey(keyCode, keys) {
		return _lang2.default.isArray(keys) ? keys.indexOf(keyCode) !== -1 : keyCode === keys;
	},


	/**
  * Indicates if a given element is valid for focus management. User input elements such as
  * input, select or textarea are excluded.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method _isValidKey
  * @param {DOMNode} element A DOM element.
  * @protected
  * @return {Boolean} A boolean value indicating if the element is valid.
  */
	_isValidTarget: function _isValidTarget(element) {
		var tagName = element.tagName.toLowerCase();

		return tagName !== 'input' && tagName !== 'select' && tagName !== 'textarea';
	},


	/**
  * Moves the focus among descendants in the especified direction.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method _moveFocus
  * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
  * @protected
  */
	_moveFocus: function _moveFocus(direction) {
		var numDescendants = this._descendants.length;

		var descendant = this._descendants[this._activeDescendant];

		descendant.setAttribute('tabIndex', -1);

		this._activeDescendant += direction;

		if (this.props.circular) {
			// Calculate proper modulo result since remainder operator doesn't behave in the
			// same way for negative numbers

			this._activeDescendant = (this._activeDescendant % numDescendants + numDescendants) % numDescendants;
		} else {
			this._activeDescendant = Math.max(Math.min(this._activeDescendant, numDescendants - 1), 0);
		}

		descendant = this._descendants[this._activeDescendant];

		descendant.setAttribute('tabIndex', 0);
		descendant.focus();
	},


	/**
  * Refreshes the descendants list by executing the CSS selector again and resets the descendants tabIndex.
  *
  * @instance
  * @memberof WidgetFocusManager
  * @method _refresh
  * @protected
  */
	_refresh: function _refresh() {
		var _this = this;

		var domNode = _reactDom2.default.findDOMNode(this);

		if (domNode) {
			var descendants = domNode.querySelectorAll(this.props.descendants);

			var priorityDescendants = [];

			this._descendants = [];

			Array.prototype.slice.call(descendants).forEach(function (item) {
				var dataTabIndex = item.getAttribute('data-tabindex');

				if (dataTabIndex) {
					priorityDescendants.push(item);
				} else {
					_this._descendants.push(item);
				}
			});

			priorityDescendants = priorityDescendants.sort(function (a, b) {
				return _lang2.default.toInt(a.getAttribute('data-tabindex')) > _lang2.default.toInt(b.getAttribute('data-tabindex'));
			});

			this._descendants = priorityDescendants.concat(this._descendants);

			this._activeDescendant = 0;

			this._descendants.some(function (item, index) {
				if (item.getAttribute('tabindex') === '0') {
					_this._activeDescendant = index;
					_this.focus();

					return true;
				}
			});
		}
	}
};

exports.default = WidgetFocusManager;

/***/ }),

/***/ "./src/components/compat/widget-interaction-point.js":
/*!***********************************************************!*\
  !*** ./src/components/compat/widget-interaction-point.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Provides functionality for calculating the point of interaction of the user with the Editor.
 *
 * @class WidgetInteractionPoint
 */
var WidgetInteractionPoint = {
	// Allows validating props being passed to the component.

	propTypes: {
		/**
   * The provided editor event.
   *
   * @instance
   * @memberof WidgetInteractionPoint
   * @property {SyntheticEvent} editorEvent
   */
		editorEvent: _propTypes2.default.object
	},

	/**
  * Returns the position, in page coordinates, according to which a widget should appear.
  * Depending on the direction of the selection, the wdiget may appear above of or on bottom of the selection.
  *
  * It depends on the props editorEvent to analyze the following user-interaction parameters:
  * - {Object} selectionData The data about the selection in the editor as returned from
  * {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
  * - {Number} pos Contains the coordinates of the position, considered as most appropriate.
  * This may be the point where the user released the mouse, or just the beginning or the end of
  * the selection.
  *
  * @instance
  * @memberof WidgetInteractionPoint
  * @method getInteractionPoint
  * @return {Object} An Object which contains the following properties:
  * direction, x, y, where x and y are in page coordinates and direction can be one of these:
  * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
  */
	getInteractionPoint: function getInteractionPoint() {
		var eventPayload = this.props.editorEvent ? this.props.editorEvent.data : null;

		if (!eventPayload) {
			return;
		}

		var selectionData = eventPayload.selectionData;

		var nativeEvent = eventPayload.nativeEvent;

		var pos = {
			x: eventPayload.nativeEvent.pageX,
			y: selectionData.region.top
		};

		var direction = selectionData.region.direction;

		var endRect = selectionData.region.endRect;

		var startRect = selectionData.region.startRect;

		if (endRect && startRect && startRect.top === endRect.top) {
			direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
		}

		var x = void 0;
		var y = void 0;

		// If we have the point where user released the mouse, show Toolbar at this point
		// otherwise show it on the middle of the selection.

		if (pos.x && pos.y) {
			x = this._getXPoint(selectionData, pos.x);

			if (direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
				y = Math.min(pos.y, selectionData.region.top);
			} else {
				y = Math.max(pos.y, this._getYPoint(selectionData, nativeEvent));
			}
		} else {
			x = selectionData.region.left + selectionData.region.width / 2;

			if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
				y = this._getYPoint(selectionData, nativeEvent);
			} else {
				y = selectionData.region.top;
			}
		}

		return {
			direction: direction,
			x: x,
			y: y
		};
	},


	/**
  * Returns the position of the Widget.
  *
  * @instance
  * @memberof WidgetInteractionPoint
  * @method _getXPoint
  * @param {Object} eventX The X coordinate received from the native event (mouseup).
  * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
  * @protected
  * @return {Number} The calculated X point in page coordinates.
  */
	_getXPoint: function _getXPoint(selectionData, eventX) {
		var region = selectionData.region;

		var left = region.startRect ? region.startRect.left : region.left;
		var right = region.endRect ? region.endRect.right : region.right;

		var x = void 0;

		if (left < eventX && right > eventX) {
			x = eventX;
		} else {
			var leftDist = Math.abs(left - eventX);
			var rightDist = Math.abs(right - eventX);

			if (leftDist < rightDist) {
				// user raised the mouse on left on the selection

				x = left;
			} else {
				x = right;
			}
		}

		return x;
	},


	/**
  * Returns the position of the Widget.
  *
  * @instance
  * @memberof WidgetInteractionPoint
  * @method _getYPoint
  * @param {Object} nativeEvent The data about event is fired
  * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
  * @protected
  * @return {Number} The calculated Y point in page coordinates.
  */
	_getYPoint: function _getYPoint(selectionData, nativeEvent) {
		var y = 0;

		if (selectionData && nativeEvent) {
			var elementTarget = new CKEDITOR.dom.element(nativeEvent.target);

			if (elementTarget.$ && elementTarget.getStyle('overflow') === 'auto') {
				y = nativeEvent.target.offsetTop + nativeEvent.target.offsetHeight;
			} else {
				y = selectionData.region.bottom;
			}
		}

		return y;
	}
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = WidgetInteractionPoint;

/***/ }),

/***/ "./src/components/compat/widget-position.js":
/*!**************************************************!*\
  !*** ./src/components/compat/widget-position.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetInteractionPoint = __webpack_require__(/*! ./widget-interaction-point */ "./src/components/compat/widget-interaction-point.js");

var _widgetInteractionPoint2 = _interopRequireDefault(_widgetInteractionPoint);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Calculates the position where an Widget should be displayed based on
 * the point where user interacted with the editor.
 *
 * @class WidgetPosition
 * @uses WidgetInteractionPoint
 */
var WidgetPosition = {
	mixins: [_widgetInteractionPoint2.default],

	// Allows validating props being passed to the component.

	propTypes: {
		/**
   * Should the widget to be restricted to the viewport, or not.
   *
   * @instance
   * @memberof WidgetPosition
   * @property {Boolean} constrainToViewport
   * @default true
   */
		constrainToViewport: _propTypes2.default.bool,

		/**
   * The gutter (vertical and horizontal) between the interaction
   * point and where the widget should be rendered.
   *
   * @instance
   * @memberof WidgetPosition
   * @property {Object} gutter
   * @default {
   *     left: 0,
   *     top: 10
   * }
   */
		gutter: _propTypes2.default.object
	},

	/**
  * Lifecycle. Returns the default values of the properties used in
  * the widget.
  *
  * @instance
  * @memberof WidgetPosition
  * @method getDefaultProps
  */
	getDefaultProps: function getDefaultProps() {
		return {
			gutter: {
				left: 0,
				top: 10
			},
			constrainToViewport: true
		};
	},


	/**
  * Cancels an scheduled animation frame.
  *
  * @instance
  * @memberof WidgetPosition
  * @method cancelAnimation
  */
	cancelAnimation: function cancelAnimation() {
		if (window.cancelAnimationFrame) {
			window.cancelAnimationFrame(this._animationFrameId);
		}
	},


	/**
  * Returns an object which contains the position of the element in
  * page coordinates, restricted to fit to given viewport.
  *
  * @instance
  * @memberof WidgetPosition
  * @method getConstrainedPosition
  * @param {Object} attrs The following properties, provided as numbers:
  * - height
  * - left
  * - top
  * - width
  * @param {Object} viewPaneSize Optional. If not provided, the current viewport will be used. Should contain at least these properties:
  * - width
  * @return {Object} An object with `x` and `y` properties, which represent the constrained position of the
  * element.
  */
	getConstrainedPosition: function getConstrainedPosition(attrs, viewPaneSize) {
		viewPaneSize = viewPaneSize || new CKEDITOR.dom.window(window).getViewPaneSize();

		var x = attrs.left;
		var y = attrs.top;

		if (attrs.left + attrs.width > viewPaneSize.width) {
			x -= attrs.left + attrs.width - viewPaneSize.width;
		}

		if (y < 0) {
			y = 0;
		}

		return {
			x: x,
			y: y
		};
	},


	/**
  * Returns the position of the Widget taking in consideration the
  * {{#crossLink "WidgetPosition/gutter:attribute"}}{{/crossLink}} attribute.
  *
  * @instance
  * @memberof WidgetPosition
  * @protected
  * @method  getWidgetXYPoint
  * @param {Number} left The left offset in page coordinates where Toolbar should be shown.
  * @param {Number} top The top offset in page coordinates where Toolbar should be shown.
  * @param {Number} direction The direction of the selection. May be one of the following:
  * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
  * @return {Array} An Array with left and top offsets in page coordinates.
  */
	getWidgetXYPoint: function getWidgetXYPoint(left, top, direction) {
		var domNode = _reactDom2.default.findDOMNode(this);

		var gutter = this.props.gutter;
		var offsetWidth = domNode.offsetWidth;
		var halfWidth = offsetWidth / 2;

		if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM || direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
			left = left - gutter.left - halfWidth;

			top = direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM ? top + gutter.top : top - domNode.offsetHeight - gutter.top;
		} else if (direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT || direction === CKEDITOR.SELECTION_RIGHT_TO_LEFT) {
			left = direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT ? left + gutter.left + domNode.offsetHeight / 2 : left - 3 * domNode.offsetHeight / 2 - gutter.left;

			top = top - gutter.top - domNode.offsetHeight / 2;
		}

		if (left < 0) {
			left = 0;
		}

		if (left > document.body.offsetWidth - halfWidth) {
			left = document.body.offsetWidth - halfWidth;
		}

		if (top < 0) {
			top = 0;
		}

		return [left, top];
	},


	/**
  * Returns true if the widget is visible, false otherwise
  *
  * @instance
  * @memberof WidgetPosition
  * @method isVisible
  * @return {Boolean} True if the widget is visible, false otherwise
  */
	isVisible: function isVisible() {
		var domNode = _reactDom2.default.findDOMNode(this);

		if (domNode) {
			var domElement = new CKEDITOR.dom.element(domNode);

			return domElement.hasClass('alloy-editor-visible');
		}

		return false;
	},


	/**
  * Moves a widget from a starting point to a destination point.
  *
  * @instance
  * @memberof WidgetPosition
  * @method moveToPoint
  * @param  {Object} startPoint The starting point for the movement.
  * @param  {Object} endPoint The destination point for the movement.
  */
	moveToPoint: function moveToPoint(startPoint, endPoint) {
		var domElement = new CKEDITOR.dom.element(_reactDom2.default.findDOMNode(this));

		domElement.setStyles({
			left: startPoint[0] + 'px',
			top: startPoint[1] + 'px',
			opacity: 0,
			pointerEvents: 'none'
		});

		domElement.removeClass('alloy-editor-invisible');

		this._animate(function () {
			domElement.addClass('ae-toolbar-transition');
			domElement.addClass('alloy-editor-visible');
			domElement.setStyles({
				left: endPoint[0] + 'px',
				top: endPoint[1] + 'px',
				opacity: 1
			});

			// 150ms to match transition-duration for .ae-toolbar-transition:

			setTimeout(function () {
				domElement.setStyles({
					pointerEvents: ''
				});
			}, 150);
		});
	},


	/**
  * Shows the widget with the default animation transition.
  *
  * @instance
  * @memberof WidgetPosition
  * @method show
  */
	show: function show() {
		var domNode = _reactDom2.default.findDOMNode(this);
		var uiNode = this.props.editor.get('uiNode');

		var scrollTop = uiNode ? uiNode.scrollTop : 0;

		if (!this.isVisible() && domNode) {
			var interactionPoint = this.getInteractionPoint();

			if (interactionPoint) {
				var domElement = new CKEDITOR.dom.element(domNode);

				var finalX = void 0,
				    finalY = void 0,
				    initialX = void 0,
				    initialY = void 0;

				finalX = initialX = parseFloat(domElement.getStyle('left'));
				finalY = initialY = parseFloat(domElement.getStyle('top'));

				if (this.props.constrainToViewport) {
					var res = this.getConstrainedPosition({
						height: parseFloat(domNode.offsetHeight),
						left: finalX,
						top: finalY,
						width: parseFloat(domNode.offsetWidth)
					});

					finalX = res.x;
					finalY = res.y;
				}

				if (interactionPoint.direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
					initialY = this.props.selectionData.region.bottom + scrollTop;
				} else {
					initialY = this.props.selectionData.region.top + scrollTop;
				}

				this.moveToPoint([initialX, initialY], [finalX, finalY]);
			}
		}
	},


	/**
  * Updates the widget position based on the current interaction point.
  *
  * @instance
  * @memberof WidgetPosition
  * @method updatePosition
  */
	updatePosition: function updatePosition() {
		var interactionPoint = this.getInteractionPoint();

		var domNode = _reactDom2.default.findDOMNode(this);

		if (interactionPoint && domNode) {
			var uiNode = this.props.editor.get('uiNode') || document.body;
			var uiNodeStyle = getComputedStyle(uiNode);
			var uiNodeMarginLeft = parseInt(uiNodeStyle.getPropertyValue('margin-left'), 10);
			var uiNodeMarginRight = parseInt(uiNodeStyle.getPropertyValue('margin-right'), 10);
			var totalWidth = uiNodeMarginLeft + uiNode.clientWidth + uiNodeMarginRight;

			var scrollTop = uiNode.tagName !== 'BODY' ? uiNode.scrollTop : 0;

			var xy = this.getWidgetXYPoint(interactionPoint.x, interactionPoint.y, interactionPoint.direction);
			xy[1] += scrollTop;

			if (xy[0] < 0) {
				xy[0] = 0;
			}
			if (xy[0] > totalWidth - domNode.offsetWidth) {
				xy[0] = totalWidth - domNode.offsetWidth;
			}

			new CKEDITOR.dom.element(domNode).setStyles({
				left: xy[0] + 'px',
				top: xy[1] + 'px'
			});
		}
	},


	/**
  * Requests an animation frame, if possible, to simulate an animation.
  *
  * @instance
  * @memberof WidgetPosition
  * @method _animate
  * @param {Function} callback The function to be executed on the scheduled frame.
  * @protected
  */
	_animate: function _animate(callback) {
		if (window.requestAnimationFrame) {
			this._animationFrameId = window.requestAnimationFrame(callback);
		} else {
			callback();
		}
	}
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = WidgetPosition;

/***/ }),

/***/ "./src/components/main.jsx":
/*!*********************************!*\
  !*** ./src/components/main.jsx ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _editorContext = __webpack_require__(/*! ../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _widgetExclusive = __webpack_require__(/*! ./base/widget-exclusive */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ./base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The main editor UI class manages a hierarchy of widgets (toolbars and buttons).
 *
 * @class UI
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 */
var UI = function (_React$Component) {
	_inherits(UI, _React$Component);

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof UI
  * @method getDefaultProps
  * @return {Object} The default properties.
  */
	function UI(props) {
		_classCallCheck(this, UI);

		var _this = _possibleConstructorReturn(this, (UI.__proto__ || Object.getPrototypeOf(UI)).call(this, props));

		_this._onDismissToolbarFocus = function () {
			var editor = _this.context.editor.get('nativeEditor');

			editor.focus();
		};

		_this.state = {
			hidden: false
		};
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * @instance
  * @memberof UI
  * @method componentDidMount
  */


	_createClass(UI, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _this2 = this;

			var editor = this.context.editor.get('nativeEditor');

			editor.on('editorInteraction', this._onEditorInteraction, this);
			editor.on('actionPerformed', this._onActionPerformed, this);
			editor.on('key', this._onEditorKey, this);

			// Set up events for hiding the UI when user stops interacting with the editor.
			// This may happen when he just clicks outside of the editor. However,
			// this does not include a situation when he clicks on some button, part of
			// editor's UI.

			// It is not easy to debounce _setUIHidden on mousedown, because if we
			// debounce it, when the handler is being invoked, the target might be no more part
			// of the editor's UI - onActionPerformed causes re-render.

			this._mousedownListener = function (event) {
				_this2._setUIHidden(event.target);
			};

			this._keyDownListener = CKEDITOR.tools.debounce(function (_event) {
				_this2._setUIHidden(document.activeElement);
			}, this.props.eventsDelay, this);

			document.addEventListener('mousedown', this._mousedownListener);
			document.addEventListener('keydown', this._keyDownListener);
		}

		/**
   * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
   * Fires `ariaUpdate` event passing ARIA related messages.
   * Fires `editorUpdate` event passing the previous and current properties and state.
   *
   * @instance
   * @memberof UI
   * @method componentDidUpdate
   */

	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps, prevState) {
			var domNode = _reactDom2.default.findDOMNode(this);

			var editor = this.context.editor.get('nativeEditor');

			if (domNode) {
				editor.fire('ariaUpdate', {
					message: this._getAvailableToolbarsMessage(domNode)
				});
			}

			editor.fire('editorUpdate', {
				prevProps: prevProps,
				prevState: prevState,
				props: this.props,
				state: this.state
			});
		}
	}, {
		key: '_getAriaUpdateTemplate',
		value: function _getAriaUpdateTemplate(ariaUpdate) {
			if (!this._ariaUpdateTemplates) {
				this._ariaUpdateTemplates = {};
			}

			if (!this._ariaUpdateTemplates[ariaUpdate]) {
				this._ariaUpdateTemplates[ariaUpdate] = new CKEDITOR.template(this._getAriaUpdates()[ariaUpdate]);
			}

			return this._ariaUpdateTemplates[ariaUpdate];
		}

		/**
   * Returns the templates for ARIA messages.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _getAriaUpdates
   * @return {Object} ARIA relates messages. Default:
   * {
   *      noToolbar: AlloyEditor.Strings.ariaUpdateNoToolbar,
   *      oneToolbar: AlloyEditor.Strings.ariaUpdateOneToolbar,
   *      manyToolbars: AlloyEditor.Strings.ariaUpdateManyToolbars
   *  }
   */

	}, {
		key: '_getAriaUpdates',
		value: function _getAriaUpdates() {
			return this.props.ariaUpdates || {
				noToolbar: AlloyEditor.Strings.ariaUpdateNoToolbar,
				oneToolbar: AlloyEditor.Strings.ariaUpdateOneToolbar,
				manyToolbars: AlloyEditor.Strings.ariaUpdateManyToolbars
			};
		}

		/**
   * Returns an ARIA message which represents the number of currently available toolbars.
   *
   * @instance
   * @memberof UI
   * @method _getAvailableToolbarsMessage
   * @protected
   * @param {CKEDITOR.dom.element} domNode The DOM node from which the available toolbars will be retrieved.
   * @return {String} The ARIA message for the number of available toolbars
   */

	}, {
		key: '_getAvailableToolbarsMessage',
		value: function _getAvailableToolbarsMessage(domNode) {
			var toolbarsNodeList = domNode.querySelectorAll('[role="toolbar"]');

			if (!toolbarsNodeList.length) {
				return this._getAriaUpdates().noToolbar;
			} else {
				var toolbarNames = Array.prototype.slice.call(toolbarsNodeList).map(function (toolbar) {
					return toolbar.getAttribute('aria-label');
				});

				var ariaUpdate = toolbarNames.length === 1 ? 'oneToolbar' : 'manyToolbars';

				return this._getAriaUpdateTemplate(ariaUpdate).output({
					toolbars: toolbarNames.join(',').replace(/,([^,]*)$/, ' and ' + '$1')
				});
			}
		}

		/**
   * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
   *
   * @instance
   * @memberof UI
   * @method componentWillUnmount
   */

	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			if (this._mousedownListener) {
				document.removeEventListener('mousedown', this._mousedownListener);
			}

			if (this._keyDownListener) {
				this._keyDownListener.detach();
				document.removeEventListener('keydown', this._keyDownListener);
			}
		}

		/**
   * Lifecycle. Renders the UI of the editor. This may include several toolbars and buttons.
   * The editor's UI also takes care of rendering the items in exclusive mode.
   *
   * @instance
   * @memberof UI
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var _this3 = this;

			if (this.state.hidden) {
				return null;
			}

			var toolbars = Object.keys(this.props.toolbars).map(function (toolbar) {
				return AlloyEditor.Toolbars[toolbar] || window[toolbar];
			});

			toolbars = this.filterExclusive(toolbars).map(function (toolbar) {
				var props = _this3.mergeExclusiveProps({
					config: _this3.props.toolbars[toolbar.key],
					editor: _this3.context.editor,
					editorEvent: _this3.state.editorEvent,
					key: toolbar.key,
					onDismiss: _this3._onDismissToolbarFocus,
					selectionData: _this3.state.selectionData
				}, toolbar.key);

				return _react2.default.createElement(toolbar, props);
			});

			return _react2.default.createElement(
				'div',
				{ className: 'ae-toolbars', onKeyDown: this.handleKey },
				toolbars
			);
		}

		/**
   * Listener to the editor's `actionPerformed` event. Sets state and redraws the UI of the editor.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _onActionPerformed
   * @param {SynteticEvent} event The provided event
   */

	}, {
		key: '_onActionPerformed',
		value: function _onActionPerformed(_event) {
			var editor = this.context.editor.get('nativeEditor');

			editor.focus();

			this.setState({
				itemExclusive: null,
				selectionData: editor.getSelectionData()
			});
		}

		/**
   * Executed when a dismiss key is pressed over a toolbar to return the focus to the editor.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _onDismissToolbarFocus
   */

	}, {
		key: '_onEditorInteraction',


		/**
   * Listener to the editor's `userInteraction` event. Retrieves the data about the user selection and
   * provides it via component's state property.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _onEditorInteraction
   * @param {SynteticEvent} event The provided event
   */
		value: function _onEditorInteraction(event) {
			this.setState({
				editorEvent: event,
				hidden: false,
				itemExclusive: null,
				selectionData: event.data.selectionData
			});
		}

		/**
   * Focuses on the active toolbar when the combination ALT+F10 is pressed inside the editor.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _onEditorKey
   */

	}, {
		key: '_onEditorKey',
		value: function _onEditorKey(event) {
			var nativeEvent = event.data.domEvent.$;

			if (nativeEvent.altKey && nativeEvent.keyCode === 121) {
				this.focus();
			}
		}

		/**
   * Checks if the target with which the user interacted is part of editor's UI or it is
   * the editable area. If none of these, sets the state of editor's UI to be hidden.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _setUIHidden
   * @param {DOMElement} target The DOM element with which user interacted lastly.
   */

	}, {
		key: '_setUIHidden',
		value: function _setUIHidden(target) {
			var domNode = _reactDom2.default.findDOMNode(this);

			if (domNode) {
				var editable = this.context.editor.get('nativeEditor').editable();
				var parentNode = target.parentNode;
				var targetNode = new CKEDITOR.dom.node(target);

				if (!editable) {
					this.setState({
						hidden: true
					});
				} else {
					var res = editable.$ === target || editable.contains(targetNode) || new CKEDITOR.dom.element(domNode).contains(targetNode);

					if (parentNode) {
						res = res || parentNode.id === 'ckimgrsz';
					}

					if (!res) {
						this.setState({
							hidden: true
						});
					}
				}
			}
		}
	}]);

	return UI;
}(_react2.default.Component);

/**
 * Fired when component updates and when it is rendered in the DOM.
 * The payload consists from a `message` property containing the ARIA message.
 *
 * @event ariaUpdate
 */

/**
 * Fired when component updates. The payload consists from an object with the following
 * properties:
 * - prevProps - The previous properties of the component
 * - prevState - The previous state of the component
 * - props - The current properties of the component
 * - state - The current state of the component
 *
 * @event ariaUpdate
 */

UI.contextType = _editorContext2.default;
UI.defaultProps = {
	circular: true,
	descendants: '[class^=ae-toolbar-]',
	eventsDelay: 0,
	keys: {
		next: 9
	}
};
UI.propTypes = {
	/**
  * Localized messages for live aria updates. Should include the following messages:
  * - noToolbar: Notification for no available toolbar in the editor.
  * - oneToolbar: Notification for just one available toolbar in the editor.
  * - manyToolbars: Notification for more than one available toolbar in the editor.
  *
  * @instance
  * @memberof UI
  * @property {Object} ariaUpdates
  */
	ariaUpdates: _propTypes2.default.object,

	/**
  * The delay (ms), after which key or mouse events will be processed.
  *
  * @instance
  * @memberof UI
  * @property {Number} eventsDelay
  */
	eventsDelay: _propTypes2.default.number,

	/**
  * The toolbars configuration for this editor instance
  *
  * @instance
  * @memberof UI
  * @property {Object} toolbars
  */
	toolbars: _propTypes2.default.object.isRequired
};
exports.default = (0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)(UI));

/***/ }),

/***/ "./src/components/toolbars/index.js":
/*!******************************************!*\
  !*** ./src/components/toolbars/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ToolbarAdd$key$Toolb;

var _toolbarAdd = __webpack_require__(/*! ./toolbar-add.jsx */ "./src/components/toolbars/toolbar-add.jsx");

var _toolbarAdd2 = _interopRequireDefault(_toolbarAdd);

var _toolbarStyles = __webpack_require__(/*! ./toolbar-styles.jsx */ "./src/components/toolbars/toolbar-styles.jsx");

var _toolbarStyles2 = _interopRequireDefault(_toolbarStyles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**
                                                                                                                                                                                                                   * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                   * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                   */

exports.default = (_ToolbarAdd$key$Toolb = {}, _defineProperty(_ToolbarAdd$key$Toolb, _toolbarAdd2.default.key, _toolbarAdd2.default), _defineProperty(_ToolbarAdd$key$Toolb, _toolbarStyles2.default.key, _toolbarStyles2.default), _ToolbarAdd$key$Toolb);

/***/ }),

/***/ "./src/components/toolbars/toolbar-add.jsx":
/*!*************************************************!*\
  !*** ./src/components/toolbars/toolbar-add.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _toolbarButtons = __webpack_require__(/*! ../base/toolbar-buttons */ "./src/components/base/toolbar-buttons.js");

var _toolbarButtons2 = _interopRequireDefault(_toolbarButtons);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetExclusive = __webpack_require__(/*! ../base/widget-exclusive */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _buttonIcon = __webpack_require__(/*! ../buttons/button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var POSITION_LEFT = 1;
var POSITION_RIGHT = 2;

/**
 * The ToolbarAdd class provides functionality for adding content to the editor.
 *
 * @class ToolbarAdd
 * @uses ToolbarButtons
 * @uses WidgetDropdown
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 */

var ToolbarAdd = function (_React$Component) {
	_inherits(ToolbarAdd, _React$Component);

	function ToolbarAdd(props) {
		_classCallCheck(this, ToolbarAdd);

		var _this = _possibleConstructorReturn(this, (ToolbarAdd.__proto__ || Object.getPrototypeOf(ToolbarAdd)).call(this, props));

		_this.state = {};
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client (not on the server),
  * immediately after the initial rendering occurs.
  *
  * @instance
  * @memberof ToolbarAdd
  * @method componentDidMount
  */


	_createClass(ToolbarAdd, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this._updatePosition();
		}

		/**
   * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ToolbarAdd
   * @method componentDidUpdate
   * @param {Object} prevProps The previous state of the component's properties.
   * @param {Object} prevState Component's previous state.
   */

	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(_prevProps, _prevState) {
			this._updatePosition();

			// In case of exclusive rendering, focus the first descendant (button)
			// so the user will be able to start interacting with the buttons immediately.

			if (this.props.renderExclusive) {
				this.focus();
			}
		}

		/**
   * Lifecycle. Renders the buttons for adding content or hides the toolbar
   * if user interacted with a non-editable element.
   *
   * @instance
   * @memberof ToolbarAdd
   * @method render
   * @return {Object|null} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			// Some operations such as `requestExclusive` may force editor to blur which will
			// invalidate the `props.editorEvent` stored value, without causing a `props` change.
			// For example, if the editor is empty, `ae_placeholder` plugin will remove
			// the target from the DOM and will prevent `add` toolbar from rendering.
			//
			// It should be safe to assume that if you have been able to render the toolbar
			// and request the exclusive mode, then rendering might be kept until the exclusive mode is left.

			if (!this.state.itemExclusive && this.props.editorEvent && this.props.editorEvent.data.nativeEvent.target && !this.props.editorEvent.data.nativeEvent.target.isContentEditable) {
				return null;
			}

			var buttons = this._getButtons();
			var className = this._getToolbarClassName();

			return _react2.default.createElement(
				'div',
				{
					'aria-label': AlloyEditor.Strings.add,
					className: className,
					'data-tabindex': this.props.config.tabIndex || 0,
					onFocus: this.focus.bind(this),
					onKeyDown: this.handleKey.bind(this),
					role: 'toolbar',
					tabIndex: '-1' },
				_react2.default.createElement(
					'div',
					{ className: 'ae-container' },
					buttons
				)
			);
		}

		/**
   * Returns a list of buttons that will eventually render to HTML.
   *
   * @instance
   * @memberof ToolbarAdd
   * @method _getButtons
   * @protected
   * @return {Object} The buttons which have to be rendered.
   */

	}, {
		key: '_getButtons',
		value: function _getButtons() {
			var buttons = void 0;

			if (this.props.renderExclusive) {
				buttons = this.getToolbarButtons(this.props.config.buttons);
			} else {
				if (this.props.selectionData && this.props.selectionData.region) {
					buttons = _react2.default.createElement(
						'button',
						{
							'aria-label': AlloyEditor.Strings.add,
							className: 'ae-button ae-button-add',
							onClick: this.props.requestExclusive.bind(this, ToolbarAdd.key),
							title: AlloyEditor.Strings.add },
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'plus' })
					);
				}
			}

			return buttons;
		}

		/**
   * Returns the class name of the toolbar in case of both exclusive and normal mode.
   *
   * @instance
   * @memberof ToolbarAdd
   * @method _getToolbarClassName
   * @protected
   * @return {String} The class name which have to be applied to the DOM element.
   */

	}, {
		key: '_getToolbarClassName',
		value: function _getToolbarClassName() {
			var cssClass = 'ae-toolbar-add';

			if (this.props.renderExclusive) {
				cssClass = 'ae-toolbar ' + this.getArrowBoxClasses();
			}

			return cssClass;
		}

		/**
   * Calculates and sets the position of the toolbar in exclusive or normal mode.
   *
   * @instance
   * @memberof ToolbarAdd
   * @method _updatePosition
   * @protected
   */

	}, {
		key: '_updatePosition',
		value: function _updatePosition() {
			var region = void 0;

			// If component is not mounted, there is nothing to do

			if (!_reactDom2.default.findDOMNode(this)) {
				return;
			}

			if (this.props.renderExclusive) {
				this.updatePosition();
				this.show();
			} else {
				if (this.props.selectionData) {
					region = this.props.selectionData.region;
				}

				if (region) {
					var domNode = _reactDom2.default.findDOMNode(this);

					var domElement = new CKEDITOR.dom.element(domNode);

					var startRect = region.startRect || region;

					var nativeEditor = this.context.editor.get('nativeEditor');

					var clientRect = nativeEditor.editable().getClientRect();

					var offsetLeft = void 0;

					var position = this.props.config.position || this.props.position;

					if (position === POSITION_LEFT) {
						offsetLeft = clientRect.left - domNode.offsetWidth - this.props.gutterExclusive.left + 'px';
					} else {
						offsetLeft = clientRect.right + this.props.gutterExclusive.left + 'px';
					}

					domNode.style.left = offsetLeft;

					domNode.style.top = Math.floor((region.bottom + region.top) / 2) + 'px';

					var uiNode = this.context.editor.get('uiNode');

					var scrollTop = uiNode ? uiNode.scrollTop : 0;

					if (nativeEditor.element.getStyle('overflow') !== 'auto') {
						domNode.style.top = Math.floor(region.top - domNode.offsetHeight / 2 + startRect.height / 2 + scrollTop) + 'px';
					} else {
						domNode.style.top = Math.floor(nativeEditor.element.$.offsetTop + startRect.height / 2 - domNode.offsetHeight / 2) + 'px';
					}

					domNode.style.opacity = 1;

					domElement.removeClass('ae-arrow-box');

					this.cancelAnimation();
				}
			}
		}
	}]);

	return ToolbarAdd;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default add
 * @memberof ToolbarAdd
 * @property {String} key
 * @static
 */


ToolbarAdd.contextType = _editorContext2.default;
ToolbarAdd.key = 'add';

/**
 * Defines the constant for positioning the Toolbar on left of the editable area.
 *
 * @default 1
 * @memberof ToolbarAdd
 * @property {String} left
 * @static
 */
ToolbarAdd.left = POSITION_LEFT;

/**
 * Defines the constant for positioning the Toolbar on right of the editable area.
 *
 * @default 2
 * @memberof ToolbarAdd
 * @property {String} right
 * @static
 */
ToolbarAdd.right = POSITION_RIGHT;

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ToolbarAdd
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ToolbarAdd.defaultProps = {
	circular: true,
	descendants: '.ae-button',
	gutterExclusive: {
		left: 10,
		top: 0
	},
	keys: {
		dismiss: [27],
		next: [39, 40],
		prev: [37, 38]
	},
	position: POSITION_LEFT
};

exports.default = (0, _widgetDropdown2.default)((0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)((0, _toolbarButtons2.default)(ToolbarAdd))));

/***/ }),

/***/ "./src/components/toolbars/toolbar-styles.jsx":
/*!****************************************************!*\
  !*** ./src/components/toolbars/toolbar-styles.jsx ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _toolbarButtons = __webpack_require__(/*! ../base/toolbar-buttons */ "./src/components/base/toolbar-buttons.js");

var _toolbarButtons2 = _interopRequireDefault(_toolbarButtons);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetExclusive = __webpack_require__(/*! ../base/widget-exclusive */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/**
 * The ToolbarStyles class hosts the buttons for styling a text selection.
 *
 * @class ToolbarStyles
 * @uses ToolbarButtons
 * @uses WidgetDropdown
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 */
var ToolbarStyles = function (_React$Component) {
	_inherits(ToolbarStyles, _React$Component);

	function ToolbarStyles(props) {
		_classCallCheck(this, ToolbarStyles);

		var _this = _possibleConstructorReturn(this, (ToolbarStyles.__proto__ || Object.getPrototypeOf(ToolbarStyles)).call(this, props));

		_this.state = {};
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client (not on the server),
  * immediately after the initial rendering occurs.
  *
  * @instance
  * @memberof ToolbarStyles
  * @method componentDidMount
  */


	_createClass(ToolbarStyles, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this._updatePosition();
		}

		/**
   * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ToolbarStyles
   * @method componentDidUpdate
   * @param {Object} prevProps The previous state of the component's properties.
   * @param {Object} prevState Component's previous state.
   */

	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(_prevProps, _prevState) {
			this._updatePosition();
		}

		/**
   * Lifecycle. Renders the buttons for adding content or hides the toolbar
   * if user interacted with a non-editable element.
   *
   * @instance
   * @memberof ToolbarStyles
   * @method render
   * @return {Object|null} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var currentSelection = this._getCurrentSelection();

			if (currentSelection) {
				var getArrowBoxClassesFn = this._getSelectionFunction(currentSelection.getArrowBoxClasses);
				var arrowBoxClasses = void 0;

				if (getArrowBoxClassesFn) {
					arrowBoxClasses = getArrowBoxClassesFn();
				} else {
					arrowBoxClasses = this.getArrowBoxClasses();
				}

				var cssClasses = 'ae-toolbar-styles ' + arrowBoxClasses;

				var buttons = currentSelection.buttons;

				if ((typeof buttons === 'undefined' ? 'undefined' : _typeof(buttons)) === 'object' && !Array.isArray(buttons)) {
					buttons = buttons[this.context.editor.get('mode')] || buttons['simple'];
				}

				var buttonsGroup = this.getToolbarButtonGroups(buttons, {
					manualSelection: this.props.editorEvent ? this.props.editorEvent.data.manualSelection : null,
					selectionType: currentSelection.name
				});

				var hasGroups = buttonsGroup.filter(function (button) {
					return Array.isArray(button);
				}).length > 0;

				var className = 'ae-container';

				if (hasGroups) {
					className += ' ae-container-column';
				}

				return _react2.default.createElement(
					'div',
					{
						'aria-label': AlloyEditor.Strings.styles,
						className: cssClasses,
						'data-tabindex': this.props.config.tabIndex || 0,
						onFocus: this.focus.bind(this),
						onKeyDown: this.handleKey.bind(this),
						role: 'toolbar',
						tabIndex: '-1' },
					_react2.default.createElement(
						'div',
						{ className: className },
						buttonsGroup.map(function (value, index) {
							if (Array.isArray(value)) {
								return _react2.default.createElement(
									'div',
									{ className: 'ae-row', key: index },
									value.map(function (button) {
										return button;
									})
								);
							} else {
								return value;
							}
						})
					)
				);
			}

			return null;
		}

		/**
   * Retrieve a function from String. It converts a fully qualified string into the mapped function.
   *
   * @instance
   * @memberof ToolbarStyles
   * @method _getSelectionFunction
   * @param {Function|String} selectionFn A function, or a fully qualified string pointing to the desired one (e.g. 'AlloyEditor.SelectionTest.image').
   * @protected
   * @return {Function} The mapped function.
   */

	}, {
		key: '_getSelectionFunction',
		value: function _getSelectionFunction(selectionFn) {
			var selectionFunction = void 0;

			if (_lang2.default.isFunction(selectionFn)) {
				selectionFunction = selectionFn;
			} else if (_lang2.default.isString(selectionFn)) {
				var parts = selectionFn.split('.');
				var currentMember = window;
				var property = parts.shift();

				while (property && _lang2.default.isObject(currentMember) && _lang2.default.isObject(currentMember[property])) {
					currentMember = currentMember[property];
					property = parts.shift();
				}

				if (_lang2.default.isFunction(currentMember)) {
					selectionFunction = currentMember;
				}
			}

			return selectionFunction;
		}

		/**
   * Analyzes the current editor selection and returns the selection configuration that matches.
   *
   * @instance
   * @memberof ToolbarStyles
   * @method _getCurrentSelection
   * @protected
   * @return {Object} The matched selection configuration.
   */

	}, {
		key: '_getCurrentSelection',
		value: function _getCurrentSelection() {
			var eventPayload = this.props.editorEvent ? this.props.editorEvent.data : null;
			var selection = void 0;

			if (eventPayload) {
				this.props.config.selections.some(function (item) {
					var testFn = this._getSelectionFunction(item.test);
					var result = void 0;

					if (testFn) {
						result = eventPayload.manualSelection === item.name || testFn({
							data: eventPayload,
							editor: this.context.editor
						});
					}

					if (result) {
						selection = item;
					}

					return result;
				}, this);
			}

			return selection;
		}

		/**
   * Calculates and sets the position of the toolbar.
   *
   * @instance
   * @memberof ToolbarStyles
   * @method _updatePosition
   * @protected
   */

	}, {
		key: '_updatePosition',
		value: function _updatePosition() {
			// If component is not mounted, there is nothing to do

			if (!_reactDom2.default.findDOMNode(this)) {
				return;
			}

			var currentSelection = this._getCurrentSelection();
			var result = void 0;

			// If current selection has a function called `setPosition`, call it
			// and check the returned value. If false, fallback to the default positioning logic.

			if (currentSelection) {
				var setPositionFn = this._getSelectionFunction(currentSelection.setPosition);

				if (setPositionFn) {
					result = setPositionFn.call(this, {
						editor: this.context.editor,
						editorEvent: this.props.editorEvent,
						selectionData: this.props.selectionData
					});
				}
			}

			if (!result) {
				this.updatePosition();
				this.show();
			}
		}
	}]);

	return ToolbarStyles;
}(_react2.default.Component);

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ToolbarStyles
 * @method getDefaultProps
 * @return {Object} The default properties.
 */


ToolbarStyles.contextType = _editorContext2.default;
ToolbarStyles.defaultProps = {
	circular: true,
	descendants: '.ae-input, .ae-button:not([disabled]), .ae-toolbar-element',
	keys: {
		dismiss: [27],
		next: [39, 40],
		prev: [37, 38]
	}
};

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default styles
 * @memberof ToolbarStyles
 * @property {String} key
 * @static
 */
ToolbarStyles.key = 'styles';

exports.default = (0, _widgetDropdown2.default)((0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)((0, _toolbarButtons2.default)(ToolbarStyles))));

/***/ }),

/***/ "./src/components/uibridge/button.jsx":
/*!********************************************!*\
  !*** ./src/components/uibridge/button.jsx ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_buttonbridge')) {
	var BUTTON_DEFS = {};

	/**
  * Generates a ButtonBridge React class for a given button definition if it has not been
  * already created based on the button name and definition.
  *
  * @private
  * @method generateButtonBridge
  * @param {String} buttonName The button's name
  * @param {Object} buttonDefinition The button's definition
  * @return {Object} The generated or already existing React Button Class
  */

	function generateButtonBridge(buttonName, buttonDefinition, editor) {
		var ButtonBridge = AlloyEditor.Buttons[buttonName];

		BUTTON_DEFS[editor.name] = BUTTON_DEFS[editor.name] || {};
		BUTTON_DEFS[editor.name][buttonName] = BUTTON_DEFS[editor.name][buttonName] || buttonDefinition;

		if (!ButtonBridge) {
			var _class, _temp2;

			ButtonBridge = (_temp2 = _class = function (_React$Component) {
				_inherits(ButtonBridge, _React$Component);

				function ButtonBridge() {
					var _ref;

					var _temp, _this, _ret;

					_classCallCheck(this, ButtonBridge);

					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}

					return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonBridge.__proto__ || Object.getPrototypeOf(ButtonBridge)).call.apply(_ref, [this].concat(args))), _this), _this._handleClick = function () {
						var editor = _this.context.editor.get('nativeEditor');

						var buttonCommand = BUTTON_DEFS[editor.name][buttonName].command;

						var buttonOnClick = BUTTON_DEFS[editor.name][buttonName].onClick;

						if (buttonOnClick) {
							buttonOnClick.call(_this);
						} else {
							editor.execCommand(buttonCommand);
						}

						editor.fire('actionPerformed', _this);
					}, _temp), _possibleConstructorReturn(_this, _ret);
				}

				_createClass(ButtonBridge, [{
					key: 'toFeature',


					// API not yet implemented inside the button
					// bridge. By mocking the unsupported method, we prevent
					// plugins from crashing if they make use of it.

					value: function toFeature() {}
				}, {
					key: 'render',
					value: function render() {
						var editor = this.context.editor.get('nativeEditor');

						var buttonClassName = 'ae-button ae-button-bridge';

						var buttonDisplayName = BUTTON_DEFS[editor.name][buttonName].name || BUTTON_DEFS[editor.name][buttonName].command || buttonName;

						var buttonLabel = BUTTON_DEFS[editor.name][buttonName].label;

						var buttonType = 'button-' + buttonDisplayName;

						var iconClassName = 'ae-icon-' + buttonDisplayName;

						var iconStyle = {};

						var cssStyle = CKEDITOR.skin.getIconStyle(buttonDisplayName);

						if (cssStyle) {
							var cssStyleParts = cssStyle.split(';');

							iconStyle.backgroundImage = cssStyleParts[0].substring(cssStyleParts[0].indexOf(':') + 1);
							iconStyle.backgroundPosition = cssStyleParts[1].substring(cssStyleParts[1].indexOf(':') + 1);
							iconStyle.backgroundSize = cssStyleParts[2].substring(cssStyleParts[2].indexOf(':') + 1);
						}

						return _react2.default.createElement(
							'button',
							{
								'aria-label': buttonLabel,
								className: buttonClassName,
								'data-type': buttonType,
								onClick: this._handleClick,
								tabIndex: this.props.tabIndex,
								title: buttonLabel },
							_react2.default.createElement('span', { className: iconClassName, style: iconStyle })
						);
					}
				}]);

				return ButtonBridge;
			}(_react2.default.Component), _class.contextType = _editorContext2.default, _class.displayName = buttonName, _class.key = buttonName, _temp2);

			AlloyEditor.Buttons[buttonName] = ButtonBridge;
		}

		return ButtonBridge;
	}

	/* istanbul ignore else */
	if (!CKEDITOR.plugins.get('button')) {
		CKEDITOR.UI_BUTTON = 'button';

		CKEDITOR.plugins.add('button', {});
	}

	/**
  * CKEditor plugin that bridges the support offered by CKEditor Button plugin. It takes over the
  * responsibility of registering and creating buttons via:
  * - editor.ui.addButton(name, definition)
  * - editor.ui.add(name, CKEDITOR.UI_BUTTON, definition)
  *
  * @class CKEDITOR.plugins.ae_buttonbridge
  * @requires CKEDITOR.plugins.ae_uibridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_buttonbridge', {
		requires: ['ae_uibridge'],

		/**
   * Set the add handler for UI_BUTTON to our own. We do this in the init phase to override
   * the one in the native plugin in case it's present.
   *
   * @method init
   * @param {Object} editor The CKEditor instance being initialized
   */
		beforeInit: function beforeInit(editor) {
			BUTTON_DEFS[editor.name] = {};

			editor.ui.addButton = function (buttonName, buttonDefinition) {
				this.add(buttonName, CKEDITOR.UI_BUTTON, buttonDefinition);
			};

			editor.ui.addHandler(CKEDITOR.UI_BUTTON, {
				add: generateButtonBridge,
				create: function create(buttonDefinition) {
					var buttonName = 'buttonBridge' + (Math.random() * 1e9 >>> 0);
					var ButtonBridge = generateButtonBridge(buttonName, buttonDefinition);

					return new ButtonBridge();
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/components/uibridge/index.js":
/*!******************************************!*\
  !*** ./src/components/uibridge/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./button.jsx */ "./src/components/uibridge/button.jsx");

__webpack_require__(/*! ./menu-button.jsx */ "./src/components/uibridge/menu-button.jsx");

__webpack_require__(/*! ./menu.jsx */ "./src/components/uibridge/menu.jsx");

__webpack_require__(/*! ./panel-menu-button.jsx */ "./src/components/uibridge/panel-menu-button.jsx");

__webpack_require__(/*! ./richcombo.jsx */ "./src/components/uibridge/richcombo.jsx");

__webpack_require__(/*! ./uibridge */ "./src/components/uibridge/uibridge.js");

/***/ }),

/***/ "./src/components/uibridge/menu-button.jsx":
/*!*************************************************!*\
  !*** ./src/components/uibridge/menu-button.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonDropdown = __webpack_require__(/*! ../buttons/button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_menubuttonbridge')) {
	var MENUBUTTON_DEFS = {};

	/**
  * Generates a MenuButtonBridge React class for a given menuButton definition if it has not been
  * already created based on the button name and definition.
  *
  * @private
  * @method generateMenuButtonBridge
  * @param {String} menuButtonName The menuButton's name
  * @param {Object} menuButtonDefinition The menuButton's definition
  * @return {Object} The generated or already existing React MenuButton Class
  */
	function generateMenuButtonBridge(menuButtonName, menuButtonDefinition, editor) {
		var MenuButtonBridge = AlloyEditor.Buttons[menuButtonName];

		MENUBUTTON_DEFS[editor.name] = MENUBUTTON_DEFS[editor.name] || {};
		MENUBUTTON_DEFS[editor.name][menuButtonName] = MENUBUTTON_DEFS[editor.name][menuButtonName] || menuButtonDefinition;

		if (!MenuButtonBridge) {
			var _class, _temp;

			MenuButtonBridge = (_temp = _class = function (_React$Component) {
				_inherits(MenuButtonBridge, _React$Component);

				function MenuButtonBridge() {
					_classCallCheck(this, MenuButtonBridge);

					return _possibleConstructorReturn(this, (MenuButtonBridge.__proto__ || Object.getPrototypeOf(MenuButtonBridge)).apply(this, arguments));
				}

				_createClass(MenuButtonBridge, [{
					key: 'toFeature',


					// API not yet implemented inside the menubutton
					// bridge. By mocking the unsupported method, we prevent
					// plugins from crashing if they make use of it.

					value: function toFeature() {}
				}, {
					key: 'render',
					value: function render() {
						var editor = this.context.editor.get('nativeEditor');

						var panelMenuButtonDisplayName = MENUBUTTON_DEFS[editor.name][menuButtonName].name || MENUBUTTON_DEFS[editor.name][menuButtonName].command || menuButtonName;

						var buttonClassName = 'ae-button ae-button-bridge';

						var iconClassName = 'ae-icon-' + panelMenuButtonDisplayName;

						var iconStyle = {};

						var cssStyle = CKEDITOR.skin.getIconStyle(panelMenuButtonDisplayName);

						if (cssStyle) {
							var cssStyleParts = cssStyle.split(';');

							iconStyle.backgroundImage = cssStyleParts[0].substring(cssStyleParts[0].indexOf(':') + 1);
							iconStyle.backgroundPosition = cssStyleParts[1].substring(cssStyleParts[1].indexOf(':') + 1);
							iconStyle.backgroundSize = cssStyleParts[2].substring(cssStyleParts[2].indexOf(':') + 1);
						}

						return _react2.default.createElement(
							'div',
							{ className: 'ae-container ae-has-dropdown' },
							_react2.default.createElement(
								'button',
								{
									'aria-expanded': this.props.expanded,
									'aria-label': MENUBUTTON_DEFS[editor.name][menuButtonName].label,
									className: buttonClassName,
									onClick: this.props.toggleDropdown,
									role: 'combobox',
									tabIndex: this.props.tabIndex,
									title: MENUBUTTON_DEFS[editor.name][menuButtonName].label },
								_react2.default.createElement('span', {
									className: iconClassName,
									style: iconStyle
								})
							),
							this.props.expanded && _react2.default.createElement(
								_buttonDropdown2.default,
								{
									onDismiss: this.props.toggleDropdown },
								this._getMenuItems()
							)
						);
					}
				}, {
					key: '_getMenuItems',
					value: function _getMenuItems() {
						var editor = this.context.editor.get('nativeEditor');
						var items = menuButtonDefinition.onMenu();
						var menuItems = Object.keys(items).map(function (key) {
							var menuItem = editor.getMenuItem(key);

							if (!menuItem) {
								return null;
							}

							var menuItemDefinition = menuItem.definition || menuItem;
							var menuItemState = items[key];

							var className = 'ae-toolbar-element ' + (menuItemState === CKEDITOR.TRISTATE_ON ? 'active' : '');
							var disabled = menuItemState === CKEDITOR.TRISTATE_DISABLED;
							var onClick = function onClick() {
								if (menuItemDefinition.command) {
									editor.execCommand(menuItemDefinition.command);
								} else if (menuItemDefinition.onClick) {
									menuItemDefinition.onClick.apply(menuItemDefinition);
								}
							};

							return _react2.default.createElement(
								'li',
								{ key: menuItem.name, role: 'option' },
								_react2.default.createElement(
									'button',
									{
										className: className,
										disabled: disabled,
										onClick: onClick },
									menuItemDefinition.label
								)
							);
						});

						return menuItems;
					}
				}]);

				return MenuButtonBridge;
			}(_react2.default.Component), _class.contextType = _editorContext2.default, _class.displayName = menuButtonName, _class.key = menuButtonName, _temp);

			AlloyEditor.Buttons[menuButtonName] = MenuButtonBridge;
		}

		return MenuButtonBridge;
	}

	/* istanbul ignore else */
	if (!CKEDITOR.plugins.get('menubutton')) {
		CKEDITOR.UI_MENU_BUTTON = 'menubutton';

		CKEDITOR.plugins.add('menubutton', {});
	}

	/**
  * CKEditor plugin that bridges the support offered by CKEditor MenuButton plugin. It takes over the
  * responsibility of registering and creating menuButtons via:
  * - editor.ui.addMenuButton(name, definition)
  * - editor.ui.add(name, CKEDITOR.UI_MENUBUTTON, definition)
  *
  * @class CKEDITOR.plugins.ae_menubuttonbridge
  * @requires CKEDITOR.plugins.ae_uibridge
  * @requires CKEDITOR.plugins.ae_menubridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_menubuttonbridge', {
		requires: ['ae_uibridge', 'ae_menubridge'],

		/**
   * Set the add handler for UI_MENUBUTTON to our own. We do this in the init phase to override
   * the one in the native plugin in case it's present.
   *
   * @method init
   * @param {Object} editor The CKEditor instance being initialized
   */
		beforeInit: function beforeInit(editor) {
			MENUBUTTON_DEFS[editor.name] = {};

			editor.ui.addMenuButton = function (menuButtonName, menuButtonDefinition) {
				this.add(menuButtonName, CKEDITOR.UI_MENUBUTTON, menuButtonDefinition);
			};

			editor.ui.addHandler(CKEDITOR.UI_MENUBUTTON, {
				add: generateMenuButtonBridge,
				create: function create(menuButtonDefinition) {
					var menuButtonName = 'buttonBridge' + (Math.random() * 1e9 >>> 0);
					var MenuButtonBridge = generateMenuButtonBridge(menuButtonName, menuButtonDefinition);

					return new MenuButtonBridge();
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/components/uibridge/menu.jsx":
/*!******************************************!*\
  !*** ./src/components/uibridge/menu.jsx ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_menubridge')) {
	/**
  * CKEditor plugin that bridges the support offered by CKEditor Menu plugin. It takes over the
  * responsibility of adding, removing and retrieving menu groups and items
  * - editor.addMenuGroup(name, order)
  * - editor.addMenuItem(name, definition)
  * - editor.addMenuItems(definitions)
  * - editor.getMenuItem(name)
  * - editor.removeMenuItem(name)
  *
  * @class CKEDITOR.plugins.ae_menubridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_menubridge', {
		/**
   * Set the add handler for UI_BUTTON to our own. We do this in the init phase to override
   * the one in the native plugin in case it's present.
   *
   * @method init
   * @param {Object} editor The CKEditor instance being initialized
   */
		beforeInit: function beforeInit(editor) {
			// Do nothing if the real menu plugin is present

			if (CKEDITOR.plugins.get('menu')) {
				return;
			}

			var groups = [];
			var groupsOrder = editor._.menuGroups = {};
			var menuItems = editor._.menuItems = {};

			for (var i = 0; i < groups.length; i++) {
				groupsOrder[groups[i]] = i + 1;
			}

			/**
    * Registers an item group to the editor context menu in order to make it
    * possible to associate it with menu items later.
    *
    * @method addMenuGroup
    * @param {String} name Specify a group name.
    * @param {Number} [order=100] Define the display sequence of this group
    * inside the menu. A smaller value gets displayed first.
    */
			editor.addMenuGroup = function (name, order) {
				groupsOrder[name] = order || 100;
			};

			/**
    * Adds an item from the specified definition to the editor context menu.
    *
    * @method addMenuItem
    * @param {String} name The menu item name.
    * @param {Object} definition The menu item definition.
    */
			editor.addMenuItem = function (name, definition) {
				if (groupsOrder[definition.group]) {
					menuItems[name] = {
						name: name,
						definition: definition
					};
				}
			};

			/**
    * Adds one or more items from the specified definition object to the editor context menu.
    *
    * @method addMenuItems
    * @param {Object} definitions Object where keys are used as itemName and corresponding values as definition for a {@link #addMenuItem} call.
    */
			editor.addMenuItems = function (definitions) {
				for (var itemName in definitions) {
					if (Object.prototype.hasOwnProperty.call(definitions, itemName)) {
						this.addMenuItem(itemName, definitions[itemName]);
					}
				}
			};

			/**
    * Retrieves a particular menu item definition from the editor context menu.
    *
    * @method getMenuItem
    * @param {String} name The name of the desired menu item.
    * @return {Object}
    */
			editor.getMenuItem = function (name) {
				return menuItems[name];
			};

			/**
    * Removes a particular menu item added before from the editor context menu.
    *
    * @method  removeMenuItem
    * @param {String} name The name of the desired menu item.
    */
			editor.removeMenuItem = function (name) {
				delete menuItems[name];
			};
		}
	});
}

/***/ }),

/***/ "./src/components/uibridge/panel-menu-button.jsx":
/*!*******************************************************!*\
  !*** ./src/components/uibridge/panel-menu-button.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonDropdown = __webpack_require__(/*! ../buttons/button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_panelmenubuttonbridge')) {
	var PANEL_MENU_DEFS = {};

	/**
  * Generates a PanelMenuButtonBridge React class for a given panelmenubutton definition if it has not been
  * already created based on the panelmenubutton name and definition.
  *
  * @private
  * @method generatePanelMenuButtonBridge
  * @param {String} panelMenuButtonName The panel button name
  * @param {Object} panelMenuButtonDefinition The panel button definition
  * @return {Object} The generated or already existing React PanelMenuButton Class
  */
	var generatePanelMenuButtonBridge = function generatePanelMenuButtonBridge(panelMenuButtonName, panelMenuButtonDefinition, editor) {
		var PanelMenuButtonBridge = AlloyEditor.Buttons[panelMenuButtonName];

		PANEL_MENU_DEFS[editor.name] = PANEL_MENU_DEFS[editor.name] || {};
		PANEL_MENU_DEFS[editor.name][panelMenuButtonName] = PANEL_MENU_DEFS[editor.name][panelMenuButtonName] || panelMenuButtonDefinition;

		if (!PanelMenuButtonBridge) {
			var _class, _temp;

			PanelMenuButtonBridge = (_temp = _class = function (_React$Component) {
				_inherits(PanelMenuButtonBridge, _React$Component);

				function PanelMenuButtonBridge() {
					_classCallCheck(this, PanelMenuButtonBridge);

					return _possibleConstructorReturn(this, (PanelMenuButtonBridge.__proto__ || Object.getPrototypeOf(PanelMenuButtonBridge)).apply(this, arguments));
				}

				_createClass(PanelMenuButtonBridge, [{
					key: 'createPanel',


					// API not yet implemented inside the panel menu button bridge. By mocking the unsupported methods, we
					// prevent plugins from crashing if they make use of them.

					value: function createPanel() {}
				}, {
					key: 'render',
					value: function render() {
						var editor = this.context.editor.get('nativeEditor');

						var panelMenuButtonDisplayName = PANEL_MENU_DEFS[editor.name][panelMenuButtonName].name || PANEL_MENU_DEFS[editor.name][panelMenuButtonName].command || panelMenuButtonName;

						var buttonClassName = 'ae-button ae-button-bridge';

						var iconClassName = 'ae-icon-' + panelMenuButtonDisplayName;

						var iconStyle = {};

						var cssStyle = CKEDITOR.skin.getIconStyle(panelMenuButtonDisplayName);

						if (cssStyle) {
							var cssStyleParts = cssStyle.split(';');

							iconStyle.backgroundImage = cssStyleParts[0].substring(cssStyleParts[0].indexOf(':') + 1);
							iconStyle.backgroundPosition = cssStyleParts[1].substring(cssStyleParts[1].indexOf(':') + 1);
							iconStyle.backgroundSize = cssStyleParts[2].substring(cssStyleParts[2].indexOf(':') + 1);
						}

						var panel = void 0;

						if (this.props.expanded) {
							panel = this._getPanel();
						}

						return _react2.default.createElement(
							'div',
							{ className: 'ae-container ae-has-dropdown' },
							_react2.default.createElement(
								'button',
								{
									'aria-expanded': this.props.expanded,
									'aria-label': PANEL_MENU_DEFS[editor.name][panelMenuButtonName].label,
									className: buttonClassName,
									onClick: this.props.toggleDropdown,
									role: 'combobox',
									tabIndex: this.props.tabIndex,
									title: PANEL_MENU_DEFS[editor.name][panelMenuButtonName].label },
								_react2.default.createElement('span', {
									className: iconClassName,
									style: iconStyle
								})
							),
							panel
						);
					}
				}, {
					key: '_getPanel',
					value: function _getPanel() {
						var editor = this.context.editor.get('nativeEditor');

						var panelMenuButtonOnBlock = PANEL_MENU_DEFS[editor.name][panelMenuButtonName].onBlock;

						var panel = {
							hide: this.props.toggleDropdown,
							show: this.props.toggleDropdown
						};

						var blockElement = new CKEDITOR.dom.element('div');

						var block = {
							element: blockElement,
							keys: {}
						};

						/* istanbul ignore else */
						if (panelMenuButtonOnBlock) {
							panelMenuButtonOnBlock.call(this, panel, block);
						}

						// TODO
						// Use block.keys to configure the panel keyboard navigation

						return _react2.default.createElement(
							_buttonDropdown2.default,
							{ onDismiss: this.props.toggleDropdown },
							_react2.default.createElement('div', {
								className: blockElement.getAttribute('class'),
								dangerouslySetInnerHTML: {
									__html: blockElement.getHtml()
								}
							})
						);
					}
				}]);

				return PanelMenuButtonBridge;
			}(_react2.default.Component), _class.contextType = _editorContext2.default, _class.displayName = panelMenuButtonName, _class.key = panelMenuButtonName, _temp);

			AlloyEditor.Buttons[panelMenuButtonName] = PanelMenuButtonBridge;
		}

		return PanelMenuButtonBridge;
	};

	/* istanbul ignore else */
	if (!CKEDITOR.plugins.get('panelmenubutton')) {
		CKEDITOR.UI_PANELBUTTON = 'panelmenubutton';

		CKEDITOR.plugins.add('panelmenubutton', {});
	}

	/* istanbul ignore else */
	if (!CKEDITOR.plugins.get('panelbutton')) {
		CKEDITOR.UI_PANELBUTTON = 'panelbutton';

		CKEDITOR.plugins.add('panelbutton', {});
	}

	/**
  * CKEditor plugin that bridges the support offered by CKEditor PanelButton plugin. It takes over the
  * responsibility of registering and creating buttons via:
  * - editor.ui.addPanelMenuButton(name, definition)
  * - editor.ui.add(name, CKEDITOR.UI_PANELBUTTON, definition)
  *
  * @class CKEDITOR.plugins.ae_panelmenubuttonbridge
  * @requires CKEDITOR.plugins.ae_uibridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_panelmenubuttonbridge', {
		requires: ['ae_uibridge'],

		/**
   * Set the add handler for UI_PANELBUTTON to our own. We do this in the init phase to override
   * the one in the native plugin in case it's present
   *
   * @method init
   * @param {Object} editor The CKEditor instance being initialized
   */
		beforeInit: function beforeInit(editor) {
			PANEL_MENU_DEFS[editor.name] = {};

			editor.ui.addPanelMenuButton = function (panelMenuButtonName, panelMenuButtonDefinition) {
				this.add(panelMenuButtonName, CKEDITOR.UI_PANELBUTTON, panelMenuButtonDefinition);
			};

			editor.ui.addHandler(CKEDITOR.UI_PANELBUTTON, {
				add: generatePanelMenuButtonBridge,
				create: function create(panelMenuButtonDefinition) {
					var panelMenuButtonName = 'panelMenuButtonBridge' + (Math.random() * 1e9 >>> 0);
					var PanelMenuButtonBridge = generatePanelMenuButtonBridge(panelMenuButtonName, panelMenuButtonDefinition);

					return new PanelMenuButtonBridge();
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/components/uibridge/richcombo.jsx":
/*!***********************************************!*\
  !*** ./src/components/uibridge/richcombo.jsx ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _buttonDropdown = __webpack_require__(/*! ../buttons/button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _buttonIcon = __webpack_require__(/*! ../buttons/button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_richcombobridge')) {
	var RICH_COMBO_DEFS = {};

	/**
  * Generates a RichComboBridge React class for a given richcombo definition if it has not been
  * already created based on the richcombo name and definition.
  *
  * @method generateRichComboBridge
  * @private
  * @param {String} richComboName The rich combo name
  * @param {Object} richComboDefinition The rich combo definition
  * @return {Object} The generated or already existing React RichCombo Class
  */
	var generateRichComboBridge = function generateRichComboBridge(richComboName, richComboDefinition, editor) {
		var RichComboBridge = AlloyEditor.Buttons[richComboName];

		RICH_COMBO_DEFS[editor.name] = RICH_COMBO_DEFS[editor.name] || {};
		RICH_COMBO_DEFS[editor.name][richComboName] = RICH_COMBO_DEFS[editor.name][richComboName] || richComboDefinition;
		RICH_COMBO_DEFS[editor.name][richComboName].currentValue = undefined;

		if (!RichComboBridge) {
			var _class, _temp;

			RichComboBridge = (_temp = _class = function (_React$Component) {
				_inherits(RichComboBridge, _React$Component);

				function RichComboBridge(props) {
					_classCallCheck(this, RichComboBridge);

					var _this = _possibleConstructorReturn(this, (RichComboBridge.__proto__ || Object.getPrototypeOf(RichComboBridge)).call(this, props));

					_this._onClick = function (event) {
						var editor = _this.context.editor.get('nativeEditor');

						var editorCombo = RICH_COMBO_DEFS[editor.name][richComboName];

						if (editorCombo.onClick) {
							var newValue = event.currentTarget.getAttribute('data-value');

							editorCombo.onClick.call(_this, newValue);

							RICH_COMBO_DEFS[editor.name][richComboName].currentValue = newValue;

							editor.fire('actionPerformed', _this);
						}
					};

					_this.state = {
						value: RICH_COMBO_DEFS[editor.name][richComboName].currentValue
					};
					return _this;
				}

				// API not yet implemented inside the richcombo bridge. By mocking the unsupported methods, we
				// prevent plugins from crashing if they make use of them.

				_createClass(RichComboBridge, [{
					key: 'commit',
					value: function commit() {}
				}, {
					key: 'createPanel',
					value: function createPanel() {}
				}, {
					key: 'disable',
					value: function disable() {}
				}, {
					key: 'enable',
					value: function enable() {}
				}, {
					key: 'getState',
					value: function getState() {}
				}, {
					key: 'hideGroup',
					value: function hideGroup() {}
				}, {
					key: 'hideItem',
					value: function hideItem() {}
				}, {
					key: 'mark',
					value: function mark() {}
				}, {
					key: 'showAll',
					value: function showAll() {}
				}, {
					key: 'startGroup',
					value: function startGroup() {}
				}, {
					key: 'unmarkAll',
					value: function unmarkAll() {}
				}, {
					key: 'add',
					value: function add(value, preview, title) {
						this._items.push({
							preview: preview,
							title: title,
							value: value
						});
					}
				}, {
					key: 'componentWillMount',
					value: function componentWillMount() {
						var editor = this.context.editor.get('nativeEditor');

						var editorCombo = RICH_COMBO_DEFS[editor.name][richComboName];

						this._items = [];

						this.setValue = this._setValue;

						if (editorCombo.init) {
							editorCombo.init.call(this);
						}

						if (editorCombo.onRender) {
							editorCombo.onRender.call(this);
						}
					}
				}, {
					key: 'componentWillUnmount',
					value: function componentWillUnmount() {
						this._cacheValue(this.state.value);

						this.setValue = this._cacheValue;
					}
				}, {
					key: 'getValue',
					value: function getValue() {
						return this.state.value;
					}
				}, {
					key: 'render',
					value: function render() {
						var editor = this.context.editor.get('nativeEditor');

						var richComboLabel = RICH_COMBO_DEFS[editor.name][richComboName].currentValue || richComboDefinition.label;

						return _react2.default.createElement(
							'div',
							{ className: 'ae-container-dropdown ae-has-dropdown' },
							_react2.default.createElement(
								'button',
								{
									'aria-expanded': this.props.expanded,
									'aria-label': richComboLabel,
									className: 'ae-toolbar-element',
									onClick: this.props.toggleDropdown,
									role: 'combobox',
									tabIndex: this.props.tabIndex,
									title: richComboLabel },
								_react2.default.createElement(
									'div',
									{ className: 'ae-container' },
									_react2.default.createElement(
										'span',
										{ className: 'ae-container-dropdown-selected-item' },
										richComboLabel
									),
									_react2.default.createElement(_buttonIcon2.default, { symbol: 'caret-bottom' })
								)
							),
							this.props.expanded && _react2.default.createElement(
								_buttonDropdown2.default,
								{
									onDismiss: this.props.toggleDropdown },
								this._getItems()
							)
						);
					}
				}, {
					key: '_cacheValue',
					value: function _cacheValue(value) {
						var editor = this.context.editor.get('nativeEditor');

						RICH_COMBO_DEFS[editor.name][richComboName].currentValue = value;
					}
				}, {
					key: '_getItems',
					value: function _getItems() {
						var _this2 = this;

						var richCombo = this;

						var items = this._items.map(function (item) {
							var className = 'ae-toolbar-element ' + (item.value === _this2.state.value ? 'active' : '');

							return _react2.default.createElement(
								'li',
								{ key: item.title, role: 'option' },
								_react2.default.createElement('button', {
									className: className,
									dangerouslySetInnerHTML: {
										__html: item.preview
									},
									'data-value': item.value,
									onClick: richCombo._onClick
								})
							);
						});

						return items;
					}
				}, {
					key: '_setValue',
					value: function _setValue(value) {
						this._cacheValue(value);

						this.setState({
							value: value
						});
					}
				}]);

				return RichComboBridge;
			}(_react2.default.Component), _class.contextType = _editorContext2.default, _class.displayName = richComboName, _class.key = richComboName, _temp);

			AlloyEditor.Buttons[richComboName] = RichComboBridge;
		}

		return RichComboBridge;
	};

	/* istanbul ignore else */
	if (!CKEDITOR.plugins.get('richcombo')) {
		CKEDITOR.UI_RICHCOMBO = 'richcombo';

		CKEDITOR.plugins.add('richcombo', {});
	}

	/**
  * CKEditor plugin that bridges the support offered by CKEditor RichCombo plugin. It takes over the
  * responsibility of registering and creating rich combo elements via:
  * - editor.ui.addRichCombo(name, definition)
  * - editor.ui.add(name, CKEDITOR.UI_RICHCOMBO, definition)
  *
  * @class CKEDITOR.plugins.ae_richcombobridge
  * @requires CKEDITOR.plugins.ae_uibridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_richcombobridge', {
		requires: ['ae_uibridge'],

		/**
   * Set the add handler for UI_RICHCOMBO to our own. We do this in the init phase to override
   * the one in the original plugin in case it's present
   *
   * @method init
   * @param {Object} editor The CKEditor instance being initialized
   */
		beforeInit: function beforeInit(editor) {
			RICH_COMBO_DEFS[editor.name] = {};

			editor.ui.addRichCombo = function (richComboName, richComboDefinition) {
				this.add(richComboName, CKEDITOR.UI_RICHCOMBO, richComboDefinition);
			};

			editor.ui.addHandler(CKEDITOR.UI_RICHCOMBO, {
				add: generateRichComboBridge,
				create: function create(richComboDefinition) {
					var richComboName = 'richComboBridge' + (Math.random() * 1e9 >>> 0);
					var RichComboBridge = generateRichComboBridge(richComboName, richComboDefinition);

					return new RichComboBridge();
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/components/uibridge/uibridge.js":
/*!*********************************************!*\
  !*** ./src/components/uibridge/uibridge.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_uibridge')) {
	/**
  * CKEditor plugin that extends CKEDITOR.ui.add function so an add handler can be specified
  * on top of the original ones. It bridges the calls to add components via:
  * - editor.ui.add(name, type, definition)
  *
  * @class CKEDITOR.plugins.ae_uibridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_uibridge', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   *
   * @method beforeInit
   * @param {Object} editor The current editor instance
   */
		beforeInit: function beforeInit(editor) {
			var originalUIAddFn = editor.ui.add;

			editor.ui.add = function (name, type, definition) {
				originalUIAddFn.call(this, name, type, definition);

				var typeHandler = this._.handlers[type];

				if (typeHandler && typeHandler.add) {
					typeHandler.add(name, definition, editor);
					AlloyEditor.registerBridgeButton(name, editor.__processingPlugin__.plugin.name);
				}
			};
		}
	});
}

/***/ }),

/***/ "./src/core/debounce.js":
/*!******************************!*\
  !*** ./src/core/debounce.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * Debounce util function. If a function execution is expensive, it might be debounced. This means
 * that it will be executed after some amount of time after its last call. For example, if we attach a
 * a function on scroll event, it might be called hundreds times per second. In this case it may be
 * debounced with, let's say 100ms. The real execution of this function will happen 100ms after last
 * scroll event.
 *
 * @memberof CKEDITOR.tools
 * @method debounce
 * @param {Array} args An array of arguments which the callback will receive.
 * @param {Function} callback The callback which has to be called after given timeout.
 * @param {Number} timeout Timeout in milliseconds after which the callback will be called.
 * @param {Object} context The context in which the callback will be called. This argument is optional.
 * @static
 */
function debounce(callback, timeout, context) {
  var args = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  var debounceHandle = void 0;

  var callFn = function callFn() {
    for (var _len = arguments.length, callArgs = Array(_len), _key = 0; _key < _len; _key++) {
      callArgs[_key] = arguments[_key];
    }

    /* eslint-disable no-invalid-this */
    var callContext = context || this;
    /* eslint-enable no-invalid-this */

    clearTimeout(debounceHandle);

    debounceHandle = setTimeout(function () {
      callback.apply(callContext, [].concat(callArgs, _toConsumableArray(args)));
    }, timeout);
  };

  callFn.detach = function () {
    clearTimeout(debounceHandle);
  };

  return callFn;
}

CKEDITOR.tools.debounce = CKEDITOR.tools.debounce || debounce;

exports.default = debounce;

/***/ }),

/***/ "./src/core/index.js":
/*!***************************!*\
  !*** ./src/core/index.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debounce = undefined;

var _debounce = __webpack_require__(/*! ./debounce */ "./src/core/debounce.js");

var _debounce2 = _interopRequireDefault(_debounce);

__webpack_require__(/*! ./link */ "./src/core/link.js");

__webpack_require__(/*! ./plugins */ "./src/core/plugins.js");

__webpack_require__(/*! ./selection-region */ "./src/core/selection-region.js");

__webpack_require__(/*! ./table */ "./src/core/table.js");

__webpack_require__(/*! ./tools */ "./src/core/tools.js");

__webpack_require__(/*! ./uicore */ "./src/core/uicore.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.debounce = _debounce2.default; /**
                                        * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                        * SPDX-License-Identifier: LGPL-3.0-or-later
                                        */

/***/ }),

/***/ "./src/core/link.js":
/*!**************************!*\
  !*** ./src/core/link.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var REGEX_BOOKMARK_SCHEME = /^#.*/i;
var REGEX_EMAIL_SCHEME = /^[a-z0-9\u0430-\u044F._-]+@/i;
var REGEX_URI_SCHEME = /^(?:[a-z][a-z0-9+\-.]*):|^\//i;

/**
 * Link class utility. Provides methods for create, delete and update links.
 *
 * @class CKEDITOR.Link
 * @constructor
 * @param {Object} editor The CKEditor instance.
 */
function Link(editor, config) {
	this._editor = editor;
	this.appendProtocol = config && config.appendProtocol === false ? false : true;
}

Link.prototype = {
	constructor: Link,

	/**
  * Advances the editor selection to the next available position after a
  * given link or the one in the current selection.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method advanceSelection
  * @param {CKEDITOR.dom.element} link The link element which link style should be removed.
  */
	advanceSelection: function advanceSelection(link) {
		link = link || this.getFromSelection();

		var range = this._editor.getSelection().getRanges()[0];

		if (link) {
			range.moveToElementEditEnd(link);

			var nextNode = range.getNextEditableNode();

			if (nextNode && !this._editor.element.equals(nextNode.getCommonAncestor(link))) {
				var whitespace = /\s/.exec(nextNode.getText());

				var offset = whitespace ? whitespace.index + 1 : 0;

				range.setStart(nextNode, offset);
				range.setEnd(nextNode, offset);
			}
		}

		this._editor.getSelection().selectRanges([range]);
	},


	/**
  * Create a link with given URI as href.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method create
  * @param {Object} attrs A config object with link attributes. These might be arbitrary DOM attributes.
  * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
  * @param {String} URI The URI of the link.
  */
	create: function create(URI, attrs, modifySelection) {
		var selection = this._editor.getSelection();

		var range = selection.getRanges()[0];

		if (range.collapsed) {
			var text = new CKEDITOR.dom.text(URI, this._editor.document);
			range.insertNode(text);
			range.selectNodeContents(text);
		}

		URI = this._getCompleteURI(URI);

		var linkAttrs = CKEDITOR.tools.merge({
			'data-cke-saved-href': URI,
			href: URI,
			rel: 'noopener noreferrer'
		}, attrs);

		if (!linkAttrs.target) {
			var linkCfg = this._editor.config.linkCfg || {};
			var defaultTarget = linkCfg && linkCfg.defaultTarget;
			if (defaultTarget) {
				linkAttrs.target = defaultTarget;
			}
		}

		var style = new CKEDITOR.style({
			attributes: linkAttrs,
			element: 'a'
		});

		style.type = CKEDITOR.STYLE_INLINE;
		style.applyToRange(range, this._editor);

		if (modifySelection && modifySelection.advance) {
			this.advanceSelection();
		} else {
			range.select();
		}
	},


	/**
  * Retrieves a link from the current selection.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method getFromSelection
  * @return {CKEDITOR.dom.element} The retrieved link or null if not found.
  */
	getFromSelection: function getFromSelection() {
		var selection = this._editor.getSelection();

		var selectedElement = selection.getSelectedElement();

		if (selectedElement && selectedElement.is('a')) {
			return selectedElement;
		}

		if (selectedElement && CKEDITOR.env.ie) {
			var children = selectedElement.getChildren();

			var count = children.count();

			for (var i = 0; i < count; i++) {
				var node = children.getItem(i);

				if (node.is('a')) {
					return node;
				}
			}
		}

		var range = selection.getRanges()[0];

		if (range) {
			range.shrink(CKEDITOR.SHRINK_TEXT);

			return this._editor.elementPath(range.getCommonAncestor()).contains('a', 1);
		}

		return null;
	},


	/**
  * Removes a link from the editor.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method remove
  * @param {CKEDITOR.dom.element} link The link element which link style should be removed.
  * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
  */
	remove: function remove(link, modifySelection) {
		var editor = this._editor;

		if (link) {
			if (modifySelection && modifySelection.advance) {
				this.advanceSelection();
			}

			link.remove(editor);
		} else {
			var style = new CKEDITOR.style({
				alwaysRemoveElement: 1,
				element: 'a',
				type: CKEDITOR.STYLE_INLINE
			});

			// 'removeStyle()' removes the style from the editor's current selection.
			//  We need to force the selection to be the whole link element
			//  to remove it properly.

			var selection = editor.getSelection();
			selection.selectElement(selection.getStartElement());

			editor.removeStyle(style);
		}
	},


	/**
  * Updates the href of an already existing link.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method update
  * @param {CKEDITOR.dom.element} link The link element which href should be removed.
  * @param {Object|String} attrs The attributes to update or remove. Attributes with null values will be removed.
  * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
  */
	update: function update(attrs, link, modifySelection) {
		var instance = this;

		link = link || this.getFromSelection();

		if (typeof attrs === 'string') {
			var uri = instance._getCompleteURI(attrs);

			link.setAttributes({
				'data-cke-saved-href': uri,
				href: uri
			});
		} else if ((typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs)) === 'object') {
			var removeAttrs = [];

			var setAttrs = {};

			Object.keys(attrs).forEach(function (key) {
				if (attrs[key] === null) {
					if (key === 'href') {
						removeAttrs.push('data-cke-saved-href');
					}

					removeAttrs.push(key);
				} else {
					if (key === 'href') {
						var _uri = instance._getCompleteURI(attrs[key]);

						setAttrs['data-cke-saved-href'] = _uri;
						setAttrs[key] = _uri;
					} else {
						setAttrs[key] = attrs[key];
					}
				}
			});

			link.removeAttributes(removeAttrs);
			link.setAttributes(setAttrs);
		}

		if (modifySelection && modifySelection.advance) {
			this.advanceSelection(link);
		}
	},


	/**
  * Checks if the URI begins with a '#' symbol to determine if it's an on page bookmark.
  * If it doesn't, it then checks if the URI has an '@' symbol. If it does and the URI
  * looks like an email and doesn't have 'mailto:', 'mailto:' is added to the URI.
  * If it doesn't and the URI doesn't have a scheme, the default 'http' scheme with
  * hierarchical path '//' is added to the URI.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method _getCompleteURI
  * @param {String} URI The URI of the link.
  * @protected
  * @return {String} The URI updated with the protocol.
  */
	_getCompleteURI: function _getCompleteURI(URI) {
		if (REGEX_BOOKMARK_SCHEME.test(URI)) {
			return URI;
		} else if (REGEX_EMAIL_SCHEME.test(URI)) {
			URI = 'mailto:' + URI;
		} else if (!REGEX_URI_SCHEME.test(URI)) {
			URI = this.appendProtocol ? 'http://' + URI : URI;
		}

		return URI;
	}
};

CKEDITOR.Link = CKEDITOR.Link || Link;

/***/ }),

/***/ "./src/core/plugins.js":
/*!*****************************!*\
  !*** ./src/core/plugins.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

// Wraps each of the plugin lifecycle methods in a closure that will
// set up the editor.__processingPlugin__ variable so it can be globally
// accessed exposing the plugin being processed and the lifecycle phase
// in which it is happening
//
// @param {Object} plugin The plugin to wrap lifecycle methods

var wrapPluginLifecycle = function wrapPluginLifecycle(plugin) {
	var methods = ['beforeInit', 'init', 'afterInit'];

	methods.forEach(function (methodName) {
		if (plugin[methodName]) {
			plugin[methodName] = CKEDITOR.tools.override(plugin[methodName], function (originalPluginMethod) {
				var payload = {
					phase: methodName,
					plugin: plugin
				};

				return function (editor) {
					editor.__processingPlugin__ = payload;

					// eslint-disable-next-line no-invalid-this
					originalPluginMethod.call(this, editor);

					editor.__processingPlugin__ = null;
				};
			});
		}
	});
};

// Filters the requires object to remove unwanted dependencies. At this point
// only 'toolbar' has been identified, but more can appear. An unwanted plugin
// dependency is one that prevents a necessary plugin from being removed
//
// @param {string|Array<string>} requires The requires object
// @return {string} The filtered requires object

var filterUnwantedDependencies = function filterUnwantedDependencies(requires) {
	if (typeof requires === 'string') {
		requires = requires.split(',');
	}

	return requires.filter(function (require) {
		return require !== 'toolbar';
	});
};

/**
 * CKEDITOR.plugins class utility which adds additional methods to those of CKEditor.
 *
 * @class CKEDITOR.plugins
 */

/**
 * Overrides CKEDITOR.plugins.load method so we can extend the lifecycle methods of
 * the loaded plugins to add some metainformation about the plugin being processed
 *
 * @param {String/Array} names The name of the resource to load. It may be a
 * string with a single resource name, or an array with several names.
 * @param {Function} callback A function to be called when all resources
 * are loaded. The callback will receive an array containing all loaded names.
 * @param {Object} [scope] The scope object to be used for the callback call.
 * @memberof CKEDITOR.plugins
 * @method load
 * @static
 */
CKEDITOR.plugins.load = CKEDITOR.tools.override(CKEDITOR.plugins.load, function (pluginsLoad) {
	// Wrap original load function so we can transform the plugin input parameter
	// before passing it down to the original callback

	return function (names, callback, scope) {
		// eslint-disable-next-line no-invalid-this
		pluginsLoad.call(this, names, function (plugins) {
			if (callback) {
				Object.keys(plugins).forEach(function (pluginName) {
					var plugin = plugins[pluginName];

					if (plugin.requires) {
						plugin.requires = filterUnwantedDependencies(plugin.requires);
					}

					wrapPluginLifecycle(plugin);
				});

				callback.call(scope, plugins);
			}
		});
	};
});

/***/ }),

/***/ "./src/core/selection-region.js":
/*!**************************************!*\
  !*** ./src/core/selection-region.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

if (!CKEDITOR.plugins.get('ae_selectionregion')) {
	CKEDITOR.SELECTION_TOP_TO_BOTTOM = 0;
	CKEDITOR.SELECTION_BOTTOM_TO_TOP = 1;
	CKEDITOR.SELECTION_LEFT_TO_RIGHT = 2;
	CKEDITOR.SELECTION_RIGHT_TO_LEFT = 3;

	/**
  * SelectionRegion utility class which provides metadata about the selection. The metadata may be the start and end
  * rectangles, caret region, etc. **This class is not intended to be used standalone. Its functions will
  * be merged into each editor instance, so the developer may use them directly via the editor, without making
  * an instance of this class**.
  *
  * @class SelectionRegion
  * @constructor
  */
	function SelectionRegion() {}

	SelectionRegion.prototype = {
		constructor: SelectionRegion,

		/**
   * Creates selection from two points in page coordinates.
   *
   * @instance
   * @memberof SelectionRegion
   * @method createSelectionFromPoint
   * @param {Number} x X point in page coordinates.
   * @param {Number} y Y point in page coordinates.
   */
		createSelectionFromPoint: function createSelectionFromPoint(x, y) {
			this.createSelectionFromRange(x, y, x, y);
		},


		/**
   * Creates selection from range. A range consists from two points in page coordinates.
   *
   * @instance
   * @memberof SelectionRegion
   * @method createSelectionFromRange
   * @param {Number} startX X coordinate of the first point.
   * @param {Number} startY Y coordinate of the first point.
   * @param {Number} endX X coordinate of the second point.
   * @param {Number} endY Y coordinate of the second point.
   */
		createSelectionFromRange: function createSelectionFromRange(startX, startY, endX, endY) {
			var end = void 0;
			var endContainer = void 0;
			var endOffset = void 0;
			var range = void 0;
			var start = void 0;
			var startContainer = void 0;
			var startOffset = void 0;

			if (typeof document.caretPositionFromPoint === 'function') {
				start = document.caretPositionFromPoint(startX, startY);
				end = document.caretPositionFromPoint(endX, endY);

				startContainer = start.offsetNode;
				endContainer = end.offsetNode;

				startOffset = start.offset;
				endOffset = end.offset;

				range = this.createRange();
			} else if (typeof document.caretRangeFromPoint === 'function') {
				start = document.caretRangeFromPoint(startX, startY);
				end = document.caretRangeFromPoint(endX, endY);

				startContainer = start.startContainer;
				endContainer = end.startContainer;

				startOffset = start.startOffset;
				endOffset = end.startOffset;

				range = this.createRange();
			}

			if (range && document.getSelection) {
				range.setStart(new CKEDITOR.dom.node(startContainer), startOffset);
				range.setEnd(new CKEDITOR.dom.node(endContainer), endOffset);

				this.getSelection().selectRanges([range]);
			} else if (typeof document.body.createTextRange === 'function') {
				var selection = this.getSelection();

				selection.unlock();

				range = document.body.createTextRange();
				range.moveToPoint(startX, startY);

				var endRange = range.duplicate();
				endRange.moveToPoint(endX, endY);

				range.setEndPoint('EndToEnd', endRange);
				range.select();

				this.getSelection().lock();
			}
		},


		/**
   * Returns the region of the current position of the caret. The points are in page coordinates.
   *
   * @instance
   * @memberof SelectionRegion
   * @method getCaretRegion
   * @return {Object} Returns object with the following properties:
   * - bottom
   * - left
   * - right
   * - top
   */
		getCaretRegion: function getCaretRegion() {
			var selection = this.getSelection();

			var region = {
				bottom: 0,
				left: 0,
				right: 0,
				top: 0
			};

			var bookmarks = selection.createBookmarks();

			if (!bookmarks.length) {
				return region;
			}

			var bookmarkNodeEl = bookmarks[0].startNode.$;

			bookmarkNodeEl.style.display = 'inline-block';

			region = new CKEDITOR.dom.element(bookmarkNodeEl).getClientRect();

			bookmarkNodeEl.parentNode.removeChild(bookmarkNodeEl);

			var scrollPos = new CKEDITOR.dom.window(window).getScrollPosition();

			region.bottom = scrollPos.y + region.bottom;
			region.left = scrollPos.x + region.left;
			region.right = scrollPos.x + region.right;
			region.top = scrollPos.y + region.top;

			return region;
		},


		/**
   * Returns data for the current selection.
   *
   * @instance
   * @memberof SelectionRegion
   * @method getSelectionData
   * @return {Object|null} Returns an object with the following data:
   * - element - The currently selected element, if any
   * - text - The selected text
   * - region - The data, returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionRegion:method"}}{{/crossLink}}
   */
		getSelectionData: function getSelectionData() {
			var selection = this.getSelection();

			if (!selection.getNative()) {
				return null;
			}

			var result = {
				element: selection.getSelectedElement(),
				text: selection.getSelectedText()
			};

			result.region = this.getSelectionRegion(selection);

			return result;
		},


		/**
   * Returns the region of the current selection.
   *
   * @instance
   * @memberof SelectionRegion
   * @method getSelectionRegion
   * @return {Object} Returns object which is being returned from
   * {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getClientRectsRegion:method"}}{{/crossLink}} with three more properties:
   * - direction - the direction of the selection. Can be one of these:
   *   1. CKEDITOR.SELECTION_TOP_TO_BOTTOM
   *   2. CKEDITOR.SELECTION_BOTTOM_TO_TOP
   * - height - The height of the selection region
   * - width - The width of the selection region
   */
		getSelectionRegion: function getSelectionRegion() {
			var region = this.getClientRectsRegion();

			region.direction = this.getSelectionDirection();

			region.height = region.bottom - region.top;
			region.width = region.right - region.left;

			return region;
		},


		/**
   * Returns true if the current selection is empty, false otherwise.
   *
   * @instance
   * @memberof SelectionRegion
   * @method isSelectionEmpty
   * @return {Boolean} Returns true if the current selection is empty, false otherwise.
   */
		isSelectionEmpty: function isSelectionEmpty() {
			var selection = this.getSelection();

			if (selection.getType() === CKEDITOR.SELECTION_NONE) {
				return true;
			}

			var ranges = selection.getRanges();

			return ranges && ranges.length === 1 && ranges[0].collapsed;
		},


		/**
   * Returns object with data about the [client rectangles](https://developer.mozilla.org/en-US/docs/Web/API/Element.getClientRects) of the selection,
   * normalized across browses. All offsets below are in page coordinates.
   *
   * @instance
   * @memberof SelectionRegion
   * @method getClientRectsRegion
   * @return {Object} Returns object with the following data:
   * - bottom - bottom offset of all client rectangles
   * - left - left offset of all client rectangles
   * - right - right offset of all client rectangles
   * - top - top offset of all client rectangles
   * - startRect - An Object, which contains the following information:
   *     + bottom - bottom offset
   *     + height - the height of the rectangle
   *     + left - left offset of the selection
   *     + right - right offset of the selection
   *     + top - top offset of the selection
   *     + width - the width of the rectangle
   * - endRect - An Object, which contains the following information:
   *     + bottom - bottom offset
   *     + height - the height of the rectangle
   *     + left - left offset of the selection
   *     + right - right offset of the selection
   *     + top - top offset of the selection
   *     + width - the width of the rectangle
   *
   * If there is no native selection, the objects will be filled with 0.
   */
		getClientRectsRegion: function getClientRectsRegion() {
			var selection = this.getSelection();
			var nativeSelection = selection.getNative();

			var defaultRect = {
				bottom: 0,
				height: 0,
				left: 0,
				right: 0,
				top: 0,
				width: 0
			};

			var region = {
				bottom: 0,
				endRect: defaultRect,
				left: 0,
				right: 0,
				top: 0,
				startRect: defaultRect
			};

			if (!nativeSelection) {
				return region;
			}

			var bottom = 0;
			var clientRects = void 0;
			var left = Infinity;
			var right = -Infinity;
			var top = Infinity;

			if (nativeSelection.createRange) {
				clientRects = nativeSelection.createRange().getClientRects();
			} else {
				clientRects = nativeSelection.rangeCount > 0 ? nativeSelection.getRangeAt(0).getClientRects() : [];
			}

			if (clientRects.length === 0) {
				region = this.getCaretRegion();
			} else {
				for (var i = 0, length = clientRects.length; i < length; i++) {
					var item = clientRects[i];

					if (item.left < left) {
						left = item.left;
					}

					if (item.right > right) {
						right = item.right;
					}

					if (item.top < top) {
						top = item.top;
					}

					if (item.bottom > bottom) {
						bottom = item.bottom;
					}
				}

				var scrollPos = new CKEDITOR.dom.window(window).getScrollPosition();

				region.bottom = scrollPos.y + bottom;
				region.left = scrollPos.x + left;
				region.right = scrollPos.x + right;
				region.top = scrollPos.y + top;

				if (clientRects.length) {
					var endRect = clientRects[clientRects.length - 1];
					var startRect = clientRects[0];

					region.endRect = {
						bottom: scrollPos.y + endRect.bottom,
						height: endRect.height,
						left: scrollPos.x + endRect.left,
						right: scrollPos.x + endRect.right,
						top: scrollPos.y + endRect.top,
						width: endRect.width
					};

					region.startRect = {
						bottom: scrollPos.y + startRect.bottom,
						height: startRect.height,
						left: scrollPos.x + startRect.left,
						right: scrollPos.x + startRect.right,
						top: scrollPos.y + startRect.top,
						width: startRect.width
					};
				}
			}

			return region;
		},


		/**
   * Retrieves the direction of the selection. The direction is from top to bottom or from bottom to top.
   * For IE < 9 it is not possible, so the direction for these browsers will be always CKEDITOR.SELECTION_TOP_TO_BOTTOM.
   *
   * @instance
   * @memberof SelectionRegion
   * @method getSelectionDirection
   * @return {Number} Returns a number which represents selection direction. It might be one of these:
   * - CKEDITOR.SELECTION_TOP_TO_BOTTOM;
   * - CKEDITOR.SELECTION_BOTTOM_TO_TOP;
   */
		getSelectionDirection: function getSelectionDirection() {
			var direction = CKEDITOR.SELECTION_TOP_TO_BOTTOM;
			var selection = this.getSelection();
			var nativeSelection = selection.getNative();

			if (!nativeSelection) {
				return direction;
			}

			var anchorNode = void 0;

			if ((anchorNode = nativeSelection.anchorNode) && anchorNode.compareDocumentPosition) {
				var position = anchorNode.compareDocumentPosition(nativeSelection.focusNode);

				if (!position && nativeSelection.anchorOffset > nativeSelection.focusOffset || position === Node.DOCUMENT_POSITION_PRECEDING) {
					direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
				}
			}

			return direction;
		}
	};

	CKEDITOR.plugins.add('ae_selectionregion', {
		init: function init(editor) {
			var attr = void 0;
			var hasOwnProperty = Object.prototype.hasOwnProperty;

			for (attr in SelectionRegion.prototype) {
				if (hasOwnProperty.call(SelectionRegion.prototype, attr) && typeof editor[attr] === 'undefined') {
					editor[attr] = SelectionRegion.prototype[attr];
				}
			}
		}
	});
}

/***/ }),

/***/ "./src/core/table.js":
/*!***************************!*\
  !*** ./src/core/table.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var IE_NON_DIRECTLY_EDITABLE_ELEMENT = {
	table: 1,
	col: 1,
	colgroup: 1,
	tbody: 1,
	td: 1,
	tfoot: 1,
	th: 1,
	thead: 1,
	tr: 1
};

/**
 * Table class utility. Provides methods for create, delete and update tables.
 *
 * @class CKEDITOR.Table
 * @constructor
 * @param {Object} editor The CKEditor instance.
 */

function Table(editor) {
	this._editor = editor;
}

Table.HEADING_BOTH = 'Both';
Table.HEADING_COL = 'Column';
Table.HEADING_NONE = 'None';
Table.HEADING_ROW = 'Row';

Table.prototype = {
	constructor: Table,

	/**
  * Creates a table.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method create
  * @param {Object} config Table configuration object
  * @return {Object} The created table
  */
	create: function create(config) {
		var editor = this._editor;
		var table = this._createElement('table');

		config = config || {};

		// Generate the rows and cols.

		var tbody = table.append(this._createElement('tbody'));
		var rows = config.rows || 1;
		var cols = config.cols || 1;

		for (var i = 0; i < rows; i++) {
			var row = tbody.append(this._createElement('tr'));
			for (var j = 0; j < cols; j++) {
				var cell = row.append(this._createElement('td'));

				cell.appendBogus();
			}
		}

		this.setAttributes(table, config.attrs);
		this.setHeading(table, config.heading);

		// Insert the table element if we're creating one.

		editor.insertElement(table);

		var firstCell = new CKEDITOR.dom.element(table.$.rows[0].cells[0]);
		var range = editor.createRange();
		range.moveToPosition(firstCell, CKEDITOR.POSITION_AFTER_START);
		range.select();

		return table;
	},


	/**
  * Retrieves a table from the current selection.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method getFromSelection
  * @return {CKEDITOR.dom.element} The retrieved table or null if not found.
  */
	getFromSelection: function getFromSelection() {
		var table = void 0;
		var selection = this._editor.getSelection();
		var selected = selection.getSelectedElement();

		if (selected && selected.is('table')) {
			table = selected;
		} else {
			var ranges = selection.getRanges();

			if (ranges.length > 0) {
				// Webkit could report the following range on cell selection (#4948):
				// <table><tr><td>[&nbsp;</td></tr></table>]

				/* istanbul ignore else */
				if (CKEDITOR.env.webkit) {
					ranges[0].shrink(CKEDITOR.NODE_ELEMENT);
				}

				table = this._editor.elementPath(ranges[0].getCommonAncestor(true)).contains('table', 1);
			}
		}

		return table;
	},


	/**
  * Checks if a given table can be considered as editable. This method
  * workarounds a limitation of IE where for some elements (like table),
  * `isContentEditable` returns always false. This is because IE does not support
  * `contenteditable` on such elements. However, despite such elements
  * cannot be set as content editable directly, a content editable SPAN,
  * or DIV element can be placed inside the individual table cells.
  * See https://msdn.microsoft.com/en-us/library/ms537837%28v=VS.85%29.aspx
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method isEditable
  * @param {CKEDITOR.dom.element} el The table element to test if editable
  * @return {Boolean}
  */
	isEditable: function isEditable(el) {
		if (!CKEDITOR.env.ie || !el.is(IE_NON_DIRECTLY_EDITABLE_ELEMENT)) {
			return !el.isReadOnly();
		}

		if (el.hasAttribute('contenteditable')) {
			return el.getAttribute('contenteditable') !== 'false';
		}

		return this.isEditable(el.getParent());
	},


	/**
  * Returns which heading style is set for the given table.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method getHeading
  * @param {CKEDITOR.dom.element} table The table to gather the heading from. If null, it will be retrieved from the current selection.
  * @return {String} The heading of the table. Expected values are `CKEDITOR.Table.NONE`, `CKEDITOR.Table.ROW`, `CKEDITOR.Table.COL` and `CKEDITOR.Table.BOTH`.
  */
	getHeading: function getHeading(table) {
		table = table || this.getFromSelection();

		if (!table) {
			return null;
		}

		var rowHeadingSettings = table.$.tHead !== null;

		var colHeadingSettings = true;

		// Check if all of the first cells in every row are TH

		for (var row = 0; row < table.$.rows.length; row++) {
			// If just one cell isn't a TH then it isn't a header column

			var cell = table.$.rows[row].cells[0];

			if (cell && cell.nodeName.toLowerCase() !== 'th') {
				colHeadingSettings = false;
				break;
			}
		}

		var headingSettings = Table.HEADING_NONE;

		if (rowHeadingSettings) {
			headingSettings = Table.HEADING_ROW;
		}

		if (colHeadingSettings) {
			headingSettings = headingSettings === Table.HEADING_ROW ? Table.HEADING_BOTH : Table.HEADING_COL;
		}

		return headingSettings;
	},


	/**
  * Removes a table from the editor.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method remove
  * @param {CKEDITOR.dom.element} table The table element which table style should be removed.
  */
	remove: function remove(table) {
		var editor = this._editor;

		if (table) {
			table.remove();
		} else {
			table = editor.elementPath().contains('table', 1);

			if (table) {
				// If the table's parent has only one child remove it as well (unless it's a table cell, or the editable element) (#5416, #6289, #12110)

				var parent = table.getParent();
				var editable = editor.editable();

				if (parent.getChildCount() === 1 && !parent.is('td', 'th') && !parent.equals(editable)) {
					table = parent;
				}

				var range = editor.createRange();
				range.moveToPosition(table, CKEDITOR.POSITION_BEFORE_START);
				table.remove();
			}
		}
	},


	/**
  * Assigns provided attributes to a table.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method setAttributes
  * @param {Object} table The table to which the attributes should be assigned
  * @param {Object} attrs The attributes which have to be assigned to the table
  */
	setAttributes: function setAttributes(table, attrs) {
		if (attrs) {
			Object.keys(attrs).forEach(function (attr) {
				table.setAttribute(attr, attrs[attr]);
			});
		}
	},


	/**
  * Sets the appropriate table heading style to a table.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method setHeading
  * @param {CKEDITOR.dom.element} table The table element to which the heading should be set. If null, it will be retrieved from the current selection.
  * @param {String} heading The table heading to be set. Accepted values are: `CKEDITOR.Table.NONE`, `CKEDITOR.Table.ROW`, `CKEDITOR.Table.COL` and `CKEDITOR.Table.BOTH`.
  */
	setHeading: function setHeading(table, heading) {
		table = table || this.getFromSelection();

		var i = void 0;
		var newCell = void 0;
		var tableHead = void 0;
		var tableBody = table.getElementsByTag('tbody').getItem(0);

		var tableHeading = this.getHeading(table);
		var hadColHeading = tableHeading === Table.HEADING_COL || tableHeading === Table.HEADING_BOTH;

		var needColHeading = heading === Table.HEADING_COL || heading === Table.HEADING_BOTH;
		var needRowHeading = heading === Table.HEADING_ROW || heading === Table.HEADING_BOTH;

		// If we need row heading and don't have a <thead> element yet, move the
		// first row of the table to the head and convert the nodes to <th> ones.

		if (!table.$.tHead && needRowHeading) {
			var tableFirstRow = tableBody.getElementsByTag('tr').getItem(0);
			var tableFirstRowChildCount = tableFirstRow.getChildCount();

			// Change TD to TH:

			for (i = 0; i < tableFirstRowChildCount; i++) {
				var cell = tableFirstRow.getChild(i);

				// Skip bookmark nodes. (#6155)

				if (cell.type === CKEDITOR.NODE_ELEMENT && !cell.data('cke-bookmark')) {
					cell.renameNode('th');
					cell.setAttribute('scope', 'col');
				}
			}

			tableHead = this._createElement(table.$.createTHead());
			tableHead.append(tableFirstRow.remove());
		}

		// If we don't need row heading and we have a <thead> element, move the
		// row out of there and into the <tbody> element.

		if (table.$.tHead !== null && !needRowHeading) {
			// Move the row out of the THead and put it in the TBody:

			tableHead = this._createElement(table.$.tHead);

			var previousFirstRow = tableBody.getFirst();

			while (tableHead.getChildCount() > 0) {
				var newFirstRow = tableHead.getFirst();
				var newFirstRowChildCount = newFirstRow.getChildCount();

				for (i = 0; i < newFirstRowChildCount; i++) {
					newCell = newFirstRow.getChild(i);

					if (newCell.type === CKEDITOR.NODE_ELEMENT) {
						newCell.renameNode('td');
						newCell.removeAttribute('scope');
					}
				}

				newFirstRow.insertBefore(previousFirstRow);
			}

			tableHead.remove();
		}

		tableHeading = this.getHeading(table);
		var hasColHeading = tableHeading === Table.HEADING_COL || tableHeading === Table.HEADING_BOTH;

		// If we need column heading and the table doesn't have it, convert every first cell in
		// every row into a `<th scope="row">` element.

		if (!hasColHeading && needColHeading) {
			for (i = 0; i < table.$.rows.length; i++) {
				if (table.$.rows[i].cells[0].nodeName.toLowerCase() !== 'th') {
					newCell = new CKEDITOR.dom.element(table.$.rows[i].cells[0]);
					newCell.renameNode('th');
					newCell.setAttribute('scope', 'row');
				}
			}
		}

		// If we don't need column heading but the table has it, convert every first cell in every
		// row back into a `<td>` element.

		if (hadColHeading && !needColHeading) {
			for (i = 0; i < table.$.rows.length; i++) {
				var row = new CKEDITOR.dom.element(table.$.rows[i]);

				if (row.getParent().getName() === 'tbody') {
					newCell = new CKEDITOR.dom.element(row.$.cells[0]);
					newCell.renameNode('td');
					newCell.removeAttribute('scope');
				}
			}
		}
	},


	/**
  * Creates a new CKEDITOR.dom.element using the passed tag name.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @protected
  * @method _createElement
  * @param {String} name The tag name from which an element should be created
  * @return {CKEDITOR.dom.element} Instance of CKEDITOR DOM element class
  */
	_createElement: function _createElement(name) {
		return new CKEDITOR.dom.element(name, this._editor.document);
	}
};

CKEDITOR.on('instanceReady', function (event) {
	var headingCommands = [Table.HEADING_NONE, Table.HEADING_ROW, Table.HEADING_COL, Table.HEADING_BOTH];

	var tableUtils = new Table(event.editor);

	headingCommands.forEach(function (heading) {
		event.editor.addCommand('tableHeading' + heading, {
			exec: function exec(_editor) {
				tableUtils.setHeading(null, heading);
			}
		});
	});
});

CKEDITOR.Table = CKEDITOR.Table || Table;

/***/ }),

/***/ "./src/core/tools.js":
/*!***************************!*\
  !*** ./src/core/tools.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * CKEDITOR.tools class utility which adds additional methods to those of CKEditor.
 *
 * @class CKEDITOR.tools
 */

/**
 * Sends a request using the JSONP technique.
 *
 * @memberof CKEDITOR.tools
 * @method jsonp
 * @param {CKEDITOR.template} urlTemplate The template of the URL to be requested. All properties passed in `urlParams` can be used, plus a `{callback}`, which represent a JSONP callback, must be defined.
 * @param {Function} callback A function to be called in case of success.
 * @param {Function} errorCallback A function to be called in case of failure.
 * @param {Object} urlParams Parameters to be passed to the `urlTemplate`.
 * @return {Object} An object with the following properties:
 *  - id: the transaction ID
 *  - a `cancel()` method
 * @static
 */
CKEDITOR.tools.jsonp = function (urlTemplate, urlParams, callback, errorCallback) {
	var callbackKey = CKEDITOR.tools.getNextNumber();

	urlParams = urlParams || {};
	urlParams.callback = 'CKEDITOR._.jsonpCallbacks[' + callbackKey + ']';

	if (!CKEDITOR._.jsonpCallbacks) {
		CKEDITOR._.jsonpCallbacks = {};
	}

	CKEDITOR._.jsonpCallbacks[callbackKey] = function (response) {
		setTimeout(function () {
			cleanUp();

			callback(response);
		});
	};

	var scriptElement = new CKEDITOR.dom.element('script');
	scriptElement.setAttribute('src', urlTemplate.output(urlParams));
	scriptElement.on('error', function () {
		cleanUp();

		if (errorCallback) {
			errorCallback();
		}
	});

	function cleanUp() {
		if (scriptElement) {
			scriptElement.remove();
			delete CKEDITOR._.jsonpCallbacks[callbackKey];
			scriptElement = null;
		}
	}

	CKEDITOR.document.getBody().append(scriptElement);

	return {
		cancel: cleanUp,
		id: callbackKey
	};
};

/**
 * Returns a new object containing all of the properties of all the supplied
 * objects. The properties from later objects will overwrite those in earlier
 * objects.
 *
 * Passing in a single object will create a shallow copy of it.
 *
 * @memberof CKEDITOR.tools
 * @method merge
 * @param {Object} objects* One or more objects to merge.
 * @return {Object} A new merged object.
 * @static
 */
CKEDITOR.tools.merge = CKEDITOR.tools.merge || function () {
	var result = {};

	for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		args[_key] = arguments[_key];
	}

	for (var i = 0; i < args.length; ++i) {
		var obj = args[i];

		for (var key in obj) {
			if (Object.prototype.hasOwnProperty.call(obj, key)) {
				result[key] = obj[key];
			}
		}
	}

	return result;
};

/**
 * Simulates event on a DOM element.
 *
 * @memberof CKEDITOR.tools
 * @method simulate
 * @param {DOMElement} element The element on which the event shoud be simualted.
 * @param {String} event The name of the event which have to be simulated.
 * @static
 */
CKEDITOR.tools.simulate = function (element, event) {
	var eventInstance = document.createEvent('Events');
	eventInstance.initEvent(event, true, false);
	element.dispatchEvent(eventInstance);
};

/***/ }),

/***/ "./src/core/uicore.js":
/*!****************************!*\
  !*** ./src/core/uicore.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

if (!CKEDITOR.plugins.get('ae_uicore')) {
	/**
  * UICore class which will handle user interactions with the editor. These interactions
  * might be triggered via mouse, keyboard or touch devices. The class fill fire an event via
  * CKEditor's event system - "editorInteraction". The UI may listen to this event and
  * execute some actions - for example to show/hide toolbars.
  *
  * By default if user presses the Esc key, 'editorInteraction' event won't be fired. However, this behaviour can be changed
  * by setting {{#crossLink "CKEDITOR.plugins.ae_uicore/allowEsc:attribute"}}{{/crossLink}} config property in editor's configuration to true.
  *
  * @class ae_uicore
  */

	/**
  * Fired when user interacts somehow with the browser. This may be clicking with the mouse, pressing keyboard button,
  * or touching screen. This even will be not fired after each interaction. It will be debounced. By default the timeout
  * is 50ms. This value can be overwritten via {{#crossLink "CKEDITOR.plugins.ae_uicore/timeout:attribute"}}{{/crossLink}}
  * property of editor's configuration, like: editor.config.uicore.timeout = 100
  *
  * @memberof ae_uicore
  * @event ae_uicore#editorInteraction
  * @param {Object} data An object which contains the following properties:
  * - nativeEvent - The event as received from CKEditor.
  * - selectionData - The data, returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
  */

	/**
  * Fired by UI elements like Toolbars or Buttons when their state changes. The listener updates the live region with the provided data.
  *
  * @memberof ae_uicore
  * @event ae_uicore#ariaUpdate
  * @param {Object} data An object which contains the following properties:
  * - message - The provided message from the UI element.
  */

	/**
  * If set to true, the editor will still fire {{#crossLink "CKEDITOR.plugins.ae_uicore/editorInteraction:event"}}{{/crossLink}} event,
  * if user presses Esc key.
  *
  * @memberof ae_uicore
  * @attribute allowEsc
  * @default false
  * @type Boolean
  */

	/**
  * Specifies the default timeout after which the {{#crossLink "CKEDITOR.plugins.ae_uicore/editorInteraction:event"}}{{/crossLink}} event
  * will be fired.
  *
  * @memberof ae_uicore
  * @attribute timeout
  * @default 50 (ms)
  * @type Number
  */

	CKEDITOR.plugins.add('ae_uicore', {
		/**
   * Initializer lifecycle implementation for the UICore plugin.
   *
   * @memberof ae_uicore
   * @method init
   * @param {Object} editor The current CKEditor instance.
   * @protected
   */
		init: function init(editor) {
			var ariaState = [];

			var ariaElement = this._createAriaElement(editor.id);

			var uiTasksTimeout = editor.config.uicore ? editor.config.uicore.timeout : 50;

			var handleUI = CKEDITOR.tools.debounce(function (event) {
				ariaState = [];

				if (event.name !== 'keyup' || event.data.$.keyCode !== 27 || editor.config.allowEsc) {
					var selectionData = editor.getSelectionData();

					if (selectionData) {
						editor.fire('editorInteraction', {
							nativeEvent: event.data.$,
							selectionData: selectionData
						});
					}
				}
			}, uiTasksTimeout);

			var handleAria = CKEDITOR.tools.debounce(function (_event) {
				ariaElement.innerHTML = ariaState.join('. ');
			}, uiTasksTimeout);

			var handleMouseLeave = CKEDITOR.tools.debounce(function (event) {
				var aeUINodes = document.querySelectorAll('.ae-ui');

				var found = void 0;

				for (var i = 0; i < aeUINodes.length; i++) {
					if (aeUINodes[i].contains(event.data.$.relatedTarget)) {
						found = true;
						break;
					}
				}

				if (!found) {
					handleUI(event);
				}
			}, uiTasksTimeout);

			editor.on('ariaUpdate', function (event) {
				// handleAria is debounced function, so if it is being called multiple times, it will
				// be canceled until some time passes.
				// For that reason here we explicitly append the current message to the list of messages
				// and call handleAria. Since it is debounced, when some timeout passes,
				// all the messages will be applied to the live region and not only the last one.

				ariaState.push(event.data.message);

				handleAria();
			});

			editor.once('contentDom', function () {
				var editable = editor.editable();

				var focusHandler = editable.attachListener(editable, 'focus', function (event) {
					focusHandler.removeListener();

					editable.attachListener(editable, 'keyup', handleUI);
					editable.attachListener(editable, 'mouseup', handleUI);
					editable.attachListener(editable, 'mouseleave', handleMouseLeave);

					handleUI(event);
				});
			});

			editor.on('destroy', function (_event) {
				ariaElement.parentNode.removeChild(ariaElement);

				handleUI.detach();
			});
		},


		/**
   * Creates and applies an HTML element to the body of the document which will contain ARIA messages.
   *
   * @memberof ae_uicore
   * @method _createAriaElement
   * @param {String} id The provided id of the element. It will be used as prefix for the final element Id.
   * @protected
   * @return {HTMLElement} The created and applied to DOM element.
   */
		_createAriaElement: function _createAriaElement(id) {
			var statusElement = document.createElement('div');

			statusElement.className = 'ae-sr-only';

			statusElement.setAttribute('aria-live', 'polite');
			statusElement.setAttribute('role', 'status');
			statusElement.setAttribute('id', id + 'LiveRegion');

			document.body.appendChild(statusElement);

			return statusElement;
		}
	});
}

/***/ }),

/***/ "./src/oop/attribute.js":
/*!******************************!*\
  !*** ./src/oop/attribute.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _lang = __webpack_require__(/*! ./lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
                                                                                                                                                                                                     * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                     * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                     */

/**
 * Attribute implementation.
 *
 * @class Attribute
 * @constructor
 */
function Attribute(config) {
	this.__config__ = config || {};
	this.__ATTRS__ = {};
}

Attribute.prototype = {
	constructor: Attribute,

	/**
  * Retrieves the value of an attribute.
  *
  * @instance
  * @memberof Attribute
  * @method get
  * @param {String} attr The attribute which value should be retrieved.
  * @return {Any} The value of the attribute.
  */
	get: function get(attr) {
		var currentAttr = this.constructor.ATTRS[attr];

		if (!currentAttr) {
			return;
		}

		if (!this._isInitialized(attr)) {
			this._init(attr);
		}

		var curValue = this.__ATTRS__[attr];

		if (currentAttr.getter) {
			curValue = this._callStringOrFunction(currentAttr.getter, curValue);
		}

		return curValue;
	},


	/**
  * Sets the value of an attribute.
  *
  * @instance
  * @memberof Attribute
  * @method set
  * @param {String} attr The attribute which value should be set.
  * @param {Any} value The value which should be set to the attribute.
  */
	set: function set(attr, value) {
		var currentAttr = this.constructor.ATTRS[attr];

		if (!currentAttr) {
			return;
		}

		if (!this._isInitialized(attr)) {
			this._init(attr);
		}

		if (currentAttr.readOnly) {
			return;
		}

		if (currentAttr.writeOnce && this._isInitialized(attr)) {
			return;
		}

		if (currentAttr.validator && !this._callStringOrFunction(currentAttr.validator, value)) {
			return;
		}

		if (currentAttr.setter) {
			value = this._callStringOrFunction(currentAttr.setter, value);
		}

		this.__ATTRS__[attr] = value;
	},


	/**
  * Calls the provided param as function with the supplied arguments.
  * If param provided as string, a corresponding function in this object will
  * be called. If provided param is a function, it will be directly called.
  *
  * @instance
  * @memberof Attribute
  * @method _callStringOrFunction
  * @param  {Any|Array} args The arguments which will be provided to the called function
  * @param  {String|Function} stringOrFunction The function which should be called
  * @protected
  * @return {Any} The returned value from the called function
  */
	_callStringOrFunction: function _callStringOrFunction(stringOrFunction, args) {
		var result = null;

		if (!_lang2.default.isArray(args)) {
			args = [args];
		}

		if (_lang2.default.isString(stringOrFunction) && _lang2.default.isFunction(this[stringOrFunction])) {
			result = this[stringOrFunction].apply(this, _toConsumableArray(args));
		} else if (_lang2.default.isFunction(stringOrFunction)) {
			result = stringOrFunction.apply(this, args);
		}

		return result;
	},


	/**
  * Initializes an attribute. Sets its default value depending on the flags of the
  * attribute and the passed configuration object to the constructor.
  *
  * @instance
  * @memberof Attribute
  * @method _init
  * @param {String} attr The name of the attribute which have to be initialized.
  * @protected
  */
	_init: function _init(attr) {
		var value = void 0;

		var currentAttr = this.constructor.ATTRS[attr];

		// Check if there is default value or passed one via configuration object

		var hasDefaultValue = Object.prototype.hasOwnProperty.call(currentAttr, 'value');
		var hasPassedValueViaConfig = Object.prototype.hasOwnProperty.call(this.__config__, attr);

		// If there is valueFn, set the value to be the result of invocation of this function

		if (currentAttr.valueFn) {
			value = this._callStringOrFunction(currentAttr.valueFn, value);

			this.__ATTRS__[attr] = value;
		}

		// else if the attribute has readOnly flag, set the default value from the attribute,
		// regardless if there is value or not
		else if (currentAttr.readOnly) {
				value = currentAttr.value;
			}

			// else if the attribute has writeOnce value, set it from the passed configuration or from the
			// default value, in this order. Otherwise, return miserable.
			else if (currentAttr.writeOnce) {
					if (hasPassedValueViaConfig) {
						value = this.__config__[attr];
					} else if (hasDefaultValue) {
						value = currentAttr.value;
					} else {
						return;
					}
				}

				// These two cases below are easy - set the value to be from the passed config or
				// from the default value, in this order.
				else if (hasPassedValueViaConfig) {
						value = this.__config__[attr];
					} else if (hasDefaultValue) {
						value = currentAttr.value;
					}

		// If there is validator, and user passed config object - check the returned value.
		// If it is false, then set as initial value the default one.
		// However, if there is no default value, just return.

		if (currentAttr.validator && hasPassedValueViaConfig && !this._callStringOrFunction(currentAttr.validator, value)) {
			if (hasDefaultValue) {
				value = currentAttr.value;
			} else {
				return;
			}
		}

		// If there is setter and user passed config object - pass the value thought the setter.
		// The value might be one from defaultFn, default value or provided from the config.

		if (currentAttr.setter && hasPassedValueViaConfig) {
			value = this._callStringOrFunction(currentAttr.setter, value);
		}

		// Finally, set the value as initial value to the storage with values.

		this.__ATTRS__[attr] = value;
	},


	/**
  * Checks if an attribute is initialized. An attribute is considered as initialized
  * when there is an own property with this name in the local collection of attribute values
  * for the current instance.
  *
  * @instance
  * @memberof Attribute
  * @method _isInitialized
  * @param {String} attr The attribute which should be checked if it is initialized.
  * @protected
  * @return {Boolean} Returns true if the attribute has been initialized, false otherwise.
  */
	_isInitialized: function _isInitialized(attr) {
		return Object.prototype.hasOwnProperty.call(this.__ATTRS__, attr);
	}
};

exports.default = Attribute;

/***/ }),

/***/ "./src/oop/base.js":
/*!*************************!*\
  !*** ./src/oop/base.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _attribute = __webpack_require__(/*! ./attribute */ "./src/oop/attribute.js");

var _attribute2 = _interopRequireDefault(_attribute);

var _lang = __webpack_require__(/*! ./lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _oop = __webpack_require__(/*! ./oop */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Quick and dirty impl of Base class.
 *
 * @class Base
 * @constructor
 */
function Base(config) {
	Base.superclass.constructor.call(this, config);

	this.init(config);
} /**
   * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
   * SPDX-License-Identifier: LGPL-3.0-or-later
   */

(0, _oop2.default)(Base, _attribute2.default, {
	/**
  * Calls the `initializer` method of each class which extends Base starting from the parent to the child.
  * Will pass the configuration object to each initializer method.
  *
  * @instance
  * @memberof Base
  * @method init
  * @param {Object} config Configuration object
  */
	init: function init(config) {
		this._callChain('initializer', config);
	},


	/**
  * Calls the `destructor` method of each class which extends Base starting from the parent to the child.
  *
  * @instance
  * @memberof Base
  * @method destroy
  */
	destroy: function destroy() {
		this._callChain('destructor');
	},


	/**
  * Calls a method of each class, which is being present in the hierarchy starting from parent to the child.
  *
  * @instance
  * @memberof Base
  * @method _callChain
  * @param {Object|Array} args The arguments with which the method should be invoked
  * @param {String} wat  The method, which should be invoked
  * @protected
  */
	_callChain: function _callChain(wat, args) {
		var arr = [];

		var ctor = this.constructor;

		while (ctor) {
			if (_lang2.default.isFunction(ctor.prototype[wat])) {
				arr.push(ctor.prototype[wat]);
			}

			ctor = ctor.superclass ? ctor.superclass.constructor : null;
		}

		arr = arr.reverse();

		args = _lang2.default.isArray(args) ? args : [args];

		for (var i = 0; i < arr.length; i++) {
			var item = arr[i];

			item.apply(this, args);
		}
	}
});

exports.default = Base;

/***/ }),

/***/ "./src/oop/lang.js":
/*!*************************!*\
  !*** ./src/oop/lang.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * Provides core language utilities.
 *
 * @class Lang
 */
var Lang = {
	/**
  * Check if the passed value is an array.
  *
  * @memberof Lang
  * @method isArray
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is an array, false otherwise.
  * @static
  */
	isArray: function isArray(value) {
		return Object.prototype.toString.call(value) === '[object Array]';
	},


	/**
  * Check if the passed value is boolean.
  *
  * @memberof Lang
  * @method isBoolean
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is boolean, false otherwise.
  * @static
  */
	isBoolean: function isBoolean(value) {
		return typeof value === 'boolean';
	},


	/**
  * Check if the passed value is a function.
  *
  * @memberof Lang
  * @method isFunction
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is a function, false otherwise.
  * @static
  */
	isFunction: function isFunction(value) {
		return typeof value === 'function';
	},


	/**
  * Check if the passed value is NULL.
  *
  * @memberof Lang
  * @method isNull
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is NULL, false otherwise.
  * @static
  */
	isNull: function isNull(value) {
		return value === null;
	},


	/**
  * Check if the passed value is number.
  *
  * @memberof Lang
  * @method isNumber
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is number, false otherwise.
  * @static
  */
	isNumber: function isNumber(value) {
		return typeof value === 'number' && isFinite(value);
	},


	/**
  * Check if the passed value is an object
  *
  * @memberof Lang
  * @method isObject
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is an object, false otherwise.
  * @static
  */
	isObject: function isObject(value) {
		var valueType = typeof value === 'undefined' ? 'undefined' : _typeof(value);

		return value && (valueType === 'object' || Lang.isFunction(value));
	},


	/**
  * Check if the passed value is a string.
  *
  * @memberof Lang
  * @method isString
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is a string, false otherwise.
  * @static
  */
	isString: function isString(value) {
		return typeof value === 'string';
	},


	/**
  * Adds all properties from the supplier to the receiver.
  * The function will add all properties, not only these owned by the supplier.
  *
  * @memberof Lang
  * @method mix
  * @param {Object} receiver The object which will receive properties.
  * @param {Object} supplier The object which provides properties.
  * @return {Object} The modified receiver.
  * @static
  */
	mix: function mix(receiver, supplier) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;

		for (var key in supplier) {
			if (hasOwnProperty.call(supplier, key)) {
				receiver[key] = supplier[key];
			}
		}
	},


	/**
  * Converts value to Integer.
  *
  * @memberof Lang
  * @method toInt
  * @param {Any} value The value which have to be converted to Integer.
  * @return {Integer} The converted value.
  * @static
  */
	toInt: function toInt(value) {
		return parseInt(value, 10);
	}
};

exports.default = Lang;

/***/ }),

/***/ "./src/oop/oop.js":
/*!************************!*\
  !*** ./src/oop/oop.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _lang = __webpack_require__(/*! ./lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sets the prototype, constructor and superclass properties to support an inheritance strategy
 * that can chain constructors and methods. Static members will not be inherited.
 *
 * @memberof OOP
 * @method extend
 * @param {Function} receiver The class which will extend another class.
 * @param {Function} supplier The class which will provide the properties the child class.
 * @param {Object} protoProps Prototype properties to add/override.
 * @param {Object} staticProps Static properties to add/overwrite.
 * @return {Function} The extended class.
 * @static
 */
var extend = function extend(receiver, supplier, protoProps, staticProps) {
	if (!supplier || !receiver) {
		throw new Error('extend failed, verify dependencies');
	}

	var supplierProto = supplier.prototype;

	var receiverProto = Object.create(supplierProto);
	receiver.prototype = receiverProto;

	receiverProto.constructor = receiver;
	receiver.superclass = supplierProto;

	// assign constructor property

	if (supplier !== Object && supplierProto.constructor === Object.prototype.constructor) {
		supplierProto.constructor = supplier;
	}

	// add prototype overrides

	if (protoProps) {
		_lang2.default.mix(receiverProto, protoProps);
	}

	// add object overrides

	if (staticProps) {
		_lang2.default.mix(receiver, staticProps);
	}

	return receiver;
}; /**
    * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
    * SPDX-License-Identifier: LGPL-3.0-or-later
    */

exports.default = extend;

/***/ }),

/***/ "./src/plugins/DragEvent.es.js":
/*!*************************************!*\
  !*** ./src/plugins/DragEvent.es.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var DragEvent = function () {
	function DragEvent(window, document) {
		_classCallCheck(this, DragEvent);

		this.document = document;
		this.window = window;

		this.events = {
			keydown: this.keydown.bind(this),
			mousemove: this.mousemove.bind(this),
			mouseup: this.mouseup.bind(this)
		};
	}

	_createClass(DragEvent, [{
		key: 'start',
		value: function start(event) {
			event.preventDefault();
			event.stopPropagation();

			this.target = event.target;

			this.className = this.target.className;

			this.startPos = {
				x: event.clientX,
				y: event.clientY
			};

			this.update(event);

			this.document.addEventListener('keydown', this.events.keydown, false);
			this.document.addEventListener('mousemove', this.events.mousemove, false);
			this.document.addEventListener('mouseup', this.events.mouseup, false);

			this.document.body.classList.add('dragging-' + this.className);

			if (typeof this.onStart === 'function') {
				this.onStart();
			}
		}
	}, {
		key: 'update',
		value: function update(event) {
			this.currentPos = {
				x: event.clientX,
				y: event.clientY
			};

			this.delta = {
				x: event.clientX - this.startPos.x,
				y: event.clientY - this.startPos.y
			};

			this.keys = {
				alt: event.altKey,
				ctrl: event.ctrlKey,
				shift: event.shiftKey
			};
		}
	}, {
		key: 'mousemove',
		value: function mousemove(event) {
			this.update(event);

			if (typeof this.onDrag === 'function') {
				this.onDrag();
			}

			if (event.which === 0) {
				this.mouseup(event);
			}
		}
	}, {
		key: 'keydown',
		value: function keydown(event) {
			if (event.keyCode === 27) {
				this.release();
			}
		}
	}, {
		key: 'mouseup',
		value: function mouseup(event) {
			this.update(event);

			this.release();

			if (typeof this.onComplete === 'function') {
				this.onComplete();
			}
		}
	}, {
		key: 'release',
		value: function release() {
			this.document.body.classList.remove('dragging-' + this.className);

			this.document.removeEventListener('keydown', this.events.keydown, false);
			this.document.removeEventListener('mousemove', this.events.mousemove, false);
			this.document.removeEventListener('mouseup', this.events.mouseup, false);

			if (typeof this.onRelease === 'function') {
				this.onRelease();
			}
		}
	}]);

	return DragEvent;
}();

exports.DragEvent = DragEvent;
exports.default = DragEvent;

/***/ }),

/***/ "./src/plugins/Resizer.es.js":
/*!***********************************!*\
  !*** ./src/plugins/Resizer.es.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Resizer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _DragEvent = __webpack_require__(/*! ./DragEvent.es */ "./src/plugins/DragEvent.es.js");

var _DragEvent2 = _interopRequireDefault(_DragEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var IMAGE_HANDLES = ['tl', 'tr', 'bl', 'br'];

var POSITION_ELEMENT_FN = {
	bl: function bl(handle, left, top, box) {
		positionElement(handle, -3 + left, box.height - 4 + top);
	},
	br: function br(handle, left, top, box) {
		positionElement(handle, box.width - 4 + left, box.height - 4 + top);
	},
	rm: function rm(handle, left, top, box) {
		positionElement(handle, box.width - 4 + left, Math.round(box.height / 2) - 3 + top);
	},
	tl: function tl(handle, left, top, _box) {
		positionElement(handle, left - 3, top - 3);
	},
	tr: function tr(handle, left, top, box) {
		positionElement(handle, box.width - 4 + left, -3 + top);
	}
};

var positionElement = function positionElement(el, left, top) {
	el.style.left = left + 'px';
	el.style.top = top + 'px';
};

var getBoundingBox = function getBoundingBox(window, el) {
	var rect = el.getBoundingClientRect();

	return {
		height: rect.height,
		left: rect.left + window.pageXOffset,
		top: rect.top + window.pageYOffset,
		width: rect.width
	};
};

var Resizer = function () {
	function Resizer(editor) {
		var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		_classCallCheck(this, Resizer);

		this.cfg = cfg;
		this.editor = editor;

		this.document = editor.document ? editor.document.$ : document;
		this.window = editor.window ? editor.window.$ : window;

		this.box = null;
		this.container = null;
		this.handles = {};
		this.preview = null;
		this.previewBox = null;
		this.result = null;

		this.init();
	}

	_createClass(Resizer, [{
		key: 'init',
		value: function init() {
			var _this = this;

			this.container = this.document.createElement('div');
			this.container.id = 'ckimgrsz';

			this.preview = this.document.createElement('span');

			this.container.appendChild(this.preview);

			this.handles = {};

			IMAGE_HANDLES.forEach(function (handleName) {
				_this.handles[handleName] = _this.createHandle(handleName);
			});

			var keys = Object.keys(this.handles);

			for (var i = 0; i < keys.length; i++) {
				this.container.appendChild(this.handles[keys[i]]);
			}
		}
	}, {
		key: 'createHandle',
		value: function createHandle(name) {
			var el = this.document.createElement('i');

			el.classList.add(name);

			return el;
		}
	}, {
		key: 'isHandle',
		value: function isHandle(el) {
			var keys = Object.keys(this.handles);

			var result = false;

			for (var i = 0; i < keys.length; i++) {
				if (this.handles[keys[i]] === el) {
					result = true;
				}
			}

			return result;
		}
	}, {
		key: 'show',
		value: function show(el) {
			var uiNode = this.editor.config.uiNode || document.body;

			this.el = el;

			this.box = getBoundingBox(this.window, this.el);

			positionElement(this.container, this.box.left, this.box.top + uiNode.scrollTop);

			uiNode.appendChild(this.container);

			this.el.classList.add('ckimgrsz');

			this.showHandles();
		}
	}, {
		key: 'hide',
		value: function hide() {
			var elements = this.document.getElementsByClassName('ckimgrsz');

			for (var i = 0; i < elements.length; i++) {
				elements[i].classList.remove('ckimgrsz');
			}

			this.hideHandles();

			if (this.container.parentNode) {
				this.container.parentNode.removeChild(this.container);
			}
		}
	}, {
		key: 'initDrag',
		value: function initDrag(event) {
			var _this2 = this;

			if (event.button !== 0) {
				return;
			}

			var drag = new _DragEvent2.default(this.window, this.document);

			drag.onStart = function () {
				_this2.showPreview();

				_this2.isDragging = true;

				_this2.editor.getSelection().lock();
			};

			drag.onDrag = function () {
				_this2.calculateSize(drag);

				var editorBounds = _this2.editor.element.$.getBoundingClientRect();

				if (_this2.previewBox.width >= editorBounds.width) {
					return;
				}

				_this2.updatePreview();

				var box = _this2.previewBox;

				_this2.updateHandles(box, box.left, box.top);
			};

			drag.onRelease = function () {
				_this2.hidePreview();

				_this2.isDragging = false;

				_this2.hide();

				_this2.editor.getSelection().unlock();

				_this2.editor.fire('saveSnapshot');
			};

			drag.onComplete = function () {
				_this2.resizeComplete();

				_this2.editor.fire('saveSnapshot');
			};

			drag.start(event);
		}
	}, {
		key: 'updateHandles',
		value: function updateHandles(box) {
			var left = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
			var top = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

			var keys = Object.keys(this.handles);

			for (var i = 0; i < keys.length; i++) {
				POSITION_ELEMENT_FN[keys[i]](this.handles[keys[i]], left, top, box);
			}
		}
	}, {
		key: 'showHandles',
		value: function showHandles() {
			this.updateHandles(this.box);

			var keys = Object.keys(this.handles);

			for (var i = 0; i < keys.length; i++) {
				this.handles[keys[i]].style.display = 'block';
			}
		}
	}, {
		key: 'hideHandles',
		value: function hideHandles() {
			var keys = Object.keys(this.handles);

			for (var i = 0; i < keys.length; i++) {
				this.handles[keys[i]].style.display = 'none';
			}
		}
	}, {
		key: 'showPreview',
		value: function showPreview() {
			this.calculateSize();

			this.updatePreview();

			this.preview.style.display = 'block';
		}
	}, {
		key: 'updatePreview',
		value: function updatePreview() {
			positionElement(this.preview, this.previewBox.left, this.previewBox.top);

			this.preview.style.height = this.previewBox.height + 'px';
			this.preview.style.width = this.previewBox.width + 'px';
		}
	}, {
		key: 'hidePreview',
		value: function hidePreview() {
			var box = getBoundingBox(this.window, this.preview);

			this.result = {
				height: box.height,
				width: box.width
			};

			this.preview.style.display = 'none';
		}
	}, {
		key: 'calculateSize',
		value: function calculateSize(data) {
			this.previewBox = {
				height: this.box.height,
				left: 0,
				top: 0,
				width: this.box.width
			};

			if (!data) {
				return;
			}

			var className = data.target.className;

			if (className.indexOf('r') >= 0) {
				this.previewBox.width = Math.max(32, this.box.width + data.delta.x);
			}

			if (className.indexOf('b') >= 0) {
				this.previewBox.height = Math.max(32, this.box.height + data.delta.y);
			}

			if (className.indexOf('l') >= 0) {
				this.previewBox.width = Math.max(32, this.box.width - data.delta.x);
			}

			if (className.indexOf('t') >= 0) {
				this.previewBox.height = Math.max(32, this.box.height - data.delta.y);
			}

			if (className.indexOf('m') < 0 && !data.keys.shift) {
				var ratio = this.box.width / this.box.height;

				if (this.previewBox.width / this.previewBox.height > ratio) {
					this.previewBox.height = Math.round(this.previewBox.width / ratio);
				} else {
					this.previewBox.width = Math.round(this.previewBox.height * ratio);
				}
			}

			if (className.indexOf('l') >= 0) {
				this.previewBox.left = this.box.width - this.previewBox.width;
			}

			if (className.indexOf('t') >= 0) {
				this.previewBox.top = this.box.height - this.previewBox.height;
			}
		}
	}, {
		key: 'resizeComplete',
		value: function resizeComplete() {
			this.cfg.onComplete(this.el, this.result.width, this.result.height);
		}
	}]);

	return Resizer;
}();

exports.Resizer = Resizer;
exports.default = Resizer;

/***/ }),

/***/ "./src/plugins/addimages.js":
/*!**********************************!*\
  !*** ./src/plugins/addimages.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var isIE = CKEDITOR.env.ie;

if (!CKEDITOR.plugins.get('ae_addimages')) {
	/**
  * CKEditor plugin which allows Drag&Drop of images directly into the editable area. The image will be encoded
  * as Data URI. An event `beforeImageAdd` will be fired with the list of dropped images. If any of the listeners
  * returns `false` or cancels the event, the images won't be added to the content. Otherwise,
  * an event `imageAdd` will be fired with the inserted element into the editable area.
  *
  * @class CKEDITOR.plugins.ae_addimages
  */

	/**
  * Fired before adding images to the editor.
  *
  * @event CKEDITOR.plugins.ae_addimages#beforeImageAdd
  * @instance
  * @memberof CKEDITOR.plugins.ae_addimages
  * @param {Array} imageFiles Array of image files
  */

	/**
  * Fired when an image is being added to the editor successfully.
  *
  * @event CKEDITOR.plugins.ae_addimages#imageAdd
  * @instance
  * @memberof CKEDITOR.plugins.ae_addimages
  * @param {CKEDITOR.dom.element} el The created image with src as Data URI
  * @param {File} file The image file
  */

	CKEDITOR.plugins.add('ae_addimages', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function registers a 'dragenter', 'dragover', 'drop' and `paste` events on the editing area.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			var _this = this;

			editor.once('contentDom', function () {
				var editable = editor.editable();

				editable.attachListener(editable, 'dragenter', _this._onDragEnter, _this, {
					editor: editor
				});

				editable.attachListener(editable, 'dragover', _this._onDragOver, _this, {
					editor: editor
				});

				editable.attachListener(editable, 'drop', _this._onDragDrop, _this, {
					editor: editor
				});

				editable.attachListener(editable, 'paste', _this._onPaste, _this, {
					editor: editor
				});
			});
		},


		/**
   * Accepts an array of dropped files to the editor. Then, it filters the images and sends them for further
   * processing to {{#crossLink "CKEDITOR.plugins.ae_addimages/_processFile:method"}}{{/crossLink}}
   *
   * @fires CKEDITOR.plugins.ae_addimages#beforeImageAdd
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _handleFiles
   * @param {Array} files Array of dropped files. Only the images from this list will be processed.
   * @param {Object} editor The current editor instance
   * @protected
   */
		_handleFiles: function _handleFiles(files, editor) {
			var file = void 0;
			var i = void 0;

			var imageFiles = [];

			for (i = 0; i < files.length; i++) {
				file = files[i];

				if (file.type.indexOf('image') === 0) {
					imageFiles.push(file);
				}
			}

			var result = editor.fire('beforeImageAdd', {
				imageFiles: imageFiles
			});

			if (result) {
				for (i = 0; i < imageFiles.length; i++) {
					file = imageFiles[i];

					this._processFile(file, editor);
				}
			}

			return false;
		},


		/**
   * Handles drag drop event. The function will create a selection from the current
   * point and will send a list of files to be processed to
   * {{#crossLink "CKEDITOR.plugins.ae_addimages/_handleFiles:method"}}{{/crossLink}} method.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _onDragDrop
   * @param {CKEDITOR.dom.event} event dragdrop event, as received natively from CKEditor
   * @protected
   */
		_onDragDrop: function _onDragDrop(event) {
			var nativeEvent = event.data.$;

			var transferFiles = nativeEvent.dataTransfer.files;

			if (transferFiles.length > 0) {
				new CKEDITOR.dom.event(nativeEvent).preventDefault();

				var editor = event.listenerData.editor;

				event.listenerData.editor.createSelectionFromPoint(nativeEvent.clientX, nativeEvent.clientY);

				this._handleFiles(transferFiles, editor);
			}
		},


		/**
   * Handles drag enter event. In case of IE, this function will prevent the event.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _onDragEnter
   * @param {DOM event} event dragenter event, as received natively from CKEditor
   * @protected
   */
		_onDragEnter: function _onDragEnter(event) {
			if (isIE) {
				this._preventEvent(event);
			}
		},


		/**
   * Handles drag over event. In case of IE, this function will prevent the event.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _onDragOver
   * @param {DOM event} event dragover event, as received natively from CKEditor
   * @protected
   */
		_onDragOver: function _onDragOver(event) {
			if (isIE) {
				this._preventEvent(event);
			}
		},


		/**
   * Checks if the pasted data is image and passes it to
   * {{#crossLink "CKEDITOR.plugins.ae_addimages/_processFile:method"}}{{/crossLink}} for processing.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _onPaste
   * @param {CKEDITOR.dom.event} event A `paste` event, as received natively from CKEditor
   * @protected
   */
		_onPaste: function _onPaste(event) {
			if (event.data && event.data.$ && event.data.$.clipboardData && event.data.$.clipboardData.items && event.data.$.clipboardData.items.length > 0) {
				var pastedData = event.data.$.clipboardData.items[0];

				if (pastedData.type.indexOf('image') === 0) {
					var imageFile = pastedData.getAsFile();

					this._processFile(imageFile, event.listenerData.editor);
				}
			}
		},


		/**
   * Prevents a native event.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _preventEvent
   * @param {DOM event} event The event to be prevented.
   * @protected
   */
		_preventEvent: function _preventEvent(event) {
			event = new CKEDITOR.dom.event(event.data.$);

			event.preventDefault();
			event.stopPropagation();
		},


		/**
   * Processes an image file. The function creates an img element and sets as source
   * a Data URI, then fires an 'imageAdd' event via CKEditor's event system.
   *
   * @fires CKEDITOR.plugins.ae_addimages#imageAdd
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _preventEvent
   * @param {DOM event} event The event to be prevented.
   * @protected
   */
		_processFile: function _processFile(file, editor) {
			var reader = new FileReader();

			reader.addEventListener('loadend', function () {
				var bin = reader.result;

				var el = CKEDITOR.dom.element.createFromHtml('<img src="' + bin + '">');

				editor.insertElement(el);

				var imageData = {
					el: el,
					file: file
				};

				editor.fire('imageAdd', imageData);
			});

			reader.readAsDataURL(file);
		}
	});
}

/***/ }),

/***/ "./src/plugins/autolink.js":
/*!*********************************!*\
  !*** ./src/plugins/autolink.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

if (!CKEDITOR.plugins.get('ae_autolink')) {
	// Disables the auto URL detection feature in IE, their lacks functionality:
	// They convert the links only on space. We do on space, comma, semicolon and Enter.

	if (/MSIE ([^;]*)|Trident.*; rv:([0-9.]+)/.test(navigator.userAgent)) {
		document.execCommand('AutoUrlDetect', false, false);
	}

	var KEY_BACK = 8;

	var KEY_COMMA = 188;

	var KEY_ENTER = 13;

	var KEY_SEMICOLON = 186;

	var KEY_SPACE = 32;

	var DELIMITERS = [KEY_COMMA, KEY_ENTER, KEY_SEMICOLON, KEY_SPACE];

	var REGEX_LAST_WORD = /[^\s]+/gim;

	// Seen at https://stackoverflow.com/a/5717133/2103996

	var REGEX_URL = '^(https?:\\/\\/)?' + // protocol
	'((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|' + // domain name
	'((\\d{1,3}\\.){3}\\d{1,3}))' + // OR ip (v4) address
	'(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*' + // port and path
	'(\\?[;&a-z\\d%_.~+=-]*)?' + // query string
	'(\\#[-a-z\\d_]*)?$';

	var REGEX_EMAIL = /[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}/i;

	/**
  * CKEditor plugin which automatically generates links when user types text which looks like URL.
  *
  * @class CKEDITOR.plugins.ae_autolink
  * @constructor
  */
	CKEDITOR.plugins.add('ae_autolink', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function registers the `keyup` event on the editing area.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			var _this = this;

			editor.once('contentDom', function () {
				var editable = editor.editable();

				editable.attachListener(editable, 'keyup', _this._onKeyUp, _this, {
					editor: editor
				});
			});

			editor.on('paste', function (event) {
				if (event.data.method === 'paste') {
					if (event.data.dataValue.indexOf('<') > -1 || event.data.dataValue.indexOf('&lt;') > -1) {
						if (event.data.dataValue.indexOf('<u><font color="') > -1) {
							event.data.dataValue = event.data.dataValue.replace(/<u><font color="#(.*?)">|<\/font><\/u>/g, '');
						}

						return;
					}

					var instance = _this;

					event.data.dataValue = event.data.dataValue.replace(RegExp(REGEX_URL, 'gim'), function (url) {
						if (instance._isValidURL(url)) {
							if (instance._isValidEmail(url)) {
								return '<a href="mailto:' + url + '">' + url + '</a>';
							} else {
								return '<a href="' + url + '">' + url + '</a>';
							}
						}
					});
				}
			});
		},


		/**
   * Retrieves the last word introduced by the user. Reads from the current
   * caret position backwards until it finds the first white space.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _getLastWord
   * @protected
   * @return {String} The last word introduced by user
   */
		_getLastWord: function _getLastWord(editor) {
			var range = editor.getSelection().getRanges()[0];

			if (!range) {
				return;
			}

			var offset = range.startOffset;

			var previousText = '';

			// The user pressed Enter, so we have to look on the previous node

			if (this._currentKeyCode === KEY_ENTER) {
				var previousNode = range.startContainer.getPrevious();

				var lastChild = void 0;

				if (previousNode) {
					// If previous node is a SPACE, (it does not have 'getLast' method),
					// ignore it and find the previous text node

					while (!previousNode.getLast) {
						previousNode = previousNode.getPrevious();
					}

					lastChild = previousNode.getLast();

					// Depending on the browser, the last child node may be a <BR>
					// (which does not have 'getText' method),
					// so ignore it and find the previous text node

					while (lastChild && !lastChild.getText()) {
						lastChild = lastChild.getPrevious();
					}
				}

				// Check if the lastChild is already a link

				if (!(lastChild && lastChild.$.href)) {
					this._startContainer = lastChild;
					previousText = lastChild ? lastChild.getText() : '';
					this._offset = previousText.length;
				}
			} else {
				this._startContainer = range.startContainer;

				// Last character is the delimiter, ignore it

				previousText = this._startContainer.getText().substring(0, offset - 1);

				this._offset = offset - 1;
			}

			var lastWord = '';

			var match = previousText.match(REGEX_LAST_WORD);

			if (match) {
				lastWord = match.pop();
			}

			return lastWord;
		},


		/**
   * Checks if the given link is a valid Email.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method isValidEmail
   * @param {String} link The email we want to know if it is a valid Email
   * @protected
   * @return {Boolean} Returns true if the email is a valid Email, false otherwise
   */
		_isValidEmail: function _isValidEmail(email) {
			return REGEX_EMAIL.test(email);
		},


		/**
   * Checks if the given link is a valid URL.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method isValidURL
   * @param {String} link The link we want to know if it is a valid URL
   * @protected
   * @return {Boolean} Returns true if the link is a valid URL, false otherwise
   */
		_isValidURL: function _isValidURL(link) {
			return RegExp(REGEX_URL, 'i').test(link);
		},


		/**
   * Listens to the `keydown` event and if the keycode is `Backspace`, removes the previously
   * created link.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _onKeyDown
   * @param {EventFacade} event EventFacade object
   * @protected
   */
		_onKeyDown: function _onKeyDown(event) {
			var nativeEvent = event.data.$;

			var editor = event.listenerData.editor;

			var editable = editor.editable();

			editable.removeListener('keydown', this._onKeyDown);

			if (nativeEvent.keyCode === KEY_BACK) {
				event.cancel();
				event.data.preventDefault();

				this._removeLink(editor);
			}

			this._ckLink = null;
		},


		/**
   * Listens to the `Enter` and `Space` key events in order to check if the last word
   * introduced by the user should be replaced by a link element.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _onKeyUp
   * @param {EventFacade} event EventFacade object
   * @protected
   */
		_onKeyUp: function _onKeyUp(event) {
			var nativeEvent = event.data.$;

			this._currentKeyCode = nativeEvent.keyCode;

			if (DELIMITERS.indexOf(this._currentKeyCode) !== -1) {
				var editor = event.listenerData.editor;

				var lastWord = this._getLastWord(editor);

				if (this._isValidURL(lastWord)) {
					this._replaceContentByLink(editor, lastWord);
				}
			}
		},


		/**
   * Replaces content by a link element.
   *
   * @fires CKEDITOR.plugins.ae_autolink#autolinkAdd
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _replaceContentByLink
   * @param {String} content The text that has to be replaced by an link element
   * @protected
   */
		_replaceContentByLink: function _replaceContentByLink(editor, content) {
			var range = editor.createRange();
			var node = CKEDITOR.dom.element.get(this._startContainer);
			var offset = this._offset;

			// Select the content, so CKEDITOR.Link can properly replace it

			range.setStart(node, offset - content.length);
			range.setEnd(node, offset);
			range.select();

			var ckLink = new CKEDITOR.Link(editor);
			ckLink.create(content);
			this._ckLink = ckLink;

			var linkNode = ckLink.getFromSelection();
			editor.fire('autolinkAdd', linkNode);

			this._subscribeToKeyEvent(editor);

			// Now range is on the link and it is selected. We have to
			// return focus to the caret position.

			range = editor.getSelection().getRanges()[0];

			// If user pressed `Enter`, get the next editable node at position 0,
			// otherwise set the cursor at the next character of the link (the white space)

			if (this._currentKeyCode === KEY_ENTER) {
				var nextEditableNode = range.getNextEditableNode();

				range.setStart(nextEditableNode, 0);
				range.setEnd(nextEditableNode, 0);
			} else {
				var enclosedNode = range.getEnclosedNode();

				range.setStart(enclosedNode, 0);
				range.setEnd(enclosedNode, 0);
			}

			range.select();
		},


		/**
   * Fired when a URL is detected in text and converted to a link.
   *
   * @event CKEDITOR.plugins.ae_autolink#autolinkAdd
   * @memberof CKEDITOR.plugins.ae_autolink
   * @param {CKEDITOR.dom.element} el Node of the created link.
   */

		/**
   * Removes the created link element, and replaces it by its text.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _removeLink
   * @protected
   */
		_removeLink: function _removeLink(editor) {
			var range = editor.getSelection().getRanges()[0];
			var caretOffset = range.startOffset;

			// Select the link, so CKEDITOR.Link can properly remove it

			var linkNode = this._startContainer.getNext() || this._startContainer;

			var newRange = editor.createRange();
			newRange.setStart(linkNode, 0);
			newRange.setEndAfter(linkNode);
			newRange.select();

			this._ckLink.remove();

			// Return focus to the caret position

			range.setEnd(range.startContainer, caretOffset);
			range.setStart(range.startContainer, caretOffset);

			range.select();
		},


		/**
   * Subscribe to a key event of the editable aria.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _subscribeToKeyEvent
   * @protected
   */
		_subscribeToKeyEvent: function _subscribeToKeyEvent(editor) {
			var editable = editor.editable();

			// Change the priority of keydown listener - 1 means the highest priority.
			// In Chrome on pressing `Enter` the listener is not being invoked.
			// See http://dev.ckeditor.com/ticket/11861 for more information.

			editable.attachListener(editable, 'keydown', this._onKeyDown, this, {
				editor: editor
			}, 1);
		}
	});
}

/***/ }),

/***/ "./src/plugins/autolist.js":
/*!*********************************!*\
  !*** ./src/plugins/autolist.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

if (!CKEDITOR.plugins.get('ae_autolist')) {
	var KEY_BACK = 8;

	var KEY_SPACE = 32;

	var DEFAULT_CONFIG = [{
		regex: /^\*$/,
		type: 'bulletedlist'
	}, {
		regex: /^1\.$/,
		type: 'numberedlist'
	}];

	/**
  * CKEditor plugin which automatically generates ordered/unordered list when user types text which looks like a list.
  *
  * @class CKEDITOR.plugins.ae_autolist
  * @constructor
  */
	CKEDITOR.plugins.add('ae_autolist', {
		/**
   * Initialization of the plugin, part of CKeditor plugin lifecycle.
   * The function registers the `keydown` event on the content editing area.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolist
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			var _this = this;

			editor.once('contentDom', function () {
				var editable = editor.editable();

				editable.attachListener(editable, 'keydown', _this._onKeyDown, _this, {
					editor: editor
				});
			});
		},


		/**
   * Checks for pressing the `Backspace` key in order to undo the list creation.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolist
   * @method _checkForBackspaceAndUndo
   * @param {Event} event Event object
   * @protected
   */
		_checkForBackspaceAndUndo: function _checkForBackspaceAndUndo(event) {
			var editor = event.listenerData.editor;

			var nativeEvent = event.data.$;

			var editable = editor.editable();

			editable.removeListener('keydown', this._checkForBackspaceAndUndo);

			if (nativeEvent.keyCode === KEY_BACK) {
				editor.execCommand('undo');
				editor.insertHtml(event.listenerData.bullet + '&nbsp;');
				event.data.preventDefault();
			}
		},


		/**
   * Checks current line to find match with MATCHES object to create OL or UL.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolist
   * @method _checkLine
   * @param {editor} Editor object
   * @protected
   * @return {Object|null} Returns an object which contains the detected list config if any
   */
		_getListConfig: function _getListConfig(editor) {
			var configRegex = editor.config.autolist || DEFAULT_CONFIG;

			var range = editor.getSelection().getRanges()[0];

			var textContainer = range.endContainer.getText();

			var bullet = textContainer.substring(0, range.startOffset);

			var text = textContainer.substring(range.startOffset, textContainer.length);

			var index = 0;

			var regexLen = configRegex.length;

			var autolistCfg = null;

			while (!autolistCfg && regexLen > index) {
				var regexItem = configRegex[index];

				if (regexItem.regex.test(bullet)) {
					autolistCfg = {
						bullet: bullet,
						editor: editor,
						text: text,
						type: regexItem.type
					};

					break;
				}

				index++;
			}

			return autolistCfg;
		},


		/**
   * Create list with different types: Bulleted or Numbered list
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolist
   * @method _createList
   * @param {Object} listConfig Object that contains bullet, text and type for creating the list
   * @protected
   */
		_createList: function _createList(listConfig) {
			var editor = listConfig.editor;

			var range = editor.getSelection().getRanges()[0];

			range.endContainer.setText(listConfig.text);
			editor.execCommand(listConfig.type);

			var editable = editor.editable();

			// Subscribe to keydown in order to check if the next key press is `Backspace`.
			// If so, the creation of the list will be discarded.

			editable.attachListener(editable, 'keydown', this._checkForBackspaceAndUndo, this, {
				editor: editor,
				bullet: listConfig.bullet
			}, 1);
		},


		/**
   * Listens to the `Space` key events to check if the last word
   * introduced by the user should be replaced by a list (OL or UL)
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolist
   * @method _onKeyDown
   * @param {Event} event Event object
   * @protected
   */
		_onKeyDown: function _onKeyDown(event) {
			var nativeEvent = event.data.$;

			if (nativeEvent.keyCode === KEY_SPACE) {
				var listConfig = this._getListConfig(event.listenerData.editor);

				if (listConfig) {
					event.data.preventDefault();
					this._createList(listConfig);
				}
			}
		}
	});
}

/***/ }),

/***/ "./src/plugins/dragresize.js":
/*!***********************************!*\
  !*** ./src/plugins/dragresize.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * CKEditor plugin: Dragable image resizing
 * https://github.com/sstur/ck-dragresize
 * - Shows semi-transparent overlay while resizing
 * - Enforces Aspect Ratio (unless holding shift)
 * - Snap to size of other images in editor
 * - Escape while dragging cancels resize
 */
if (!CKEDITOR.plugins.get('ae_dragresize')) {
	var IMAGE_HANDLES = {
		both: ['tl', 'tm', 'tr', 'lm', 'rm', 'bl', 'bm', 'br'],
		height: ['tl', 'tm', 'tr', 'bl', 'bm', 'br'],
		scale: ['tl', 'tr', 'bl', 'br'],
		width: ['tl', 'tr', 'lm', 'rm', 'bl', 'br']
	};

	var POSITION_ELEMENT_FN = {
		bl: function bl(handle, left, top, box) {
			positionElement(handle, -3 + left, box.height - 4 + top);
		},
		bm: function bm(handle, left, top, box) {
			positionElement(handle, Math.round(box.width / 2) - 3 + left, box.height - 4 + top);
		},
		br: function br(handle, left, top, box) {
			positionElement(handle, box.width - 4 + left, box.height - 4 + top);
		},
		lm: function lm(handle, left, top, box) {
			positionElement(handle, -3 + left, Math.round(box.height / 2) - 3 + top);
		},
		tl: function tl(handle, left, top, _box) {
			positionElement(handle, left - 3, top - 3);
		},
		tm: function tm(handle, left, top, box) {
			positionElement(handle, Math.round(box.width / 2) - 3 + left, -3 + top);
		},
		tr: function tr(handle, left, top, box) {
			positionElement(handle, box.width - 4 + left, -3 + top);
		},
		rm: function rm(handle, left, top, box) {
			positionElement(handle, box.width - 4 + left, Math.round(box.height / 2) - 3 + top);
		}
	};

	var IMAGE_SNAP_TO_SIZE = 7;

	var isFirefox = 'MozAppearance' in document.documentElement.style;

	var isWebKit = 'WebkitAppearance' in document.documentElement.style;

	var enablePlugin = isWebKit || isFirefox;

	if (enablePlugin) {
		// CSS is added in a compressed form

		CKEDITOR.addCss('img::selection{color:rgba(0,0,0,0)}img.ckimgrsz{outline:1px dashed #000}#ckimgrsz{position:absolute;width:0;height:0;cursor:default;z-index:10001}#ckimgrsz span{display:none;position:absolute;top:0;left:0;width:0;height:0;background-size:100% 100%;opacity:.65;outline:1px dashed #000}#ckimgrsz i{position:absolute;display:block;width:5px;height:5px;background:#fff;border:1px solid #000}#ckimgrsz i.active,#ckimgrsz i:hover{background:#000}#ckimgrsz i.br,#ckimgrsz i.tl{cursor:nwse-resize}#ckimgrsz i.bm,#ckimgrsz i.tm{cursor:ns-resize}#ckimgrsz i.bl,#ckimgrsz i.tr{cursor:nesw-resize}#ckimgrsz i.lm,#ckimgrsz i.rm{cursor:ew-resize}body.dragging-br,body.dragging-br *,body.dragging-tl,body.dragging-tl *{cursor:nwse-resize!important}body.dragging-bm,body.dragging-bm *,body.dragging-tm,body.dragging-tm *{cursor:ns-resize!important}body.dragging-bl,body.dragging-bl *,body.dragging-tr,body.dragging-tr *{cursor:nesw-resize!important}body.dragging-lm,body.dragging-lm *,body.dragging-rm,body.dragging-rm *{cursor:ew-resize!important}');
	}

	/**
  * Initializes the plugin
  */
	CKEDITOR.plugins.add('ae_dragresize', {
		onLoad: function onLoad() {
			if (!enablePlugin) {
				return;
			}
		},
		init: function init(editor) {
			if (!enablePlugin) {
				return;
			}

			editor.once('contentDom', function (_evt) {
				_init(editor);
			});
		}
	});

	function _init(editor) {
		var window = editor.window.$;

		var document = editor.document.$;

		if (isFirefox) {
			// Disable the native image resizing

			document.execCommand('enableObjectResizing', false, false);
		}

		var snapToSize = typeof IMAGE_SNAP_TO_SIZE === 'undefined' ? null : IMAGE_SNAP_TO_SIZE;

		editor.config.imageScaleResize = editor.config.imageScaleResize || 'both';

		var resizer = new Resizer(editor, {
			imageScaleResize: editor.config.imageScaleResize,
			snapToSize: snapToSize
		});

		var mouseDownListener = function mouseDownListener(e) {
			if (resizer.isHandle(e.target)) {
				resizer.initDrag(e);
			}
		};

		document.addEventListener('mousedown', mouseDownListener, false);

		function selectionChange() {
			var selection = editor.getSelection();

			if (!selection) {
				return;
			}

			// If an element is selected and that element is an IMG

			if (selection.getType() !== CKEDITOR.SELECTION_NONE && selection.getStartElement().is('img')) {
				// And we're not right or middle clicking on the image

				if (!window.event || !window.event.button || window.event.button === 0) {
					resizer.show(selection.getStartElement().$);
				}
			} else {
				resizer.hide();
			}
		}

		editor.on('selectionChange', selectionChange);

		editor.on('getData', function (e) {
			var html = e.data.dataValue || '';
			html = html.replace(/<div id="ckimgrsz"([\s\S]*?)<\/div>/i, '');
			html = html.replace(/\b(ckimgrsz)\b/g, '');
			e.data.dataValue = html;
		});

		editor.on('beforeUndoImage', function () {
			// Remove the handles before undo images are saved

			resizer.hide();
		});

		editor.on('afterUndoImage', function () {
			// Restore the handles after undo images are saved

			selectionChange();
		});

		editor.on('blur', function () {
			// Remove the handles when editor loses focus

			resizer.hide();
		});

		editor.on('beforeModeUnload', function self() {
			editor.removeListener('beforeModeUnload', self);
			resizer.hide();
		});

		editor.on('destroy', function () {
			var resizeElement = document.getElementById('ckimgrsz');

			if (resizeElement) {
				resizeElement.remove();
			}

			if (isFirefox) {
				document.execCommand('enableObjectResizing', false, true);
			}

			document.removeEventListener('mousedown', mouseDownListener);
		});

		// Update the selection when the browser window is resized

		var resizeTimeout = void 0;
		editor.window.on('resize', function () {
			// Cancel any resize waiting to happen

			clearTimeout(resizeTimeout);

			// Delay resize to "debounce"

			resizeTimeout = setTimeout(selectionChange, 50);
		});
	}

	function Resizer(editor, cfg) {
		this.editor = editor;
		this.window = editor.window.$;
		this.document = editor.document.$;
		this.cfg = cfg || {};
		this.init();
	}

	Resizer.prototype = {
		init: function init() {
			var instance = this;

			var container = this.container = this.document.createElement('div');

			container.id = 'ckimgrsz';
			this.preview = this.document.createElement('span');
			container.appendChild(this.preview);

			var handles = this.handles = {};

			IMAGE_HANDLES[this.cfg.imageScaleResize].forEach(function (handleName) {
				handles[handleName] = instance.handles[handleName] = instance.createHandle(handleName);
			});

			for (var n in handles) {
				if (Object.prototype.hasOwnProperty.call(handles, n)) {
					container.appendChild(handles[n]);
				}
			}
		},
		createHandle: function createHandle(name) {
			var el = this.document.createElement('i');
			el.classList.add(name);

			return el;
		},
		isHandle: function isHandle(el) {
			var handles = this.handles;
			for (var n in handles) {
				if (handles[n] === el) {
					return true;
				}
			}

			return false;
		},
		show: function show(el) {
			var uiNode = this.editor.config.uiNode;

			var scrollTop = uiNode ? uiNode.scrollTop : 0;

			this.el = el;
			if (this.cfg.snapToSize) {
				this.otherImages = toArray(this.document.getElementsByTagName('img'));
				this.otherImages.splice(this.otherImages.indexOf(el), 1);
			}
			var box = this.box = getBoundingBox(this.window, el);
			positionElement(this.container, box.left, box.top + scrollTop);

			uiNode = uiNode || document.body;

			uiNode.appendChild(this.container);

			this.el.classList.add('ckimgrsz');
			this.showHandles();
		},
		hide: function hide() {
			// Remove class from all img.ckimgrsz

			var elements = this.document.getElementsByClassName('ckimgrsz');
			for (var i = 0; i < elements.length; ++i) {
				elements[i].classList.remove('ckimgrsz');
			}
			this.hideHandles();
			if (this.container.parentNode) {
				this.container.parentNode.removeChild(this.container);
			}
		},
		initDrag: function initDrag(e) {
			if (e.button !== 0) {
				// right-click or middle-click

				return;
			}
			var resizer = this;
			var drag = new DragEvent(this.window, this.document);
			drag.onStart = function () {
				resizer.showPreview();
				resizer.isDragging = true;
				resizer.editor.getSelection().lock();
			};
			drag.onDrag = function () {
				resizer.calculateSize(this);
				resizer.updatePreview();
				var box = resizer.previewBox;
				resizer.updateHandles(box, box.left, box.top);
			};
			drag.onRelease = function () {
				resizer.isDragging = false;
				resizer.hidePreview();
				resizer.hide();
				resizer.editor.getSelection().unlock();

				// Save an undo snapshot before the image is permanently changed

				resizer.editor.fire('saveSnapshot');
			};
			drag.onComplete = function () {
				resizer.resizeComplete();

				// Save another snapshot after the image is changed

				resizer.editor.fire('saveSnapshot');
			};
			drag.start(e);
		},
		updateHandles: function updateHandles(box, left, top) {
			left = left || 0;
			top = top || 0;
			var handles = this.handles;

			for (var handle in handles) {
				if (Object.prototype.hasOwnProperty.call(handles, handle)) {
					POSITION_ELEMENT_FN[handle](handles[handle], left, top, box);
				}
			}
		},
		showHandles: function showHandles() {
			var handles = this.handles;
			this.updateHandles(this.box);
			for (var n in handles) {
				if (Object.prototype.hasOwnProperty.call(handles, n)) {
					handles[n].style.display = 'block';
				}
			}
		},
		hideHandles: function hideHandles() {
			var handles = this.handles;
			for (var n in handles) {
				if (Object.prototype.hasOwnProperty.call(handles, n)) {
					handles[n].style.display = 'none';
				}
			}
		},
		showPreview: function showPreview() {
			this.preview.style.backgroundImage = 'url("' + this.el.src + '")';
			this.calculateSize();
			this.updatePreview();
			this.preview.style.display = 'block';
		},
		updatePreview: function updatePreview() {
			var box = this.previewBox;
			positionElement(this.preview, box.left, box.top);
			this.preview.style.width = this.previewBox.width + 'px';
			this.preview.style.height = this.previewBox.height + 'px';
		},
		hidePreview: function hidePreview() {
			var box = getBoundingBox(this.window, this.preview);
			this.result = {
				width: box.width,
				height: box.height
			};
			this.preview.style.display = 'none';
		},
		calculateSize: function calculateSize(data) {
			var box = this.previewBox = {
				top: 0,
				left: 0,
				width: this.box.width,
				height: this.box.height
			};

			if (!data) {
				return;
			}

			var attr = data.target.className;

			if (~attr.indexOf('r')) {
				box.width = Math.max(32, this.box.width + data.delta.x);
			}
			if (~attr.indexOf('b')) {
				box.height = Math.max(32, this.box.height + data.delta.y);
			}
			if (~attr.indexOf('l')) {
				box.width = Math.max(32, this.box.width - data.delta.x);
			}
			if (~attr.indexOf('t')) {
				box.height = Math.max(32, this.box.height - data.delta.y);
			}

			// if dragging corner, enforce aspect ratio (unless shift key is being held)

			if (attr.indexOf('m') < 0 && !data.keys.shift) {
				var ratio = this.box.width / this.box.height;
				if (box.width / box.height > ratio) {
					box.height = Math.round(box.width / ratio);
				} else {
					box.width = Math.round(box.height * ratio);
				}
			}

			var snapToSize = this.cfg.snapToSize;

			if (snapToSize) {
				var others = this.otherImages;
				for (var i = 0; i < others.length; i++) {
					var other = getBoundingBox(this.window, others[i]);
					if (Math.abs(box.width - other.width) <= snapToSize && Math.abs(box.height - other.height) <= snapToSize) {
						box.width = other.width;
						box.height = other.height;
						break;
					}
				}
			}

			// recalculate left or top position

			if (~attr.indexOf('l')) {
				box.left = this.box.width - box.width;
			}
			if (~attr.indexOf('t')) {
				box.top = this.box.height - box.height;
			}
		},
		resizeComplete: function resizeComplete() {
			resizeElement.call(this, this.el, this.result.width, this.result.height);
		}
	};

	function DragEvent(window, document) {
		this.window = window;
		this.document = document;
		this.events = {
			mousemove: bind(this.mousemove, this),
			keydown: bind(this.keydown, this),
			mouseup: bind(this.mouseup, this)
		};
	}

	DragEvent.prototype = {
		start: function start(e) {
			e.preventDefault();
			e.stopPropagation();
			this.target = e.target;
			this.attr = e.target.className;
			this.startPos = {
				x: e.clientX,
				y: e.clientY
			};
			this.update(e);
			var events = this.events;
			this.document.addEventListener('mousemove', events.mousemove, false);
			this.document.addEventListener('keydown', events.keydown, false);
			this.document.addEventListener('mouseup', events.mouseup, false);
			this.document.body.classList.add('dragging-' + this.attr);
			if (this.onStart) {
				this.onStart();
			}
		},
		update: function update(e) {
			this.currentPos = {
				x: e.clientX,
				y: e.clientY
			};
			this.delta = {
				x: e.clientX - this.startPos.x,
				y: e.clientY - this.startPos.y
			};
			this.keys = {
				shift: e.shiftKey,
				ctrl: e.ctrlKey,
				alt: e.altKey
			};
		},
		mousemove: function mousemove(e) {
			this.update(e);
			if (this.onDrag) {
				this.onDrag();
			}
			if (e.which === 0) {
				// mouse button released outside window; mouseup wasn't fired (Chrome)

				this.mouseup(e);
			}
		},
		keydown: function keydown(e) {
			// escape key cancels dragging

			if (e.keyCode === 27) {
				this.release();
			}
		},
		mouseup: function mouseup(e) {
			this.update(e);
			this.release();
			if (this.onComplete) {
				this.onComplete();
			}
		},
		release: function release() {
			this.document.body.classList.remove('dragging-' + this.attr);
			var events = this.events;
			this.document.removeEventListener('mousemove', events.mousemove, false);
			this.document.removeEventListener('keydown', events.keydown, false);
			this.document.removeEventListener('mouseup', events.mouseup, false);
			if (this.onRelease) {
				this.onRelease();
			}
		}
	};

	// helper functions

	function toArray(obj) {
		var len = obj.length;

		var arr = new Array(len);
		for (var i = 0; i < len; i++) {
			arr[i] = obj[i];
		}

		return arr;
	}

	function bind(fn, ctx) {
		if (fn.bind) {
			return fn.bind(ctx);
		}

		return function () {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			fn.apply(ctx, args);
		};
	}

	function positionElement(el, left, top) {
		el.style.left = String(left) + 'px';
		el.style.top = String(top) + 'px';
	}

	function resizeElement(el, width, height) {
		var imageScaleResize = this.editor.config.imageScaleResize;
		if (imageScaleResize === 'both') {
			el.setAttribute('width', String(width));
			el.style.width = String(width) + 'px';
			el.setAttribute('height', String(height));
			el.style.height = String(height) + 'px';
		} else if (imageScaleResize === 'width' || imageScaleResize === 'scale') {
			el.removeAttribute('height');
			el.style.height = 'auto';
			el.setAttribute('width', String(width));
			el.style.width = String(width) + 'px';
		} else if (imageScaleResize === 'height') {
			el.setAttribute('height', String(height));
			el.style.height = String(height) + 'px';
			el.removeAttribute('width');
			el.style.width = 'auto';
		}
	}

	function getBoundingBox(window, el) {
		var rect = el.getBoundingClientRect();

		return {
			left: rect.left + window.pageXOffset,
			top: rect.top + window.pageYOffset,
			width: rect.width,
			height: rect.height
		};
	}
}

/***/ }),

/***/ "./src/plugins/dragresize_ie11.js":
/*!****************************************!*\
  !*** ./src/plugins/dragresize_ie11.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

(function () {
	if (CKEDITOR.plugins.get('ae_dragresize_ie11')) {
		return;
	}

	var template = '<img alt="" src="" />';

	var templateBlock = new CKEDITOR.template('<figure class="{captionedClass}">' + template + '<figcaption>{captionPlaceholder}</figcaption>' + '</figure>');

	var alignmentsObj = { left: 0, center: 1, right: 2 };

	var regexPercent = /^\s*(\d+%)\s*$/i;

	CKEDITOR.plugins.add('ae_dragresize_ie11', {
		requires: 'widget',
		onLoad: function onLoad() {
			CKEDITOR.addCss('.cke_image_nocaption{' +
			// This is to remove unwanted space so resize
			// wrapper is displayed property.

			'line-height:0' + '}' + '.cke_editable.cke_image_ne, .cke_editable.cke_image_ne *{cursor:ne-resize !important}' + '.cke_editable.cke_image_nw, .cke_editable.cke_image_nw *{cursor:nw-resize !important}' + '.cke_editable.cke_image_sw, .cke_editable.cke_image_sw *{cursor:sw-resize !important}' + '.cke_editable.cke_image_se, .cke_editable.cke_image_se *{cursor:se-resize !important}' + '.cke_image_resizer{' + 'display:none;' + 'position:absolute;' + 'width:10px;' + 'height:10px;' + 'background:#000;' + 'outline:1px solid #fff;' +
			// Prevent drag handler from being misplaced (#11207).

			'line-height:0;' + 'cursor:se-resize;' + '}' + '.cke_image_resizer_wrapper{' + 'position:relative;' + 'display:inline-block;' + 'line-height:0;' + '}' +
			// Top-right corner style of the resizer.

			'.cke_image_resizer.cke_image_resizer_ne{' + 'cursor:ne-resize;' + 'left:auto;' + 'right:-5px;' + 'top:-5px;' + '}' +
			// Top-left corner style of the resizer.

			'.cke_image_resizer.cke_image_resizer_nw{' + 'cursor:nw-resize;' + 'left:-5px;' + 'right:auto;' + 'top:-5px;' + '}' +
			// Bottom-right corner style of the resizer.

			'.cke_image_resizer.cke_image_resizer_se{' + 'bottom:-5px;' + 'cursor:se-resize;' + 'left:auto;' + 'right:-5px;' + '}' +
			// Bottom-left corner style of the resizer.

			'.cke_image_resizer.cke_image_resizer_sw{' + 'bottom:-5px;' + 'cursor:sw-resize;' + 'left:-5px;' + 'right:auto;' + '}' + '.cke_widget_wrapper:hover .cke_image_resizer,' + '.cke_image_resizing>.cke_image_resizer{' + 'display:block' + '}' +
			// Expand widget wrapper when linked inline image.

			'.cke_widget_wrapper>a{' + 'display:inline-block' + '}');
		},
		init: function init(editor) {
			// Adapts configuration from original image plugin. Should be removed
			// when we'll rename ae_dragresize_ie11 to image.

			var image = widgetDef(editor);

			// Register the widget.

			editor.widgets.add('image', image);

			// Add a listener to handle selection change events and properly detect editor
			// interactions on the widgets without messing with widget native selection

			editor.on('selectionChange', function (_event) {
				var selection = editor.getSelection();

				if (selection) {
					var element = selection.getSelectedElement();

					if (element) {
						var widgetElement = element.findOne('img');

						if (widgetElement) {
							var region = element.getClientRect();

							var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();
							region.left -= scrollPosition.x;
							region.top += scrollPosition.y;

							region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;

							editor.fire('editorInteraction', {
								nativeEvent: {},
								selectionData: {
									element: widgetElement,
									region: region
								}
							});
						}
					}
				}
			});
		},
		afterInit: function afterInit(editor) {
			// Integrate with align commands (justify plugin).

			var align = { left: 1, right: 1, center: 1, block: 1 };

			var integrate = alignCommandIntegrator(editor);

			for (var value in align) {
				if (Object.prototype.hasOwnProperty.call(align, value)) {
					integrate(value);
				}
			}
		}
	});

	// Widget states (forms) depending on alignment and configuration.
	//
	// Non-captioned widget (inline styles)
	// 		ââââââââ¬ââââââââââââââââââââââââââââââââ¬ââââââââââââââââââââââââââââââ
	// 		âAlign âInternal form                  âData                         â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		ânone  â<wrapper>                      â<img />                      â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âleft  â<wrapper style=âfloat:leftâ>   â<img style=âfloat:leftâ />   â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âcenterâ<wrapper>                      â<p style=âtext-align:centerâ>â
	// 		â      â <p style=âtext-align:centerâ> â  <img />                    â
	// 		â      â   <img />                     â</p>                         â
	// 		â      â </p>                          â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âright â<wrapper style=âfloat:rightâ>  â<img style=âfloat:rightâ />  â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ´ââââââââââââââââââââââââââââââââ´ââââââââââââââââââââââââââââââ
	//
	// Non-captioned widget (config.ae_dragresize_ie11_alignClasses defined)
	// 		ââââââââ¬ââââââââââââââââââââââââââââââââ¬ââââââââââââââââââââââââââââââ
	// 		âAlign âInternal form                  âData                         â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		ânone  â<wrapper>                      â<img />                      â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âleft  â<wrapper class=âleftâ>         â<img class=âleftâ />         â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âcenterâ<wrapper>                      â<p class=âcenterâ>           â
	// 		â      â <p class=âcenterâ>            â <img />                     â
	// 		â      â   <img />                     â</p>                         â
	// 		â      â </p>                          â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ¼ââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââ¤
	// 		âright â<wrapper class=ârightâ>        â<img class=ârightâ />        â
	// 		â      â <img />                       â                             â
	// 		â      â</wrapper>                     â                             â
	// 		ââââââââ´ââââââââââââââââââââââââââââââââ´ââââââââââââââââââââââââââââââ
	//
	// Captioned widget (inline styles)
	// 		ââââââââ¬âââââââââââââââââââââââââââââââââââââââââ¬âââââââââââââââââââââââââââââââââââââââââ
	// 		âAlign âInternal form                           âData                                    â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		ânone  â<wrapper>                               â<figure />                              â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âleft  â<wrapper style=âfloat:leftâ>            â<figure style=âfloat:leftâ />           â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âcenterâ<wrapper style=âtext-align:centerâ>     â<div style=âtext-align:centerâ>         â
	// 		â      â <figure style=âdisplay:inline-blockâ />â <figure style=âdisplay:inline-blockâ />â
	// 		â      â</wrapper>                              â</p>                                    â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âright â<wrapper style=âfloat:rightâ>           â<figure style=âfloat:rightâ />          â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ´âââââââââââââââââââââââââââââââââââââââââ´âââââââââââââââââââââââââââââââââââââââââ
	//
	// Captioned widget (config.ae_dragresize_ie11_alignClasses defined)
	// 		ââââââââ¬âââââââââââââââââââââââââââââââââââââââââ¬âââââââââââââââââââââââââââââââââââââââââ
	// 		âAlign âInternal form                           âData                                    â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		ânone  â<wrapper>                               â<figure />                              â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âleft  â<wrapper class=âleftâ>                  â<figure class=âleftâ />                 â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âcenterâ<wrapper class=âcenterâ>                â<div class=âcenterâ>                    â
	// 		â      â <figure />                             â <figure />                             â
	// 		â      â</wrapper>                              â</p>                                    â
	// 		ââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¼âââââââââââââââââââââââââââââââââââââââââ¤
	// 		âright â<wrapper class=ârightâ>                 â<figure class=ârightâ />                â
	// 		â      â <figure />                             â                                        â
	// 		â      â</wrapper>                              â                                        â
	// 		ââââââââ´âââââââââââââââââââââââââââââââââââââââââ´âââââââââââââââââââââââââââââââââââââââââ
	//
	// @param {CKEDITOR.editor}
	// @returns {Object}

	function widgetDef(editor) {
		var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

		var captionedClass = editor.config.ae_dragresize_ie11_captionedClass;

		function deflate() {
			if (this.deflated) {
				return;
			}

			// Remember whether widget was focused before destroyed.

			if (editor.widgets.focused == this.widget) {
				this.focused = true;
			}

			editor.widgets.destroy(this.widget);

			// Mark widget was destroyed.

			this.deflated = true;
		}

		function inflate() {
			var editable = editor.editable();

			var doc = editor.document;

			// Create a new widget. This widget will be either captioned
			// non-captioned, block or inline according to what is the
			// new state of the widget.

			if (this.deflated) {
				this.widget = editor.widgets.initOn(this.element, 'image', this.widget.data);

				// Once widget was re-created, it may become an inline element without
				// block wrapper (i.e. when unaligned, end not captioned). Let's do some
				// sort of autoparagraphing here (#10853).

				if (this.widget.inline && !new CKEDITOR.dom.elementPath(this.widget.wrapper, editable).block) {
					var block = doc.createElement(editor.activeEnterMode == CKEDITOR.ENTER_P ? 'p' : 'div');
					block.replace(this.widget.wrapper);
					this.widget.wrapper.move(block);
				}

				// The focus must be transferred from the old one (destroyed)
				// to the new one (just created).

				if (this.focused) {
					this.widget.focus();
					delete this.focused;
				}

				delete this.deflated;
			}

			// If now widget was destroyed just update wrapper's alignment.
			// According to the new state.
			else {
					setWrapperAlign(this.widget, alignClasses);
				}
		}

		return {
			allowedContent: getWidgetAllowedContent(editor),

			requiredContent: 'img[src,alt]',

			features: getWidgetFeatures(editor),

			styleableElements: 'img figure',

			// This widget converts style-driven dimensions to attributes.

			contentTransformations: [['img[width]: sizeToAttribute']],

			// This widget has an editable caption.

			editables: {
				caption: {
					selector: 'figcaption',
					allowedContent: 'br em strong sub sup u s; a[!href,target]'
				}
			},

			parts: {
				image: 'img',
				caption: 'figcaption'

				// parts#link defined in widget#init
			},

			// Template of the widget: plain image.

			template: template,

			data: function data() {
				var features = this.features;

				// Image can't be captioned when figcaption is disallowed (#11004).

				if (this.data.hasCaption && !editor.filter.checkFeature(features.caption)) {
					this.data.hasCaption = false;
				}

				// Image can't be aligned when floating is disallowed (#11004).

				if (this.data.align != 'none' && !editor.filter.checkFeature(features.align)) {
					this.data.align = 'none';
				}

				// Convert the internal form of the widget from the old state to the new one.

				this.shiftState({
					widget: this,
					element: this.element,
					oldData: this.oldData,
					newData: this.data,
					deflate: deflate,
					inflate: inflate
				});

				// Update widget.parts.link since it will not auto-update unless widget
				// is destroyed and re-inited.

				if (!this.data.link) {
					if (this.parts.link) {
						delete this.parts.link;
					}
				} else {
					if (!this.parts.link) {
						this.parts.link = this.parts.image.getParent();
					}
				}

				this.parts.image.setAttributes({
					src: this.data.src,

					// This internal is required by the editor.

					'data-cke-saved-src': this.data.src,

					alt: this.data.alt
				});

				// If shifting non-captioned -> captioned, remove classes
				// related to styles from <img/>.

				if (this.oldData && !this.oldData.hasCaption && this.data.hasCaption) {
					for (var c in this.data.classes) {
						if (Object.prototype.hasOwnProperty.call(this.data.classes, c)) {
							this.parts.image.removeClass(c);
						}
					}
				}

				// Set dimensions of the image according to gathered data.
				// Do it only when the attributes are allowed (#11004).

				if (editor.filter.checkFeature(features.dimension)) {
					setDimensions(this);
				}

				// Cache current data.

				this.oldData = CKEDITOR.tools.extend({}, this.data);
			},
			init: function init() {
				var helpers = CKEDITOR.plugins.ae_dragresize_ie11;

				var image = this.parts.image;

				var data = {
					hasCaption: !!this.parts.caption,
					src: image.getAttribute('src'),
					alt: image.getAttribute('alt') || '',
					width: image.getAttribute('width') || '',

					// Lock ratio is on by default (#10833).

					lock: this.ready ? helpers.checkHasNaturalRatio(image) : true
				};

				data.height = data.lock ? null : image.getAttribute('height') || '';

				// If we used 'a' in widget#parts definition, it could happen that
				// selected element is a child of widget.parts#caption. Since there's no clever
				// way to solve it with CSS selectors, it's done like that. (#11783).

				var link = image.getAscendant('a');

				if (link && this.wrapper.contains(link)) {
					this.parts.link = link;
				}

				// Depending on configuration, read style/class from element and
				// then remove it. Removed style/class will be set on wrapper in #data listener.
				// Note: Center alignment is detected during upcast, so only left/right cases
				// are checked below.

				if (!data.align) {
					var alignElement = data.hasCaption ? this.element : image;

					// Read the initial left/right alignment from the class set on element.

					if (alignClasses) {
						if (alignElement.hasClass(alignClasses[0])) {
							data.align = 'left';
						} else if (alignElement.hasClass(alignClasses[2])) {
							data.align = 'right';
						}

						if (data.align) {
							alignElement.removeClass(alignClasses[alignmentsObj[data.align]]);
						} else {
							data.align = 'none';
						}
					}

					// Read initial float style from figure/image and then remove it.
					else {
							data.align = alignElement.getStyle('float') || 'none';
							alignElement.removeStyle('float');
						}
				}

				// Update data.link object with attributes if the link has been discovered.

				if (editor.plugins.link && this.parts.link) {
					data.link = helpers.getLinkAttributesParser()(editor, this.parts.link);

					// Get rid of cke_widget_* classes in data. Otherwise
					// they might appear in link dialog.

					var advanced = data.link.advanced;
					if (advanced && advanced.advCSSClasses) {
						advanced.advCSSClasses = CKEDITOR.tools.trim(advanced.advCSSClasses.replace(/cke_\S+/, ''));
					}
				}

				// Get rid of extra vertical space when there's no caption.
				// It will improve the look of the resizer.

				this.wrapper[(data.hasCaption ? 'remove' : 'add') + 'Class']('cke_image_nocaption');

				this.setData(data);

				// Setup dynamic image resizing with mouse.
				// Don't initialize resizer when dimensions are disallowed (#11004).

				if (editor.filter.checkFeature(this.features.dimension) && editor.config.ae_dragresize_ie11_disableResizer !== true) {
					setupResizer(this);
				}

				var dragHandlerStyle = this.dragHandlerContainer.$.style;
				dragHandlerStyle.setAttribute('backgroundColor', 'rgba(255, 255, 255, 1');
				dragHandlerStyle.setAttribute('opacity', '1');

				this.shiftState = helpers.stateShifter(this.editor);

				// Add widget editing option to its context menu.

				this.on('contextMenu', function (evt) {
					evt.data.image = CKEDITOR.TRISTATE_OFF;

					// Integrate context menu items for link.
					// Note that widget may be wrapped in a link, which
					// does not belong to that widget (#11814).

					if (this.parts.link || this.wrapper.getAscendant('a')) {
						evt.data.link = evt.data.unlink = CKEDITOR.TRISTATE_OFF;
					}
				});
			},


			// Overrides default method to handle internal mutability of ae_dragresize_ie11.
			// @see CKEDITOR.plugins.widget#addClass

			addClass: function addClass(className) {
				getStyleableElement(this).addClass(className);
			},


			// Overrides default method to handle internal mutability of ae_dragresize_ie11.
			// @see CKEDITOR.plugins.widget#hasClass

			hasClass: function hasClass(className) {
				return getStyleableElement(this).hasClass(className);
			},


			// Overrides default method to handle internal mutability of ae_dragresize_ie11.
			// @see CKEDITOR.plugins.widget#removeClass

			removeClass: function removeClass(className) {
				getStyleableElement(this).removeClass(className);
			},


			// Overrides default method to handle internal mutability of ae_dragresize_ie11.
			// @see CKEDITOR.plugins.widget#getClasses

			getClasses: function () {
				var classRegex = new RegExp('^(' + [].concat(captionedClass, alignClasses).join('|') + ')$');

				return function () {
					var classes = this.repository.parseElementClasses(getStyleableElement(this).getAttribute('class'));

					// Neither config.ae_dragresize_ie11_captionedClass nor config.ae_dragresize_ie11_alignClasses
					// do not belong to style classes.

					for (var c in classes) {
						if (classRegex.test(c)) {
							delete classes[c];
						}
					}

					return classes;
				};
			}(),

			upcast: upcastWidgetElement(editor),
			downcast: downcastWidgetElement(editor),

			getLabel: function getLabel() {
				var label = (this.data.alt || '') + ' ' + this.pathName;

				return this.editor.lang.widget.label.replace(/%1/, label);
			}
		};
	}

	/**
  * A set of Enhanced Image (ae_dragresize_ie11) plugin helpers.
  *
  * @class
  * @singleton
  */
	CKEDITOR.plugins.ae_dragresize_ie11 = {
		stateShifter: function stateShifter(editor) {
			// Tag name used for centering non-captioned widgets.

			var doc = editor.document;

			var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

			var captionedClass = editor.config.ae_dragresize_ie11_captionedClass;

			var editable = editor.editable();

			// The order that stateActions get executed. It matters!

			var shiftables = ['hasCaption', 'align', 'link'];

			// Atomic procedures, one per state variable.

			var stateActions = {
				align: function align(shift, oldValue, newValue) {
					var el = shift.element;

					// Alignment changed.

					if (shift.changed.align || el.$.style.marginLeft === 'auto' && el.$.style.marginRight === 'auto') {
						// No caption in the new state.

						if (!shift.newData.hasCaption) {
							// Changed to "center" (non-captioned).

							if (newValue == 'center' || el.$.style.marginLeft === 'auto' && el.$.style.marginRight === 'auto') {
								shift.deflate();
								shift.element = wrapInCentering(editor, el);
							}

							// Changed to "non-center" from "center" while caption removed.

							if (!shift.changed.hasCaption && oldValue == 'center' && newValue != 'center') {
								shift.deflate();
								shift.element = unwrapFromCentering(el);
							}
						}
					}

					// Alignment remains and "center" removed caption.
					else if (newValue == 'center' && shift.changed.hasCaption && !shift.newData.hasCaption) {
							shift.deflate();
							shift.element = wrapInCentering(editor, el);
						}

					// Finally set display for figure.

					if (!alignClasses && el.is('figure')) {
						if (newValue == 'center') {
							el.setStyle('display', 'inline-block');
						} else {
							el.removeStyle('display');
						}
					}
				},
				hasCaption: function hasCaption(shift, oldValue, newValue) {
					// This action is for real state change only.

					if (!shift.changed.hasCaption) {
						return;
					}

					// Get <img/> or <a><img/></a> from widget. Note that widget element might itself
					// be what we're looking for. Also element can be <p style="text-align:center"><a>...</a></p>.

					var imageOrLink = void 0;
					if (shift.element.is({ img: 1, a: 1 })) {
						imageOrLink = shift.element;
					} else {
						imageOrLink = shift.element.findOne('a,img');
					}

					// Switching hasCaption always destroys the widget.

					shift.deflate();

					// There was no caption, but the caption is to be added.

					if (newValue) {
						// Create new <figure> from widget template.

						var figure = CKEDITOR.dom.element.createFromHtml(templateBlock.output({
							captionedClass: captionedClass,
							captionPlaceholder: editor.lang.ae_dragresize_ie11.captionPlaceholder
						}), doc);

						// Replace element with <figure>.

						replaceSafely(figure, shift.element);

						// Use old <img/> or <a><img/></a> instead of the one from the template,
						// so we won't lose additional attributes.

						imageOrLink.replace(figure.findOne('img'));

						// Update widget's element.

						shift.element = figure;
					}

					// The caption was present, but now it's to be removed.
					else {
							// Unwrap <img/> or <a><img/></a> from figure.

							imageOrLink.replace(shift.element);

							// Update widget's element.

							shift.element = imageOrLink;
						}
				},
				link: function link(shift, oldValue, newValue) {
					if (shift.changed.link) {
						var img = shift.element.is('img') ? shift.element : shift.element.findOne('img');

						var link = shift.element.is('a') ? shift.element : shift.element.findOne('a');

						// Why deflate:
						// If element is <img/>, it will be wrapped into <a>,
						// which becomes a new widget.element.
						// If element is <a><img/></a>, it will be unlinked
						// so <img/> becomes a new widget.element.

						var needsDeflate = shift.element.is('a') && !newValue || shift.element.is('img') && newValue;

						var newEl = void 0;

						if (needsDeflate) {
							shift.deflate();
						}

						// If unlinked the image, returned element is <img>.

						if (!newValue) {
							newEl = unwrapFromLink(link);
						} else {
							// If linked the image, returned element is <a>.

							if (!oldValue) {
								newEl = wrapInLink(img, shift.newData.link);
							}

							// Set and remove all attributes associated with this state.

							var attributes = CKEDITOR.plugins.ae_dragresize_ie11.getLinkAttributesGetter()(editor, newValue);

							if (!CKEDITOR.tools.isEmpty(attributes.set)) {
								(newEl || link).setAttributes(attributes.set);
							}

							if (attributes.removed.length) {
								(newEl || link).removeAttributes(attributes.removed);
							}
						}

						if (needsDeflate) {
							shift.element = newEl;
						}
					}
				}
			};

			function wrapInCentering(editor, element) {
				var attribsAndStyles = {};

				if (alignClasses) {
					attribsAndStyles.attributes = { class: alignClasses[1] };
				} else {
					attribsAndStyles.styles = { 'text-align': 'center' };
				}

				// There's no gentle way to center inline element with CSS, so create p/div
				// that wraps widget contents and does the trick either with style or class.

				var center = doc.createElement(editor.activeEnterMode == CKEDITOR.ENTER_P ? 'p' : 'div', attribsAndStyles);

				// Replace element with centering wrapper.

				replaceSafely(center, element);
				element.move(center);

				return center;
			}

			function unwrapFromCentering(element) {
				var imageOrLink = element.findOne('a,img');

				imageOrLink.replace(element);

				return imageOrLink;
			}

			// Wraps <img/> -> <a><img/></a>.
			// Returns reference to <a>.
			//
			// @param {CKEDITOR.dom.element} img
			// @param {Object} linkData
			// @returns {CKEDITOR.dom.element}

			function wrapInLink(img, linkData) {
				var link = doc.createElement('a', {
					attributes: {
						href: linkData.url
					}
				});

				link.replace(img);
				img.move(link);

				return link;
			}

			// De-wraps <a><img/></a> -> <img/>.
			// Returns the reference to <img/>
			//
			// @param {CKEDITOR.dom.element} link
			// @returns {CKEDITOR.dom.element}

			function unwrapFromLink(link) {
				var img = link.findOne('img');

				img.replace(link);

				return img;
			}

			function replaceSafely(replacing, replaced) {
				if (replaced.getParent()) {
					var range = editor.createRange();

					range.moveToPosition(replaced, CKEDITOR.POSITION_BEFORE_START);

					// Remove old element. Do it before insertion to avoid a case when
					// element is moved from 'replaced' element before it, what creates
					// a tricky case which insertElementIntorRange does not handle.

					replaced.remove();

					editable.insertElementIntoRange(replacing, range);
				} else {
					replacing.replace(replaced);
				}
			}

			return function (shift) {
				var name = void 0;
				var i = void 0;

				shift.changed = {};

				for (i = 0; i < shiftables.length; i++) {
					name = shiftables[i];

					shift.changed[name] = shift.oldData ? shift.oldData[name] !== shift.newData[name] : false;
				}

				// Iterate over possible state variables.

				for (i = 0; i < shiftables.length; i++) {
					name = shiftables[i];

					stateActions[name](shift, shift.oldData ? shift.oldData[name] : null, shift.newData[name]);
				}

				shift.inflate();
			};
		},


		/**
   * Checks whether the current image ratio matches the natural one
   * by comparing dimensions.
   *
   * @param {CKEDITOR.dom.element} image
   * @return {Boolean}
   */
		checkHasNaturalRatio: function checkHasNaturalRatio(image) {
			var $ = image.$;

			var natural = this.getNatural(image);

			// The reason for two alternative comparisons is that the rounding can come from
			// both dimensions, e.g. there are two cases:
			// 	1. height is computed as a rounded relation of the real height and the value of width,
			//	2. width is computed as a rounded relation of the real width and the value of heigh.

			return Math.round($.clientWidth / natural.width * natural.height) == $.clientHeight || Math.round($.clientHeight / natural.height * natural.width) == $.clientWidth;
		},


		/**
   * Returns natural dimensions of the image. For modern browsers
   * it uses natural(Width|Height). For old ones (IE8) it creates
   * a new image and reads the dimensions.
   *
   * @param {CKEDITOR.dom.element} image
   * @return {Object}
   */
		getNatural: function getNatural(image) {
			var dimensions = void 0;

			if (image.$.naturalWidth) {
				dimensions = {
					width: image.$.naturalWidth,
					height: image.$.naturalHeight
				};
			} else {
				var img = new Image();
				img.src = image.getAttribute('src');

				dimensions = {
					width: img.width,
					height: img.height
				};
			}

			return dimensions;
		},


		/**
   * Returns an attribute getter function. Default getter comes from the Link plugin
   * and is documented by {@link CKEDITOR.plugins.link#getLinkAttributes}.
   *
   * **Note:** It is possible to override this method and use a custom getter e.g.
   * in the absence of the Link plugin.
   *
   * **Note:** If a custom getter is used, a data model format it produces
   * must be compatible with {@link CKEDITOR.plugins.link#getLinkAttributes}.
   *
   * **Note:** A custom getter must understand the data model format produced by
   * {@link #getLinkAttributesParser} to work correctly.
   *
   * @return {Function} A function that gets (composes) link attributes.
   * @since 4.5.5
   */
		getLinkAttributesGetter: function getLinkAttributesGetter() {
			// #13885

			return CKEDITOR.plugins.link.getLinkAttributes;
		},


		/**
   * Returns an attribute parser function. Default parser comes from the Link plugin
   * and is documented by {@link CKEDITOR.plugins.link#parseLinkAttributes}.
   *
   * **Note:** It is possible to override this method and use a custom parser e.g.
   * in the absence of the Link plugin.
   *
   * **Note:** If a custom parser is used, a data model format produced by the parser
   * must be compatible with {@link #getLinkAttributesGetter}.
   *
   * **Note:** If a custom parser is used, it should be compatible with the
   * {@link CKEDITOR.plugins.link#parseLinkAttributes} data model format. Otherwise the
   * Link plugin dialog may not be populated correctly with parsed data. However
   * as long as Enhanced Image is **not** used with the Link plugin dialog, any custom data model
   * will work, being stored as an internal property of Enhanced Image widget's data only.
   *
   * @return {Function} A function that parses attributes.
   * @since 4.5.5
   */
		getLinkAttributesParser: function getLinkAttributesParser() {
			// #13885

			return CKEDITOR.plugins.link.parseLinkAttributes;
		}
	};

	function setWrapperAlign(widget, alignClasses) {
		var wrapper = widget.wrapper;

		var align = widget.data.align;

		var hasCaption = widget.data.hasCaption;

		if (alignClasses) {
			// Remove all align classes first.

			for (var i = 3; i--;) {
				wrapper.removeClass(alignClasses[i]);
			}

			if (align == 'center') {
				// Avoid touching non-captioned, centered widgets because
				// they have the class set on the element instead of wrapper:
				//
				// 	<div class="cke_widget_wrapper">
				// 		<p class="center-class">
				// 			<img />
				// 		</p>
				// 	</div>

				if (hasCaption) {
					wrapper.addClass(alignClasses[1]);
				}
			} else if (align != 'none') {
				wrapper.addClass(alignClasses[alignmentsObj[align]]);
			}
		} else {
			if (align == 'center') {
				if (hasCaption) {
					wrapper.setStyle('text-align', 'center');
				} else {
					wrapper.removeStyle('text-align');
				}

				wrapper.removeStyle('float');
			} else {
				if (align == 'none') {
					wrapper.removeStyle('float');
				} else {
					wrapper.setStyle('float', align);
				}

				wrapper.removeStyle('text-align');
			}

			var image = wrapper.$.querySelector('img');

			var imageStyles = image.getAttribute('style');

			if (imageStyles) {
				var styles = '';

				var heightStyles = /(height:.+?;)/.exec(imageStyles);
				if (heightStyles) {
					styles += heightStyles[0];
				}

				var widthStyles = /(width:.+?;)/.exec(imageStyles);
				if (widthStyles) {
					styles += widthStyles[0];
				}

				image.setAttribute('style', styles);
			}
		}
	}

	// Returns a function that creates widgets from all <img> and
	// <figure class="{config.ae_dragresize_ie11_captionedClass}"> elements.
	//
	// @param {CKEDITOR.editor} editor
	// @returns {Function}

	function upcastWidgetElement(editor) {
		var isCenterWrapper = centerWrapperChecker(editor);

		var captionedClass = editor.config.ae_dragresize_ie11_captionedClass;

		// @param {CKEDITOR.htmlParser.element} el
		// @param {Object} data

		return function (el, data) {
			var dimensions = { width: 1, height: 1 };

			var name = el.name;

			var image = void 0;

			// #11110 Don't initialize on pasted fake objects.

			if (el.attributes['data-cke-realelement']) {
				return;
			}

			// If a center wrapper is found, there are 3 possible cases:
			//
			// 1. <div style="text-align:center"><figure>...</figure></div>.
			//    In this case centering is done with a class set on widget.wrapper.
			//    Simply replace centering wrapper with figure (it's no longer necessary).
			//
			// 2. <p style="text-align:center"><img/></p>.
			//    Nothing to do here: <p> remains for styling purposes.
			//
			// 3. <div style="text-align:center"><img/></div>.
			//    Nothing to do here (2.) but that case is only possible in enterMode different
			//    than ENTER_P.

			if (isCenterWrapper(el)) {
				if (name == 'div') {
					var figure = el.getFirst('figure');

					// Case #1.

					if (figure) {
						el.replaceWith(figure);
						el = figure;
					}
				}

				// Cases #2 and #3 (handled transparently)

				// If there's a centering wrapper, save it in data.

				data.align = 'center';

				// Image can be wrapped in link <a><img/></a>.

				image = el.getFirst('img') || el.getFirst('a').getFirst('img');
			}

			// No center wrapper has been found.
			else if (name == 'figure' && el.hasClass(captionedClass)) {
					image = el.getFirst('img') || el.getFirst('a').getFirst('img');

					// Upcast linked image like <a><img/></a>.
				} else if (isLinkedOrStandaloneImage(el)) {
					image = el.name == 'a' ? el.children[0] : el;
				}

			if (!image) {
				return;
			}

			// If there's an image, then cool, we got a widget.
			// Now just remove dimension attributes expressed with %.

			for (var d in dimensions) {
				if (Object.prototype.hasOwnProperty.call(dimensions, d)) {
					var dimension = image.attributes[d];
					if (dimension && dimension.match(regexPercent)) {
						delete image.attributes[d];
					}
				}
			}

			return el;
		};
	}

	// Returns a function which transforms the widget to the external format
	// according to the current configuration.
	//
	// @param {CKEDITOR.editor}

	function downcastWidgetElement(editor) {
		var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

		// @param {CKEDITOR.htmlParser.element} el

		return function (el) {
			// In case of <a><img/></a>, <img/> is the element to hold
			// inline styles or classes (ae_dragresize_ie11_alignClasses).

			var attrsHolder = el.name == 'a' ? el.getFirst() : el;

			var attrs = attrsHolder.attributes;

			var align = this.data.align;

			// De-wrap the image from resize handle wrapper.
			// Only block widgets have one.

			if (!this.inline) {
				var resizeWrapper = el.getFirst('span');

				if (resizeWrapper) {
					resizeWrapper.replaceWith(resizeWrapper.getFirst({ img: 1, a: 1 }));
				}
			}

			if (align && align != 'none') {
				var styles = CKEDITOR.tools.parseCssText(attrs.style || '');

				// When the widget is captioned (<figure>) and internally centering is done
				// with widget's wrapper style/class, in the external data representation,
				// <figure> must be wrapped with an element holding an style/class:
				//
				// 	<div style="text-align:center">
				// 		<figure class="image" style="display:inline-block">...</figure>
				// 	</div>
				// or
				// 	<div class="some-center-class">
				// 		<figure class="image">...</figure>
				// 	</div>
				//

				if (align == 'center' && el.name == 'figure') {
					el = el.wrapWith(new CKEDITOR.htmlParser.element('div', alignClasses ? { class: alignClasses[1] } : { style: 'text-align:center' }));
				}

				// If left/right, add float style to the downcasted element.
				else if (align in { left: 1, right: 1 }) {
						if (alignClasses) {
							attrsHolder.addClass(alignClasses[alignmentsObj[align]]);
						} else {
							styles['float'] = align;
						}
					}

				// Update element styles.

				if (!alignClasses && !CKEDITOR.tools.isEmpty(styles)) {
					attrs.style = CKEDITOR.tools.writeCssText(styles) + ';';
				}
			}

			return el;
		};
	}

	// Returns a function that checks if an element is a centering wrapper.
	//
	// @param {CKEDITOR.editor} editor
	// @returns {Function}

	function centerWrapperChecker(editor) {
		var captionedClass = editor.config.ae_dragresize_ie11_captionedClass;

		var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

		var validChildren = { figure: 1, a: 1, img: 1 };

		return function (el) {
			// Wrapper must be either <div> or <p>.

			if (!(el.name in { div: 1, p: 1 })) {
				return false;
			}

			var children = el.children;

			// Centering wrapper can have only one child.

			if (children.length !== 1) {
				return false;
			}

			var child = children[0];

			// Only <figure> or <img /> can be first (only) child of centering wrapper,
			// regardless of its type.

			if (!(child.name in validChildren)) {
				return false;
			}

			// If centering wrapper is <p>, only <img /> can be the child.
			//   <p style="text-align:center"><img /></p>

			if (el.name == 'p') {
				if (!isLinkedOrStandaloneImage(child)) {
					return false;
				}
			}

			// Centering <div> can hold <img/> or <figure>, depending on enterMode.
			else {
					// If a <figure> is the first (only) child, it must have a class.
					//   <div style="text-align:center"><figure>...</figure><div>

					if (child.name == 'figure') {
						if (!child.hasClass(captionedClass)) {
							return false;
						}
					} else {
						// Centering <div> can hold <img/> or <a><img/></a> only when enterMode
						// is ENTER_(BR|DIV).
						//   <div style="text-align:center"><img /></div>
						//   <div style="text-align:center"><a><img /></a></div>

						if (editor.enterMode == CKEDITOR.ENTER_P) {
							return false;
						}

						// Regardless of enterMode, a child which is not <figure> must be
						// either <img/> or <a><img/></a>.

						if (!isLinkedOrStandaloneImage(child)) {
							return false;
						}
					}
				}

			// Centering wrapper got to be... centering. If ae_dragresize_ie11_alignClasses are defined,
			// check for centering class. Otherwise, check the style.

			if (alignClasses ? el.hasClass(alignClasses[1]) : CKEDITOR.tools.parseCssText(el.attributes.style || '', true)['text-align'] == 'center') {
				return true;
			}

			return false;
		};
	}

	// Checks whether element is <img/> or <a><img/></a>.
	//
	// @param {CKEDITOR.htmlParser.element}

	function isLinkedOrStandaloneImage(el) {
		if (el.name == 'img') {
			return true;
		} else if (el.name == 'a') {
			return el.children.length == 1 && el.getFirst('img');
		}

		return false;
	}

	// Sets width and height of the widget image according to current widget data.
	//
	// @param {CKEDITOR.plugins.widget} widget

	function setDimensions(widget) {
		var data = widget.data;

		var dimensions = {
			width: data.width,
			height: data.lock ? null : data.height
		};

		var image = widget.parts.image;

		for (var d in dimensions) {
			if (dimensions[d]) {
				image.setAttribute(d, dimensions[d]);
			} else {
				image.removeAttribute(d);
			}
		}
	}

	// Defines all features related to drag-driven image resizing.
	//
	// @param {CKEDITOR.plugins.widget} widget

	function setupResizer(widget) {
		var editor = widget.editor;

		var editable = editor.editable();

		var doc = editor.document;

		// Store the resizer in a widget for testing (#11004).

		var resizer = widget.resizer = doc.createElement('span');

		// Create resizer for each corner (NE, NW, SE, SW)

		var resizerNE = doc.createElement('span');

		var resizerNW = doc.createElement('span');

		var resizerSE = doc.createElement('span');

		var resizerSW = doc.createElement('span');

		resizerNE.addClass('cke_image_resizer');
		resizerNE.addClass('cke_image_resizer_ne');

		resizerNW.addClass('cke_image_resizer');
		resizerNW.addClass('cke_image_resizer_nw');

		resizerSE.addClass('cke_image_resizer');
		resizerSE.addClass('cke_image_resizer_se');

		resizerSW.addClass('cke_image_resizer');
		resizerSW.addClass('cke_image_resizer_sw');

		// Add each directional resizer as a child of resizer

		resizer.append(resizerNE);
		resizer.append(resizerNW);
		resizer.append(resizerSE);
		resizer.append(resizerSW);

		// resizer.setAttribute( 'title', editor.lang.ae_dragresize_ie11.resizer );

		resizer.append(new CKEDITOR.dom.text('\u200B', doc));

		// Inline widgets don't need a resizer wrapper as an image spans the entire widget.

		if (!widget.inline) {
			var imageOrLink = widget.parts.link || widget.parts.image;

			var oldResizeWrapper = imageOrLink.getParent();

			var resizeWrapper = doc.createElement('span');

			resizeWrapper.addClass('cke_image_resizer_wrapper');
			resizeWrapper.append(imageOrLink);
			resizeWrapper.append(resizer);
			widget.element.append(resizeWrapper, true);

			// Remove the old wrapper which could came from e.g. pasted HTML
			// and which could be corrupted (e.g. resizer span has been lost).

			if (oldResizeWrapper.is('span')) {
				oldResizeWrapper.remove();
			}
		} else {
			widget.wrapper.append(resizer);
		}

		// Calculate values of size variables and mouse offsets.

		resizer.on('mousedown', function (evt) {
			var image = widget.parts.image;

			// The x-coordinate of the mouse relative to the screen
			// when button gets pressed.

			var startX = evt.data.$.screenX;

			var startY = evt.data.$.screenY;

			// The initial dimensions and aspect ratio of the image.

			var startWidth = image.$.clientWidth;

			var startHeight = image.$.clientHeight;

			var ratio = startWidth / startHeight;

			var listeners = [];

			var target = evt.data.getTarget();

			var factorX = void 0;

			var factorY = void 0;

			var moveDiffX = void 0;

			var moveDiffY = void 0;

			var nativeEvt = void 0;

			var newHeight = void 0;

			var newWidth = void 0;

			var updateData = void 0;

			// "factorX" and "factorY" can be either 1 or -1. I.e.: We need to
			// add/subtract the difference to get proper width, etc. Without "factorX"
			// and "factorY", resizer starts working the opposite way.

			if (target.hasClass('cke_image_resizer_ne')) {
				factorX = 1;
				factorY = 1;
			} else if (target.hasClass('cke_image_resizer_nw')) {
				factorX = -1;
				factorY = 1;
			} else if (target.hasClass('cke_image_resizer_se')) {
				factorX = 1;
				factorY = -1;
			} else if (target.hasClass('cke_image_resizer_sw')) {
				factorX = -1;
				factorY = -1;
			}

			// A class applied to editable during resizing.

			var cursorClass = 'cke_image_' + (!~factorY ? 's' : 'n') + (!~factorX ? 'w' : 'e');

			// Save the undo snapshot first: before resizing.

			editor.fire('saveSnapshot');

			// Mousemove listeners are removed on mouseup.

			attachToDocuments('mousemove', onMouseMove, listeners);

			// Clean up the mousemove listener. Update widget data if valid.

			attachToDocuments('mouseup', onMouseUp, listeners);

			// The entire editable will have the special cursor while resizing goes on.

			editable.addClass(cursorClass);

			// This is to always keep the resizer element visible while resizing.

			resizer.addClass('cke_image_resizing');

			// Attaches an event to a global document if inline editor.
			// Additionally, if classic (`iframe`-based) editor, also attaches the same event to `iframe`'s document.

			function attachToDocuments(name, callback, collection) {
				var globalDoc = CKEDITOR.document;

				var listeners = [];

				if (!doc.equals(globalDoc)) {
					listeners.push(globalDoc.on(name, callback));
				}

				listeners.push(doc.on(name, callback));

				if (collection) {
					for (var i = listeners.length; i--;) {
						collection.push(listeners.pop());
					}
				}
			}

			// Calculate width first, and then adjust height, preserving ratio.

			function adjustToX() {
				newWidth = startWidth + factorX * moveDiffX;
				newHeight = Math.round(newWidth / ratio);
			}

			// Calculate height first, and then adjust width, preserving ratio.

			function adjustToY() {
				newHeight = startHeight + factorY * moveDiffY;
				newWidth = Math.round(newHeight * ratio);
			}

			// This is how variables refer to the geometry.
			// Note: x corresponds to moveOffset, this is the position of mouse
			// Note: o corresponds to [startX, startY].
			//
			// 	+--------------+--------------+
			// 	|              |              |
			// 	|      I       |      II      |
			// 	|              |              |
			// 	+------------- o -------------+ _ _ _
			// 	|              |              |      ^
			// 	|      VI      |     III      |      | moveDiffY
			// 	|              |         x _ _ _ _ _ v
			// 	+--------------+---------|----+
			// 	               |         |
			// 	                <------->
			// 	                moveDiffX

			function onMouseMove(evt) {
				nativeEvt = evt.data.$;

				// This is how far the mouse is from the point the button was pressed.

				moveDiffX = nativeEvt.screenX - startX;
				moveDiffY = startY - nativeEvt.screenY;

				// Resize with NE, SE drag handles

				if (factorX == 1) {
					if (moveDiffX <= 0) {
						adjustToY();
					} else {
						adjustToX();
					}
				}

				// Resize with NW, SW drag handles
				else {
						if (moveDiffX <= 0) {
							adjustToX();
						} else {
							adjustToY();
						}
					}

				// Don't update attributes if less than 10.
				// This is to prevent images to visually disappear.

				if (newWidth >= 15 && newHeight >= 15) {
					image.$.style.width = newWidth + 'px';
					image.$.style.height = widget.data.lock ? 'auto' : newHeight + 'px';

					updateData = true;
				} else {
					updateData = false;
				}
			}

			function onMouseUp() {
				var l = void 0;

				while (l = listeners.pop()) {
					l.removeListener();
				}

				// Restore default cursor by removing special class.

				editable.removeClass(cursorClass);

				// This is to bring back the regular behaviour of the resizer.

				resizer.removeClass('cke_image_resizing');

				if (updateData) {
					widget.setData({
						height: widget.data.lock ? null : newHeight,
						width: newWidth
					});

					// Save another undo snapshot: after resizing.

					editor.fire('saveSnapshot');
				}

				// Don't update data twice or more.

				updateData = false;
			}
		});
	}

	/**
  * Removes the alignment value of an image
  *
  * @param {CKEDITOR.dom.element} image The image element
  * @param {String} imageAlignment The image alignment value to be removed
  */
	var removeWidgetAlignment = function removeWidgetAlignment(widget, imageAlignment) {
		if (imageAlignment === 'left' || imageAlignment === 'right') {
			widget.wrapper.removeStyle('float');
		} else if (imageAlignment === 'center') {
			widget.editor.execCommand('justifyleft');
			widget.editor.execCommand('justifyleft');
		}
	};

	// Integrates widget alignment setting with justify
	// plugin's commands (execution and refreshment).
	// @param {CKEDITOR.editor} editor
	// @param {String} value 'left', 'right', 'center' or 'block'

	function alignCommandIntegrator(editor) {
		var execCallbacks = [];

		var enabled = void 0;

		return function (value) {
			var command = editor.getCommand('justify' + value);

			// Most likely, the justify plugin isn't loaded.

			if (!command) {
				return;
			}

			// This command will be manually refreshed along with
			// other commands after exec.

			execCallbacks.push(function () {
				command.refresh(editor, editor.elementPath());
			});

			if (value in { right: 1, left: 1, center: 1 }) {
				command.on('exec', function (evt) {
					var widget = getFocusedWidget(editor);

					if (widget) {
						if (widget.data.align === value) {
							removeWidgetAlignment(widget, value);

							delete widget.data.align;
						} else {
							widget.setData('align', value);
						}

						// Once the widget changed its align, all the align commands
						// must be refreshed: the event is to be cancelled.

						for (var i = execCallbacks.length; i--;) {
							execCallbacks[i]();
						}

						evt.cancel();
					}
				});
			}

			command.on('refresh', function (evt) {
				var widget = getFocusedWidget(editor);

				var allowed = { right: 1, left: 1, center: 1 };

				if (!widget) {
					return;
				}

				// Cache "enabled" on first use. This is because filter#checkFeature may
				// not be available during plugin's afterInit in the future â a moment when
				// alignCommandIntegrator is called.

				if (enabled === undefined) {
					enabled = editor.filter.checkFeature(editor.widgets.registered.image.features.align);
				}

				// Don't allow justify commands when widget alignment is disabled (#11004).

				if (!enabled) {
					this.setState(CKEDITOR.TRISTATE_DISABLED);
				} else {
					this.setState(widget.data.align == value ? CKEDITOR.TRISTATE_ON : value in allowed ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED);
				}

				evt.cancel();
			});
		};
	}

	// Returns the focused widget, if of the type specific for this plugin.
	// If no widget is focused, `null` is returned.
	//
	// @param {CKEDITOR.editor}
	// @returns {CKEDITOR.plugins.widget}

	function getFocusedWidget(editor) {
		var widget = editor.widgets.focused;

		if (widget && widget.name == 'image') {
			return widget;
		}

		return null;
	}

	// Returns a set of widget allowedContent rules, depending
	// on configurations like config#ae_dragresize_ie11_alignClasses or
	// config#ae_dragresize_ie11_captionedClass.
	//
	// @param {CKEDITOR.editor}
	// @returns {Object}

	function getWidgetAllowedContent(editor) {
		var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

		var rules = {
			// Widget may need <div> or <p> centering wrapper.

			div: {
				match: centerWrapperChecker(editor)
			},
			p: {
				match: centerWrapperChecker(editor)
			},
			img: {
				attributes: '!src,alt,width,height'
			},
			figure: {
				classes: '!' + editor.config.ae_dragresize_ie11_captionedClass
			},
			figcaption: true
		};

		if (alignClasses) {
			// Centering class from the config.

			rules.div.classes = alignClasses[1];
			rules.p.classes = rules.div.classes;

			// Left/right classes from the config.

			rules.img.classes = alignClasses[0] + ',' + alignClasses[2];
			rules.figure.classes += ',' + rules.img.classes;
		} else {
			// Centering with text-align.

			rules.div.styles = 'text-align';
			rules.p.styles = 'text-align';

			rules.img.styles = 'float';
			rules.figure.styles = 'float,display';
		}

		return rules;
	}

	// Returns a set of widget feature rules, depending
	// on editor configuration. Note that the following may not cover
	// all the possible cases since requiredContent supports a single
	// tag only.
	//
	// @param {CKEDITOR.editor}
	// @returns {Object}

	function getWidgetFeatures(editor) {
		var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

		var features = {
			dimension: {
				requiredContent: 'img[width,height]'
			},
			align: {
				requiredContent: 'img' + (alignClasses ? '(' + alignClasses[0] + ')' : '{float}')
			},
			caption: {
				requiredContent: 'figcaption'
			}
		};

		return features;
	}

	// Returns element which is styled, considering current
	// state of the widget.
	//
	// @see CKEDITOR.plugins.widget#applyStyle
	// @param {CKEDITOR.plugins.widget} widget
	// @returns {CKEDITOR.dom.element}

	function getStyleableElement(widget) {
		return widget.data.hasCaption ? widget.element : widget.parts.image;
	}
})();

/**
 * A CSS class applied to the `<figure>` element of a captioned image.
 *
 * Read more in the [documentation](#!/guide/dev_captionedimage) and see the
 * [SDK sample](http://sdk.ckeditor.com/samples/captionedimage.html).
 *
 *		// Changes the class to "captionedImage".
 *		config.ae_dragresize_ie11_captionedClass = 'captionedImage';
 *
 * @cfg {String} [ae_dragresize_ie11_captionedClass='image']
 * @member CKEDITOR.config
 */
CKEDITOR.config.ae_dragresize_ie11_captionedClass = 'image';

/***/ }),

/***/ "./src/plugins/embed.js":
/*!******************************!*\
  !*** ./src/plugins/embed.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _priorities = __webpack_require__(/*! ./priorities */ "./src/plugins/priorities.js");

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_embed')) {
	var REGEX_HTTP = /^https?/;

	var REGEX_DEFAULT_LINK = /<a href=/;

	CKEDITOR.DEFAULT_AE_EMBED_URL_TPL = 'http://alloy.iframe.ly/api/oembed?url={url}&callback={callback}';
	CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL = '<div data-ae-embed-url="{url}"></div>';
	CKEDITOR.DEFAULT_AE_EMBED_DEFAULT_LINK_TPL = '<a href="{url}">{url}</a>';

	/**
  * CKEditor plugin which adds the infrastructure to embed urls as media objects using an oembed
  * service. By default, and for demoing purposes only, the oembed service is hosted in iframe.ly
  * at //alloy.iframe.ly/api/oembed?url={url}&callback={callback}. Note this should be changed to
  * a self-hosted or paid service in production environments. Access to the alloy.iframe.ly endpoint
  * may be restricted per domain due to significant traffic.
  *
  * This plugin adds an `embedUrl` command that can be used to easily embed a URL and transform it
  * to an embedded content.
  *
  * @class CKEDITOR.plugins.ae_embed
  */
	CKEDITOR.plugins.add('ae_embed', {
		requires: 'widget',
		init: function init(editor) {
			var AE_EMBED_URL_TPL = new CKEDITOR.template(editor.config.embedUrlTemplate || CKEDITOR.DEFAULT_AE_EMBED_URL_TPL);
			var AE_EMBED_WIDGET_TPL = new CKEDITOR.template(editor.config.embedWidgetTpl || CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL);
			var AE_EMBED_DEFAULT_LINK_TPL = new CKEDITOR.template(editor.config.embedLinkDefaultTpl || CKEDITOR.DEFAULT_AE_EMBED_DEFAULT_LINK_TPL);

			// Default function to upcast DOM elements to embed widgets.
			// It matches CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL

			var defaultEmbedWidgetUpcastFn = function defaultEmbedWidgetUpcastFn(element, data) {
				if (element.name === 'div' && element.attributes['data-ae-embed-url']) {
					data.url = element.attributes['data-ae-embed-url'];

					return true;
				}
			};

			// Create a embedUrl command that can be invoked to easily embed media URLs

			editor.addCommand('embedUrl', {
				exec: function exec(editor, data) {
					editor.insertHtml(AE_EMBED_WIDGET_TPL.output({
						url: data.url
					}));
				}
			});

			// Create a widget to properly handle embed operations

			editor.widgets.add('ae_embed', {
				mask: true,
				requiredContent: 'div[data-ae-embed-url]',

				/**
     * Listener to be executed every time the widget's data changes. It takes care of
     * requesting the embed object to the configured oembed service and render it in
     * the editor
     *
     * @method data
     * @param {event} event Data change event
     */
				data: function data(event) {
					var widget = this;

					var url = event.data.url;

					if (url) {
						CKEDITOR.tools.jsonp(AE_EMBED_URL_TPL, {
							url: encodeURIComponent(url)
						}, function (response) {
							if (response.html) {
								if (REGEX_DEFAULT_LINK.test(response.html)) {
									widget.createATag(url);
								} else {
									widget.element.setHtml(response.html);
								}
							} else {
								widget.createATag(url);
							}
						}, function (_msg) {
							widget.createATag(url);
						});
					}
				},
				createATag: function createATag(url) {
					this.editor.execCommand('undo');

					var aTagHtml = AE_EMBED_DEFAULT_LINK_TPL.output({
						url: url
					});

					this.editor.insertHtml(aTagHtml);
					this.editor.fire('actionPerformed', this);
				},


				/**
     * Function used to upcast an element to ae_embed widgets.
     *
     * @method upcast
     * @param {CKEDITOR.htmlParser.element} element The element to be checked
     * @param {Object} data The object that will be passed to the widget
     */
				upcast: function upcast(element, data) {
					var embedWidgetUpcastFn = editor.config.embedWidgetUpcastFn || defaultEmbedWidgetUpcastFn;

					return embedWidgetUpcastFn(element, data);
				}
			});

			// Add a listener to handle paste events and turn links into embed objects

			editor.once('contentDom', function () {
				editor.on('paste', function (event) {
					var link = event.data.dataValue;

					if (REGEX_HTTP.test(link)) {
						event.stop();

						editor.execCommand('embedUrl', {
							url: event.data.dataValue
						});
					}
				}, null, null,

				// Make sure we run before autolink's paste handler,
				// otherwise the link will be turned into an anchor and our
				// REGEX_HTTP test will fail.

				_priorities.HIGH_PRIORITY);
			});

			// Add a listener to handle selection change events and properly detect editor
			// interactions on the widgets without messing with widget native selection

			editor.on('selectionChange', function (_event) {
				var selection = editor.getSelection();

				if (selection) {
					var element = selection.getSelectedElement();

					if (element) {
						var widgetElement = element.findOne('[data-widget="ae_embed"]');

						if (widgetElement) {
							var region = element.getClientRect();

							var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();
							region.left -= scrollPosition.x;
							region.top += scrollPosition.y;

							region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;

							editor.fire('editorInteraction', {
								nativeEvent: {},
								selectionData: {
									element: widgetElement,
									region: region
								}
							});
						}
					}
				}
			});

			// Add a filter to skip filtering widget elements

			editor.filter.addElementCallback(function (element) {
				if ('data-ae-embed-url' in element.attributes) {
					return CKEDITOR.FILTER_SKIP_TREE;
				}
			});
		}
	});
} /**
   * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
   * SPDX-License-Identifier: LGPL-3.0-or-later
   */

/***/ }),

/***/ "./src/plugins/embedurl.js":
/*!*********************************!*\
  !*** ./src/plugins/embedurl.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Resizer = __webpack_require__(/*! ./Resizer.es */ "./src/plugins/Resizer.es.js");

var _Resizer2 = _interopRequireDefault(_Resizer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (!CKEDITOR.plugins.get('embedurl')) {
	var REGEX_HTTP = /^https?/;

	CKEDITOR.DEFAULT_LFR_EMBED_WIDGET_TPL = '<div data-embed-url="{url}" class="embed-responsive embed-responsive-16by9">{content}<div class="embed-help-message">{helpMessageIcon}<span> {helpMessage}</span></div></div><br>';

	/**
  * Enum for supported embed alignments
  * @type {Object}
  */

	var EMBED_ALIGNMENT = {
		CENTER: 'center',
		LEFT: 'left',
		RIGHT: 'right'
	};

	/**
  * Enum values for supported embed alignments
  * @type {Array}
  */

	var ALIGN_VALUES = [EMBED_ALIGNMENT.CENTER, EMBED_ALIGNMENT.LEFT, EMBED_ALIGNMENT.RIGHT];

	/**
  * Necessary styles for the center alignment
  * @type {Array.<Object>}
  */

	var CENTERED_EMBED_STYLE = [{
		name: 'display',
		value: 'block'
	}, {
		name: 'margin-left',
		value: 'auto'
	}, {
		name: 'margin-right',
		value: 'auto'
	}];

	/**
  * Retrieves the alignment value of an embed element.
  *
  * @param {CKEDITOR.dom.element} embed The embed element
  * @return {String} The alignment value
  */

	var getEmbedAlignment = function getEmbedAlignment(embed) {
		var embedAlignment = embed.getStyle('float');

		if (!embedAlignment || embedAlignment === 'inherit' || embedAlignment === 'none') {
			embedAlignment = embed.getAttribute('align');
		}

		if (!embedAlignment) {
			var centeredEmbed = CENTERED_EMBED_STYLE.every(function (style) {
				var styleCheck = embed.getStyle(style.name) === style.value;

				if (!styleCheck && style.vendorPrefixes) {
					styleCheck = style.vendorPrefixes.some(function (vendorPrefix) {
						return embed.getStyle(vendorPrefix + style.name) === style.value;
					});
				}

				return styleCheck;
			});

			embedAlignment = centeredEmbed ? EMBED_ALIGNMENT.CENTER : null;
		}

		return embedAlignment;
	};

	/**
  * Removes the alignment value of an embed
  *
  * @param {CKEDITOR.dom.element} embed The embed element
  * @param {String} embedAlignment The embed alignment value to be removed
  */

	var removeEmbedAlignment = function removeEmbedAlignment(embed, embedAlignment) {
		if (embedAlignment === EMBED_ALIGNMENT.LEFT || embedAlignment === EMBED_ALIGNMENT.RIGHT) {
			embed.removeStyle('float');

			if (embedAlignment === getEmbedAlignment(embed)) {
				embed.removeAttribute('align');
			}
		} else if (embedAlignment === EMBED_ALIGNMENT.CENTER) {
			CENTERED_EMBED_STYLE.forEach(function (style) {
				embed.removeStyle(style.name);

				if (style.vendorPrefixes) {
					style.vendorPrefixes.forEach(function (vendorPrefix) {
						return embed.removeStyle(vendorPrefix + style.name);
					});
				}
			});
		}
	};

	/**
  * Sets the alignment value of an embed
  *
  * @param {CKEDITOR.dom.element} embed The embed element
  * @param {String} embedAlignment The embed alignment value to be set
  */

	var setEmbedAlignment = function setEmbedAlignment(embed, embedAlignment) {
		removeEmbedAlignment(embed, getEmbedAlignment(embed));

		if (embedAlignment === EMBED_ALIGNMENT.LEFT || embedAlignment === EMBED_ALIGNMENT.RIGHT) {
			embed.setStyle('float', embedAlignment);
		} else if (embedAlignment === EMBED_ALIGNMENT.CENTER) {
			CENTERED_EMBED_STYLE.forEach(function (style) {
				embed.setStyle(style.name, style.value);

				if (style.vendorPrefixes) {
					style.vendorPrefixes.forEach(function (vendorPrefix) {
						return embed.setStyle(vendorPrefix + style.name, style.value);
					});
				}
			});
		}
	};

	var getSelectedElement = function getSelectedElement(editor) {
		var result = {
			alignment: null,
			element: null
		};

		var selection = editor.getSelection();

		if (selection) {
			var selectedElement = selection.getSelectedElement();

			if (selectedElement && selectedElement.getAttribute('data-cke-widget-wrapper')) {
				result.alignment = getEmbedAlignment(selectedElement);
				result.element = selectedElement;
			}
		}

		return result;
	};

	var resizeElement = function resizeElement(el, width, height) {
		var wrapperElement = el.parentElement;

		if (wrapperElement && width > 0 && height > 0) {
			var rect = wrapperElement.getBoundingClientRect();

			var pwidth = width >= rect.width ? 100 : Math.floor(width / rect.width * 100);
			var style = 'width:' + pwidth + '%;';

			wrapperElement.setAttribute('style', style);

			var widgetElement = wrapperElement.querySelector('[data-widget="embedurl"]');

			if (widgetElement) {
				var styles = JSON.parse(widgetElement.getAttribute('data-styles')) || {};

				styles.width = width + 'px';
				styles.height = height + 'px';

				widgetElement.setAttribute('data-styles', JSON.stringify(styles));

				var iframeElement = widgetElement.querySelector('iframe');

				if (iframeElement) {
					iframeElement.setAttribute('width', width);
					iframeElement.setAttribute('height', height);
				}
			}
		}
	};

	var selectWidget = function selectWidget(editor) {
		setTimeout(function () {
			var selection = editor.getSelection();

			if (selection) {
				var wrapperElement = selection.root.find('[data-cke-widget-wrapper]');

				if (wrapperElement) {
					var elementList = wrapperElement.$;
					if (elementList.length > 0) {
						var lastElement = new CKEDITOR.dom.element(elementList[elementList.length - 1]);

						var imageElement = lastElement.findOne('img');
						var widgetElement = lastElement.findOne('[data-widget="embedurl"]');

						if (imageElement && widgetElement) {
							var range = editor.createRange();

							range.setStart(widgetElement, 0);
							range.setEnd(imageElement, 1);

							selection.selectRanges([range]);
							selection.selectElement(lastElement);
						}
					}
				}
			}
		}, 0);
	};

	var currentAlignment = null;
	var currentElement = null;
	var resizer = null;

	/**
  * CKEditor plugin which adds the infrastructure to embed urls as media objects
  *
  * This plugin adds an `embedUrl` command that can be used to easily embed a URL and transform it
  * to an embedded content.
  *
  * @class CKEDITOR.plugins.embedurl
  */

	CKEDITOR.plugins.add('embedurl', {
		requires: 'widget',

		init: function init(editor) {
			var LFR_EMBED_WIDGET_TPL = new CKEDITOR.template(editor.config.embedWidgetTpl || CKEDITOR.DEFAULT_LFR_EMBED_WIDGET_TPL);

			var providers = editor.config.embedProviders || [];

			providers = providers.map(function (provider) {
				return {
					id: provider.id,
					tpl: new CKEDITOR.template('<div data-embed-id="{embedId}">' + provider.tpl + '</div>'),
					type: provider.type,
					urlSchemes: provider.urlSchemes.map(function (scheme) {
						return new RegExp(scheme);
					})
				};
			});

			var generateEmbedContent = function generateEmbedContent(url, content) {
				return LFR_EMBED_WIDGET_TPL.output({
					content: content,
					helpMessage: AlloyEditor.Strings.videoPlaybackDisabled,
					helpMessageIcon: Liferay.Util.getLexiconIconTpl('info-circle'),
					url: url
				});
			};

			var defaultEmbedWidgetUpcastFn = function defaultEmbedWidgetUpcastFn(element, data) {
				var upcastWidget = false;

				if (element.name === 'div' && element.attributes['data-embed-url']) {
					data.url = element.attributes['data-embed-url'];

					upcastWidget = true;
				} else if (element.name === 'div' && element.attributes['data-embed-id']) {
					var iframe = element.children[0];

					data.url = iframe.attributes.src;

					delete element.attributes.style;

					var embedContent = generateEmbedContent(data.url, element.getOuterHtml());

					var widgetFragment = new CKEDITOR.htmlParser.fragment.fromHtml(embedContent);

					upcastWidget = widgetFragment.children[0];

					upcastWidget.attributes['data-styles'] = element.attributes['data-styles'];
					upcastWidget.removeClass('embed-responsive');
					upcastWidget.removeClass('embed-responsive-16by9');

					element.replaceWith(upcastWidget);
				}

				return upcastWidget;
			};

			var showError = function showError(errorMsg) {
				editor.fire('error', errorMsg);

				setTimeout(function () {
					editor.getSelection().removeAllRanges();

					editor.focus();

					resizer.hide();
				}, 0);
			};

			editor.addCommand('embedUrl', {
				exec: function exec(editor, data) {
					var type = data.type;
					var url = data.url;
					var content = void 0;

					if (REGEX_HTTP.test(url)) {
						var validProvider = providers.filter(function (provider) {
							return type ? provider.type === type : true;
						}).some(function (provider) {
							var scheme = provider.urlSchemes.find(function (scheme) {
								return scheme.test(url);
							});

							if (scheme) {
								var embedId = scheme.exec(url)[1];

								content = provider.tpl.output({
									embedId: embedId
								});
							}

							return scheme;
						});

						if (validProvider) {
							editor._selectEmbedWidget = url;

							var embedContent = generateEmbedContent(url, content);

							editor.insertHtml(embedContent);
						} else {
							showError(AlloyEditor.Strings.platformNotSupported);
						}
					} else {
						showError(AlloyEditor.Strings.enterValidUrl);
					}
				}
			});

			editor.widgets.add('embedurl', {
				draggable: false,
				mask: true,
				requiredContent: 'div[data-embed-url]',

				data: function data(event) {
					var instance = this;

					// Sync dimensions and alignment with editor wrapper

					var styles = null;

					var stylesJSON = instance.element.getAttribute('data-styles');

					if (stylesJSON) {
						try {
							styles = JSON.parse(stylesJSON);
						} catch (_error) {
							styles = null;
						}
					}

					if (!styles) {
						var iframe = instance.wrapper.findOne('iframe');

						var bounds = instance.wrapper.$.getBoundingClientRect();
						var width = iframe.getAttribute('width');

						var pwidth = width >= bounds.width ? 100 : Math.round(width / bounds.width * 100);

						styles = {
							width: pwidth + '%'
						};
					}

					instance.wrapper.setAttribute('style', CKEDITOR.tools.writeCssText(styles));

					if (editor._selectEmbedWidget === event.data.url) {
						selectWidget(editor);
					}
				},
				downcast: function downcast(widget) {
					var embedContent = widget.children[0];

					embedContent.attributes.class = 'embed-responsive embed-responsive-16by9';

					embedContent.attributes['data-styles'] = JSON.stringify(CKEDITOR.tools.parseCssText(widget.parent.attributes.style));

					embedContent.attributes.style = widget.parent.attributes.style;

					return embedContent;
				},
				upcast: function upcast(element, data) {
					var embedWidgetUpcastFn = editor.config.embedWidgetUpcastFn || defaultEmbedWidgetUpcastFn;

					return embedWidgetUpcastFn(element, data);
				}
			});

			window.addEventListener('resize', function () {
				resizer.hide();
				selectWidget(editor);
			}, false);

			editor.on('selectionChange', function (_event) {
				var selection = editor.getSelection();

				if (selection) {
					var element = selection.getSelectedElement();

					if (element) {
						var widgetElement = element.findOne('[data-widget="embedurl"]');

						if (widgetElement) {
							var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();

							var region = element.getClientRect();

							region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
							region.left -= scrollPosition.x;
							region.top += scrollPosition.y;

							editor.fire('editorInteraction', {
								nativeEvent: {},
								selectionData: {
									element: widgetElement,
									region: region
								}
							});
						}

						var imageElement = element.findOne('img.cke_widget_mask');

						if (imageElement) {
							resizer.show(imageElement.$);
						}
					} else {
						resizer.hide();
					}
				}
			});

			editor.on('destroy', function () {
				var resizeElement = document.getElementById('ckimgrsz');

				if (resizeElement) {
					resizeElement.remove();
				}

				document.removeEventListener('mousedown', mouseDownListener);
			});

			editor.on('blur', function () {
				resizer.hide();
			});

			editor.filter.addElementCallback(function (element) {
				if ('data-embed-url' in element.attributes) {
					return CKEDITOR.FILTER_SKIP_TREE;
				}
			});

			var mouseDownListener = function mouseDownListener(event) {
				var result = getSelectedElement(editor);

				currentAlignment = result.alignment;
				currentElement = result.element;

				if (resizer.isHandle(event.target)) {
					resizer.initDrag(event);
				}
			};

			resizer = new _Resizer2.default(editor, {
				onComplete: function onComplete(element, width, height) {
					resizeElement(element, width, height);

					if (currentAlignment && currentElement) {
						setEmbedAlignment(currentElement, currentAlignment);
					}
					selectWidget(editor);
				}
			});

			document.addEventListener('mousedown', mouseDownListener, false);
		},

		afterInit: function afterInit(editor) {
			ALIGN_VALUES.forEach(function (alignValue) {
				var command = editor.getCommand('justify' + alignValue);

				if (command) {
					command.on('exec', function (event) {
						var selectedElement = editor.getSelection().getSelectedElement();

						if (selectedElement && selectedElement.getAttribute('data-cke-widget-wrapper')) {
							var selectedEmbed = selectedElement.findOne('[data-widget="embedurl"] [data-embed-id]');

							if (selectedEmbed) {
								var embedAlignment = getEmbedAlignment(selectedElement);

								if (embedAlignment === alignValue) {
									removeEmbedAlignment(selectedElement, alignValue);
								} else {
									setEmbedAlignment(selectedElement, alignValue);
								}

								currentElement = selectedElement;
								currentAlignment = getEmbedAlignment(selectedElement);

								var imageElement = selectedElement.findOne('img');

								if (imageElement) {
									resizer.show(imageElement.$);
								}

								event.cancel();

								var elementPath = new CKEDITOR.dom.elementPath(selectedElement);

								ALIGN_VALUES.forEach(function (alignValue) {
									var command = editor.getCommand('justify' + alignValue);

									if (command) {
										command.refresh(editor, elementPath);
									}
								});
							}
						}
					});

					command.on('refresh', function (event) {
						var lastElement = event.data.path.lastElement;

						if (lastElement && lastElement.getAttribute('data-cke-widget-wrapper') && lastElement.findOne('[data-widget] [data-embed-id]')) {
							var embedAlignment = getEmbedAlignment(lastElement);

							event.sender.setState(embedAlignment === alignValue ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF);

							event.cancel();
						}
					});
				}
			});
		}
	});
} /**
   * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
   * SPDX-License-Identifier: LGPL-3.0-or-later
   */

exports.default = CKEDITOR.plugins.get('embedurl');

/***/ }),

/***/ "./src/plugins/imagealignment.js":
/*!***************************************!*\
  !*** ./src/plugins/imagealignment.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _selectionTest = __webpack_require__(/*! ../selections/selection-test */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**
                                                                                                                                                                                                                   * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                   * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                   */

if (!CKEDITOR.plugins.get('ae_imagealignment')) {
	var _IMAGE_STYLE_ALIGNMEN;

	/**
  * Enum for supported image alignments
  * @type {Object}
  */
	var IMAGE_ALIGNMENT = {
		CENTER: 'center',
		LEFT: 'left',
		RIGHT: 'right'
	};

	/**
  * Enum values for supported image alignments
  * @type {Array}
  */
	var ALIGN_VALUES = [IMAGE_ALIGNMENT.LEFT, IMAGE_ALIGNMENT.RIGHT, IMAGE_ALIGNMENT.CENTER];

	/**
  * Necessary styles for the left|center|right alignment
  * @type {Array.<Object>}
  */
	var IMAGE_STYLE_ALIGNMENT = (_IMAGE_STYLE_ALIGNMEN = {}, _defineProperty(_IMAGE_STYLE_ALIGNMEN, IMAGE_ALIGNMENT.LEFT, [{
		name: 'display',
		value: 'inline-block'
	}, {
		name: 'float',
		value: 'left'
	}, {
		name: 'margin-right',
		value: '1.2rem'
	}]), _defineProperty(_IMAGE_STYLE_ALIGNMEN, IMAGE_ALIGNMENT.CENTER, [{
		name: 'display',
		value: 'block'
	}, {
		name: 'margin-left',
		value: 'auto'
	}, {
		name: 'margin-right',
		value: 'auto'
	}]), _defineProperty(_IMAGE_STYLE_ALIGNMEN, IMAGE_ALIGNMENT.RIGHT, [{
		name: 'display',
		value: 'inline-block'
	}, {
		name: 'float',
		value: 'right'
	}, {
		name: 'margin-left',
		value: '1.2rem'
	}]), _IMAGE_STYLE_ALIGNMEN);

	/**
  * Retrieves the alignment value of an image.
  *
  * @param {CKEDITOR.dom.element} image The image element
  * @return {String} The alignment value
  */
	var getImageAlignment = function getImageAlignment(image) {
		var imageAlignment = image.getStyle('float');

		if (!imageAlignment || imageAlignment === 'inherit' || imageAlignment === 'none') {
			imageAlignment = image.getAttribute('align');
		}

		if (!imageAlignment) {
			var centeredImage = IMAGE_STYLE_ALIGNMENT[IMAGE_ALIGNMENT.CENTER].every(function (style) {
				var styleCheck = image.getStyle(style.name) === style.value;

				if (!styleCheck && style.vendorPrefixes) {
					styleCheck = style.vendorPrefixes.some(function (vendorPrefix) {
						return image.getStyle(vendorPrefix + style.name) === style.value;
					});
				}

				return styleCheck;
			});

			if (!imageAlignment) {
				var imageContainer = image.$.parentNode;

				if (imageContainer.style.textAlign == IMAGE_ALIGNMENT.CENTER) {
					IMAGE_STYLE_ALIGNMENT[IMAGE_ALIGNMENT.CENTER].forEach(function (style) {
						image.setStyle(style.name, style.value);

						if (style.vendorPrefixes) {
							style.vendorPrefixes.forEach(function (vendorPrefix) {
								image.setStyle(vendorPrefix + style.name, style.value);
							});
						}
					});
					centeredImage = true;
					imageContainer.style.textAlign = '';
				}
			}

			imageAlignment = centeredImage ? IMAGE_ALIGNMENT.CENTER : null;
		}

		if (!CKEDITOR.env.edge && CKEDITOR.env.ie) {
			var p = image.findOne('p');
			if (p) {
				imageAlignment = p.getStyle('text-align');
			}
		}

		return imageAlignment;
	};

	/**
  * Removes the alignment value of an image
  *
  * @param {CKEDITOR.dom.element} image The image element
  * @param {String} imageAlignment The image alignment value to be removed
  */
	var removeImageAlignment = function removeImageAlignment(image, imageAlignment) {
		if (imageAlignment === IMAGE_ALIGNMENT.LEFT || imageAlignment === IMAGE_ALIGNMENT.RIGHT) {
			if (imageAlignment === getImageAlignment(image)) {
				image.removeAttribute('align');
			}
		} else if (imageAlignment === IMAGE_ALIGNMENT.CENTER) {
			var imageContainer = image.$.parentNode;

			if (imageContainer.style.textAlign == IMAGE_ALIGNMENT.CENTER) {
				imageContainer.style.textAlign = '';
			}
		}

		var styles = IMAGE_STYLE_ALIGNMENT[imageAlignment];

		if (styles) {
			styles.forEach(function (style) {
				image.removeStyle(style.name);

				if (style.vendorPrefixes) {
					style.vendorPrefixes.forEach(function (vendorPrefix) {
						image.removeStyle(vendorPrefix + style.name);
					});
				}
			});
		}
	};

	/**
  * Sets the alignment value of an image
  *
  * @param {CKEDITOR.dom.element} image The image element
  * @param {String} imageAlignment The image alignment value to be set
  */
	var setImageAlignment = function setImageAlignment(image, imageAlignment) {
		removeImageAlignment(image, getImageAlignment(image));

		var styles = IMAGE_STYLE_ALIGNMENT[imageAlignment];

		if (styles) {
			styles.forEach(function (style) {
				image.setStyle(style.name, style.value);

				if (style.vendorPrefixes) {
					style.vendorPrefixes.forEach(function (vendorPrefix) {
						image.setStyle(vendorPrefix + style.name, style.value);
					});
				}
			});
		}
	};

	/**
  * CKEditor plugin which modifies the justify commands to properly align images. This
  * plugin is an excerpt of CKEditor's original image one that can be found at
  * https://github.com/ckeditor/ckeditor-dev/blob/master/plugins/image/plugin.js
  *
  * @class CKEDITOR.plugins.ae_imagealignment
  */
	CKEDITOR.plugins.add('ae_imagealignment', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function registers a 'paste' event on the editing area.
   *
   * @method afterInit
   * @param {Object} editor The current editor instance
   */
		afterInit: function afterInit(editor) {
			var self = this;

			ALIGN_VALUES.forEach(function (value) {
				var command = editor.getCommand('justify' + value);

				if (command) {
					command.on('exec', function (event) {
						var selectionData = editor.getSelectionData();

						if (selectionData && _selectionTest2.default.image({
							data: { selectionData: selectionData }
						})) {
							var image = selectionData.element;

							var imageAlignment = getImageAlignment(image);

							if (imageAlignment === value) {
								removeImageAlignment(image, value);
							} else {
								setImageAlignment(image, value);
							}

							event.cancel();

							self.refreshCommands(editor, new CKEDITOR.dom.elementPath(image));
						}
					});

					command.on('refresh', function (event) {
						var selectionData = {
							element: event.data.path.lastElement
						};

						if (_selectionTest2.default.image({
							data: { selectionData: selectionData }
						})) {
							var imageAlignment = getImageAlignment(selectionData.element);

							this.setState(imageAlignment === value ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF);

							event.cancel();
						}
					});
				}
			});
		},


		/**
   * Forces a refresh of the modified justify commands. This is needed because the applied changes
   * do not modify the selection, so the refresh is never triggered and the UI does not update
   * properly until the next selectionChange event.
   *
   * @param {CKEDITOR.editor} editor The editor instance
   * @param {CKEDITOR.dom.elementPath} elementPath The path of the selected image
   */
		refreshCommands: function refreshCommands(editor, elementPath) {
			ALIGN_VALUES.forEach(function (value) {
				var command = editor.getCommand('justify' + value);

				if (command) {
					command.refresh(editor, elementPath);
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/plugins/index.js":
/*!******************************!*\
  !*** ./src/plugins/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.embedurl = undefined;

__webpack_require__(/*! ./addimages */ "./src/plugins/addimages.js");

__webpack_require__(/*! ./autolink */ "./src/plugins/autolink.js");

__webpack_require__(/*! ./autolist */ "./src/plugins/autolist.js");

__webpack_require__(/*! ./dragresize */ "./src/plugins/dragresize.js");

__webpack_require__(/*! ./dragresize_ie11 */ "./src/plugins/dragresize_ie11.js");

__webpack_require__(/*! ./embed */ "./src/plugins/embed.js");

var _embedurl = __webpack_require__(/*! ./embedurl */ "./src/plugins/embedurl.js");

var _embedurl2 = _interopRequireDefault(_embedurl);

__webpack_require__(/*! ./imagealignment */ "./src/plugins/imagealignment.js");

__webpack_require__(/*! ./pasteimages */ "./src/plugins/pasteimages.js");

__webpack_require__(/*! ./placeholder */ "./src/plugins/placeholder.js");

__webpack_require__(/*! ./selectionkeystrokes */ "./src/plugins/selectionkeystrokes.js");

__webpack_require__(/*! ./tableresize */ "./src/plugins/tableresize.js");

__webpack_require__(/*! ./tabletools */ "./src/plugins/tabletools.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.embedurl = _embedurl2.default; /**
                                        * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
                                        * SPDX-License-Identifier: LGPL-3.0-or-later
                                        */

/***/ }),

/***/ "./src/plugins/pasteimages.js":
/*!************************************!*\
  !*** ./src/plugins/pasteimages.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

if (!CKEDITOR.plugins.get('ae_pasteimages')) {
	/**
  * CKEditor plugin which allows pasting images directly into the editable area. The image will be encoded
  * as Data URI. An event `beforeImageAdd` will be fired with the list of pasted images. If any of the listeners
  * returns `false` or cancels the event, the images won't be added to the content. Otherwise,
  * an event `imageAdd` will be fired with the inserted element into the editable area.
  *
  * @class CKEDITOR.plugins.ae_pasteimages
  */

	/**
  * Fired before adding images to the editor.
  * @event beforeImageAdd
  * @param {Array} imageFiles Array of image files
  */

	/**
  * Fired when an image is being added to the editor successfully.
  *
  * @event imageAdd
  * @param {CKEDITOR.dom.element} el The created image with src as Data URI
  * @param {File} file The image file
  */

	CKEDITOR.plugins.add('ae_pasteimages', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function registers a 'paste' event on the editing area.
   *
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			var _this = this;

			editor.once('contentDom', function () {
				var editable = editor.editable();

				editable.attachListener(editable, 'paste', _this._onPaste, _this, {
					editor: editor
				});
			});
		},


		/**
   * The function creates an img element with src the image data as Data URI.
   * Then, it fires an 'imageAdd' event via CKEditor's event system. The passed
   * params will be:
   * - `el` - the created img element
   * - `file` - the original pasted data
   *
   * @method _onPaste
   * @protected
   * @param {CKEDITOR.dom.event} event A `paste` event, as received natively from CKEditor
   */
		_onPaste: function _onPaste(event) {
			if (event.data.$.clipboardData) {
				var pastedData = event.data.$.clipboardData.items[0];
				var editor = event.listenerData.editor;

				if (pastedData.type.indexOf('image') === 0) {
					var reader = new FileReader();
					var imageFile = pastedData.getAsFile();

					reader.onload = function (event) {
						var result = editor.fire('beforeImageAdd', {
							imageFiles: imageFile
						});

						if (result) {
							var el = CKEDITOR.dom.element.createFromHtml('<img src="' + event.target.result + '">');

							editor.insertElement(el);

							var imageData = {
								el: el,
								file: imageFile
							};

							editor.fire('imageAdd', imageData);
						}
					};

					reader.readAsDataURL(imageFile);
				}
			}
		}
	});
}

/***/ }),

/***/ "./src/plugins/placeholder.js":
/*!************************************!*\
  !*** ./src/plugins/placeholder.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

if (!CKEDITOR.plugins.get('ae_placeholder')) {
	/**
  * CKEDITOR enterMode config set the behavior of paragraphs
  * When the content is empty CKEDITOR keeps the enterMode string
  * into the content
  * @property
  * @type {string}
  */
	var brFiller = CKEDITOR.env.needsBrFiller ? '<br>' : '';

	var enterModeEmptyValue = {
		1: ['<p>' + brFiller + '</p>'],
		2: ['', ' ', brFiller],
		3: ['<div>' + brFiller + '</div>']
	};

	/**
  * CKEditor plugin which allows adding a placeholder to the editor. In this case, if there
  * is no content to the editor, there will be hint to the user.
  *
  * @class CKEDITOR.plugins.ae_placeholder
  */

	/**
  * Specifies the placeholder class which have to be aded to editor when editor is not focused.
  *
  * @attribute placeholderClass
  * @default ae_placeholder
  * @type String
  */

	CKEDITOR.plugins.add('ae_placeholder', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function registers a 'blur' and 'contentDom' event listeners.
   *
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			editor.on('blur', this._checkEmptyData, this);
			editor.on('change', this._checkEmptyData, this);
			editor.on('focus', this._removePlaceholderClass, this);
			editor.once('contentDom', this._checkEmptyData, this);
		},


		/**
   * Removes any data from the content and adds a class,
   * specified by the "placeholderClass" config attribute.
   *
   * @protected
   * @method _checkEmptyData
   * @param {CKEDITOR.dom.event} editor event, fired from CKEditor
   */
		_checkEmptyData: function _checkEmptyData(event) {
			var editor = event.editor;

			var editableNode = editor.editable();

			var innerHtml = editableNode.$.innerHTML.trim();

			var isEmpty = enterModeEmptyValue[editor.config.enterMode].some(function (element) {
				return innerHtml === element;
			});

			if (isEmpty) {
				editableNode.addClass(editor.config.placeholderClass);
			} else {
				editableNode.removeClass(editor.config.placeholderClass);
			}
		},


		/**
             * Remove placeholder class when input is focused
             *
             * @protected
             * @method _removePlaceholderClass
             + @param {CKEDITOR.dom.event} editor event, fired from CKEditor
             */
		_removePlaceholderClass: function _removePlaceholderClass(event) {
			var editor = event.editor;

			var editorNode = new CKEDITOR.dom.element(editor.element.$);

			editorNode.removeClass(editor.config.placeholderClass);
		}
	});
}

/***/ }),

/***/ "./src/plugins/priorities.js":
/*!***********************************!*\
  !*** ./src/plugins/priorities.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * Priorities that can be used to control the order in which event handlers run.
 *
 * @see https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_event.html#method-on
 */
var DEFAULT_PRIORITY = exports.DEFAULT_PRIORITY = 10;
var HIGH_PRIORITY = exports.HIGH_PRIORITY = 5;

/***/ }),

/***/ "./src/plugins/selectionkeystrokes.js":
/*!********************************************!*\
  !*** ./src/plugins/selectionkeystrokes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

if (!CKEDITOR.plugins.get('ae_selectionkeystrokes')) {
	/**
  * CKEditor plugin that simulates editor interaction events based on manual keystrokes. This
  * can be used to trigger different reactions in the editor.
  *
  * @class CKEDITOR.plugins.ae_selectionkeystrokes
  */
	CKEDITOR.plugins.add('ae_selectionkeystrokes', {
		requires: 'ae_selectionregion',

		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function adds a command to the editor for every defined selectionKeystroke
   * in the configuration and maps it to the specified keystroke.
   *
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			if (editor.config.selectionKeystrokes) {
				editor.config.selectionKeystrokes.forEach(function (selectionKeystroke) {
					var command = new CKEDITOR.command(editor, {
						exec: function exec(editor) {
							editor.fire('editorInteraction', {
								manualSelection: selectionKeystroke.selection,
								nativeEvent: {},
								selectionData: editor.getSelectionData()
							});
						}
					});

					var commandName = 'selectionKeystroke' + selectionKeystroke.selection;

					editor.addCommand(commandName, command);
					editor.setKeystroke(selectionKeystroke.keys, commandName);
				});
			}
		}
	});
}

/***/ }),

/***/ "./src/plugins/tableresize.js":
/*!************************************!*\
  !*** ./src/plugins/tableresize.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

if (!CKEDITOR.plugins.get('ae_tableresize')) {
	var pxUnit = CKEDITOR.tools.cssLength;

	function getWidth(el) {
		return CKEDITOR.env.ie ? el.$.clientWidth : parseInt(el.getComputedStyle('width'), 10);
	}

	function getBorderWidth(element, side) {
		var computed = element.getComputedStyle('border-' + side + '-width');

		var borderMap = {
			thin: '0px',
			medium: '1px',
			thick: '2px'
		};

		if (computed.indexOf('px') < 0) {
			// look up keywords

			if (computed in borderMap && element.getComputedStyle('border-style') != 'none') {
				computed = borderMap[computed];
			} else {
				computed = 0;
			}
		}

		return parseInt(computed, 10);
	}

	// Gets the table row that contains the most columns.

	function getMasterPillarRow(table) {
		var $rows = table.$.rows;

		var maxCells = 0;

		var cellsCount = void 0;

		var $elected = void 0;

		var $tr = void 0;

		for (var i = 0, len = $rows.length; i < len; i++) {
			$tr = $rows[i];
			cellsCount = $tr.cells.length;

			if (cellsCount > maxCells) {
				maxCells = cellsCount;
				$elected = $tr;
			}
		}

		return $elected;
	}

	function buildTableColumnPillars(table) {
		var pillars = [];

		var pillarIndex = -1;

		var rtl = table.getComputedStyle('direction') === 'rtl';

		// Get the raw row element that cointains the most columns.

		var $tr = getMasterPillarRow(table);

		// Get the tbody element and position, which will be used to set the
		// top and bottom boundaries.

		var tbody = new CKEDITOR.dom.element(table.$.tBodies[0]);

		var tbodyPosition = tbody.getDocumentPosition();

		// Loop thorugh all cells, building pillars after each one of them.

		for (var i = 0, len = $tr.cells.length; i < len; i++) {
			// Both the current cell and the successive one will be used in the
			// pillar size calculation.

			var td = new CKEDITOR.dom.element($tr.cells[i]);

			var nextTd = $tr.cells[i + 1] && new CKEDITOR.dom.element($tr.cells[i + 1]);

			pillarIndex += td.$.colSpan || 1;

			// Calculate the pillar boundary positions.

			var pillarLeft = void 0;
			var pillarRight = void 0;

			var x = td.getDocumentPosition().x;

			// Calculate positions based on the current cell.

			if (rtl) {
				pillarRight = x + getBorderWidth(td, 'left');
			} else {
				pillarLeft = x + td.$.offsetWidth - getBorderWidth(td, 'right');
			}

			// Calculate positions based on the next cell, if available.

			if (nextTd) {
				x = nextTd.getDocumentPosition().x;

				if (rtl) {
					pillarLeft = x + nextTd.$.offsetWidth - getBorderWidth(nextTd, 'right');
				} else {
					pillarRight = x + getBorderWidth(nextTd, 'left');
				}
			}

			// Otherwise calculate positions based on the table (for last cell).
			else {
					x = table.getDocumentPosition().x;

					if (rtl) {
						pillarLeft = x;
					} else {
						pillarRight = x + table.$.offsetWidth;
					}
				}

			var pillarWidth = Math.max(pillarRight - pillarLeft, 4);

			// The pillar should reflects exactly the shape of the hovered
			// column border line.

			pillars.push({
				table: table,
				index: pillarIndex,
				x: pillarLeft,
				y: tbodyPosition.y,
				width: pillarWidth,
				height: tbody.$.offsetHeight,
				rtl: rtl
			});
		}

		return pillars;
	}

	function getPillarAtPosition(pillars, positionX) {
		for (var i = 0, len = pillars.length; i < len; i++) {
			var pillar = pillars[i];

			if (positionX >= pillar.x && positionX <= pillar.x + pillar.width) {
				return pillar;
			}
		}

		return null;
	}

	function cancel(evt) {
		(evt.data || evt).preventDefault();
	}

	function ColumnResizer(editor, pillar) {
		var currentShift = void 0;
		var leftShiftBoundary = void 0;
		var leftSideCells = void 0;
		var resizing = void 0;
		var rightShiftBoundary = void 0;
		var rightSideCells = void 0;
		var startOffset = void 0;

		var document = editor.document;

		var resizer = CKEDITOR.dom.element.createFromHtml('<div data-cke-temp=1 contenteditable=false unselectable=on ' + 'style="position:absolute;cursor:col-resize;filter:alpha(opacity=0);opacity:0;' + 'padding:0;background-color:#004;background-image:none;border:0px none;z-index:10"></div>', document);

		var isResizing = this.isResizing = function () {
			return resizing;
		};

		var move = this.move = function (posX) {
			var resizerNewPosition = posX - Math.round(resizer.$.offsetWidth / 2);

			if (isResizing) {
				if (resizerNewPosition === leftShiftBoundary || resizerNewPosition === rightShiftBoundary) {
					return;
				}

				resizerNewPosition = Math.max(resizerNewPosition, leftShiftBoundary);
				resizerNewPosition = Math.min(resizerNewPosition, rightShiftBoundary);

				currentShift = resizerNewPosition - startOffset;
			}

			resizer.setStyle('left', pxUnit(resizerNewPosition));
		};

		function detach() {
			resizer.removeListener('mouseup', onMouseUp);
			resizer.removeListener('mousedown', onMouseDown);
			resizer.removeListener('mousemove', onMouseMove);
		}

		function resizeStart() {
			// Before starting to resize, figure out which cells to change
			// and the boundaries of this resizing shift.

			var columnIndex = pillar.index;

			var map = CKEDITOR.tools.buildTableMap(pillar.table);

			var leftColumnCells = [];

			var rightColumnCells = [];

			var leftMinSize = Number.MAX_VALUE;

			var rightMinSize = leftMinSize;

			var rtl = pillar.rtl;

			for (var i = 0, len = map.length; i < len; i++) {
				var row = map[i];

				var leftCell = row[columnIndex + (rtl ? 1 : 0)];

				var rightCell = row[columnIndex + (rtl ? 0 : 1)];

				leftCell = leftCell && new CKEDITOR.dom.element(leftCell);
				rightCell = rightCell && new CKEDITOR.dom.element(rightCell);

				if (!leftCell || !rightCell || !leftCell.equals(rightCell)) {
					if (leftCell) {
						leftMinSize = Math.min(leftMinSize, getWidth(leftCell));
					}
					if (rightCell) {
						rightMinSize = Math.min(rightMinSize, getWidth(rightCell));
					}

					leftColumnCells.push(leftCell);
					rightColumnCells.push(rightCell);
				}
			}

			// Cache the list of cells to be resized.

			leftSideCells = leftColumnCells;
			rightSideCells = rightColumnCells;

			// Cache the resize limit boundaries.

			leftShiftBoundary = pillar.x - leftMinSize;
			rightShiftBoundary = pillar.x + rightMinSize;

			resizer.setOpacity(0.5);
			startOffset = parseInt(resizer.getStyle('left'), 10);
			currentShift = 0;
			resizing = 1;

			resizer.on('mousemove', onMouseMove);

			// Prevent the native drag behavior otherwise 'mousemove' won't fire.

			document.on('dragstart', cancel);
		}

		function resizeEnd() {
			resizing = 0;

			resizer.setOpacity(0);

			if (currentShift) {
				resizeColumn();
			}

			var table = pillar.table;
			setTimeout(function () {
				table.removeCustomData('_cke_table_pillars');
			}, 0);

			document.removeListener('dragstart', cancel);
		}

		function resizeColumn() {
			var _this = this;

			var rtl = pillar.rtl;

			var cellsCount = rtl ? rightSideCells.length : leftSideCells.length;

			// Perform the actual resize to table cells, only for those by side of the pillar.

			var _loop = function _loop(i) {
				var leftCell = leftSideCells[i];

				var rightCell = rightSideCells[i];

				var table = pillar.table;

				// Defer the resizing to avoid any interference among cells.

				CKEDITOR.tools.setTimeout(function (leftCell, leftOldWidth, rightCell, rightOldWidth, tableWidth, sizeShift) {
					// 1px is the minimum valid width (#11626).

					if (leftCell) {
						leftCell.setStyle('width', pxUnit(Math.max(leftOldWidth + sizeShift, 1)));
					}
					if (rightCell) {
						rightCell.setStyle('width', pxUnit(Math.max(rightOldWidth - sizeShift, 1)));
					}

					// If we're in the last cell, we need to resize the table as well

					if (tableWidth) {
						table.setStyle('width', pxUnit(tableWidth + sizeShift * (rtl ? -1 : 1)));
					}
				}, 0, _this, [leftCell, leftCell && getWidth(leftCell), rightCell, rightCell && getWidth(rightCell), (!leftCell || !rightCell) && getWidth(table) + getBorderWidth(table, 'left') + getBorderWidth(table, 'right'), currentShift]);
			};

			for (var i = 0; i < cellsCount; i++) {
				_loop(i);
			}
		}

		function onMouseDown(evt) {
			cancel(evt);

			resizeStart();

			document.on('mouseup', onMouseUp, this);
		}

		function onMouseUp(evt) {
			evt.removeListener();

			resizeEnd();
		}

		function onMouseMove(evt) {
			move(evt.data.getPageOffset().x);
		}

		// Clean DOM when editor is destroyed.

		editor.on('destroy', function () {
			detach();

			resizer.remove();
		});

		// Place the resizer after body to prevent it
		// from being editable.

		document.getDocumentElement().append(resizer);

		resizer.setStyles({
			width: pxUnit(pillar.width),
			height: pxUnit(pillar.height),
			left: pxUnit(pillar.x),
			top: pxUnit(pillar.y)
		});

		resizer.on('mousedown', onMouseDown, this);

		document.getBody().setStyle('cursor', 'col-resize');

		// Display the resizer to receive events but don't show it,
		// only change the cursor to resizable shape.

		resizer.show();

		this.destroy = function () {
			detach();

			document.getBody().setStyle('cursor', 'auto');

			resizer.remove();
		};
	}

	function clearPillarsCache(evt) {
		var target = evt.data.getTarget();

		if (evt.name === 'mouseout') {
			// Bypass interal mouse move.

			if (!target.is('table')) {
				return;
			}

			var dest = new CKEDITOR.dom.element(evt.data.$.relatedTarget || evt.data.$.toElement);
			while (dest && dest.$ && !dest.equals(target) && !dest.is('body')) {
				dest = dest.getParent();
			}
			if (!dest || dest.equals(target)) {
				return;
			}
		}

		target.getAscendant('table', 1).removeCustomData('_cke_table_pillars');
		evt.removeListener();
	}

	CKEDITOR.plugins.add('ae_tableresize', {
		requires: 'ae_tabletools',

		init: function init(editor) {
			editor.on('contentDom', function () {
				var resizer = void 0;

				var editable = editor.editable();

				// In Classic editor it is better to use document
				// instead of editable so event will work below body.

				editable.attachListener(editable.isInline() ? editable : editor.document, 'mousemove', function (evt) {
					evt = evt.data;

					var target = evt.getTarget();

					// FF may return document and IE8 some UFO (object with no nodeType property...)
					// instead of an element (#11823).

					if (target.type !== CKEDITOR.NODE_ELEMENT) {
						return;
					}

					var pageX = evt.getPageOffset().x;

					// If we're already attached to a pillar, simply move the
					// resizer.

					if (resizer) {
						if (resizer.isResizing()) {
							resizer.move(pageX);

							cancel(evt);

							return;
						} else {
							resizer.destroy();

							resizer = null;
						}
					}

					// Considering table, tr, td, tbody but nothing else.

					var pillars = void 0;

					if (!target.is('table') && !target.getAscendant('tbody', 1)) {
						return;
					}

					var table = target.getAscendant('table', 1);

					// Make sure the table we found is inside the container
					// (eg. we should not use tables the editor is embedded within)

					if (!editor.editable().contains(table)) {
						return;
					}

					if (!(pillars = table.getCustomData('_cke_table_pillars'))) {
						// Cache table pillars calculation result.

						table.setCustomData('_cke_table_pillars', pillars = buildTableColumnPillars(table));
						table.on('mouseout', clearPillarsCache);
						table.on('mousedown', clearPillarsCache);
					}

					var pillar = getPillarAtPosition(pillars, pageX);

					if (pillar) {
						resizer = new ColumnResizer(editor, pillar);
					}
				});
			});
		}
	});
}

/***/ }),

/***/ "./src/plugins/tabletools.js":
/*!***********************************!*\
  !*** ./src/plugins/tabletools.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

if (!CKEDITOR.plugins.get('ae_tabletools')) {
	var cellNodeRegex = /^(?:td|th)$/;

	function getSelectedCells(selection) {
		var ranges = selection.getRanges();
		var retval = [];
		var database = {};

		function moveOutOfCellGuard(node) {
			// Apply to the first cell only.

			if (retval.length > 0) {
				return;
			}

			// If we are exiting from the first </td>, then the td should definitely be
			// included.

			if (node.type == CKEDITOR.NODE_ELEMENT && cellNodeRegex.test(node.getName()) && !node.getCustomData('selected_cell')) {
				CKEDITOR.dom.element.setMarker(database, node, 'selected_cell', true);
				retval.push(node);
			}
		}

		for (var i = 0; i < ranges.length; i++) {
			var range = ranges[i];

			if (range.collapsed) {
				// Walker does not handle collapsed ranges yet - fall back to old API.

				var startNode = range.getCommonAncestor();
				var nearestCell = startNode.getAscendant('td', true) || startNode.getAscendant('th', true);
				if (nearestCell) {
					retval.push(nearestCell);
				}
			} else {
				var walker = new CKEDITOR.dom.walker(range);
				var node = void 0;
				walker.guard = moveOutOfCellGuard;

				while (node = walker.next()) {
					// If may be possible for us to have a range like this:
					// <td>^1</td><td>^2</td>
					// The 2nd td shouldn't be included.
					//
					// So we have to take care to include a td we've entered only when we've
					// walked into its children.

					if (node.type != CKEDITOR.NODE_ELEMENT || !node.is(CKEDITOR.dtd.table)) {
						var parent = node.getAscendant('td', true) || node.getAscendant('th', true);
						if (parent && !parent.getCustomData('selected_cell')) {
							CKEDITOR.dom.element.setMarker(database, parent, 'selected_cell', true);
							retval.push(parent);
						}
					}
				}
			}
		}

		CKEDITOR.dom.element.clearAllMarkers(database);

		return retval;
	}

	function getFocusElementAfterDelCells(cellsToDelete) {
		var i = 0;

		var last = cellsToDelete.length - 1;

		var database = {};

		var cell = void 0;

		var focusedCell = void 0;

		var tr = void 0;

		while (cell = cellsToDelete[i++]) {
			CKEDITOR.dom.element.setMarker(database, cell, 'delete_cell', true);
		}

		// 1.first we check left or right side focusable cell row by row;

		i = 0;
		while (cell = cellsToDelete[i++]) {
			if ((focusedCell = cell.getPrevious()) && !focusedCell.getCustomData('delete_cell') || (focusedCell = cell.getNext()) && !focusedCell.getCustomData('delete_cell')) {
				CKEDITOR.dom.element.clearAllMarkers(database);

				return focusedCell;
			}
		}

		CKEDITOR.dom.element.clearAllMarkers(database);

		// 2. then we check the toppest row (outside the selection area square) focusable cell

		tr = cellsToDelete[0].getParent();
		if (tr = tr.getPrevious()) {
			return tr.getLast();
		}

		// 3. last we check the lowerest  row focusable cell

		tr = cellsToDelete[last].getParent();
		if (tr = tr.getNext()) {
			return tr.getChild(0);
		}

		return null;
	}

	function insertRow(editor, insertBefore) {
		var selection = editor.getSelection();

		var cells = getSelectedCells(selection);

		var firstCell = cells[0];

		var table = firstCell.getAscendant('table');

		var doc = firstCell.getDocument();

		var startRow = cells[0].getParent();

		var startRowIndex = startRow.$.rowIndex;

		var lastCell = cells[cells.length - 1];

		var endRowIndex = lastCell.getParent().$.rowIndex + lastCell.$.rowSpan - 1;

		var endRow = new CKEDITOR.dom.element(table.$.rows[endRowIndex]);

		var rowIndex = insertBefore ? startRowIndex : endRowIndex;

		var row = insertBefore ? startRow : endRow;

		var map = CKEDITOR.tools.buildTableMap(table);

		var cloneRow = map[rowIndex];

		var nextRow = insertBefore ? map[rowIndex - 1] : map[rowIndex + 1];

		var width = map[0].length;

		var newRow = doc.createElement('tr');
		for (var i = 0; cloneRow[i] && i < width; i++) {
			var _cell = void 0;

			// Check whether there's a spanning row here, do not break it.

			if (cloneRow[i].rowSpan > 1 && nextRow && cloneRow[i] == nextRow[i]) {
				_cell = cloneRow[i];
				_cell.rowSpan += 1;
			} else {
				_cell = new CKEDITOR.dom.element(cloneRow[i]).clone();
				_cell.removeAttribute('rowSpan');
				_cell.appendBogus();
				newRow.append(_cell);
				_cell = _cell.$;
			}

			i += _cell.colSpan - 1;
		}

		if (insertBefore) {
			newRow.insertBefore(row);
		} else {
			newRow.insertAfter(row);
		}

		var cell = new CKEDITOR.dom.element(newRow.$).getChild(cells[0] ? cells[0].$.cellIndex : 0);
		selectElement(editor, cell);
	}

	function deleteRows(selectionOrRow) {
		if (selectionOrRow instanceof CKEDITOR.dom.selection) {
			var cells = getSelectedCells(selectionOrRow);

			var firstCell = cells[0];

			var table = firstCell.getAscendant('table');

			var map = CKEDITOR.tools.buildTableMap(table);

			var startRow = cells[0].getParent();

			var startRowIndex = startRow.$.rowIndex;

			var lastCell = cells[cells.length - 1];

			var endRowIndex = lastCell.getParent().$.rowIndex + lastCell.$.rowSpan - 1;

			var rowsToDelete = [];

			// Delete cell or reduce cell spans by checking through the table map.

			for (var i = startRowIndex; i <= endRowIndex; i++) {
				var mapRow = map[i];

				var row = new CKEDITOR.dom.element(table.$.rows[i]);

				for (var j = 0; j < mapRow.length; j++) {
					var cell = new CKEDITOR.dom.element(mapRow[j]);

					var cellRowIndex = cell.getParent().$.rowIndex;

					if (cell.$.rowSpan == 1) {
						cell.remove();
					}

					// Row spanned cell.
					else {
							// Span row of the cell, reduce spanning.

							cell.$.rowSpan -= 1;

							// Root row of the cell, root cell to next row.

							if (cellRowIndex == i) {
								var nextMapRow = map[i + 1];
								if (nextMapRow[j - 1]) {
									cell.insertAfter(new CKEDITOR.dom.element(nextMapRow[j - 1]));
								} else {
									new CKEDITOR.dom.element(table.$.rows[i + 1]).append(cell, 1);
								}
							}
						}

					j += cell.$.colSpan - 1;
				}

				rowsToDelete.push(row);
			}

			var rows = table.$.rows;

			// Where to put the cursor after rows been deleted?
			// 1. Into next sibling row if any;
			// 2. Into previous sibling row if any;
			// 3. Into table's parent element if it's the very last row.

			var cursorPosition = new CKEDITOR.dom.element(rows[endRowIndex + 1] || (startRowIndex > 0 ? rows[startRowIndex - 1] : null) || table.$.parentNode);

			for (var _i = rowsToDelete.length; _i >= 0; _i--) {
				deleteRows(rowsToDelete[_i]);
			}

			return cursorPosition;
		} else if (selectionOrRow instanceof CKEDITOR.dom.element) {
			var _table = selectionOrRow.getAscendant('table');

			if (_table.$.rows.length == 1) {
				_table.remove();
			} else {
				selectionOrRow.remove();
			}
		}

		return null;
	}

	function getCellColIndex(cell, isStart) {
		var row = cell.getParent();

		var rowCells = row.$.cells;

		var colIndex = 0;
		for (var i = 0; i < rowCells.length; i++) {
			var mapCell = rowCells[i];
			colIndex += isStart ? 1 : mapCell.colSpan;
			if (mapCell == cell.$) {
				break;
			}
		}

		return colIndex - 1;
	}

	function getColumnsIndices(cells, isStart) {
		var retval = isStart ? Infinity : 0;
		for (var i = 0; i < cells.length; i++) {
			var colIndex = getCellColIndex(cells[i], isStart);
			if (isStart ? colIndex < retval : colIndex > retval) {
				retval = colIndex;
			}
		}

		return retval;
	}

	function insertColumn(editor, insertBefore) {
		var selection = editor.getSelection();

		var cells = getSelectedCells(selection);

		var firstCell = cells[0];

		var table = firstCell.getAscendant('table');

		var startCol = getColumnsIndices(cells, 1);

		var lastCol = getColumnsIndices(cells);

		var colIndex = insertBefore ? startCol : lastCol;

		var map = CKEDITOR.tools.buildTableMap(table);

		var cloneCol = [];

		var nextCol = [];

		var height = map.length;

		for (var i = 0; i < height; i++) {
			cloneCol.push(map[i][colIndex]);
			var nextCell = insertBefore ? map[i][colIndex - 1] : map[i][colIndex + 1];
			nextCol.push(nextCell);
		}

		var insertedCells = [];
		for (var _i2 = 0; _i2 < height; _i2++) {
			var _cell2 = void 0;

			if (!cloneCol[_i2]) {
				continue;
			}

			// Check whether there's a spanning column here, do not break it.

			if (cloneCol[_i2].colSpan > 1 && nextCol[_i2] == cloneCol[_i2]) {
				_cell2 = cloneCol[_i2];
				_cell2.colSpan += 1;
			} else {
				_cell2 = new CKEDITOR.dom.element(cloneCol[_i2]).clone();
				_cell2.removeAttribute('colSpan');
				_cell2.appendBogus();
				_cell2[insertBefore ? 'insertBefore' : 'insertAfter'].call(_cell2, new CKEDITOR.dom.element(cloneCol[_i2]));
				_cell2 = _cell2.$;
			}

			insertedCells[_i2] = _cell2;

			_i2 += _cell2.rowSpan - 1;
		}

		var cell = new CKEDITOR.dom.element(insertedCells[firstCell.getParent().$.rowIndex]);
		selectElement(editor, cell);
	}

	function selectElement(editor, element) {
		var range = editor.createRange();

		range.moveToPosition(element, CKEDITOR.POSITION_AFTER_START);
		editor.getSelection().selectRanges([range]);
	}

	function deleteColumns(selectionOrCell) {
		var cells = getSelectedCells(selectionOrCell);

		var firstCell = cells[0];

		var lastCell = cells[cells.length - 1];

		var table = firstCell.getAscendant('table');

		var map = CKEDITOR.tools.buildTableMap(table);

		var startColIndex = void 0;

		var endColIndex = void 0;

		var rowsToDelete = [];

		var rows = void 0;

		// Figure out selected cells' column indices.

		for (var i = 0, _rows = map.length; i < _rows; i++) {
			// eslint-disable-next-line sort-vars
			for (var j = 0, cols = map[i].length; j < cols; j++) {
				if (map[i][j] == firstCell.$) {
					startColIndex = j;
				}
				if (map[i][j] == lastCell.$) {
					endColIndex = j;
				}
			}
		}

		// Delete cell or reduce cell spans by checking through the table map.

		for (var _i3 = startColIndex; _i3 <= endColIndex; _i3++) {
			for (var _j = 0; _j < map.length; _j++) {
				var mapRow = map[_j];

				var row = new CKEDITOR.dom.element(table.$.rows[_j]);

				var cell = new CKEDITOR.dom.element(mapRow[_i3]);

				if (cell.$) {
					if (cell.$.colSpan == 1) {
						cell.remove();
					}

					// Reduce the col spans.
					else {
							cell.$.colSpan -= 1;
						}

					_j += cell.$.rowSpan - 1;

					if (!row.$.cells.length) {
						rowsToDelete.push(row);
					}
				}
			}
		}

		var firstRowCells = table.$.rows[0] && table.$.rows[0].cells;

		// Where to put the cursor after columns been deleted?
		// 1. Into next cell of the first row if any;
		// 2. Into previous cell of the first row if any;
		// 3. Into table's parent element;

		var cursorPosition = new CKEDITOR.dom.element(firstRowCells[startColIndex] || (startColIndex ? firstRowCells[startColIndex - 1] : table.$.parentNode));

		// Delete table rows only if all columns are gone (do not remove empty row).

		if (rowsToDelete.length == rows) {
			table.remove();
		}

		return cursorPosition;
	}

	function insertCell(selection, insertBefore) {
		var startElement = selection.getStartElement();
		var cell = startElement.getAscendant('td', 1) || startElement.getAscendant('th', 1);

		if (!cell) {
			return;
		}

		// Create the new cell element to be added.

		var newCell = cell.clone();
		newCell.appendBogus();

		if (insertBefore) {
			newCell.insertBefore(cell);
		} else {
			newCell.insertAfter(cell);
		}
	}

	function deleteCells(selectionOrCell) {
		if (selectionOrCell instanceof CKEDITOR.dom.selection) {
			var cellsToDelete = getSelectedCells(selectionOrCell);
			var table = cellsToDelete[0] && cellsToDelete[0].getAscendant('table');
			var cellToFocus = getFocusElementAfterDelCells(cellsToDelete);

			for (var i = cellsToDelete.length - 1; i >= 0; i--) {
				deleteCells(cellsToDelete[i]);
			}

			if (cellToFocus) {
				placeCursorInCell(cellToFocus, true);
			} else if (table) {
				table.remove();
			}
		} else if (selectionOrCell instanceof CKEDITOR.dom.element) {
			var tr = selectionOrCell.getParent();
			if (tr.getChildCount() == 1) {
				tr.remove();
			} else {
				selectionOrCell.remove();
			}
		}
	}

	// Remove filler at end and empty spaces around the cell content.

	function trimCell(cell) {
		var bogus = cell.getBogus();
		if (bogus) {
			bogus.remove();
		}
		cell.trim();
	}

	function placeCursorInCell(cell, placeAtEnd) {
		var docInner = cell.getDocument();

		var docOuter = CKEDITOR.document;

		// Fixing "Unspecified error" thrown in IE10 by resetting
		// selection the dirty and shameful way (#10308).
		// We can not apply this hack to IE8 because
		// it causes error (#11058).

		if (CKEDITOR.env.ie && CKEDITOR.env.version == 10) {
			docOuter.focus();
			docInner.focus();
		}

		var range = new CKEDITOR.dom.range(docInner);
		if (!range['moveToElementEdit' + (placeAtEnd ? 'End' : 'Start')](cell)) {
			range.selectNodeContents(cell);
			range.collapse(placeAtEnd ? false : true);
		}
		range.select(true);
	}

	function cellInRow(tableMap, rowIndex, cell) {
		var oRow = tableMap[rowIndex];
		if (typeof cell == 'undefined') {
			return oRow;
		}

		for (var c = 0; oRow && c < oRow.length; c++) {
			if (cell.is && oRow[c] == cell.$) {
				return c;
			} else if (c == cell) {
				return new CKEDITOR.dom.element(oRow[c]);
			}
		}

		return cell.is ? -1 : null;
	}

	function cellInCol(tableMap, colIndex) {
		var oCol = [];
		for (var r = 0; r < tableMap.length; r++) {
			var row = tableMap[r];
			oCol.push(row[colIndex]);

			// Avoid adding duplicate cells.

			if (row[colIndex].rowSpan > 1) {
				r += row[colIndex].rowSpan - 1;
			}
		}

		return oCol;
	}

	function mergeCells(selection, mergeDirection, isDetect) {
		var cells = getSelectedCells(selection);

		// Invalid merge request if:
		// 1. In batch mode despite that less than two selected.
		// 2. In solo mode while not exactly only one selected.
		// 3. Cells distributed in different table groups (e.g. from both thead and tbody).

		var commonAncestor = void 0;
		if ((mergeDirection ? cells.length != 1 : cells.length < 2) || (commonAncestor = selection.getCommonAncestor()) && commonAncestor.type == CKEDITOR.NODE_ELEMENT && commonAncestor.is('table')) {
			return false;
		}

		var cell = void 0;

		var firstCell = cells[0];

		var table = firstCell.getAscendant('table');

		var map = CKEDITOR.tools.buildTableMap(table);

		var mapHeight = map.length;

		var mapWidth = map[0].length;

		var startRow = firstCell.getParent().$.rowIndex;

		var startColumn = cellInRow(map, startRow, firstCell);

		if (mergeDirection) {
			var targetCell = void 0;
			try {
				var rowspan = parseInt(firstCell.getAttribute('rowspan'), 10) || 1;
				var colspan = parseInt(firstCell.getAttribute('colspan'), 10) || 1;

				targetCell = map[mergeDirection == 'up' ? startRow - rowspan : mergeDirection == 'down' ? startRow + rowspan : startRow][mergeDirection == 'left' ? startColumn - colspan : mergeDirection == 'right' ? startColumn + colspan : startColumn];
			} catch (er) {
				return false;
			}

			// 1. No cell could be merged.
			// 2. Same cell actually.

			if (!targetCell || firstCell.$ == targetCell) {
				return false;
			}

			// Sort in map order regardless of the DOM sequence.

			cells[mergeDirection == 'up' || mergeDirection == 'left' ? 'unshift' : 'push'](new CKEDITOR.dom.element(targetCell));
		}

		// Start from here are merging way ignorance (merge up/right, batch merge).

		var doc = firstCell.getDocument();

		var lastRowIndex = startRow;

		var totalRowSpan = 0;

		var totalColSpan = 0;

		// Use a documentFragment as buffer when appending cell contents.

		var frag = !isDetect && new CKEDITOR.dom.documentFragment(doc);

		var dimension = 0;

		for (var i = 0; i < cells.length; i++) {
			cell = cells[i];

			var tr = cell.getParent();

			var cellFirstChild = cell.getFirst();

			var colSpan = cell.$.colSpan;

			var rowSpan = cell.$.rowSpan;

			var rowIndex = tr.$.rowIndex;

			var colIndex = cellInRow(map, rowIndex, cell);

			// Accumulated the actual places taken by all selected cells.

			dimension += colSpan * rowSpan;

			// Accumulated the maximum virtual spans from column and row.

			totalColSpan = Math.max(totalColSpan, colIndex - startColumn + colSpan);
			totalRowSpan = Math.max(totalRowSpan, rowIndex - startRow + rowSpan);

			if (!isDetect) {
				// Trim all cell fillers and check to remove empty cells.

				if (trimCell(cell), cell.getChildren().count()) {
					// Merge vertically cells as two separated paragraphs.

					if (rowIndex != lastRowIndex && cellFirstChild && !(cellFirstChild.isBlockBoundary && cellFirstChild.isBlockBoundary({ br: 1 }))) {
						var last = frag.getLast(CKEDITOR.dom.walker.whitespaces(true));
						if (last && !(last.is && last.is('br'))) {
							frag.append('br');
						}
					}

					cell.moveChildren(frag);
				}
				if (i) {
					cell.remove();
				} else {
					cell.setHtml('');
				}
			}
			lastRowIndex = rowIndex;
		}

		if (!isDetect) {
			frag.moveChildren(firstCell);

			firstCell.appendBogus();

			if (totalColSpan >= mapWidth) {
				firstCell.removeAttribute('rowSpan');
			} else {
				firstCell.$.rowSpan = totalRowSpan;
			}

			if (totalRowSpan >= mapHeight) {
				firstCell.removeAttribute('colSpan');
			} else {
				firstCell.$.colSpan = totalColSpan;
			}

			// Swip empty <tr> left at the end of table due to the merging.

			var trs = new CKEDITOR.dom.nodeList(table.$.rows);

			var count = trs.count();

			for (var _i4 = count - 1; _i4 >= 0; _i4--) {
				var tailTr = trs.getItem(_i4);
				if (!tailTr.$.cells.length) {
					tailTr.remove();
					count++;
					continue;
				}
			}

			return firstCell;
		}

		// Be able to merge cells only if actual dimension of selected
		// cells equals to the caculated rectangle.
		else {
				return totalRowSpan * totalColSpan == dimension;
			}
	}

	function verticalSplitCell(selection, isDetect) {
		var cells = getSelectedCells(selection);
		if (cells.length > 1) {
			return false;
		} else if (isDetect) {
			return true;
		}

		var cell = cells[0];

		var tr = cell.getParent();

		var table = tr.getAscendant('table');

		var map = CKEDITOR.tools.buildTableMap(table);

		var rowIndex = tr.$.rowIndex;

		var colIndex = cellInRow(map, rowIndex, cell);

		var rowSpan = cell.$.rowSpan;

		var newCell = void 0;

		var newRowSpan = void 0;

		var newCellRowSpan = void 0;

		var newRowIndex = void 0;

		if (rowSpan > 1) {
			newRowSpan = Math.ceil(rowSpan / 2);
			newCellRowSpan = Math.floor(rowSpan / 2);
			newRowIndex = rowIndex + newRowSpan;
			var newCellTr = new CKEDITOR.dom.element(table.$.rows[newRowIndex]);

			var newCellRow = cellInRow(map, newRowIndex);

			var candidateCell = void 0;

			newCell = cell.clone();

			// Figure out where to insert the new cell by checking the vitual row.

			for (var c = 0; c < newCellRow.length; c++) {
				candidateCell = newCellRow[c];

				// Catch first cell actually following the column.

				if (candidateCell.parentNode == newCellTr.$ && c > colIndex) {
					newCell.insertBefore(new CKEDITOR.dom.element(candidateCell));
					break;
				} else {
					candidateCell = null;
				}
			}

			// The destination row is empty, append at will.

			if (!candidateCell) {
				newCellTr.append(newCell);
			}
		} else {
			newCellRowSpan = newRowSpan = 1;

			var _newCellTr = tr.clone();
			_newCellTr.insertAfter(tr);
			_newCellTr.append(newCell = cell.clone());

			var cellsInSameRow = cellInRow(map, rowIndex);
			for (var i = 0; i < cellsInSameRow.length; i++) {
				cellsInSameRow[i].rowSpan++;
			}
		}

		newCell.appendBogus();

		cell.$.rowSpan = newRowSpan;
		newCell.$.rowSpan = newCellRowSpan;
		if (newRowSpan == 1) {
			cell.removeAttribute('rowSpan');
		}
		if (newCellRowSpan == 1) {
			newCell.removeAttribute('rowSpan');
		}

		return newCell;
	}

	function horizontalSplitCell(selection, isDetect) {
		var cells = getSelectedCells(selection);
		if (cells.length > 1) {
			return false;
		} else if (isDetect) {
			return true;
		}

		var cell = cells[0];

		var tr = cell.getParent();

		var table = tr.getAscendant('table');

		var map = CKEDITOR.tools.buildTableMap(table);

		var rowIndex = tr.$.rowIndex;

		var colIndex = cellInRow(map, rowIndex, cell);

		var colSpan = cell.$.colSpan;

		var newColSpan = void 0;

		var newCellColSpan = void 0;

		if (colSpan > 1) {
			newColSpan = Math.ceil(colSpan / 2);
			newCellColSpan = Math.floor(colSpan / 2);
		} else {
			newCellColSpan = newColSpan = 1;
			var cellsInSameCol = cellInCol(map, colIndex);
			for (var i = 0; i < cellsInSameCol.length; i++) {
				cellsInSameCol[i].colSpan++;
			}
		}
		var newCell = cell.clone();
		newCell.insertAfter(cell);
		newCell.appendBogus();

		cell.$.colSpan = newColSpan;
		newCell.$.colSpan = newCellColSpan;
		if (newColSpan == 1) {
			cell.removeAttribute('colSpan');
		}
		if (newCellColSpan == 1) {
			newCell.removeAttribute('colSpan');
		}

		return newCell;
	}

	CKEDITOR.plugins.add('ae_tabletools', {
		init: function init(editor) {
			function createDef(def) {
				return CKEDITOR.tools.extend(def || {}, {
					contextSensitive: 1,
					refresh: function refresh(editor, path) {
						this.setState(path.contains({ td: 1, th: 1 }, 1) ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED);
					}
				});
			}
			function addCmd(name, def) {
				var cmd = editor.getCommand(name);

				if (cmd) {
					return;
				}

				cmd = editor.addCommand(name, def);
				editor.addFeature(cmd);
			}

			addCmd('rowDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					placeCursorInCell(deleteRows(selection));
				}
			}));

			addCmd('rowInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					insertRow(editor, true);
				}
			}));

			addCmd('rowInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					insertRow(editor);
				}
			}));

			addCmd('columnDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					var element = deleteColumns(selection);
					if (element) {
						placeCursorInCell(element, true);
					}
				}
			}));

			addCmd('columnInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					insertColumn(editor, true);
				}
			}));

			addCmd('columnInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					insertColumn(editor);
				}
			}));

			addCmd('cellDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					deleteCells(selection);
				}
			}));

			addCmd('cellMerge', createDef({
				allowedContent: 'td[colspan,rowspan]',
				requiredContent: 'td[colspan,rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection()), true);
				}
			}));

			addCmd('cellMergeRight', createDef({
				allowedContent: 'td[colspan]',
				requiredContent: 'td[colspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection(), 'right'), true);
				}
			}));

			addCmd('cellMergeDown', createDef({
				allowedContent: 'td[rowspan]',
				requiredContent: 'td[rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection(), 'down'), true);
				}
			}));

			addCmd('cellVerticalSplit', createDef({
				allowedContent: 'td[rowspan]',
				requiredContent: 'td[rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(verticalSplitCell(editor.getSelection()));
				}
			}));

			addCmd('cellHorizontalSplit', createDef({
				allowedContent: 'td[colspan]',
				requiredContent: 'td[colspan]',
				exec: function exec(editor) {
					placeCursorInCell(horizontalSplitCell(editor.getSelection()));
				}
			}));

			addCmd('cellInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertCell(selection, true);
				}
			}));

			addCmd('cellInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertCell(selection);
				}
			}));
		},


		getSelectedCells: getSelectedCells
	});
}

/**
 * Create a two-dimension array that reflects the actual layout of table cells,
 * with cell spans, with mappings to the original td elements.
 *
 * @param {CKEDITOR.dom.element} table
 * @member CKEDITOR.tools
 */
CKEDITOR.tools.buildTableMap = function (table) {
	var aRows = table.$.rows;

	// Row and Column counters.

	var r = -1;

	var aMap = [];

	for (var i = 0; i < aRows.length; i++) {
		r++;
		if (!aMap[r]) {
			aMap[r] = [];
		}

		var c = -1;

		for (var j = 0; j < aRows[i].cells.length; j++) {
			var oCell = aRows[i].cells[j];

			c++;
			while (aMap[r][c]) {
				c++;
			}

			var iColSpan = isNaN(oCell.colSpan) ? 1 : oCell.colSpan;
			var iRowSpan = isNaN(oCell.rowSpan) ? 1 : oCell.rowSpan;

			for (var rs = 0; rs < iRowSpan; rs++) {
				if (!aMap[r + rs]) {
					aMap[r + rs] = [];
				}

				for (var cs = 0; cs < iColSpan; cs++) {
					aMap[r + rs][c + cs] = aRows[i].cells[j];
				}
			}

			c += iColSpan - 1;
		}
	}

	return aMap;
};

/***/ }),

/***/ "./src/selections/selection-arrowbox.js":
/*!**********************************************!*\
  !*** ./src/selections/selection-arrowbox.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var tableSelectionGetArrowBoxClasses = function tableSelectionGetArrowBoxClasses() {
  return 'ae-arrow-box ae-arrow-box-bottom';
};

var SelectionGetArrowBoxClasses = {
  table: tableSelectionGetArrowBoxClasses
};

exports.default = SelectionGetArrowBoxClasses;

/***/ }),

/***/ "./src/selections/selection-position.js":
/*!**********************************************!*\
  !*** ./src/selections/selection-position.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Default gutter value for toolbar positioning

var DEFAULT_GUTTER = {
	left: 0,
	top: 0
};

/**
 * Centers a Toolbar according to given rectangle
 *
 * @method centerToolbar
 * @param {Object} toolbar The toolbar to be centered
 * @param {Object} rect The rectangle according to which the Toolbar will be centered
 */
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var centerToolbar = function centerToolbar(toolbar, rect) {
	var toolbarNode = _reactDom2.default.findDOMNode(toolbar);

	var nativeEditor = toolbar.context.editor.get('nativeEditor');
	var uiNode = nativeEditor.config.uiNode || document.body;
	var uiNodeStyle = getComputedStyle(uiNode);
	var uiNodeMarginLeft = parseInt(uiNodeStyle.getPropertyValue('margin-left'), 10);
	var uiNodeMarginRight = parseInt(uiNodeStyle.getPropertyValue('margin-right'), 10);
	var totalWidth = uiNodeMarginLeft + uiNode.clientWidth + uiNodeMarginRight;

	var halfNodeWidth = toolbarNode.offsetWidth / 2;
	var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();

	var gutter = toolbar.props.gutter || DEFAULT_GUTTER;

	var widgetXY = toolbar.getWidgetXYPoint(rect.left + rect.width / 2 - scrollPosition.x, rect.top + scrollPosition.y, CKEDITOR.SELECTION_BOTTOM_TO_TOP);

	var caretPosition = nativeEditor.getSelection();
	var ranges = caretPosition.getRanges();
	var offsetHeight = 0;

	if (ranges && ranges.length === 1) {
		var startContainer = ranges[0].startContainer;

		if (startContainer.$.nodeType !== Node.ELEMENT_NODE) {
			startContainer = startContainer.getParent();
		}

		var nodeName = startContainer.$.nodeName;

		if (nodeName === 'TD' || nodeName === 'TH') {
			var startContainerClientRect = startContainer.getClientRect();
			offsetHeight = startContainerClientRect.y - rect.top;
		}
	}

	var scrollTop = uiNode ? uiNode.scrollTop : 0;

	var endPosition = [rect.left + rect.width / 2 - halfNodeWidth - scrollPosition.x, rect.top + offsetHeight - toolbarNode.offsetHeight + scrollPosition.y - gutter.top + scrollTop];

	if (endPosition[0] < 0) {
		endPosition[0] = 0;
	} else if (endPosition[0] > totalWidth - toolbarNode.offsetWidth) {
		endPosition[0] = totalWidth - toolbarNode.offsetWidth;
	}

	toolbar.moveToPoint(widgetXY, endPosition);
};

/**
 * Sets the position of a toolbar according to the position of the selected image
 *
 * @method imageSelectionSetPosition
 * @param {Object} payload Payload, should contain the selection data for retrieving the
 * client rectangle of the selected image
 * @return {Boolean} True, in all cases
 */
var imageSelectionSetPosition = function imageSelectionSetPosition(payload) {
	var selectionData = payload.selectionData ? payload.selectionData : payload.editorEvent ? payload.editorEvent.data.selectionData : null;

	if (selectionData && selectionData.element) {
		var nativeEditor = payload.editor.get('nativeEditor');
		var uiNode = nativeEditor.config.uiNode;

		var scrollTop = uiNode ? uiNode.scrollTop : 0;

		var rect = selectionData.element.getClientRect();
		rect.top += scrollTop;

		centerToolbar(this, rect);

		return true;
	}
};

/**
 * Sets the position of a toolbar according to the position of the selected image
 *
 * @method tableSelectionSetPosition
 * @param {Object} payload Object, which contains the selection data for retrieving the
 * client rectangle of the selected table
 * @return {Boolean} True, in all cases
 */
var tableSelectionSetPosition = function tableSelectionSetPosition(payload) {
	var nativeEditor = payload.editor.get('nativeEditor');
	var uiNode = nativeEditor.config.uiNode;

	var scrollTop = uiNode ? uiNode.scrollTop : 0;

	var table = new CKEDITOR.Table(nativeEditor).getFromSelection();
	var rect = table.getClientRect();
	rect.top += scrollTop;

	centerToolbar(this, rect);

	return true;
};

var SelectionSetPosition = {
	image: imageSelectionSetPosition,
	table: tableSelectionSetPosition
};

exports.default = SelectionSetPosition;

/***/ }),

/***/ "./src/selections/selection-test.js":
/*!******************************************!*\
  !*** ./src/selections/selection-test.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var _isRangeAtElementEnd = function _isRangeAtElementEnd(range, element) {
	// Finding if a range is at the end of an element is somewhat tricky
	// due to how CKEditor handles ranges. It might depend on whether a
	// source node inside the element is selected or not. For now, we
	// need to cover the following cases:
	//
	// - The text length of the element is the same as the endOffset of
	//   the range.
	// - Both start and end containers match the element and the start
	//   and end offsets are 1.

	return element.getText().length === range.endOffset || element.equals(range.startContainer) && element.equals(range.endContainer) && range.startOffset === range.endOffset && range.endOffset === 1;
};

var embedSelectionTest = function embedSelectionTest(payload) {
	var selectionData = payload.data.selectionData;

	return !!(selectionData.element && selectionData.element.getAttribute('data-widget') === 'ae_embed');
};

var embedUrlSelectionTest = function embedUrlSelectionTest(payload) {
	var selectionData = payload.data.selectionData;

	return !!(selectionData.element && selectionData.element.getAttribute('data-widget') === 'embedurl');
};

var headingTextSelectionTest = function headingTextSelectionTest(payload) {
	var headings = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
	var nativeEditor = payload.editor.get('nativeEditor');
	var selectionData = payload.data.selectionData;
	var selectionEmpty = nativeEditor.isSelectionEmpty();

	return !!(!selectionData.element && selectionData.region && !selectionEmpty && !nativeEditor.getSelection().getCommonAncestor().isReadOnly() && nativeEditor.elementPath().contains(headings));
};

var linkSelectionTest = function linkSelectionTest(payload) {
	var nativeEditor = payload.editor.get('nativeEditor');
	var range = nativeEditor.getSelection().getRanges()[0];
	var selectionData = payload.data.selectionData;

	var element = new CKEDITOR.Link(nativeEditor).getFromSelection();
	var isSelectionEmpty = nativeEditor.isSelectionEmpty();
	var elementIsNotImage = selectionData.element ? selectionData.element.getName() !== 'img' : true;

	return !!(isSelectionEmpty && elementIsNotImage && element && element.getText().length !== range.endOffset && element && !element.isReadOnly() && !_isRangeAtElementEnd(range, element));
};

var imageSelectionTest = function imageSelectionTest(payload) {
	var selectionData = payload.data.selectionData;
	var element = selectionData.element;
	var hasImage = !!element && !!element.findOne('img');
	var isImage = !!element && element.getName() === 'img';

	return !!(element && (hasImage || isImage));
};

var textSelectionTest = function textSelectionTest(payload) {
	var nativeEditor = payload.editor.get('nativeEditor');

	var selectionEmpty = nativeEditor.isSelectionEmpty();

	var selectionData = payload.data.selectionData;

	return !!(!selectionData.element && selectionData.region && !selectionEmpty && !nativeEditor.getSelection().getCommonAncestor().isReadOnly());
};

var tableSelectionTest = function tableSelectionTest(payload) {
	var nativeEditor = payload.editor.get('nativeEditor');

	var table = new CKEDITOR.Table(nativeEditor);
	var element = table.getFromSelection();

	return !!(element && table.isEditable(element));
};

var SelectionTest = {
	embed: embedSelectionTest,
	embedUrl: embedUrlSelectionTest,
	header: headingTextSelectionTest,
	image: imageSelectionTest,
	link: linkSelectionTest,
	table: tableSelectionTest,
	text: textSelectionTest
};

exports.default = SelectionTest;

/***/ }),

/***/ "./src/selections/selections.js":
/*!**************************************!*\
  !*** ./src/selections/selections.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _selectionArrowbox = __webpack_require__(/*! ./selection-arrowbox */ "./src/selections/selection-arrowbox.js");

var _selectionArrowbox2 = _interopRequireDefault(_selectionArrowbox);

var _selectionPosition = __webpack_require__(/*! ./selection-position */ "./src/selections/selection-position.js");

var _selectionPosition2 = _interopRequireDefault(_selectionPosition);

var _selectionTest = __webpack_require__(/*! ./selection-test */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Selections = [{
	name: 'embed',
	buttons: ['embedRemove', 'embedEdit'],
	test: _selectionTest2.default.embed
}, {
	name: 'embedUrl',
	buttons: ['embedVideo', 'embedVideoEdit'],
	test: _selectionTest2.default.embedUrl
}, {
	name: 'link',
	buttons: ['linkEdit'],
	test: _selectionTest2.default.link
}, {
	name: 'image',
	buttons: ['imageLeft', 'imageCenter', 'imageRight', 'removeImage'],
	setPosition: _selectionPosition2.default.image,
	test: _selectionTest2.default.image
}, {
	name: 'text',
	buttons: {
		full: [['Font', 'FontSize', 'separator', 'bold', 'italic', 'underline', 'strike', 'separator', 'link'], ['paragraphAlign', 'separator', 'ul', 'ol', 'separator', 'h1', 'h2', 'separator', 'indentBlock', 'outdentBlock', 'separator', 'TextColor', 'BGColor', 'separator', 'code', 'quote', 'separator', 'removeFormat']],

		simple: ['styles', 'bold', 'italic', 'underline', 'link']
	},
	test: _selectionTest2.default.text
}, {
	name: 'table',
	buttons: ['tableHeading', 'tableRow', 'tableColumn', 'tableCell', 'tableRemove'],
	getArrowBoxClasses: _selectionArrowbox2.default.table,
	setPosition: _selectionPosition2.default.table,
	test: _selectionTest2.default.table
}]; /**
     * SPDX-FileCopyrightText: Â© 2014 Liferay, Inc. <https://liferay.com>
     * SPDX-License-Identifier: LGPL-3.0-or-later
     */

exports.default = Selections;

/***/ }),

/***/ "react":
/*!****************************************************************************************************!*\
  !*** external {"amd":"react","commonjs":"react","commonjs2":"react","root":"React","umd":"react"} ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window[undefined]; }());

/***/ }),

/***/ "react-dom":
/*!***********************************************************************************************************************!*\
  !*** external {"amd":"react-dom","commonjs":"react-dom","commonjs2":"react-dom","root":"ReactDOM","umd":"react-dom"} ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window[undefined]; }());

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BbGxveUVkaXRvci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9hZGFwdGVyL2NvcmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvYWRhcHRlci9lZGl0b3ItY29udGV4dC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9hZGFwdGVyL21haW4uanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tbWFuZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tbWFuZHMvcmVtb3ZlLWltYWdlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tYWN0aW9uLXN0eWxlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2J1dHRvbi1jb21tYW5kLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24ta2V5c3Ryb2tlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tcHJvcHMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tc3R5bGUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS90b29sYmFyLWJ1dHRvbnMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL3dpZGdldC1kcm9wZG93bi5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2Uvd2lkZ2V0LWV4Y2x1c2l2ZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1hY2Nlc3NpYmlsaXR5LWltYWdlLWFsdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1iYWNrZ3JvdW5kLWNvbG9yLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWJvbGQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tY2FtZXJhLWltYWdlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWNhbWVyYS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1jb2RlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWNvbG9yLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWNvbW1hbmQtbGlzdC1pdGVtLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWNvbW1hbmRzLWxpc3QuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tZHJvcGRvd24uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tZW1iZWQtZWRpdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1lbWJlZC12aWRlby1lZGl0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWVtYmVkLXZpZGVvLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWVtYmVkLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWgxLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWgyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWhsaW5lLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWljb24uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taW1hZ2UtYWxpZ24tY2VudGVyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWltYWdlLWFsaWduLWxlZnQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taW1hZ2UtYWxpZ24tcmlnaHQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taW1hZ2UuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taW5kZW50LWJsb2NrLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWl0YWxpYy5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1pdGVtLXNlbGVjdG9yLWF1ZGlvLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWl0ZW0tc2VsZWN0b3ItaW1hZ2UuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taXRlbS1zZWxlY3Rvci12aWRlby5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1saW5rLWF1dG9jb21wbGV0ZS1saXN0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWxpbmstYnJvd3NlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWxpbmstZWRpdC1icm93c2UuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tbGluay1lZGl0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWxpbmstdGFyZ2V0LWVkaXQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tbGluay5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1vbC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1vdXRkZW50LWJsb2NrLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXBhcmFncmFwaC1hbGlnbi1sZWZ0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXBhcmFncmFwaC1hbGlnbi1yaWdodC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1wYXJhZ3JhcGgtYWxpZ24uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcGFyYWdyYXBoLWNlbnRlci5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1wYXJhZ3JhcGgtanVzdGlmeS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1xdW90ZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1yZW1vdmUtZm9ybWF0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXJlbW92ZS1pbWFnZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1zZXBhcmF0b3IuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3BhY2luZy5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1zdHJpa2UuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3R5bGVzLWxpc3QtaGVhZGVyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0tcmVtb3ZlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3R5bGVzLWxpc3QuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3R5bGVzLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN1YnNjcmlwdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1zdXBlcnNjcmlwdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS1jZWxsLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLWNvbHVtbi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS1lZGl0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLWhlYWRpbmcuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tdGFibGUtcmVtb3ZlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLXJvdy5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YXJnZXQtbGlzdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10d2l0dGVyLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXVsLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXVuZGVybGluZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvY29tcGF0L2J1dHRvbi1hY3Rpb24tc3R5bGUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9jb21wYXQvYnV0dG9uLWNvbW1hbmQtYWN0aXZlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvY29tcGF0L2J1dHRvbi1jb21tYW5kLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvY29tcGF0L2J1dHRvbi1rZXlzdHJva2UuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9jb21wYXQvYnV0dG9uLXByb3BzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvY29tcGF0L2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvY29tcGF0L2J1dHRvbi1zdHlsZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2NvbXBhdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2NvbXBhdC90b29sYmFyLWJ1dHRvbnMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9jb21wYXQvd2lkZ2V0LWFycm93LWJveC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2NvbXBhdC93aWRnZXQtZHJvcGRvd24uanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9jb21wYXQvd2lkZ2V0LWV4Y2x1c2l2ZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2NvbXBhdC93aWRnZXQtZm9jdXMtbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2NvbXBhdC93aWRnZXQtaW50ZXJhY3Rpb24tcG9pbnQuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9jb21wYXQvd2lkZ2V0LXBvc2l0aW9uLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvbWFpbi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy90b29sYmFycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3Rvb2xiYXJzL3Rvb2xiYXItYWRkLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3Rvb2xiYXJzL3Rvb2xiYXItc3R5bGVzLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL2J1dHRvbi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy91aWJyaWRnZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL21lbnUtYnV0dG9uLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL21lbnUuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvdWlicmlkZ2UvcGFuZWwtbWVudS1idXR0b24uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvdWlicmlkZ2UvcmljaGNvbWJvLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL3VpYnJpZGdlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb3JlL2xpbmsuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS9wbHVnaW5zLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvc2VsZWN0aW9uLXJlZ2lvbi5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb3JlL3RhYmxlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvdG9vbHMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS91aWNvcmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvb29wL2F0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9vb3AvYmFzZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9vb3AvbGFuZy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9vb3Avb29wLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvRHJhZ0V2ZW50LmVzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvUmVzaXplci5lcy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2FkZGltYWdlcy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2F1dG9saW5rLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvYXV0b2xpc3QuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9kcmFncmVzaXplLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvZHJhZ3Jlc2l6ZV9pZTExLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvZW1iZWQuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9lbWJlZHVybC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2ltYWdlYWxpZ25tZW50LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9wYXN0ZWltYWdlcy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL3BsYWNlaG9sZGVyLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvcHJpb3JpdGllcy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL3NlbGVjdGlvbmtleXN0cm9rZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy90YWJsZXJlc2l6ZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL3RhYmxldG9vbHMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvc2VsZWN0aW9ucy9zZWxlY3Rpb24tYXJyb3dib3guanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvc2VsZWN0aW9ucy9zZWxlY3Rpb24tcG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvc2VsZWN0aW9ucy9zZWxlY3Rpb24tdGVzdC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9zZWxlY3Rpb25zL3NlbGVjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvZXh0ZXJuYWwge1wiYW1kXCI6XCJyZWFjdFwiLFwiY29tbW9uanNcIjpcInJlYWN0XCIsXCJjb21tb25qczJcIjpcInJlYWN0XCIsXCJyb290XCI6XCJSZWFjdFwiLFwidW1kXCI6XCJyZWFjdFwifSIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci9leHRlcm5hbCB7XCJhbWRcIjpcInJlYWN0LWRvbVwiLFwiY29tbW9uanNcIjpcInJlYWN0LWRvbVwiLFwiY29tbW9uanMyXCI6XCJyZWFjdC1kb21cIixcInJvb3RcIjpcIlJlYWN0RE9NXCIsXCJ1bWRcIjpcInJlYWN0LWRvbVwifSJdLCJuYW1lcyI6WyJFTUJFRF9WSURFT19XSURUSCIsIkVNQkVEX1ZJREVPX0hFSUdIVCIsIkNvcmUiLCJjb25maWciLCJzdXBlcmNsYXNzIiwiY29uc3RydWN0b3IiLCJjYWxsIiwiQmFzZSIsImluaXRpYWxpemVyIiwibm9kZSIsImdldCIsInNldEF0dHJpYnV0ZSIsImVkaXRvciIsIkNLRURJVE9SIiwiaW5saW5lIiwiYWxsb3dlZENvbnRlbnQiLCJ0b29sYmFycyIsInJlbW92ZVBsdWdpbnMiLCJleHRyYVBsdWdpbnMiLCJlbWJlZFByb3ZpZGVycyIsInBsYWNlaG9sZGVyQ2xhc3MiLCJwYXN0ZUZyb21Xb3JkUmVtb3ZlU3R5bGVzIiwicGFzdGVGcm9tV29yZFJlbW92ZUZvbnRTdHlsZXMiLCJzZWxlY3Rpb25LZXlzdHJva2VzIiwic3ByaXRlbWFwIiwiTGFuZyIsIm1peCIsImVudiIsImllIiwiZWRnZSIsInBsdWdpbiIsInJlcGxhY2UiLCJvbmNlIiwiX2FkZFJlYWRPbmx5TGlua0NsaWNrTGlzdGVuZXIiLCJlZGl0YWJsZSIsImV4dHJhQ29tbWFuZHMiLCJleHRyYUNvbW1hbmRLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImkiLCJsZW5ndGgiLCJjb21tYW5kTmFtZSIsImNvbW1hbmRzIiwiYWRkQ29tbWFuZCIsImFkZENsYXNzIiwiX2VkaXRvciIsIkFsbG95RWRpdG9yIiwibG9hZExhbmd1YWdlUmVzb3VyY2VzIiwiX3JlbmRlclVJIiwiYmluZCIsImRlc3RydWN0b3IiLCJfZGVzdHJveWVkIiwiX2VkaXRvclVJRWxlbWVudCIsIlJlYWN0RE9NIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIm5hdGl2ZUVkaXRvciIsInJlbW92ZUNsYXNzIiwiX2NsZWFyU2VsZWN0aW9ucyIsImRlc3Ryb3kiLCJpc01TU2VsZWN0aW9uIiwid2luZG93IiwiZ2V0U2VsZWN0aW9uIiwiZG9jdW1lbnQiLCIkIiwic2VsZWN0aW9uIiwiZW1wdHkiLCJnZXRXaW5kb3ciLCJyZW1vdmVBbGxSYW5nZXMiLCJvbiIsIl9kZWZhdWx0UmVhZE9ubHlDbGlja0ZuIiwiZXZlbnQiLCJtb3VzZUV2ZW50IiwiZGF0YSIsImhhc0N0cmxLZXkiLCJjdHJsS2V5IiwibWV0YUtleSIsInNob3VsZE9wZW4iLCJyZWFkT25seSIsInByZXZlbnREZWZhdWx0IiwibGlzdGVuZXJEYXRhIiwiZmlyZSIsImNrRWxlbWVudCIsImRvbSIsImVsZW1lbnRQYXRoIiwiZ2V0VGFyZ2V0IiwibGluayIsImxhc3RFbGVtZW50IiwiaHJlZiIsImF0dHJpYnV0ZXMiLCJ2YWx1ZSIsInRhcmdldCIsIl9yZWRpcmVjdExpbmsiLCJfZ2V0TmF0aXZlRWRpdG9yIiwib3BlbiIsImxvY2F0aW9uIiwiZWRpdG9yVUlFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsInVpTm9kZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNhbGxiYWNrUmVmIiwiX21haW5VSSIsImVsZW1lbnQiLCJyZW5kZXIiLCJfdG9FbGVtZW50IiwiaXNTdHJpbmciLCJnZXRFbGVtZW50QnlJZCIsIl92YWxpZGF0ZUFsbG93ZWRDb250ZW50IiwiaXNPYmplY3QiLCJpc0Jvb2xlYW4iLCJfdmFsaWRhdGVUb29sYmFycyIsImlzTnVsbCIsIkFUVFJTIiwidmFsaWRhdG9yIiwid3JpdGVPbmNlIiwiZG9jdW1lbnRCcm93c2VMaW5rQ2FsbGJhY2siLCJpc0Z1bmN0aW9uIiwidW5kZWZpbmVkIiwiZG9jdW1lbnRCcm93c2VMaW5rVXJsIiwiaXNBcnJheSIsImlkIiwidHBsIiwidHlwZSIsInVybFNjaGVtZXMiLCJlbmFibGVDb250ZW50RWRpdGFibGUiLCJldmVudHNEZWxheSIsImlzTnVtYmVyIiwicmVtb3ZlSW1hZ2UiLCJyZW1vdmVJbWFnZUNvbW1hbmQiLCJtb2RlIiwiZ2V0dGVyIiwiQ1RSTCIsIlNISUZUIiwiQUxMT1lFRElUT1JfQkFTRVBBVEgiLCJzcmNOb2RlIiwic2V0dGVyIiwiYWRkIiwiYnV0dG9ucyIsInRhYkluZGV4Iiwic3R5bGVzIiwic2VsZWN0aW9ucyIsIlNlbGVjdGlvbnMiLCJpbXBsZW1lbnRPbiIsIkVkaXRvckNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ0b1Byb3BzIiwiZm9yd2FyZGluZ0NvbXBvbmVudCIsImZvcndhcmRSZWYiLCJwcm9wcyIsInJlZiIsImNvbnRleHQiLCJrZXkiLCJDb21wb25lbnQiLCJDb21wYXQiLCJCUklER0VfQlVUVE9OUyIsImltcGxlbWVudEV2ZW50VGFyZ2V0IiwiZ2V0QmFzZVBhdGgiLCJwYXRoIiwic2NyaXB0cyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwibWF0Y2giLCJzcmMiLCJyZWdleEJhc2VQYXRoIiwiaW5kZXhPZiIsInNsaWNlIiwiRXJyb3IiLCJjYWxsYmFjayIsIlN0cmluZ3MiLCJzZXRUaW1lb3V0IiwiX2xhbmdSZXNvdXJjZVJlcXVlc3RlZCIsImxhbmd1YWdlcyIsInVzZXJMYW5ndWFnZSIsIm5hdmlnYXRvciIsImxhbmd1YWdlIiwicGFydHMiLCJ0b0xvd2VyQ2FzZSIsImxhbmciLCJsb2NhbGUiLCJzY3JpcHRMb2FkZXIiLCJsb2FkIiwiZ2V0VXJsIiwibG9hZGVkIiwicmVzb3VyY2UiLCJiYXNlUGF0aCIsInRpbWVzdGFtcCIsImNoYXJBdCIsInRlc3QiLCJnZXRCdXR0b25zIiwicmVkdWNlIiwiYWNjIiwidmFsIiwiY29uY2F0IiwicmVnaXN0ZXJCcmlkZ2VCdXR0b24iLCJidXR0b25OYW1lIiwicGx1Z2luTmFtZSIsInB1c2giLCJPT1AiLCJleHRlbmQiLCJBdHRyaWJ1dGUiLCJCdXR0b25zIiwiU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzIiwiU2VsZWN0aW9uU2V0UG9zaXRpb24iLCJTZWxlY3Rpb25UZXN0IiwiVG9vbGJhcnMiLCJleGVjIiwicmFuZ2VzIiwiZ2V0UmFuZ2VzIiwic3RhcnRDb250YWluZXIiLCJuZXh0UmFuZ2UiLCJyYW5nZSIsInNldFN0YXJ0Iiwic2V0RW5kIiwic2VsZWN0ZWRFbGVtZW50IiwiZ2V0U2VsZWN0ZWRFbGVtZW50IiwiZ2V0TmFtZSIsIm5hdGl2ZSIsImdldE5hdGl2ZSIsInNlbGVjdFJhbmdlcyIsInJlbW92ZSIsImFwcGx5U3R5bGUiLCJpc0FjdGl2ZSIsImdldFN0eWxlIiwibG9jayIsInJlbW92ZVN0eWxlIiwidW5sb2NrIiwiV3JhcHBlZENvbXBvbmVudCIsImNvbnRleHRUeXBlIiwiY29tbWFuZCIsImdldENvbW1hbmQiLCJzdGF0ZSIsIlRSSVNUQVRFX09OIiwiZXhlY0NvbW1hbmQiLCJrZXlzdHJva2UiLCJuYW1lIiwia2V5c3Ryb2tlRm4iLCJmbiIsIl9kZWZhdWx0S2V5c3Ryb2tlQ29tbWFuZCIsImtleXN0cm9rZUhhbmRsZXIiLCJrZXlzdHJva2VzIiwic2V0S2V5c3Ryb2tlIiwiYnV0dG9uQ2ZnIiwidG9vbHMiLCJtZXJnZSIsInN0YXRlQ2xhc3NlcyIsInN0eWxlIiwic3BsaXQiLCJjdXJyZW50TWVtYmVyIiwicHJvcGVydHkiLCJzaGlmdCIsIl9zdHlsZSIsImNoZWNrQWN0aXZlIiwiZGVmYXVsdCIsIl9hbmltYXRpb25GcmFtZUlkIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJhcnJvd0JveENsYXNzZXMiLCJnZXRJbnRlcmFjdGlvblBvaW50IiwiZGlyZWN0aW9uIiwiU0VMRUNUSU9OX1RPUF9UT19CT1RUT00iLCJhdHRycyIsInZpZXdQYW5lU2l6ZSIsImdldFZpZXdQYW5lU2l6ZSIsIngiLCJsZWZ0IiwieSIsInRvcCIsIndpZHRoIiwiZXZlbnRQYXlsb2FkIiwiZWRpdG9yRXZlbnQiLCJzZWxlY3Rpb25EYXRhIiwibmF0aXZlRXZlbnQiLCJwb3MiLCJwYWdlWCIsInJlZ2lvbiIsImVuZFJlY3QiLCJzdGFydFJlY3QiLCJTRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCIsIl9nZXRYUG9pbnQiLCJNYXRoIiwibWluIiwibWF4IiwiX2dldFlQb2ludCIsImV2ZW50WCIsInJpZ2h0IiwibGVmdERpc3QiLCJhYnMiLCJyaWdodERpc3QiLCJlbGVtZW50VGFyZ2V0Iiwib2Zmc2V0VG9wIiwib2Zmc2V0SGVpZ2h0IiwiYm90dG9tIiwiZG9tTm9kZSIsImZpbmRET01Ob2RlIiwiZ3V0dGVyIiwib2Zmc2V0V2lkdGgiLCJTRUxFQ1RJT05fTEVGVF9UT19SSUdIVCIsIlNFTEVDVElPTl9SSUdIVF9UT19MRUZUIiwiZG9tRWxlbWVudCIsImhhc0NsYXNzIiwic3RhcnRQb2ludCIsImVuZFBvaW50Iiwic2V0U3R5bGVzIiwib3BhY2l0eSIsInBvaW50ZXJFdmVudHMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzY3JvbGxUb3AiLCJpc1Zpc2libGUiLCJpbnRlcmFjdGlvblBvaW50IiwiZmluYWxYIiwiZmluYWxZIiwiaW5pdGlhbFgiLCJpbml0aWFsWSIsInBhcnNlRmxvYXQiLCJjb25zdHJhaW5Ub1ZpZXdwb3J0IiwicmVzIiwiZ2V0Q29uc3RyYWluZWRQb3NpdGlvbiIsImhlaWdodCIsIm1vdmVUb1BvaW50IiwidWlOb2RlU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwidWlOb2RlTWFyZ2luTGVmdCIsInBhcnNlSW50IiwiZ2V0UHJvcGVydHlWYWx1ZSIsInVpTm9kZU1hcmdpblJpZ2h0IiwidG90YWxXaWR0aCIsImNsaWVudFdpZHRoIiwidGFnTmFtZSIsInh5IiwiZ2V0V2lkZ2V0WFlQb2ludCIsImFkZGl0aW9uYWxQcm9wcyIsImxpc3QiLCJidXR0b24iLCJBcnJheSIsImdldFRvb2xiYXJCdXR0b25zIiwiYnV0dG9uUHJvcHMiLCJ0b29sYmFyQnV0dG9ucyIsImZpbHRlckV4Y2x1c2l2ZSIsImZpbHRlciIsIm1hcCIsImNmZyIsImluZGV4IiwibWVyZ2VFeGNsdXNpdmVQcm9wcyIsInRhYktleSIsInRyaWdnZXIiLCJtZXJnZURyb3Bkb3duUHJvcHMiLCJkZWZhdWx0UHJvcHMiLCJvYmoiLCJpdGVtS2V5IiwiZXhwYW5kZWQiLCJpdGVtRHJvcGRvd24iLCJkcm9wZG93blRyaWdnZXIiLCJ0b2dnbGVEcm9wZG93biIsInRvZ2dsZURpcmVjdGlvbiIsInNldFN0YXRlIiwibW92ZUZvY3VzIiwiZm9jdXMiLCJuZXh0UHJvcHMiLCJyZXF1ZXN0RXhjbHVzaXZlIiwiaXRlbUV4Y2x1c2l2ZSIsIml0ZW1zIiwiaXRlbSIsImNhbmNlbEV4Y2x1c2l2ZSIsInJlbmRlckV4Y2x1c2l2ZSIsIkRJUkVDVElPTl9OT05FIiwiRElSRUNUSU9OX05FWFQiLCJESVJFQ1RJT05fUFJFViIsIkFDVElPTl9OT05FIiwiQUNUSU9OX01PVkVfRk9DVVMiLCJBQ1RJT05fRElTTUlTU19GT0NVUyIsIl9pc1ZhbGlkVGFyZ2V0IiwiX2Rlc2NlbmRhbnRzIiwiYWN0aXZlRGVzY2VuZGFudEVsIiwiX2FjdGl2ZURlc2NlbmRhbnQiLCJhY3RpdmVFbGVtZW50IiwiZm9jdXNGaXJzdENoaWxkIiwic3RvcFByb3BhZ2F0aW9uIiwiaGFuZGxlS2V5IiwiYWN0aW9uIiwiX2dldEZvY3VzQWN0aW9uIiwiX21vdmVGb2N1cyIsIm9uRGlzbWlzcyIsIl9yZWZyZXNoIiwiX2dldEZvY3VzTW92ZURpcmVjdGlvbiIsImRpc21pc3NBY3Rpb24iLCJfZ2V0Rm9jdXNEaXNtaXNzQWN0aW9uIiwiZGlzbWlzcyIsImZvY3VzTW92ZURpcmVjdGlvbiIsIl9pc1ZhbGlkS2V5Iiwia2V5Q29kZSIsImRpc21pc3NOZXh0IiwiZGlzbWlzc1ByZXYiLCJjaXJjdWxhciIsIm5leHQiLCJwcmV2Iiwic2hpZktleSIsIm51bURlc2NlbmRhbnRzIiwiZGVzY2VuZGFudCIsImRlc2NlbmRhbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsInByaW9yaXR5RGVzY2VuZGFudHMiLCJwcm90b3R5cGUiLCJmb3JFYWNoIiwiZGF0YVRhYkluZGV4IiwiZ2V0QXR0cmlidXRlIiwic29ydCIsImEiLCJiIiwidG9JbnQiLCJzb21lIiwiQnV0dG9uQWNjZXNzaWJpbGl0eUltYWdlQWx0IiwiX2hhbmRsZUFsdENoYW5nZSIsImltYWdlQWx0IiwiX2ZvY3VzQWx0SW5wdXQiLCJfaGFuZGxlS2V5RG93biIsIl91cGRhdGVJbWFnZUFsdCIsIl9yZXF1ZXN0RXhjbHVzaXZlIiwicmVmcyIsInJlZkFsdElucHV0IiwiaW1hZ2VFbGVtZW50IiwiX2VsZW1lbnQiLCJmaW5kT25lIiwiaW1hZ2UiLCJfZ2V0SW5pdGlhbFN0YXRlIiwibWFudWFsU2VsZWN0aW9uIiwiZ2V0U3RhcnRFbGVtZW50IiwiY29uZmlybSIsImluc3RhbmNlIiwiZm9jdXNBbHRFbCIsIkJ1dHRvbkJhY2tncm91bmRDb2xvciIsImFjdGl2ZUNvbG9yIiwibm9ybWFsIiwiYWN0aXZlQ29sb3JDbGFzcyIsImNvbG9ycyIsIl9nZXRDb2xvcnMiLCJpdGVtU3R5bGUiLCJjbGFzcyIsInN0eWxlQ2xhc3MiLCJfY2hlY2tBY3RpdmUiLCJidXR0b25TdHlsZXNQcm9wcyIsImFjdGl2ZVN0eWxlIiwic2hvd1JlbW92ZVN0eWxlc0l0ZW0iLCJzdHlsZUNvbmZpZyIsInN0eWxlRm4iLCJfYXBwbHlTdHlsZSIsInByaW1hcnkiLCJkaXNhYmxlZCIsInN1Y2Nlc3MiLCJkYW5nZXIiLCJ3YXJuaW5nIiwiaW5mbyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsImJvb2wiLCJsYWJlbCIsInN0cmluZyIsImFycmF5T2YiLCJvYmplY3QiLCJudW1iZXIiLCJmdW5jIiwiQnV0dG9uQm9sZCIsImNzc0NsYXNzIiwiZ2V0U3RhdGVDbGFzc2VzIiwiYm9sZCIsIkJ1dHRvbkNhbWVyYUltYWdlIiwidGFrZVBob3RvIiwidmlkZW9FbCIsIl92aWRlb0NvbnRhaW5lclJlZiIsImN1cnJlbnQiLCJjYW52YXNFbCIsIl9jYW52YXNDb250YWluZXJSZWYiLCJnZXRDb250ZXh0IiwiX3ZpZGVvSGVpZ2h0IiwidmlkZW9XaWR0aCIsImRyYXdJbWFnZSIsImltZ1VSTCIsInRvRGF0YVVSTCIsImVsIiwiY3JlYXRlRnJvbUh0bWwiLCJpbnNlcnRFbGVtZW50IiwiX2hhbmRsZVN0cmVhbUVycm9yIiwiYWxlcnQiLCJlcnJvciIsIl9oYW5kbGVTdHJlYW1TdWNjZXNzIiwiYWRkRXZlbnRMaXN0ZW5lciIsInZpZGVvSGVpZ2h0IiwiaXNOYU4iLCJfc3RyZWFtIiwic3RyZWFtIiwibW96R2V0VXNlck1lZGlhIiwibW96U3JjT2JqZWN0Iiwic3JjT2JqZWN0IiwicGxheSIsIl9idXR0b25UYWtlUGhvdG9SZWYiLCJjcmVhdGVSZWYiLCJzdG9wIiwiZ2V0VmlkZW9UcmFja3MiLCJ0cmFjayIsImdldFVzZXJNZWRpYSIsIndlYmtpdEdldFVzZXJNZWRpYSIsIm1zR2V0VXNlck1lZGlhIiwidmlkZW8iLCJhdWRpbyIsIkJ1dHRvbkNhbWVyYSIsInByb3RvY29sIiwiY2FtZXJhRGlzYWJsZWQiLCJjYW1lcmEiLCJCdXR0b25Db2RlIiwiY29kZSIsIkJ1dHRvbkNvbG9yIiwiZGFyayIsImRhcmtHcmF5Iiwic2Vjb25kYXJ5IiwibGlnaHQiLCJsaWdodGVyIiwid2hpdGUiLCJCdXR0b25Db21tYW5kTGlzdEl0ZW0iLCJkZXNjcmlwdGlvbiIsIl9nZXRDbGFzc05hbWUiLCJCdXR0b25Db21tYW5kc0xpc3QiLCJfcmVmIiwibGlzdElkIiwiX3JlbmRlckFjdGlvbnMiLCJpY29uIiwiQnV0dG9uRHJvcGRvd24iLCJjaGlsZHJlbiIsIktFWV9FTlRFUiIsIktFWV9FU0MiLCJCdXR0b25FbWJlZEVkaXQiLCJfY2xlYXJMaW5rIiwibGlua0hyZWYiLCJfZW1iZWRMaW5rIiwidXJsIiwiX2ZvY3VzTGlua0lucHV0IiwibGlua0lucHV0IiwiX2hhbmRsZUxpbmtIcmVmQ2hhbmdlIiwiX3JlbW92ZUVtYmVkIiwiZW1iZWRXcmFwcGVyIiwiZ2V0QXNjZW5kYW50IiwiZ2V0SW5pdGlhbFN0YXRlIiwiZW1iZWQiLCJpbml0aWFsTGluayIsImNsZWFyTGlua1N0eWxlIiwiZGVsZXRlRW1iZWQiLCJlZGl0TGluayIsImNsZWFySW5wdXQiLCJjbGVhciIsIl9pc1ZhbGlkU3RhdGUiLCJ2YWxpZFN0YXRlIiwiQnV0dG9uRW1iZWRWaWRlb0VkaXQiLCJfZW1iZWRWaWRlb1VSTCIsInZpZGVvVVJMIiwiX2ZvY3VzVmlkZW9VcmxJbnB1dCIsIl9oYW5kbGVWaWRlb1VSTENoYW5nZSIsIm5ld1N0YXRlIiwiYWxsIiwibmV3Iiwib2xkIiwiaW5pdGlhbEVtYmVkIiwiaW5wdXRQbGFjZWhvbGRlciIsInBhc3RlVmlkZW9MaW5rIiwiY2xlYXJWaWRlb1VSTFN0eWxlIiwiQnV0dG9uRW1iZWRWaWRlbyIsIkJ1dHRvbkVtYmVkIiwiQnV0dG9uSDEiLCJoMSIsIkJ1dHRvbkgyIiwiaDIiLCJCdXR0b25IbGluZSIsImhvcml6b250YWxydWxlIiwiQnV0dG9uSWNvbiIsInN5bWJvbCIsImNsYXNzTmFtZVByZWZpeCIsImNvbWJpbmVkQ2xhc3NOYW1lIiwiQnV0dG9uSW1hZ2VBbGlnbkNlbnRlciIsImFsaWduQ2VudGVyIiwiQnV0dG9uSW1hZ2VBbGlnbkxlZnQiLCJhbGlnbkxlZnQiLCJCdXR0b25JbWFnZUFsaWduUmlnaHQiLCJhbGlnblJpZ2h0IiwiQnV0dG9uSW1hZ2UiLCJoYW5kbGVDbGljayIsImZpbGVJbnB1dCIsImNsaWNrIiwiX29uSW5wdXRDaGFuZ2UiLCJpbnB1dEVsIiwiZmlsZXMiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwiZmlsZSIsIm9ubG9hZCIsInJlc3VsdCIsImltYWdlRmlsZXMiLCJpbWFnZURhdGEiLCJyZWFkQXNEYXRhVVJMIiwiaW5wdXRTeWxlIiwiZGlzcGxheSIsIkJ1dHRvbkluZGVudEJsb2NrIiwiaW5kZW50IiwiQnV0dG9uSXRhbGljIiwiaXRhbGljIiwiQnV0dG9uSXRlbVNlbGVjdG9yQXVkaW8iLCJfaGFuZGxlQ2xpY2siLCJCdXR0b25JdGVtU2VsZWN0b3JJbWFnZSIsIkJ1dHRvbkl0ZW1TZWxlY3RvclZpZGVvIiwiQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QiLCJ0ZXJtIiwiY2xlYXJUaW1lb3V0IiwiX3RpbWVvdXQiLCJfdXBkYXRlSXRlbXMiLCJkZWxheSIsImF1dG9jb21wbGV0ZVNlbGVjdGVkIiwic2V0QXV0b2NvbXBsZXRlU3RhdGUiLCJzZWxlY3RlZCIsIl9yZW5kZXJBdXRvY29tcGxldGVJdGVtcyIsIm5leHRTdGF0ZSIsImhhbmRsZUxpbmtBdXRvY29tcGxldGVDbGljayIsInRpdGxlIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsIkJ1dHRvbkxpbmtCcm93c2UiLCJtZXJnZUJ1dHRvbkNmZ1Byb3BzIiwiQnV0dG9uTGlua0VkaXRCcm93c2UiLCJfYnJvd3NlQ2xpY2siLCJicm93c2VMaW5rQ2FsbGJhY2siLCJsaW5rVGFyZ2V0IiwibGlua0VkaXRCdXR0b25SZWYiLCJjaGFuZ2VMaW5rQ2FsbGJhY2siLCJfdXBkYXRlTGluayIsInNlbGVjdGVkSXRlbSIsImFwcGx5IiwibGlua1RpdGxlIiwibGlua1V0aWxzIiwiTGluayIsImFwcGVuZFByb3RvY29sIiwibGlua0F0dHJzIiwibW9kaWZ5U2VsZWN0aW9uIiwiYWR2YW5jZSIsInBsdWdpbnMiLCJjcmVvbGUiLCJvcmlnaW4iLCJ1cGRhdGUiLCJjcmVhdGUiLCJnZXRGcm9tU2VsZWN0aW9uIiwiQnV0dG9uTGlua0VkaXQiLCJhZHZhbmNlU2VsZWN0aW9uIiwiX2hhbmRsZUxpbmtUYXJnZXRDaGFuZ2UiLCJfcmVtb3ZlTGluayIsImJvb2ttYXJrcyIsImNyZWF0ZUJvb2ttYXJrcyIsInNlbGVjdEJvb2ttYXJrcyIsInRhcmdldFNlbGVjdG9yIiwiYWxsb3dlZFRhcmdldHMiLCJoYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlIiwic2VsZWN0ZWRUYXJnZXQiLCJsaW5rVGFyZ2V0RGVmYXVsdCIsIkJ1dHRvbkxpbmtUYXJnZXRFZGl0IiwiYXV0b2NvbXBsZXRlRHJvcGRvd24iLCJkYXRhRm4iLCJhdXRvY29tcGxldGVEcm9wZG93blByb3BzIiwiX2hhbmRsZUxpbmtBdXRvY29tcGxldGVDbGljayIsIl9zZXRBdXRvY29tcGxldGVTdGF0ZSIsImJ1dHRvbkNsZWFyTGluayIsInBsYWNlaG9sZGVyUHJvcCIsInBsYWNlaG9sZGVyIiwicmVtb3ZlTGluayIsInNob3dUYXJnZXRTZWxlY3RvciIsImRlZmF1bHRMaW5rVGFyZ2V0IiwiZm9jdXNMaW5rRWwiLCJhdXRvY29tcGxldGVVcmwiLCJjdXN0b21JbmRleFN0YXJ0IiwiYWxsb3dlZExpbmtUYXJnZXRzIiwiQnV0dG9uTGluayIsIkJ1dHRvbk9yZGVyZWRMaXN0IiwibnVtYmVyZWRsaXN0IiwiQnV0dG9uT3V0ZGVudEJsb2NrIiwib3V0ZGVudCIsIkJ1dHRvblBhcmFncmFwaEFsaWduTGVmdCIsIkJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHQiLCJCdXR0b25QYXJhZ3JhcGhBbGlnbiIsImJ1dHRvbkNvbW1hbmRzTGlzdCIsImJ1dHRvbkNvbW1hbmRzTGlzdElkIiwiZ2V0Q29tbWFuZHMiLCJfZ2V0Q29tbWFuZHMiLCJhY3RpdmVDb21tYW5kIiwiYWxpZ25tZW50IiwicG9wIiwiaWNvbkNsYXNzTmFtZSIsInJvdyIsImFsaWduSnVzdGlmeSIsIkJ1dHRvblBhcmFncmFwaENlbnRlciIsIkJ1dHRvblBhcmFncmFwaEp1c3RpZnkiLCJCdXR0b25RdW90ZSIsInF1b3RlIiwiQnV0dG9uUmVtb3ZlRm9ybWF0IiwicmVtb3ZlZm9ybWF0IiwiQnV0dG9uUmVtb3ZlSW1hZ2UiLCJCdXR0b25TZXBhcmF0b3IiLCJfcHJvcHMiLCJCdXR0b25TcGFjaW5nIiwiYWN0aXZlU3BhY2luZyIsInNwYWNpbmdzIiwiX2dldFNwYWNpbmdzIiwiYWN0aXZlIiwiQnV0dG9uU3RyaWtlIiwic3RyaWtlIiwiQnV0dG9uc1N0eWxlc0xpc3RIZWFkZXIiLCJCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZSIsIl9yZW1vdmVTdHlsZXMiLCJyZW1vdmVCbG9ja3MiLCJibG9ja1N0eWxlIiwiYmxvY2tJdGVtIiwiQnV0dG9uU3R5bGVzTGlzdEl0ZW0iLCJfb25DbGljayIsInN0eWxlQ2ZnIiwibWFyZ2luIiwiX3ByZXZpZXciLCJidWlsZFByZXZpZXciLCJfX2h0bWwiLCJCdXR0b25TdHlsZXNMaXN0IiwiYmxvY2tTdHlsZXMiLCJpbmxpbmVTdHlsZXMiLCJvYmplY3RTdHlsZXMiLCJTVFlMRV9CTE9DSyIsIlNUWUxFX0lOTElORSIsIlNUWUxFX09CSkVDVCIsIl9ibG9ja1N0eWxlcyIsIl9pbmxpbmVTdHlsZXMiLCJfb2JqZWN0U3R5bGVzIiwicmVtb3ZlU3R5bGVzSXRlbSIsIl9yZW5kZXJTdHlsZXNJdGVtcyIsIkJ1dHRvblN0eWxlcyIsIl9nZXRTdHlsZXMiLCJidXR0b25TdHlsZXNMaXN0IiwiZm9ybWF0dGVkIiwiY2l0ZSIsIkJ1dHRvblN1YnNjcmlwdCIsInN1YnNjcmlwdCIsIkJ1dHRvblN1cGVyc2NyaXB0Iiwic3VwZXJzY3JpcHQiLCJCdXR0b25UYWJsZUNlbGwiLCJjZWxsIiwiY2VsbEluc2VydEJlZm9yZSIsImNlbGxJbnNlcnRBZnRlciIsImNlbGxEZWxldGUiLCJjZWxsTWVyZ2UiLCJjZWxsTWVyZ2VEb3duIiwiY2VsbE1lcmdlUmlnaHQiLCJjZWxsU3BsaXRIb3Jpem9udGFsIiwiY2VsbFNwbGl0VmVydGljYWwiLCJCdXR0b25UYWJsZUNvbHVtbiIsImNvbHVtbiIsImNvbHVtbkluc2VydEJlZm9yZSIsImNvbHVtbkluc2VydEFmdGVyIiwiY29sdW1uRGVsZXRlIiwiSU5QVVRfTkFNRVMiLCJDT0xTIiwiUk9XUyIsIk1JTklNVU1fR1JJRF9WQUxVRSIsIkJ1dHRvblRhYmxlRWRpdCIsIl9jcmVhdGVUYWJsZSIsInRhYmxlVXRpbHMiLCJUYWJsZSIsImNvbHMiLCJyb3dzIiwidGFibGVBdHRyaWJ1dGVzIiwiX2hhbmRsZUNoYW5nZSIsImlucHV0TmFtZSIsInJvd3NSZWYiLCJjb2xzUmVmIiwidGltZSIsIkRhdGUiLCJub3ciLCJyb3dzSWQiLCJjb2xzSWQiLCJjb2x1bW5zIiwiYm9yZGVyIiwiY2VsbFBhZGRpbmciLCJjZWxsU3BhY2luZyIsIkJ1dHRvblRhYmxlSGVhZGluZyIsImFjdGl2ZUhlYWRpbmciLCJnZXRIZWFkaW5nIiwiYWN0aXZlSGVhZGluZ0ludHJvIiwiaGVhZGVycyIsImFjdGl2ZUhlYWRpbmdMYWJlbCIsImhlYWRlcnNOb25lIiwiaGVhZGVyc1JvdyIsImhlYWRlcnNDb2x1bW4iLCJoZWFkZXJzQm90aCIsIkJ1dHRvblRhYmxlUmVtb3ZlIiwiX3JlbW92ZVRhYmxlIiwiZGVsZXRlVGFibGUiLCJCdXR0b25UYWJsZVJvdyIsInJvd0luc2VydEJlZm9yZSIsInJvd0luc2VydEFmdGVyIiwicm93RGVsZXRlIiwiQnV0dG9uVGFibGUiLCJ0YWJsZSIsIkJ1dHRvblRhcmdldExpc3QiLCJsaXN0VGFyZ2V0cyIsIl9yZW5kZXJMaXN0VGFyZ2V0cyIsImxpbmtUYXJnZXRTZWxmIiwibGlua1RhcmdldEJsYW5rIiwibGlua1RhcmdldFBhcmVudCIsImxpbmtUYXJnZXRUb3AiLCJ0YXJnZXRzIiwiX2dldEFsbG93ZWRUYXJnZXRJdGVtcyIsIk1BWF9UV0VFVF9MRU5HVEgiLCJCdXR0b25Ud2l0dGVyIiwiX2dldEhyZWYiLCJ0d2l0dGVyIiwic2VsZWN0ZWRUZXh0IiwiZ2V0U2VsZWN0ZWRUZXh0Iiwic3Vic3RyaW5nIiwidmlhIiwidHdpdHRlckhyZWYiLCJCdXR0b25Vbm9yZGVyZWRsaXN0IiwiYnVsbGV0ZWRsaXN0IiwiQnV0dG9uVW5kZXJsaW5lIiwidW5kZXJsaW5lIiwiQnV0dG9uT2wiLCJCdXR0b25TdHlsZXNMaXN0SGVhZGVyIiwiQnV0dG9uVWwiLCJCdXR0b25BY3Rpb25TdHlsZSIsIkJ1dHRvbkNvbW1hbmRBY3RpdmUiLCJCdXR0b25Db21tYW5kIiwiaXNSZXF1aXJlZCIsIm1vZGlmaWVzU2VsZWN0aW9uIiwic2VsZWN0aW9uQ2hhbmdlIiwiQnV0dG9uS2V5c3Ryb2tlIiwiY29tcG9uZW50V2lsbE1vdW50IiwicmFuZG9tIiwidG9TdHJpbmciLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIkJ1dHRvblByb3BzIiwiQnV0dG9uU3RhdGVDbGFzc2VzIiwiaXNEaXNhYmxlZCIsIkJ1dHRvblN0eWxlIiwib25lT2ZUeXBlIiwiVG9vbGJhckJ1dHRvbnMiLCJnZXRUb29sYmFyQnV0dG9uR3JvdXBzIiwiV2lkZ2V0QXJyb3dCb3giLCJnZXRBcnJvd0JveENsYXNzZXMiLCJXaWRnZXREcm9wZG93biIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJfbmV4dFByb3BzIiwiV2lkZ2V0RXhjbHVzaXZlIiwiV2lkZ2V0Rm9jdXNNYW5hZ2VyIiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJXaWRnZXRJbnRlcmFjdGlvblBvaW50IiwiV2lkZ2V0UG9zaXRpb24iLCJtaXhpbnMiLCJnZXREZWZhdWx0UHJvcHMiLCJjYW5jZWxBbmltYXRpb24iLCJoYWxmV2lkdGgiLCJfYW5pbWF0ZSIsInNob3ciLCJ1cGRhdGVQb3NpdGlvbiIsIlVJIiwiX29uRGlzbWlzc1Rvb2xiYXJGb2N1cyIsImhpZGRlbiIsIl9vbkVkaXRvckludGVyYWN0aW9uIiwiX29uQWN0aW9uUGVyZm9ybWVkIiwiX29uRWRpdG9yS2V5IiwiX21vdXNlZG93bkxpc3RlbmVyIiwiX3NldFVJSGlkZGVuIiwiX2tleURvd25MaXN0ZW5lciIsImRlYm91bmNlIiwicHJldlByb3BzIiwicHJldlN0YXRlIiwibWVzc2FnZSIsIl9nZXRBdmFpbGFibGVUb29sYmFyc01lc3NhZ2UiLCJhcmlhVXBkYXRlIiwiX2FyaWFVcGRhdGVUZW1wbGF0ZXMiLCJ0ZW1wbGF0ZSIsIl9nZXRBcmlhVXBkYXRlcyIsImFyaWFVcGRhdGVzIiwibm9Ub29sYmFyIiwiYXJpYVVwZGF0ZU5vVG9vbGJhciIsIm9uZVRvb2xiYXIiLCJhcmlhVXBkYXRlT25lVG9vbGJhciIsIm1hbnlUb29sYmFycyIsImFyaWFVcGRhdGVNYW55VG9vbGJhcnMiLCJ0b29sYmFyc05vZGVMaXN0IiwidG9vbGJhck5hbWVzIiwidG9vbGJhciIsIl9nZXRBcmlhVXBkYXRlVGVtcGxhdGUiLCJvdXRwdXQiLCJqb2luIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRldGFjaCIsIl9ldmVudCIsImdldFNlbGVjdGlvbkRhdGEiLCJkb21FdmVudCIsImFsdEtleSIsInRhcmdldE5vZGUiLCJjb250YWlucyIsIlRvb2xiYXJBZGQiLCJUb29sYmFyU3R5bGVzIiwiUE9TSVRJT05fTEVGVCIsIlBPU0lUSU9OX1JJR0hUIiwiX3VwZGF0ZVBvc2l0aW9uIiwiX3ByZXZQcm9wcyIsIl9wcmV2U3RhdGUiLCJpc0NvbnRlbnRFZGl0YWJsZSIsIl9nZXRCdXR0b25zIiwiX2dldFRvb2xiYXJDbGFzc05hbWUiLCJjbGllbnRSZWN0IiwiZ2V0Q2xpZW50UmVjdCIsIm9mZnNldExlZnQiLCJwb3NpdGlvbiIsImd1dHRlckV4Y2x1c2l2ZSIsImZsb29yIiwiY3VycmVudFNlbGVjdGlvbiIsIl9nZXRDdXJyZW50U2VsZWN0aW9uIiwiZ2V0QXJyb3dCb3hDbGFzc2VzRm4iLCJfZ2V0U2VsZWN0aW9uRnVuY3Rpb24iLCJjc3NDbGFzc2VzIiwiYnV0dG9uc0dyb3VwIiwic2VsZWN0aW9uVHlwZSIsImhhc0dyb3VwcyIsInNlbGVjdGlvbkZuIiwic2VsZWN0aW9uRnVuY3Rpb24iLCJ0ZXN0Rm4iLCJzZXRQb3NpdGlvbkZuIiwic2V0UG9zaXRpb24iLCJCVVRUT05fREVGUyIsImdlbmVyYXRlQnV0dG9uQnJpZGdlIiwiYnV0dG9uRGVmaW5pdGlvbiIsIkJ1dHRvbkJyaWRnZSIsImJ1dHRvbkNvbW1hbmQiLCJidXR0b25PbkNsaWNrIiwib25DbGljayIsImJ1dHRvbkNsYXNzTmFtZSIsImJ1dHRvbkRpc3BsYXlOYW1lIiwiYnV0dG9uTGFiZWwiLCJidXR0b25UeXBlIiwiaWNvblN0eWxlIiwiY3NzU3R5bGUiLCJza2luIiwiZ2V0SWNvblN0eWxlIiwiY3NzU3R5bGVQYXJ0cyIsImJhY2tncm91bmRJbWFnZSIsImJhY2tncm91bmRQb3NpdGlvbiIsImJhY2tncm91bmRTaXplIiwiZGlzcGxheU5hbWUiLCJVSV9CVVRUT04iLCJyZXF1aXJlcyIsImJlZm9yZUluaXQiLCJ1aSIsImFkZEJ1dHRvbiIsImFkZEhhbmRsZXIiLCJNRU5VQlVUVE9OX0RFRlMiLCJnZW5lcmF0ZU1lbnVCdXR0b25CcmlkZ2UiLCJtZW51QnV0dG9uTmFtZSIsIm1lbnVCdXR0b25EZWZpbml0aW9uIiwiTWVudUJ1dHRvbkJyaWRnZSIsInBhbmVsTWVudUJ1dHRvbkRpc3BsYXlOYW1lIiwiX2dldE1lbnVJdGVtcyIsIm9uTWVudSIsIm1lbnVJdGVtcyIsIm1lbnVJdGVtIiwiZ2V0TWVudUl0ZW0iLCJtZW51SXRlbURlZmluaXRpb24iLCJkZWZpbml0aW9uIiwibWVudUl0ZW1TdGF0ZSIsIlRSSVNUQVRFX0RJU0FCTEVEIiwiVUlfTUVOVV9CVVRUT04iLCJhZGRNZW51QnV0dG9uIiwiVUlfTUVOVUJVVFRPTiIsImdyb3VwcyIsImdyb3Vwc09yZGVyIiwiXyIsIm1lbnVHcm91cHMiLCJhZGRNZW51R3JvdXAiLCJvcmRlciIsImFkZE1lbnVJdGVtIiwiZ3JvdXAiLCJhZGRNZW51SXRlbXMiLCJkZWZpbml0aW9ucyIsIml0ZW1OYW1lIiwiaGFzT3duUHJvcGVydHkiLCJyZW1vdmVNZW51SXRlbSIsIlBBTkVMX01FTlVfREVGUyIsImdlbmVyYXRlUGFuZWxNZW51QnV0dG9uQnJpZGdlIiwicGFuZWxNZW51QnV0dG9uTmFtZSIsInBhbmVsTWVudUJ1dHRvbkRlZmluaXRpb24iLCJQYW5lbE1lbnVCdXR0b25CcmlkZ2UiLCJwYW5lbCIsIl9nZXRQYW5lbCIsInBhbmVsTWVudUJ1dHRvbk9uQmxvY2siLCJvbkJsb2NrIiwiaGlkZSIsImJsb2NrRWxlbWVudCIsImJsb2NrIiwiZ2V0SHRtbCIsIlVJX1BBTkVMQlVUVE9OIiwiYWRkUGFuZWxNZW51QnV0dG9uIiwiUklDSF9DT01CT19ERUZTIiwiZ2VuZXJhdGVSaWNoQ29tYm9CcmlkZ2UiLCJyaWNoQ29tYm9OYW1lIiwicmljaENvbWJvRGVmaW5pdGlvbiIsIlJpY2hDb21ib0JyaWRnZSIsImN1cnJlbnRWYWx1ZSIsImVkaXRvckNvbWJvIiwibmV3VmFsdWUiLCJjdXJyZW50VGFyZ2V0IiwicHJldmlldyIsIl9pdGVtcyIsInNldFZhbHVlIiwiX3NldFZhbHVlIiwiaW5pdCIsIm9uUmVuZGVyIiwiX2NhY2hlVmFsdWUiLCJyaWNoQ29tYm9MYWJlbCIsIl9nZXRJdGVtcyIsInJpY2hDb21ibyIsIlVJX1JJQ0hDT01CTyIsImFkZFJpY2hDb21ibyIsIm9yaWdpbmFsVUlBZGRGbiIsInR5cGVIYW5kbGVyIiwiaGFuZGxlcnMiLCJfX3Byb2Nlc3NpbmdQbHVnaW5fXyIsInRpbWVvdXQiLCJhcmdzIiwiZGVib3VuY2VIYW5kbGUiLCJjYWxsRm4iLCJjYWxsQXJncyIsImNhbGxDb250ZXh0IiwiUkVHRVhfQk9PS01BUktfU0NIRU1FIiwiUkVHRVhfRU1BSUxfU0NIRU1FIiwiUkVHRVhfVVJJX1NDSEVNRSIsIm1vdmVUb0VsZW1lbnRFZGl0RW5kIiwibmV4dE5vZGUiLCJnZXROZXh0RWRpdGFibGVOb2RlIiwiZXF1YWxzIiwiZ2V0Q29tbW9uQW5jZXN0b3IiLCJ3aGl0ZXNwYWNlIiwiZ2V0VGV4dCIsIm9mZnNldCIsIlVSSSIsImNvbGxhcHNlZCIsInRleHQiLCJpbnNlcnROb2RlIiwic2VsZWN0Tm9kZUNvbnRlbnRzIiwiX2dldENvbXBsZXRlVVJJIiwicmVsIiwibGlua0NmZyIsImRlZmF1bHRUYXJnZXQiLCJhcHBseVRvUmFuZ2UiLCJzZWxlY3QiLCJpcyIsImdldENoaWxkcmVuIiwiY291bnQiLCJnZXRJdGVtIiwic2hyaW5rIiwiU0hSSU5LX1RFWFQiLCJhbHdheXNSZW1vdmVFbGVtZW50Iiwic2VsZWN0RWxlbWVudCIsInVyaSIsInNldEF0dHJpYnV0ZXMiLCJyZW1vdmVBdHRycyIsInNldEF0dHJzIiwicmVtb3ZlQXR0cmlidXRlcyIsIndyYXBQbHVnaW5MaWZlY3ljbGUiLCJtZXRob2RzIiwibWV0aG9kTmFtZSIsIm92ZXJyaWRlIiwicGF5bG9hZCIsInBoYXNlIiwib3JpZ2luYWxQbHVnaW5NZXRob2QiLCJmaWx0ZXJVbndhbnRlZERlcGVuZGVuY2llcyIsInJlcXVpcmUiLCJuYW1lcyIsInNjb3BlIiwicGx1Z2luc0xvYWQiLCJTZWxlY3Rpb25SZWdpb24iLCJjcmVhdGVTZWxlY3Rpb25Gcm9tUG9pbnQiLCJjcmVhdGVTZWxlY3Rpb25Gcm9tUmFuZ2UiLCJzdGFydFgiLCJzdGFydFkiLCJlbmRYIiwiZW5kWSIsImVuZCIsImVuZENvbnRhaW5lciIsImVuZE9mZnNldCIsInN0YXJ0Iiwic3RhcnRPZmZzZXQiLCJjYXJldFBvc2l0aW9uRnJvbVBvaW50Iiwib2Zmc2V0Tm9kZSIsImNyZWF0ZVJhbmdlIiwiY2FyZXRSYW5nZUZyb21Qb2ludCIsImNyZWF0ZVRleHRSYW5nZSIsImVuZFJhbmdlIiwiZHVwbGljYXRlIiwic2V0RW5kUG9pbnQiLCJnZXRDYXJldFJlZ2lvbiIsImJvb2ttYXJrTm9kZUVsIiwic3RhcnROb2RlIiwic2Nyb2xsUG9zIiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJnZXRTZWxlY3Rpb25SZWdpb24iLCJnZXRDbGllbnRSZWN0c1JlZ2lvbiIsImdldFNlbGVjdGlvbkRpcmVjdGlvbiIsImlzU2VsZWN0aW9uRW1wdHkiLCJnZXRUeXBlIiwiU0VMRUNUSU9OX05PTkUiLCJuYXRpdmVTZWxlY3Rpb24iLCJkZWZhdWx0UmVjdCIsImNsaWVudFJlY3RzIiwiSW5maW5pdHkiLCJnZXRDbGllbnRSZWN0cyIsInJhbmdlQ291bnQiLCJnZXRSYW5nZUF0IiwiYW5jaG9yTm9kZSIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiZm9jdXNOb2RlIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNPZmZzZXQiLCJOb2RlIiwiRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HIiwiYXR0ciIsIklFX05PTl9ESVJFQ1RMWV9FRElUQUJMRV9FTEVNRU5UIiwiY29sIiwiY29sZ3JvdXAiLCJ0Ym9keSIsInRkIiwidGZvb3QiLCJ0aCIsInRoZWFkIiwidHIiLCJIRUFESU5HX0JPVEgiLCJIRUFESU5HX0NPTCIsIkhFQURJTkdfTk9ORSIsIkhFQURJTkdfUk9XIiwiX2NyZWF0ZUVsZW1lbnQiLCJhcHBlbmQiLCJqIiwiYXBwZW5kQm9ndXMiLCJzZXRIZWFkaW5nIiwiaGVhZGluZyIsImZpcnN0Q2VsbCIsImNlbGxzIiwibW92ZVRvUG9zaXRpb24iLCJQT1NJVElPTl9BRlRFUl9TVEFSVCIsIndlYmtpdCIsIk5PREVfRUxFTUVOVCIsImlzRWRpdGFibGUiLCJpc1JlYWRPbmx5IiwiaGFzQXR0cmlidXRlIiwiZ2V0UGFyZW50Iiwicm93SGVhZGluZ1NldHRpbmdzIiwidEhlYWQiLCJjb2xIZWFkaW5nU2V0dGluZ3MiLCJub2RlTmFtZSIsImhlYWRpbmdTZXR0aW5ncyIsInBhcmVudCIsImdldENoaWxkQ291bnQiLCJQT1NJVElPTl9CRUZPUkVfU1RBUlQiLCJuZXdDZWxsIiwidGFibGVIZWFkIiwidGFibGVCb2R5IiwiZ2V0RWxlbWVudHNCeVRhZyIsInRhYmxlSGVhZGluZyIsImhhZENvbEhlYWRpbmciLCJuZWVkQ29sSGVhZGluZyIsIm5lZWRSb3dIZWFkaW5nIiwidGFibGVGaXJzdFJvdyIsInRhYmxlRmlyc3RSb3dDaGlsZENvdW50IiwiZ2V0Q2hpbGQiLCJyZW5hbWVOb2RlIiwiY3JlYXRlVEhlYWQiLCJwcmV2aW91c0ZpcnN0Um93IiwiZ2V0Rmlyc3QiLCJuZXdGaXJzdFJvdyIsIm5ld0ZpcnN0Um93Q2hpbGRDb3VudCIsInJlbW92ZUF0dHJpYnV0ZSIsImluc2VydEJlZm9yZSIsImhhc0NvbEhlYWRpbmciLCJoZWFkaW5nQ29tbWFuZHMiLCJqc29ucCIsInVybFRlbXBsYXRlIiwidXJsUGFyYW1zIiwiZXJyb3JDYWxsYmFjayIsImNhbGxiYWNrS2V5IiwiZ2V0TmV4dE51bWJlciIsImpzb25wQ2FsbGJhY2tzIiwicmVzcG9uc2UiLCJjbGVhblVwIiwic2NyaXB0RWxlbWVudCIsImdldEJvZHkiLCJjYW5jZWwiLCJzaW11bGF0ZSIsImV2ZW50SW5zdGFuY2UiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJhcmlhU3RhdGUiLCJhcmlhRWxlbWVudCIsIl9jcmVhdGVBcmlhRWxlbWVudCIsInVpVGFza3NUaW1lb3V0IiwidWljb3JlIiwiaGFuZGxlVUkiLCJhbGxvd0VzYyIsImhhbmRsZUFyaWEiLCJpbm5lckhUTUwiLCJoYW5kbGVNb3VzZUxlYXZlIiwiYWVVSU5vZGVzIiwiZm91bmQiLCJyZWxhdGVkVGFyZ2V0IiwiZm9jdXNIYW5kbGVyIiwiYXR0YWNoTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsInN0YXR1c0VsZW1lbnQiLCJfX2NvbmZpZ19fIiwiX19BVFRSU19fIiwiY3VycmVudEF0dHIiLCJfaXNJbml0aWFsaXplZCIsIl9pbml0IiwiY3VyVmFsdWUiLCJfY2FsbFN0cmluZ09yRnVuY3Rpb24iLCJzZXQiLCJzdHJpbmdPckZ1bmN0aW9uIiwiaGFzRGVmYXVsdFZhbHVlIiwiaGFzUGFzc2VkVmFsdWVWaWFDb25maWciLCJ2YWx1ZUZuIiwiX2NhbGxDaGFpbiIsIndhdCIsImFyciIsImN0b3IiLCJyZXZlcnNlIiwiaXNGaW5pdGUiLCJ2YWx1ZVR5cGUiLCJyZWNlaXZlciIsInN1cHBsaWVyIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwic3VwcGxpZXJQcm90byIsInJlY2VpdmVyUHJvdG8iLCJEcmFnRXZlbnQiLCJldmVudHMiLCJrZXlkb3duIiwibW91c2Vtb3ZlIiwibW91c2V1cCIsInN0YXJ0UG9zIiwiY2xpZW50WCIsImNsaWVudFkiLCJjbGFzc0xpc3QiLCJvblN0YXJ0IiwiY3VycmVudFBvcyIsImRlbHRhIiwiYWx0IiwiY3RybCIsInNoaWZ0S2V5Iiwib25EcmFnIiwid2hpY2giLCJyZWxlYXNlIiwib25Db21wbGV0ZSIsIm9uUmVsZWFzZSIsIklNQUdFX0hBTkRMRVMiLCJQT1NJVElPTl9FTEVNRU5UX0ZOIiwiYmwiLCJoYW5kbGUiLCJib3giLCJwb3NpdGlvbkVsZW1lbnQiLCJiciIsInJtIiwicm91bmQiLCJ0bCIsIl9ib3giLCJnZXRCb3VuZGluZ0JveCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiUmVzaXplciIsImNvbnRhaW5lciIsImhhbmRsZXMiLCJwcmV2aWV3Qm94IiwiaGFuZGxlTmFtZSIsImNyZWF0ZUhhbmRsZSIsInNob3dIYW5kbGVzIiwiZWxlbWVudHMiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiaGlkZUhhbmRsZXMiLCJkcmFnIiwic2hvd1ByZXZpZXciLCJpc0RyYWdnaW5nIiwiY2FsY3VsYXRlU2l6ZSIsImVkaXRvckJvdW5kcyIsInVwZGF0ZVByZXZpZXciLCJ1cGRhdGVIYW5kbGVzIiwiaGlkZVByZXZpZXciLCJyZXNpemVDb21wbGV0ZSIsInJhdGlvIiwiaXNJRSIsIl9vbkRyYWdFbnRlciIsIl9vbkRyYWdPdmVyIiwiX29uRHJhZ0Ryb3AiLCJfb25QYXN0ZSIsIl9oYW5kbGVGaWxlcyIsIl9wcm9jZXNzRmlsZSIsInRyYW5zZmVyRmlsZXMiLCJkYXRhVHJhbnNmZXIiLCJfcHJldmVudEV2ZW50IiwiY2xpcGJvYXJkRGF0YSIsInBhc3RlZERhdGEiLCJpbWFnZUZpbGUiLCJnZXRBc0ZpbGUiLCJiaW4iLCJ1c2VyQWdlbnQiLCJLRVlfQkFDSyIsIktFWV9DT01NQSIsIktFWV9TRU1JQ09MT04iLCJLRVlfU1BBQ0UiLCJERUxJTUlURVJTIiwiUkVHRVhfTEFTVF9XT1JEIiwiUkVHRVhfVVJMIiwiUkVHRVhfRU1BSUwiLCJfb25LZXlVcCIsIm1ldGhvZCIsImRhdGFWYWx1ZSIsIlJlZ0V4cCIsIl9pc1ZhbGlkVVJMIiwiX2lzVmFsaWRFbWFpbCIsIl9nZXRMYXN0V29yZCIsInByZXZpb3VzVGV4dCIsIl9jdXJyZW50S2V5Q29kZSIsInByZXZpb3VzTm9kZSIsImdldFByZXZpb3VzIiwibGFzdENoaWxkIiwiZ2V0TGFzdCIsIl9zdGFydENvbnRhaW5lciIsIl9vZmZzZXQiLCJsYXN0V29yZCIsImVtYWlsIiwiX29uS2V5RG93biIsIl9ja0xpbmsiLCJfcmVwbGFjZUNvbnRlbnRCeUxpbmsiLCJjb250ZW50IiwiY2tMaW5rIiwibGlua05vZGUiLCJfc3Vic2NyaWJlVG9LZXlFdmVudCIsIm5leHRFZGl0YWJsZU5vZGUiLCJlbmNsb3NlZE5vZGUiLCJnZXRFbmNsb3NlZE5vZGUiLCJjYXJldE9mZnNldCIsImdldE5leHQiLCJuZXdSYW5nZSIsInNldEVuZEFmdGVyIiwiREVGQVVMVF9DT05GSUciLCJyZWdleCIsIl9jaGVja0ZvckJhY2tzcGFjZUFuZFVuZG8iLCJpbnNlcnRIdG1sIiwiYnVsbGV0IiwiX2dldExpc3RDb25maWciLCJjb25maWdSZWdleCIsImF1dG9saXN0IiwidGV4dENvbnRhaW5lciIsInJlZ2V4TGVuIiwiYXV0b2xpc3RDZmciLCJyZWdleEl0ZW0iLCJfY3JlYXRlTGlzdCIsImxpc3RDb25maWciLCJzZXRUZXh0IiwiYm90aCIsInNjYWxlIiwiYm0iLCJsbSIsInRtIiwiSU1BR0VfU05BUF9UT19TSVpFIiwiaXNGaXJlZm94IiwiZG9jdW1lbnRFbGVtZW50IiwiaXNXZWJLaXQiLCJlbmFibGVQbHVnaW4iLCJhZGRDc3MiLCJvbkxvYWQiLCJzbmFwVG9TaXplIiwiaW1hZ2VTY2FsZVJlc2l6ZSIsInJlc2l6ZXIiLCJtb3VzZURvd25MaXN0ZW5lciIsImUiLCJpc0hhbmRsZSIsImluaXREcmFnIiwiaHRtbCIsInNlbGYiLCJyZXNpemVFbGVtZW50IiwicmVzaXplVGltZW91dCIsIm4iLCJvdGhlckltYWdlcyIsInRvQXJyYXkiLCJzcGxpY2UiLCJvdGhlcnMiLCJvdGhlciIsImxlbiIsImN0eCIsIlN0cmluZyIsInRlbXBsYXRlQmxvY2siLCJhbGlnbm1lbnRzT2JqIiwiY2VudGVyIiwicmVnZXhQZXJjZW50Iiwid2lkZ2V0RGVmIiwid2lkZ2V0cyIsIndpZGdldEVsZW1lbnQiLCJzY3JvbGxQb3NpdGlvbiIsImFmdGVySW5pdCIsImFsaWduIiwiaW50ZWdyYXRlIiwiYWxpZ25Db21tYW5kSW50ZWdyYXRvciIsImFsaWduQ2xhc3NlcyIsImFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXMiLCJjYXB0aW9uZWRDbGFzcyIsImFlX2RyYWdyZXNpemVfaWUxMV9jYXB0aW9uZWRDbGFzcyIsImRlZmxhdGUiLCJkZWZsYXRlZCIsImZvY3VzZWQiLCJ3aWRnZXQiLCJpbmZsYXRlIiwiZG9jIiwiaW5pdE9uIiwid3JhcHBlciIsImFjdGl2ZUVudGVyTW9kZSIsIkVOVEVSX1AiLCJtb3ZlIiwic2V0V3JhcHBlckFsaWduIiwiZ2V0V2lkZ2V0QWxsb3dlZENvbnRlbnQiLCJyZXF1aXJlZENvbnRlbnQiLCJmZWF0dXJlcyIsImdldFdpZGdldEZlYXR1cmVzIiwic3R5bGVhYmxlRWxlbWVudHMiLCJjb250ZW50VHJhbnNmb3JtYXRpb25zIiwiZWRpdGFibGVzIiwiY2FwdGlvbiIsInNlbGVjdG9yIiwiaGFzQ2FwdGlvbiIsImNoZWNrRmVhdHVyZSIsInNoaWZ0U3RhdGUiLCJvbGREYXRhIiwibmV3RGF0YSIsImMiLCJjbGFzc2VzIiwiZGltZW5zaW9uIiwic2V0RGltZW5zaW9ucyIsImhlbHBlcnMiLCJhZV9kcmFncmVzaXplX2llMTEiLCJyZWFkeSIsImNoZWNrSGFzTmF0dXJhbFJhdGlvIiwiYWxpZ25FbGVtZW50IiwiZ2V0TGlua0F0dHJpYnV0ZXNQYXJzZXIiLCJhZHZhbmNlZCIsImFkdkNTU0NsYXNzZXMiLCJ0cmltIiwic2V0RGF0YSIsImFlX2RyYWdyZXNpemVfaWUxMV9kaXNhYmxlUmVzaXplciIsInNldHVwUmVzaXplciIsImRyYWdIYW5kbGVyU3R5bGUiLCJkcmFnSGFuZGxlckNvbnRhaW5lciIsInN0YXRlU2hpZnRlciIsImV2dCIsIlRSSVNUQVRFX09GRiIsInVubGluayIsImdldFN0eWxlYWJsZUVsZW1lbnQiLCJnZXRDbGFzc2VzIiwiY2xhc3NSZWdleCIsInJlcG9zaXRvcnkiLCJwYXJzZUVsZW1lbnRDbGFzc2VzIiwidXBjYXN0IiwidXBjYXN0V2lkZ2V0RWxlbWVudCIsImRvd25jYXN0IiwiZG93bmNhc3RXaWRnZXRFbGVtZW50IiwiZ2V0TGFiZWwiLCJwYXRoTmFtZSIsInNoaWZ0YWJsZXMiLCJzdGF0ZUFjdGlvbnMiLCJvbGRWYWx1ZSIsImNoYW5nZWQiLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJ3cmFwSW5DZW50ZXJpbmciLCJ1bndyYXBGcm9tQ2VudGVyaW5nIiwic2V0U3R5bGUiLCJpbWFnZU9yTGluayIsImltZyIsImZpZ3VyZSIsImNhcHRpb25QbGFjZWhvbGRlciIsInJlcGxhY2VTYWZlbHkiLCJuZWVkc0RlZmxhdGUiLCJuZXdFbCIsInVud3JhcEZyb21MaW5rIiwid3JhcEluTGluayIsImdldExpbmtBdHRyaWJ1dGVzR2V0dGVyIiwiaXNFbXB0eSIsInJlbW92ZWQiLCJhdHRyaWJzQW5kU3R5bGVzIiwibGlua0RhdGEiLCJyZXBsYWNpbmciLCJyZXBsYWNlZCIsImluc2VydEVsZW1lbnRJbnRvUmFuZ2UiLCJuYXR1cmFsIiwiZ2V0TmF0dXJhbCIsImNsaWVudEhlaWdodCIsImRpbWVuc2lvbnMiLCJuYXR1cmFsV2lkdGgiLCJuYXR1cmFsSGVpZ2h0IiwiSW1hZ2UiLCJnZXRMaW5rQXR0cmlidXRlcyIsInBhcnNlTGlua0F0dHJpYnV0ZXMiLCJxdWVyeVNlbGVjdG9yIiwiaW1hZ2VTdHlsZXMiLCJoZWlnaHRTdHlsZXMiLCJ3aWR0aFN0eWxlcyIsImlzQ2VudGVyV3JhcHBlciIsImNlbnRlcldyYXBwZXJDaGVja2VyIiwicmVwbGFjZVdpdGgiLCJpc0xpbmtlZE9yU3RhbmRhbG9uZUltYWdlIiwiZCIsImF0dHJzSG9sZGVyIiwicmVzaXplV3JhcHBlciIsInBhcnNlQ3NzVGV4dCIsIndyYXBXaXRoIiwiaHRtbFBhcnNlciIsIndyaXRlQ3NzVGV4dCIsInZhbGlkQ2hpbGRyZW4iLCJkaXYiLCJwIiwiY2hpbGQiLCJlbnRlck1vZGUiLCJyZXNpemVyTkUiLCJyZXNpemVyTlciLCJyZXNpemVyU0UiLCJyZXNpemVyU1ciLCJvbGRSZXNpemVXcmFwcGVyIiwic2NyZWVuWCIsInNjcmVlblkiLCJzdGFydFdpZHRoIiwic3RhcnRIZWlnaHQiLCJsaXN0ZW5lcnMiLCJmYWN0b3JYIiwiZmFjdG9yWSIsIm1vdmVEaWZmWCIsIm1vdmVEaWZmWSIsIm5hdGl2ZUV2dCIsIm5ld0hlaWdodCIsIm5ld1dpZHRoIiwidXBkYXRlRGF0YSIsImN1cnNvckNsYXNzIiwiYXR0YWNoVG9Eb2N1bWVudHMiLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VVcCIsImNvbGxlY3Rpb24iLCJnbG9iYWxEb2MiLCJhZGp1c3RUb1giLCJhZGp1c3RUb1kiLCJsIiwicmVtb3ZlV2lkZ2V0QWxpZ25tZW50IiwiaW1hZ2VBbGlnbm1lbnQiLCJleGVjQ2FsbGJhY2tzIiwiZW5hYmxlZCIsInJlZnJlc2giLCJnZXRGb2N1c2VkV2lkZ2V0IiwiYWxsb3dlZCIsInJlZ2lzdGVyZWQiLCJydWxlcyIsImZpZ2NhcHRpb24iLCJSRUdFWF9IVFRQIiwiUkVHRVhfREVGQVVMVF9MSU5LIiwiREVGQVVMVF9BRV9FTUJFRF9VUkxfVFBMIiwiREVGQVVMVF9BRV9FTUJFRF9XSURHRVRfVFBMIiwiREVGQVVMVF9BRV9FTUJFRF9ERUZBVUxUX0xJTktfVFBMIiwiQUVfRU1CRURfVVJMX1RQTCIsImVtYmVkVXJsVGVtcGxhdGUiLCJBRV9FTUJFRF9XSURHRVRfVFBMIiwiZW1iZWRXaWRnZXRUcGwiLCJBRV9FTUJFRF9ERUZBVUxUX0xJTktfVFBMIiwiZW1iZWRMaW5rRGVmYXVsdFRwbCIsImRlZmF1bHRFbWJlZFdpZGdldFVwY2FzdEZuIiwibWFzayIsImVuY29kZVVSSUNvbXBvbmVudCIsImNyZWF0ZUFUYWciLCJzZXRIdG1sIiwiYVRhZ0h0bWwiLCJlbWJlZFdpZGdldFVwY2FzdEZuIiwiSElHSF9QUklPUklUWSIsImFkZEVsZW1lbnRDYWxsYmFjayIsIkZJTFRFUl9TS0lQX1RSRUUiLCJERUZBVUxUX0xGUl9FTUJFRF9XSURHRVRfVFBMIiwiRU1CRURfQUxJR05NRU5UIiwiQ0VOVEVSIiwiTEVGVCIsIlJJR0hUIiwiQUxJR05fVkFMVUVTIiwiQ0VOVEVSRURfRU1CRURfU1RZTEUiLCJnZXRFbWJlZEFsaWdubWVudCIsImVtYmVkQWxpZ25tZW50IiwiY2VudGVyZWRFbWJlZCIsImV2ZXJ5Iiwic3R5bGVDaGVjayIsInZlbmRvclByZWZpeGVzIiwidmVuZG9yUHJlZml4IiwicmVtb3ZlRW1iZWRBbGlnbm1lbnQiLCJzZXRFbWJlZEFsaWdubWVudCIsIndyYXBwZXJFbGVtZW50IiwicGFyZW50RWxlbWVudCIsInB3aWR0aCIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImlmcmFtZUVsZW1lbnQiLCJzZWxlY3RXaWRnZXQiLCJyb290IiwiZmluZCIsImVsZW1lbnRMaXN0IiwiY3VycmVudEFsaWdubWVudCIsImN1cnJlbnRFbGVtZW50IiwiTEZSX0VNQkVEX1dJREdFVF9UUEwiLCJwcm92aWRlcnMiLCJwcm92aWRlciIsInNjaGVtZSIsImdlbmVyYXRlRW1iZWRDb250ZW50IiwiaGVscE1lc3NhZ2UiLCJ2aWRlb1BsYXliYWNrRGlzYWJsZWQiLCJoZWxwTWVzc2FnZUljb24iLCJMaWZlcmF5IiwiVXRpbCIsImdldExleGljb25JY29uVHBsIiwidXBjYXN0V2lkZ2V0IiwiaWZyYW1lIiwiZW1iZWRDb250ZW50IiwiZ2V0T3V0ZXJIdG1sIiwid2lkZ2V0RnJhZ21lbnQiLCJmcmFnbWVudCIsImZyb21IdG1sIiwic2hvd0Vycm9yIiwiZXJyb3JNc2ciLCJ2YWxpZFByb3ZpZGVyIiwiZW1iZWRJZCIsIl9zZWxlY3RFbWJlZFdpZGdldCIsInBsYXRmb3JtTm90U3VwcG9ydGVkIiwiZW50ZXJWYWxpZFVybCIsImRyYWdnYWJsZSIsInN0eWxlc0pTT04iLCJfZXJyb3IiLCJib3VuZHMiLCJhbGlnblZhbHVlIiwic2VsZWN0ZWRFbWJlZCIsInNlbmRlciIsIklNQUdFX0FMSUdOTUVOVCIsIklNQUdFX1NUWUxFX0FMSUdOTUVOVCIsImdldEltYWdlQWxpZ25tZW50IiwiY2VudGVyZWRJbWFnZSIsImltYWdlQ29udGFpbmVyIiwidGV4dEFsaWduIiwicmVtb3ZlSW1hZ2VBbGlnbm1lbnQiLCJzZXRJbWFnZUFsaWdubWVudCIsInJlZnJlc2hDb21tYW5kcyIsImVtYmVkdXJsIiwiYnJGaWxsZXIiLCJuZWVkc0JyRmlsbGVyIiwiZW50ZXJNb2RlRW1wdHlWYWx1ZSIsIl9jaGVja0VtcHR5RGF0YSIsIl9yZW1vdmVQbGFjZWhvbGRlckNsYXNzIiwiZWRpdGFibGVOb2RlIiwiaW5uZXJIdG1sIiwiZWRpdG9yTm9kZSIsIkRFRkFVTFRfUFJJT1JJVFkiLCJzZWxlY3Rpb25LZXlzdHJva2UiLCJweFVuaXQiLCJjc3NMZW5ndGgiLCJnZXRXaWR0aCIsImdldEJvcmRlcldpZHRoIiwic2lkZSIsImNvbXB1dGVkIiwiYm9yZGVyTWFwIiwidGhpbiIsIm1lZGl1bSIsInRoaWNrIiwiZ2V0TWFzdGVyUGlsbGFyUm93IiwiJHJvd3MiLCJtYXhDZWxscyIsImNlbGxzQ291bnQiLCIkZWxlY3RlZCIsIiR0ciIsImJ1aWxkVGFibGVDb2x1bW5QaWxsYXJzIiwicGlsbGFycyIsInBpbGxhckluZGV4IiwicnRsIiwidEJvZGllcyIsInRib2R5UG9zaXRpb24iLCJnZXREb2N1bWVudFBvc2l0aW9uIiwibmV4dFRkIiwiY29sU3BhbiIsInBpbGxhckxlZnQiLCJwaWxsYXJSaWdodCIsInBpbGxhcldpZHRoIiwiZ2V0UGlsbGFyQXRQb3NpdGlvbiIsInBvc2l0aW9uWCIsInBpbGxhciIsIkNvbHVtblJlc2l6ZXIiLCJjdXJyZW50U2hpZnQiLCJsZWZ0U2hpZnRCb3VuZGFyeSIsImxlZnRTaWRlQ2VsbHMiLCJyZXNpemluZyIsInJpZ2h0U2hpZnRCb3VuZGFyeSIsInJpZ2h0U2lkZUNlbGxzIiwiaXNSZXNpemluZyIsInBvc1giLCJyZXNpemVyTmV3UG9zaXRpb24iLCJvbk1vdXNlRG93biIsInJlc2l6ZVN0YXJ0IiwiY29sdW1uSW5kZXgiLCJidWlsZFRhYmxlTWFwIiwibGVmdENvbHVtbkNlbGxzIiwicmlnaHRDb2x1bW5DZWxscyIsImxlZnRNaW5TaXplIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwicmlnaHRNaW5TaXplIiwibGVmdENlbGwiLCJyaWdodENlbGwiLCJzZXRPcGFjaXR5IiwicmVzaXplRW5kIiwicmVzaXplQ29sdW1uIiwicmVtb3ZlQ3VzdG9tRGF0YSIsImxlZnRPbGRXaWR0aCIsInJpZ2h0T2xkV2lkdGgiLCJ0YWJsZVdpZHRoIiwic2l6ZVNoaWZ0IiwiZ2V0UGFnZU9mZnNldCIsImdldERvY3VtZW50RWxlbWVudCIsImNsZWFyUGlsbGFyc0NhY2hlIiwiZGVzdCIsInRvRWxlbWVudCIsImlzSW5saW5lIiwiZ2V0Q3VzdG9tRGF0YSIsInNldEN1c3RvbURhdGEiLCJjZWxsTm9kZVJlZ2V4IiwiZ2V0U2VsZWN0ZWRDZWxscyIsInJldHZhbCIsImRhdGFiYXNlIiwibW92ZU91dE9mQ2VsbEd1YXJkIiwic2V0TWFya2VyIiwibmVhcmVzdENlbGwiLCJ3YWxrZXIiLCJndWFyZCIsImR0ZCIsImNsZWFyQWxsTWFya2VycyIsImdldEZvY3VzRWxlbWVudEFmdGVyRGVsQ2VsbHMiLCJjZWxsc1RvRGVsZXRlIiwibGFzdCIsImZvY3VzZWRDZWxsIiwiaW5zZXJ0Um93IiwiZ2V0RG9jdW1lbnQiLCJzdGFydFJvdyIsInN0YXJ0Um93SW5kZXgiLCJyb3dJbmRleCIsImxhc3RDZWxsIiwiZW5kUm93SW5kZXgiLCJyb3dTcGFuIiwiZW5kUm93IiwiY2xvbmVSb3ciLCJuZXh0Um93IiwibmV3Um93IiwiY2xvbmUiLCJpbnNlcnRBZnRlciIsImNlbGxJbmRleCIsImRlbGV0ZVJvd3MiLCJzZWxlY3Rpb25PclJvdyIsInJvd3NUb0RlbGV0ZSIsIm1hcFJvdyIsImNlbGxSb3dJbmRleCIsIm5leHRNYXBSb3ciLCJjdXJzb3JQb3NpdGlvbiIsImdldENlbGxDb2xJbmRleCIsImlzU3RhcnQiLCJyb3dDZWxscyIsImNvbEluZGV4IiwibWFwQ2VsbCIsImdldENvbHVtbnNJbmRpY2VzIiwiaW5zZXJ0Q29sdW1uIiwic3RhcnRDb2wiLCJsYXN0Q29sIiwiY2xvbmVDb2wiLCJuZXh0Q29sIiwibmV4dENlbGwiLCJpbnNlcnRlZENlbGxzIiwiZGVsZXRlQ29sdW1ucyIsInNlbGVjdGlvbk9yQ2VsbCIsInN0YXJ0Q29sSW5kZXgiLCJlbmRDb2xJbmRleCIsImZpcnN0Um93Q2VsbHMiLCJpbnNlcnRDZWxsIiwic3RhcnRFbGVtZW50IiwiZGVsZXRlQ2VsbHMiLCJjZWxsVG9Gb2N1cyIsInBsYWNlQ3Vyc29ySW5DZWxsIiwidHJpbUNlbGwiLCJib2d1cyIsImdldEJvZ3VzIiwicGxhY2VBdEVuZCIsImRvY0lubmVyIiwiZG9jT3V0ZXIiLCJ2ZXJzaW9uIiwiY29sbGFwc2UiLCJjZWxsSW5Sb3ciLCJ0YWJsZU1hcCIsIm9Sb3ciLCJjZWxsSW5Db2wiLCJvQ29sIiwiciIsIm1lcmdlQ2VsbHMiLCJtZXJnZURpcmVjdGlvbiIsImlzRGV0ZWN0IiwiY29tbW9uQW5jZXN0b3IiLCJtYXBIZWlnaHQiLCJtYXBXaWR0aCIsInN0YXJ0Q29sdW1uIiwidGFyZ2V0Q2VsbCIsInJvd3NwYW4iLCJjb2xzcGFuIiwiZXIiLCJsYXN0Um93SW5kZXgiLCJ0b3RhbFJvd1NwYW4iLCJ0b3RhbENvbFNwYW4iLCJmcmFnIiwiZG9jdW1lbnRGcmFnbWVudCIsImNlbGxGaXJzdENoaWxkIiwiaXNCbG9ja0JvdW5kYXJ5Iiwid2hpdGVzcGFjZXMiLCJtb3ZlQ2hpbGRyZW4iLCJ0cnMiLCJub2RlTGlzdCIsInRhaWxUciIsInZlcnRpY2FsU3BsaXRDZWxsIiwibmV3Um93U3BhbiIsIm5ld0NlbGxSb3dTcGFuIiwibmV3Um93SW5kZXgiLCJjZWlsIiwibmV3Q2VsbFRyIiwibmV3Q2VsbFJvdyIsImNhbmRpZGF0ZUNlbGwiLCJjZWxsc0luU2FtZVJvdyIsImhvcml6b250YWxTcGxpdENlbGwiLCJuZXdDb2xTcGFuIiwibmV3Q2VsbENvbFNwYW4iLCJjZWxsc0luU2FtZUNvbCIsImNyZWF0ZURlZiIsImRlZiIsImNvbnRleHRTZW5zaXRpdmUiLCJhZGRDbWQiLCJjbWQiLCJhZGRGZWF0dXJlIiwiYVJvd3MiLCJhTWFwIiwib0NlbGwiLCJpQ29sU3BhbiIsImlSb3dTcGFuIiwicnMiLCJjcyIsInRhYmxlU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzIiwiREVGQVVMVF9HVVRURVIiLCJjZW50ZXJUb29sYmFyIiwidG9vbGJhck5vZGUiLCJoYWxmTm9kZVdpZHRoIiwid2lkZ2V0WFkiLCJjYXJldFBvc2l0aW9uIiwibm9kZVR5cGUiLCJFTEVNRU5UX05PREUiLCJzdGFydENvbnRhaW5lckNsaWVudFJlY3QiLCJlbmRQb3NpdGlvbiIsImltYWdlU2VsZWN0aW9uU2V0UG9zaXRpb24iLCJ0YWJsZVNlbGVjdGlvblNldFBvc2l0aW9uIiwiX2lzUmFuZ2VBdEVsZW1lbnRFbmQiLCJlbWJlZFNlbGVjdGlvblRlc3QiLCJlbWJlZFVybFNlbGVjdGlvblRlc3QiLCJoZWFkaW5nVGV4dFNlbGVjdGlvblRlc3QiLCJoZWFkaW5ncyIsInNlbGVjdGlvbkVtcHR5IiwibGlua1NlbGVjdGlvblRlc3QiLCJlbGVtZW50SXNOb3RJbWFnZSIsImltYWdlU2VsZWN0aW9uVGVzdCIsImhhc0ltYWdlIiwiaXNJbWFnZSIsInRleHRTZWxlY3Rpb25UZXN0IiwidGFibGVTZWxlY3Rpb25UZXN0IiwiZW1iZWRVcmwiLCJoZWFkZXIiLCJmdWxsIiwic2ltcGxlIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQTBDLGdDQUFnQztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUF3RCxrQkFBa0I7QUFDMUU7QUFDQSx5REFBaUQsY0FBYztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQXlDLGlDQUFpQztBQUMxRSx3SEFBZ0gsbUJBQW1CLEVBQUU7QUFDckk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUNB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QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFVBQVUsS0FBcUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFxQztBQUN6QztBQUNBOztBQUVBLDhDQUE4QyxjQUFjOztBQUU1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGLGFBQWE7QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLGVBQWU7QUFDM0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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IiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2FkYXB0ZXIvbWFpbi5qc1wiKTtcbiIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi44LjVcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlO1xudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHxcbiAgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKTtcbn1cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgbG93UHJpb3JpdHlXYXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcblxudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7XG5cbi8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7XG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCAnLi4vY29yZSc7XG5cbmltcG9ydCAnLi4vcGx1Z2lucyc7XG5cbmltcG9ydCAnLi4vY29tcG9uZW50cy91aWJyaWRnZSc7XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuaW1wb3J0IHtyZW1vdmVJbWFnZUNvbW1hbmR9IGZyb20gJy4uL2NvbW1hbmRzJztcbmltcG9ydCBVSSBmcm9tICcuLi9jb21wb25lbnRzL21haW4uanN4JztcbmltcG9ydCBCYXNlIGZyb20gJy4uL29vcC9iYXNlJztcbmltcG9ydCBMYW5nIGZyb20gJy4uL29vcC9sYW5nJztcbmltcG9ydCBleHRlbmQgZnJvbSAnLi4vb29wL29vcCc7XG5pbXBvcnQgU2VsZWN0aW9ucyBmcm9tICcuLi9zZWxlY3Rpb25zL3NlbGVjdGlvbnMnO1xuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi9lZGl0b3ItY29udGV4dCc7XG5cbmNvbnN0IEVNQkVEX1ZJREVPX1dJRFRIID0gNTYwO1xuY29uc3QgRU1CRURfVklERU9fSEVJR0hUID0gMzE1O1xuXG4vKipcbiAqIEFsbG95RWRpdG9yIG1haW4gY2xhc3MuIENyZWF0ZXMgaW5zdGFuY2Ugb2YgdGhlIGVkaXRvciBhbmQgcHJvdmlkZXMgdGhlIHVzZXIgY29uZmlndXJhdGlvblxuICogdG8gdGhlIFVJLlxuICpcbiAqIEBjbGFzcyBDb3JlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gdG8gYmUgdXNlZC5cbiAqL1xuZnVuY3Rpb24gQ29yZShjb25maWcpIHtcblx0Q29yZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgY29uZmlnKTtcbn1cblxuZXh0ZW5kKFxuXHRDb3JlLFxuXHRCYXNlLFxuXHR7XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZXIgbGlmZWN5Y2xlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgQWxsb3lFZGl0b3IgY2xhc3MuIENyZWF0ZXMgYSBDS0VkaXRvclxuXHRcdCAqIGluc3RhbmNlLCBwYXNzaW5nIGl0IHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uIGF0dHJpYnV0ZXMuXG5cdFx0ICpcblx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAbWV0aG9kIGluaXRpYWxpemVyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdCBsaXRlcmFsIGZvciB0aGUgZWRpdG9yLlxuXHRcdCAqL1xuXHRcdGluaXRpYWxpemVyKGNvbmZpZykge1xuXHRcdFx0Y29uc3Qgbm9kZSA9IHRoaXMuZ2V0KCdzcmNOb2RlJyk7XG5cblx0XHRcdGlmICh0aGlzLmdldCgnZW5hYmxlQ29udGVudEVkaXRhYmxlJykpIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICd0cnVlJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGVkaXRvciA9IENLRURJVE9SLmlubGluZShub2RlKTtcblxuXHRcdFx0ZWRpdG9yLmNvbmZpZy5hbGxvd2VkQ29udGVudCA9IHRoaXMuZ2V0KCdhbGxvd2VkQ29udGVudCcpO1xuXG5cdFx0XHRlZGl0b3IuY29uZmlnLnRvb2xiYXJzID0gdGhpcy5nZXQoJ3Rvb2xiYXJzJyk7XG5cblx0XHRcdGVkaXRvci5jb25maWcucmVtb3ZlUGx1Z2lucyA9IHRoaXMuZ2V0KCdyZW1vdmVQbHVnaW5zJyk7XG5cblx0XHRcdGVkaXRvci5jb25maWcuZXh0cmFQbHVnaW5zID0gdGhpcy5nZXQoJ2V4dHJhUGx1Z2lucycpO1xuXG5cdFx0XHRlZGl0b3IuY29uZmlnLmVtYmVkUHJvdmlkZXJzID0gdGhpcy5nZXQoJ2VtYmVkUHJvdmlkZXJzJyk7XG5cblx0XHRcdGVkaXRvci5jb25maWcucGxhY2Vob2xkZXJDbGFzcyA9IHRoaXMuZ2V0KCdwbGFjZWhvbGRlckNsYXNzJyk7XG5cblx0XHRcdGVkaXRvci5jb25maWcucGFzdGVGcm9tV29yZFJlbW92ZVN0eWxlcyA9IGZhbHNlO1xuXHRcdFx0ZWRpdG9yLmNvbmZpZy5wYXN0ZUZyb21Xb3JkUmVtb3ZlRm9udFN0eWxlcyA9IGZhbHNlO1xuXG5cdFx0XHRlZGl0b3IuY29uZmlnLnNlbGVjdGlvbktleXN0cm9rZXMgPSB0aGlzLmdldCgnc2VsZWN0aW9uS2V5c3Ryb2tlcycpO1xuXG5cdFx0XHRlZGl0b3IuY29uZmlnLnNwcml0ZW1hcCA9IHRoaXMuZ2V0KCdzcHJpdGVtYXAnKTtcblxuXHRcdFx0TGFuZy5taXgoZWRpdG9yLmNvbmZpZywgY29uZmlnKTtcblxuXHRcdFx0aWYgKENLRURJVE9SLmVudi5pZSAmJiAhQ0tFRElUT1IuZW52LmVkZ2UpIHtcblx0XHRcdFx0Y29uc3QgcGx1Z2luID0gJ2FlX2RyYWdyZXNpemVfaWUxMSc7XG5cblx0XHRcdFx0ZWRpdG9yLmNvbmZpZy5leHRyYVBsdWdpbnMgPSBlZGl0b3IuY29uZmlnLmV4dHJhUGx1Z2lucy5yZXBsYWNlKFxuXHRcdFx0XHRcdCdhZV9kcmFncmVzaXplJyxcblx0XHRcdFx0XHRwbHVnaW5cblx0XHRcdFx0KTtcblx0XHRcdFx0ZWRpdG9yLmNvbmZpZy5yZW1vdmVQbHVnaW5zID0gZWRpdG9yLmNvbmZpZy5yZW1vdmVQbHVnaW5zLnJlcGxhY2UoXG5cdFx0XHRcdFx0J2FlX2RyYWdyZXNpemUnLFxuXHRcdFx0XHRcdHBsdWdpblxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRlZGl0b3Iub25jZSgnY29udGVudERvbScsICgpID0+IHtcblx0XHRcdFx0dGhpcy5fYWRkUmVhZE9ubHlMaW5rQ2xpY2tMaXN0ZW5lcihlZGl0b3IpO1xuXG5cdFx0XHRcdGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdFx0Y29uc3QgZXh0cmFDb21tYW5kcyA9IHRoaXMuZ2V0KCdleHRyYUNvbW1hbmRzJyk7XG5cblx0XHRcdFx0Y29uc3QgZXh0cmFDb21tYW5kS2V5cyA9IE9iamVjdC5rZXlzKGV4dHJhQ29tbWFuZHMpO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGV4dHJhQ29tbWFuZEtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBjb21tYW5kTmFtZSA9IGV4dHJhQ29tbWFuZEtleXNbaV07XG5cblx0XHRcdFx0XHRpZiAoZWRpdG9yLmNvbW1hbmRzW2NvbW1hbmROYW1lXSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWRpdG9yLmFkZENvbW1hbmQoY29tbWFuZE5hbWUsIGV4dHJhQ29tbWFuZHNbY29tbWFuZE5hbWVdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVkaXRhYmxlLmFkZENsYXNzKCdhZS1lZGl0YWJsZScpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX2VkaXRvciA9IGVkaXRvcjtcblxuXHRcdFx0QWxsb3lFZGl0b3IubG9hZExhbmd1YWdlUmVzb3VyY2VzKHRoaXMuX3JlbmRlclVJLmJpbmQodGhpcykpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZXN0cnVjdG9yIGxpZmVjeWNsZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIEFsbG95RWR0b3IgY2xhc3MuIERlc3Ryb3lzIHRoZSBDS0VkaXRvclxuXHRcdCAqIGluc3RhbmNlIGFuZCBkZXN0cm95cyBhbGwgY3JlYXRlZCB0b29sYmFycy5cblx0XHQgKlxuXHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBtZXRob2QgZGVzdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGRlc3RydWN0b3IoKSB7XG5cdFx0XHR0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuXG5cdFx0XHRpZiAodGhpcy5fZWRpdG9yVUlFbGVtZW50KSB7XG5cdFx0XHRcdFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUodGhpcy5fZWRpdG9yVUlFbGVtZW50KTtcblx0XHRcdFx0dGhpcy5fZWRpdG9yVUlFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoXG5cdFx0XHRcdFx0dGhpcy5fZWRpdG9yVUlFbGVtZW50XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRoaXMuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0aWYgKG5hdGl2ZUVkaXRvcikge1xuXHRcdFx0XHRjb25zdCBlZGl0YWJsZSA9IG5hdGl2ZUVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRcdGlmIChlZGl0YWJsZSkge1xuXHRcdFx0XHRcdGVkaXRhYmxlLnJlbW92ZUNsYXNzKCdhZS1lZGl0YWJsZScpO1xuXG5cdFx0XHRcdFx0aWYgKHRoaXMuZ2V0KCdlbmFibGVDb250ZW50RWRpdGFibGUnKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5nZXQoJ3NyY05vZGUnKS5zZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0XHRcdCdjb250ZW50ZWRpdGFibGUnLFxuXHRcdFx0XHRcdFx0XHQnZmFsc2UnXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2NsZWFyU2VsZWN0aW9ucygpO1xuXG5cdFx0XHRcdG5hdGl2ZUVkaXRvci5kZXN0cm95KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENsZWFyIHNlbGVjdGlvbnMgZnJvbSB3aW5kb3cgb2JqZWN0XG5cdFx0ICpcblx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAbWV0aG9kIF9jbGVhclNlbGVjdGlvbnNcblx0XHQgKi9cblx0XHRfY2xlYXJTZWxlY3Rpb25zKCkge1xuXHRcdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gdGhpcy5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdFx0Y29uc3QgaXNNU1NlbGVjdGlvbiA9IHR5cGVvZiB3aW5kb3cuZ2V0U2VsZWN0aW9uICE9ICdmdW5jdGlvbic7XG5cblx0XHRcdGlmIChuYXRpdmVFZGl0b3IuZG9jdW1lbnQpIHtcblx0XHRcdFx0aWYgKGlzTVNTZWxlY3Rpb24pIHtcblx0XHRcdFx0XHRuYXRpdmVFZGl0b3IuZG9jdW1lbnQuJC5zZWxlY3Rpb24uZW1wdHkoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuYXRpdmVFZGl0b3IuZG9jdW1lbnRcblx0XHRcdFx0XHRcdC5nZXRXaW5kb3coKVxuXHRcdFx0XHRcdFx0LiQuZ2V0U2VsZWN0aW9uKClcblx0XHRcdFx0XHRcdC5yZW1vdmVBbGxSYW5nZXMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBNZXRob2QgdG8gc2V0IGRlZmF1bHQgbGluayBiZWhhdmlvclxuXHRcdCAqXG5cdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQG1ldGhvZCBfYWRkUmVhZE9ubHlMaW5rQ2xpY2tMaXN0ZW5lclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3Jcblx0XHQgKi9cblx0XHRfYWRkUmVhZE9ubHlMaW5rQ2xpY2tMaXN0ZW5lcihlZGl0b3IpIHtcblx0XHRcdGVkaXRvci5lZGl0YWJsZSgpLm9uKCdjbGljaycsIHRoaXMuX2RlZmF1bHRSZWFkT25seUNsaWNrRm4sIHRoaXMsIHtcblx0XHRcdFx0ZWRpdG9yLFxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENhbGxlZCBvbiBgY2xpY2tgIGV2ZW50IHdoZW4gdGhlIGVkaXRvciBpcyBpbiByZWFkIG9ubHkgbW9kZS4gTmF2aWdhdGVzIHRvIGxpbmsncyBVUkwgb3Igb3BlbnNcblx0XHQgKiB0aGUgbGluayBpbiBhIG5ldyB3aW5kb3cuXG5cdFx0ICpcblx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBldmVudCByZWFkT25seUNsaWNrXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBtZXRob2QgX2RlZmF1bHRSZWFkT25seUNsaWNrRm5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIGZpcmVkIGBjbGlja2AgZXZlbnQgcGF5bG9hZFxuXHRcdCAqL1xuXHRcdF9kZWZhdWx0UmVhZE9ubHlDbGlja0ZuKGV2ZW50KSB7XG5cdFx0XHRjb25zdCBtb3VzZUV2ZW50ID0gZXZlbnQuZGF0YS4kO1xuXHRcdFx0Y29uc3QgaGFzQ3RybEtleSA9IG1vdXNlRXZlbnQuY3RybEtleSB8fCBtb3VzZUV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRjb25zdCBzaG91bGRPcGVuID0gdGhpcy5fZWRpdG9yLmNvbmZpZy5yZWFkT25seSB8fCBoYXNDdHJsS2V5O1xuXG5cdFx0XHRtb3VzZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdGlmICghc2hvdWxkT3Blbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0ZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvclxuXHRcdFx0XHRcdC5lZGl0YWJsZSgpXG5cdFx0XHRcdFx0LmVkaXRvci5maXJlKCdyZWFkT25seUNsaWNrJywgZXZlbnQuZGF0YSkgIT09IGZhbHNlXG5cdFx0XHQpIHtcblx0XHRcdFx0Y29uc3QgY2tFbGVtZW50ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50UGF0aChcblx0XHRcdFx0XHRldmVudC5kYXRhLmdldFRhcmdldCgpLFxuXHRcdFx0XHRcdHRoaXNcblx0XHRcdFx0KTtcblx0XHRcdFx0Y29uc3QgbGluayA9IGNrRWxlbWVudC5sYXN0RWxlbWVudDtcblxuXHRcdFx0XHRpZiAobGluaykge1xuXHRcdFx0XHRcdGNvbnN0IGhyZWYgPSBsaW5rLiQuYXR0cmlidXRlcy5ocmVmXG5cdFx0XHRcdFx0XHQ/IGxpbmsuJC5hdHRyaWJ1dGVzLmhyZWYudmFsdWVcblx0XHRcdFx0XHRcdDogbnVsbDtcblx0XHRcdFx0XHRjb25zdCB0YXJnZXQgPSBoYXNDdHJsS2V5XG5cdFx0XHRcdFx0XHQ/ICdfYmxhbmsnXG5cdFx0XHRcdFx0XHQ6IGxpbmsuJC5hdHRyaWJ1dGVzLnRhcmdldFxuXHRcdFx0XHRcdFx0PyBsaW5rLiQuYXR0cmlidXRlcy50YXJnZXQudmFsdWVcblx0XHRcdFx0XHRcdDogbnVsbDtcblx0XHRcdFx0XHR0aGlzLl9yZWRpcmVjdExpbmsoaHJlZiwgdGFyZ2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXRyaWV2ZXMgdGhlIG5hdGl2ZSBDS0VkaXRvciBpbnN0YW5jZS4gSGF2aW5nIHRoaXMsIHRoZSBkZXZlbG9wZXIgbWF5IHVzZSB0aGUgQVBJIG9mIENLRWRpdG9yIE9PVEIuXG5cdFx0ICpcblx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAbWV0aG9kIF9nZXROYXRpdmVFZGl0b3Jcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIG9mIENLRWRpdG9yLlxuXHRcdCAqL1xuXHRcdF9nZXROYXRpdmVFZGl0b3IoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZWRpdG9yO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZWRpcmVjdHMgdGhlIGJyb3dzZXIgdG8gYSBnaXZlbiBsaW5rXG5cdFx0ICpcblx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAbWV0aG9kIF9yZWRpcmVjdExpbmtcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gaHJlZiBUaGUgaHJlZiB0byB0YWtlIHRoZSBicm93c2VyIHRvXG5cdFx0ICogQHBhcmFtIHtzdHJpbmc9fSB0YXJnZXQgU3BlY2lmaWVzIHdoZXJlIHRvIGRpc3BsYXkgdGhlIGxpbmtcblx0XHQgKi9cblx0XHRfcmVkaXJlY3RMaW5rKGhyZWYsIHRhcmdldCkge1xuXHRcdFx0aWYgKHRhcmdldCAmJiBocmVmKSB7XG5cdFx0XHRcdHdpbmRvdy5vcGVuKGhyZWYsIHRhcmdldCk7XG5cdFx0XHR9IGVsc2UgaWYgKGhyZWYpIHtcblx0XHRcdFx0d2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW5kZXJzIHRoZSBzcGVjaWZpZWQgZnJvbSB0aGUgdXNlciB0b29sYmFycy5cblx0XHQgKlxuXHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBtZXRob2QgX3JlbmRlclVJXG5cdFx0ICovXG5cdFx0X3JlbmRlclVJKCkge1xuXHRcdFx0aWYgKCF0aGlzLl9kZXN0cm95ZWQpIHtcblx0XHRcdFx0Y29uc3QgZWRpdG9yVUlFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRcdGVkaXRvclVJRWxlbWVudC5jbGFzc05hbWUgPSAnYWUtdWknO1xuXG5cdFx0XHRcdGNvbnN0IHVpTm9kZSA9IHRoaXMuZ2V0KCd1aU5vZGUnKSB8fCBkb2N1bWVudC5ib2R5O1xuXG5cdFx0XHRcdHVpTm9kZS5hcHBlbmRDaGlsZChlZGl0b3JVSUVsZW1lbnQpO1xuXG5cdFx0XHRcdGNvbnN0IGNhbGxiYWNrUmVmID0gZWxlbWVudCA9PiB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLl9tYWluVUkgJiYgZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fbWFpblVJID0gZWxlbWVudDtcblx0XHRcdFx0XHRcdHRoaXMuZ2V0KCduYXRpdmVFZGl0b3InKS5maXJlKCd1aVJlYWR5Jyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdFJlYWN0RE9NLnJlbmRlcihcblx0XHRcdFx0XHQ8RWRpdG9yQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17e2VkaXRvcjogdGhpc319PlxuXHRcdFx0XHRcdFx0PFVJXG5cdFx0XHRcdFx0XHRcdGV2ZW50c0RlbGF5PXt0aGlzLmdldCgnZXZlbnRzRGVsYXknKX1cblx0XHRcdFx0XHRcdFx0cmVmPXtjYWxsYmFja1JlZn1cblx0XHRcdFx0XHRcdFx0dG9vbGJhcnM9e3RoaXMuZ2V0KCd0b29sYmFycycpfVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8L0VkaXRvckNvbnRleHQuUHJvdmlkZXI+LFxuXHRcdFx0XHRcdGVkaXRvclVJRWxlbWVudFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdHRoaXMuX2VkaXRvclVJRWxlbWVudCA9IGVkaXRvclVJRWxlbWVudDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYW4gSFRNTCBlbGVtZW50IGZyb20gdGhlIHBhc3NlZCB2YWx1ZS4gSWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIHN0cmluZywgaXQgc2hvdWxkIGJlXG5cdFx0ICogdGhlIElkIG9mIHRoZSBlbGVtZW50IHdoaWNoIGhhdmUgdG8gYmUgcmV0cmlldmVkIGZyb20gdGhlIERPTS5cblx0XHQgKiBJZiBhbiBIVE1MIEVsZW1lbnQgaXMgcGFzc2VkLCB0aGUgZWxlbWVudCBpdHNlbGYgd2lsbCBiZSByZXR1cm5lZC5cblx0XHQgKlxuXHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1ldGhvZCBfdG9FbGVtZW50XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBwYXJhbSB7IShTdHJpbmd8SFRNTEVsZW1lbnQpfSB2YWx1ZSBTdHJpbmcsIHdoaWNoIGhhdmUgdG8gY29ycmVzcG9uZCB0byBhbiBIVE1MIGVsZW1lbnQgZnJvbSB0aGUgRE9NLFxuXHRcdCAqIG9yIHRoZSBIVE1MIGVsZW1lbnQgaXRzZWxmLiBJZiBJZCBpcyBwYXNzZWQsIHRoZSBIVE1MIGVsZW1lbnQgd2lsbCBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgRE9NLlxuXHRcdCAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBBbiBIVE1MIGVsZW1lbnQuXG5cdFx0ICovXG5cdFx0X3RvRWxlbWVudCh2YWx1ZSkge1xuXHRcdFx0aWYgKExhbmcuaXNTdHJpbmcodmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFZhbGlkYXRlcyB0aGUgYWxsb3dlZCBjb250ZW50IGF0dHJpYnV0ZS4gTG9va1xuXHRcdCAqIFtoZXJlXShodHRwOi8vZG9jcy5ja2VkaXRvci5jb20vIyEvYXBpL0NLRURJVE9SLmNvbmZpZy1jZmctYWxsb3dlZENvbnRlbnQpIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuXHRcdCAqIHN1cHBvcnRlZCB2YWx1ZXMuXG5cdFx0ICpcblx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAbWV0aG9kIF92YWxpZGF0ZUFsbG93ZWRDb250ZW50XG5cdFx0ICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgY3VycmVudCB2YWx1ZSBpcyB2YWxpZCBjb25maWd1cmF0aW9uLCBmYWxzZSBvdGhlcndpc2Vcblx0XHQgKi9cblx0XHRfdmFsaWRhdGVBbGxvd2VkQ29udGVudCh2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0TGFuZy5pc1N0cmluZyh2YWx1ZSkgfHxcblx0XHRcdFx0TGFuZy5pc09iamVjdCh2YWx1ZSkgfHxcblx0XHRcdFx0TGFuZy5pc0Jvb2xlYW4odmFsdWUpXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBWYWxpZGF0ZXMgdGhlIHZhbHVlIG9mIHRvb2xiYXJzIGF0dHJpYnV0ZVxuXHRcdCAqXG5cdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQG1ldGhvZCBfdmFsaWRhdGVUb29sYmFyc1xuXHRcdCAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZFxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIGN1cnJlbnQgdmFsdWUgaXMgdmFsaWQgdG9vbGJhcnMgY29uZmlndXJhdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlXG5cdFx0ICovXG5cdFx0X3ZhbGlkYXRlVG9vbGJhcnModmFsdWUpIHtcblx0XHRcdHJldHVybiBMYW5nLmlzT2JqZWN0KHZhbHVlKSB8fCBMYW5nLmlzTnVsbCh2YWx1ZSk7XG5cdFx0fSxcblx0fSxcblx0e1xuXHRcdEFUVFJTOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIENvbmZpZ3VyZXMgdGhlIGFsbG93ZWQgY29udGVudCBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgQWxsb3lFZGl0b3IuXG5cdFx0XHQgKiBMb29rIG9uIHRoZSBbb2ZmaWNpYWwgQ0tFZGl0b3IgQVBJXShodHRwOi8vZG9jcy5ja2VkaXRvci5jb20vIyEvYXBpL0NLRURJVE9SLmNvbmZpZy1jZmctYWxsb3dlZENvbnRlbnQpXG5cdFx0XHQgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdmFsaWQgdmFsdWVzLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSBhbGxvd2VkQ29udGVudFxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQHdyaXRlT25jZVxuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW4sIFN0cmluZywgT2JqZWN0fVxuXHRcdFx0ICovXG5cdFx0XHRhbGxvd2VkQ29udGVudDoge1xuXHRcdFx0XHR2YWxpZGF0b3I6ICdfdmFsaWRhdGVBbGxvd2VkQ29udGVudCcsXG5cdFx0XHRcdHZhbHVlOiB0cnVlLFxuXHRcdFx0XHR3cml0ZU9uY2U6IHRydWUsXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBjbGlja2luZyBvbiB0aGVcblx0XHRcdCAqIDxjb2RlPnNyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWxpbmstZWRpdC1icm93c2UuanN4PC9jb2RlPlxuXHRcdFx0ICogY29tcG9uZW50LlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXR5IGRvY3VtZW50QnJvd3NlTGlua0NhbGxiYWNrXG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbnx1bmRlZmluZWR9XG5cdFx0XHQgKi9cblx0XHRcdGRvY3VtZW50QnJvd3NlTGlua0NhbGxiYWNrOiB7XG5cdFx0XHRcdHZhbGlkYXRvcjogTGFuZy5pc0Z1bmN0aW9uLFxuXHRcdFx0XHR2YWx1ZTogdW5kZWZpbmVkLFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDb25maWd1cmF0aW9uIGZvciB0aGVcblx0XHRcdCAqIDxjb2RlPnNyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWxpbmstZWRpdC1icm93c2UuanN4PC9jb2RlPlxuXHRcdFx0ICogY29tcG9uZW50LlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXR5IGRvY3VtZW50QnJvd3NlTGlua1VybFxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfHVuZGVmaW5lZH1cblx0XHRcdCAqL1xuXHRcdFx0ZG9jdW1lbnRCcm93c2VMaW5rVXJsOiB7XG5cdFx0XHRcdHZhbGlkYXRvcjogTGFuZy5pc1N0cmluZyxcblx0XHRcdFx0dmFsdWU6IHVuZGVmaW5lZCxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogTGlzdCBvZiBlbWJlZCBwcm92aWRlcnMgZm9yIHZpZGVvc1xuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSBlbWJlZFByb3ZpZGVyc1xuXHRcdFx0ICogQGRlZmF1bHQgW11cblx0XHRcdCAqIEB0eXBlIEFycmF5fVxuXHRcdFx0ICovXG5cdFx0XHRlbWJlZFByb3ZpZGVyczoge1xuXHRcdFx0XHR2YWxpZGF0b3I6IExhbmcuaXNBcnJheSxcblx0XHRcdFx0dmFsdWU6IFtcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZDogJ2ZhY2Vib29rJyxcblx0XHRcdFx0XHRcdHRwbDogYDxpZnJhbWUgYWxsb3dGdWxsU2NyZWVuPVwidHJ1ZVwiIGFsbG93VHJhbnNwYXJlbmN5PVwidHJ1ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgZnJhbWVib3JkZXI9XCIwXCIgaGVpZ2h0PVwiJHtFTUJFRF9WSURFT19IRUlHSFR9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBzcmM9XCJodHRwczovL3d3dy5mYWNlYm9vay5jb20vcGx1Z2lucy92aWRlby5waHA/aHJlZj17ZW1iZWRJZH0nXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgJnNob3dfdGV4dD0wJndpZHRoPSR7RU1CRURfVklERU9fV0lEVEh9JmhlaWdodD0ke0VNQkVEX1ZJREVPX0hFSUdIVH1cIiBzY3JvbGxpbmc9XCJub1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgc3R5bGU9XCJib3JkZXI6bm9uZTtvdmVyZmxvdzpoaWRkZW5cIiB3aWR0aD1cIiR7RU1CRURfVklERU9fV0lEVEh9fVwiPjwvaWZyYW1lPmAsXG5cdFx0XHRcdFx0XHR0eXBlOiAndmlkZW8nLFxuXHRcdFx0XHRcdFx0dXJsU2NoZW1lczogW1xuXHRcdFx0XHRcdFx0XHQnKGh0dHBzPzpcXFxcL1xcXFwvKD86d3d3XFxcXC4pP2ZhY2Vib29rLmNvbVxcXFwvXFxcXFMqXFxcXC92aWRlb3NcXFxcL1xcXFxTKiknLFxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlkOiAndHdpdGNoJyxcblx0XHRcdFx0XHRcdHRwbDogYDxpZnJhbWUgYWxsb3dmdWxsc2NyZWVuPVwidHJ1ZVwiIGZyYW1lYm9yZGVyPVwiMFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgaGVpZ2h0PVwiJHtFTUJFRF9WSURFT19IRUlHSFR9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBzcmM9XCJodHRwczovL3BsYXllci50d2l0Y2gudHYvP2F1dG9wbGF5PWZhbHNlJnZpZGVvPXtlbWJlZElkfVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgc2Nyb2xsaW5nPVwibm9cIiB3aWR0aD1cIiR7RU1CRURfVklERU9fV0lEVEh9XCI+PC9pZnJhbWU+YCxcblx0XHRcdFx0XHRcdHR5cGU6ICd2aWRlbycsXG5cdFx0XHRcdFx0XHR1cmxTY2hlbWVzOiBbXG5cdFx0XHRcdFx0XHRcdCdodHRwcz86XFxcXC9cXFxcLyg/Ond3d1xcXFwuKT90d2l0Y2gudHZcXFxcL3ZpZGVvc1xcXFwvKFxcXFxTKikkJyxcblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZDogJ3ZpbWVvJyxcblx0XHRcdFx0XHRcdHRwbDogYDxpZnJhbWUgYWxsb3dmdWxsc2NyZWVuIGZyYW1lYm9yZGVyPVwiMFwiIGhlaWdodD1cIiR7RU1CRURfVklERU9fSEVJR0hUfVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgbW96YWxsb3dmdWxsc2NyZWVuIHNyYz1cImh0dHBzOi8vcGxheWVyLnZpbWVvLmNvbS92aWRlby97ZW1iZWRJZH1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0IHdlYmtpdGFsbG93ZnVsbHNjcmVlbiB3aWR0aD1cIiR7RU1CRURfVklERU9fV0lEVEh9XCI+PC9pZnJhbWU+YCxcblx0XHRcdFx0XHRcdHR5cGU6ICd2aWRlbycsXG5cdFx0XHRcdFx0XHR1cmxTY2hlbWVzOiBbXG5cdFx0XHRcdFx0XHRcdCdodHRwcz86XFxcXC9cXFxcLyg/Ond3d1xcXFwuKT92aW1lb1xcXFwuY29tXFxcXC9hbGJ1bVxcXFwvLipcXFxcL3ZpZGVvXFxcXC8oXFxcXFMqKScsXG5cdFx0XHRcdFx0XHRcdCdodHRwcz86XFxcXC9cXFxcLyg/Ond3d1xcXFwuKT92aW1lb1xcXFwuY29tXFxcXC9jaGFubmVsc1xcXFwvLipcXFxcLyhcXFxcUyopJyxcblx0XHRcdFx0XHRcdFx0J2h0dHBzPzpcXFxcL1xcXFwvKD86d3d3XFxcXC4pP3ZpbWVvXFxcXC5jb21cXFxcL2dyb3Vwc1xcXFwvLipcXFxcL3ZpZGVvc1xcXFwvKFxcXFxTKiknLFxuXHRcdFx0XHRcdFx0XHQnaHR0cHM/OlxcXFwvXFxcXC8oPzp3d3dcXFxcLik/dmltZW9cXFxcLmNvbVxcXFwvKFxcXFxTKikkJyxcblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZDogJ3lvdXR1YmUnLFxuXHRcdFx0XHRcdFx0dHBsOiBgPGlmcmFtZSBhbGxvdz1cImF1dG9wbGF5OyBlbmNyeXB0ZWQtbWVkaWFcIiBhbGxvd2Z1bGxzY3JlZW5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBoZWlnaHQ9XCIke0VNQkVEX1ZJREVPX0hFSUdIVH1cIiBmcmFtZWJvcmRlcj1cIjBcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0IHNyYz1cImh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkL3tlbWJlZElkfT9yZWw9MFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgd2lkdGg9XCIke0VNQkVEX1ZJREVPX1dJRFRIfVwiPjwvaWZyYW1lPmAsXG5cdFx0XHRcdFx0XHR0eXBlOiAndmlkZW8nLFxuXHRcdFx0XHRcdFx0dXJsU2NoZW1lczogW1xuXHRcdFx0XHRcdFx0XHQnaHR0cHM/OlxcXFwvXFxcXC8oPzp3d3dcXFxcLik/eW91dHViZS5jb21cXFxcL3dhdGNoXFxcXD92PShcXFxcUyopJCcsXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdF0sXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNwZWNpZmllcyB3aGV0aGVyIEFsbG95RWRpdG9yIHNldCB0aGUgY29udGVudGVkaXRhYmxlIGF0dHJpYnV0ZVxuXHRcdFx0ICogdG8gXCJ0cnVlXCIgb24gaXRzIHNyY05vZGUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BlcnR5IGVuYWJsZUNvbnRlbnRFZGl0YWJsZVxuXHRcdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdFx0ICogQHdyaXRlT25jZVxuXHRcdFx0ICovXG5cdFx0XHRlbmFibGVDb250ZW50RWRpdGFibGU6IHtcblx0XHRcdFx0dmFsaWRhdG9yOiBMYW5nLmlzQm9vbGVhbixcblx0XHRcdFx0dmFsdWU6IHRydWUsXG5cdFx0XHRcdHdyaXRlT25jZTogdHJ1ZSxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIGRlbGF5ICh0aW1lb3V0KSwgaW4gbXMsIGFmdGVyIHdoaWNoIGV2ZW50cyBzdWNoIGxpa2Uga2V5IG9yIG1vdXNlIGV2ZW50cyB3aWxsIGJlIHByb2Nlc3NlZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGVydHkgZXZlbnRzRGVsYXlcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0XHRcdGV2ZW50c0RlbGF5OiB7XG5cdFx0XHRcdHZhbGlkYXRvcjogTGFuZy5pc051bWJlcixcblx0XHRcdFx0dmFsdWU6IDEwMCxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIGxpc3Qgb2YgZXh0cmEgY29tbWFuZHMgdG8gYmUgYWRkZWQgdG8gdGhlIGVkaXRvci5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGVydHkgZXh0cmFDb21tYW5kc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqL1xuXHRcdFx0ZXh0cmFDb21tYW5kczoge1xuXHRcdFx0XHR2YWxpZGF0b3I6IExhbmcuaXNPYmplY3QsXG5cdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0cmVtb3ZlSW1hZ2U6IHJlbW92ZUltYWdlQ29tbWFuZCxcblx0XHRcdFx0fSxcblx0XHRcdFx0d3JpdGVPbmNlOiB0cnVlLFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTcGVjaWZpZXMgdGhlIGV4dHJhIHBsdWdpbnMgd2hpY2ggaGF2ZSB0byBiZSBsb2FkZWQgdG8gdGhlIGN1cnJlbnQgQ0tFZGl0b3IgaW5zdGFuY2UgaW4gb3JkZXIgdG9cblx0XHRcdCAqIG1ha2UgQWxsb3lFZGl0b3IgdG8gd29yayBwcm9wZXJseS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGVydHkgZXh0cmFQbHVnaW5zXG5cdFx0XHQgKiBAZGVmYXVsdCAndWljb3JlLHNlbGVjdGlvbnJlZ2lvbixkcmFncmVzaXplLGFkZGltYWdlcyxwbGFjZWhvbGRlcix0YWJsZXRvb2xzLHRhYmxlcmVzaXplLGF1dG9saW5rJ1xuXHRcdFx0ICogQHdyaXRlT25jZVxuXHRcdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHRcdCAqL1xuXHRcdFx0ZXh0cmFQbHVnaW5zOiB7XG5cdFx0XHRcdHZhbGlkYXRvcjogTGFuZy5pc1N0cmluZyxcblx0XHRcdFx0dmFsdWU6XG5cdFx0XHRcdFx0J2FlX3VpY29yZSxhZV9zZWxlY3Rpb25yZWdpb24sYWVfc2VsZWN0aW9ua2V5c3Ryb2tlcyxhZV9pbWFnZWFsaWdubWVudCxhZV9hZGRpbWFnZXMsYWVfcGxhY2Vob2xkZXIsJyArXG5cdFx0XHRcdFx0J2FlX3RhYmxldG9vbHMsYWVfdGFibGVyZXNpemUsYWVfYXV0b2xpbmssYWVfZW1iZWQsYWVfYXV0b2xpc3QsYWVfZHJhZ3Jlc2l6ZSwnICtcblx0XHRcdFx0XHQnYWVfdWlicmlkZ2UsYWVfcmljaGNvbWJvYnJpZGdlLGFlX3BhbmVsbWVudWJ1dHRvbmJyaWRnZSxhZV9tZW51YnJpZGdlLGFlX21lbnVidXR0b25icmlkZ2UsYWVfYnV0dG9uYnJpZGdlLGZvbnQsY29sb3JidXR0b24nLFxuXHRcdFx0XHR3cml0ZU9uY2U6IHRydWUsXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNwZWNpZmllcyB0aGUgXCJtb2RlXCIgZm9yIGFsbG95IGVkaXRvclxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BlcnR5IG1vZGVcblx0XHRcdCAqIEBkZWZhdWx0ICdzaW1wbGUnXG5cdFx0XHQgKiBAd3JpdGVPbmNlXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICovXG5cdFx0XHRtb2RlOiB7XG5cdFx0XHRcdHZhbGlkYXRvcjogTGFuZy5pc1N0cmluZyxcblx0XHRcdFx0dmFsdWU6ICdzaW1wbGUnLFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXRyaWV2ZXMgdGhlIG5hdGl2ZSBDS0VkaXRvciBpbnN0YW5jZS4gSGF2aW5nIHRoaXMsIHRoZSBkZXZlbG9wZXIgbWF5IHVzZSB0aGUgZnVsbCBBUEkgb2YgQ0tFZGl0b3IuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BlcnR5IG5hdGl2ZUVkaXRvclxuXHRcdFx0ICogQHJlYWRPbmx5XG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICovXG5cdFx0XHRuYXRpdmVFZGl0b3I6IHtcblx0XHRcdFx0Z2V0dGVyOiAnX2dldE5hdGl2ZUVkaXRvcicsXG5cdFx0XHRcdHJlYWRPbmx5OiB0cnVlLFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTcGVjaWZpZXMgdGhlIGNsYXNzLCB3aGljaCBzaG91bGQgYmUgYWRkZWQgYnkgUGxhY2Vob2xkZXIgcGx1Z2luXG5cdFx0XHQgKiB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3BsYWNlaG9sZGVyfX17ey9jcm9zc0xpbmt9fVxuXHRcdFx0ICogd2hlbiBlZGl0b3IgaXMgbm90IGZvY3VzZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BlcnR5IHBsYWNlaG9sZGVyQ2xhc3Ncblx0XHRcdCAqIEBkZWZhdWx0ICdhZS1wbGFjZWhvbGRlcidcblx0XHRcdCAqIEB3cml0ZU9uY2Vcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKi9cblx0XHRcdHBsYWNlaG9sZGVyQ2xhc3M6IHtcblx0XHRcdFx0dmFsaWRhdG9yOiBMYW5nLmlzU3RyaW5nLFxuXHRcdFx0XHR2YWx1ZTogJ2FlLXBsYWNlaG9sZGVyJyxcblx0XHRcdFx0d3JpdGVPbmNlOiB0cnVlLFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTcGVjaWZpZXMgdGhlIHBsdWdpbnMsIHdoaWNoIGNvbWUgYnkgZGVmYXVsdCB3aXRoIENLRWRpdG9yLCBidXQgd2hpY2ggYXJlIG5vdCBuZWVkZWQgYnkgQWxsb3lFZGl0b3IuXG5cdFx0XHQgKiBUaGVzZSBwbHVnaW5zIGFkZCB0aGUgZGVmYXVsdCBVSSBmb3IgQ0tlZGl0b3IsIHdoaWNoIGlzIG5vIG1vcmUgbmVlZGVkLiBQbGVhc2Ugbm90ZSB0aGF0IEFsbG95RWR0b3Jcblx0XHRcdCAqIGNvbWVzIHdpdGggaXRzIG93biBoaWdobHkgb3B0aW1pemVkIGNvcHkgb2YgQ0tFZGl0b3IgKGp1c3QgY3VzdG9taXplZCB2aWEgdGhlaXIgb2ZmaWNpYWwgZG93bmxvYWQgcGFnZSkuXG5cdFx0XHQgKiBUaGlzIHZlcnNpb24gZG9lcyBub3QgY29tZSB3aXRoIHRoZSB1bm5lZWRlZCBwbHVnaW5zLCBzbyB0aGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSB3b24ndCBiZSBuZWVkZWQuXG5cdFx0XHQgKiBIb3dldmVyLCBpZiB5b3UgZGVjaWRlIHRvIGdvIHdpdGggdGhlIE9PVEIgdmVyc2lvbiBvZiBDS0VkaXRvciwgeW91IHdpbGwgaGF2ZSB0byByZW1vdmUgc29tZSBvZiB0aGVcblx0XHRcdCAqIHBsdWdpbnMgaWYgeW91IGRlY2lkZSB0byB1c2UgQWxsb3lFZGl0b3IuIEtlZXAgaW4gbWluZCB0aGF0IHJlbW92aW5nIHRoZXNlIHBsdWdpbnMgZG9lc24ndCByZW1vdmUgdGhlbVxuXHRcdFx0ICogZW50aXJlbHkgZnJvbSBDS0VkaXRvci4gSXQganVzdCByZW1vdmVzIHRoZW0gZnJvbSBpdHMgY3VycmVudCBpbnN0YW5jZSwgaW4gd2hpY2ggeW91IHdpbGwgdXNlIGRpZmZlcmVudFxuXHRcdFx0ICogVUkgLSB0aG9zZSBvZiBBbGxveUVkaXRvci4gWW91IHdpbGwgYmUgZnVsbHkgYWJsZSB0byB1c2UgYm90aCBPT1RCIENLRWRpdG9yIGFuZCBBbGxveUVkaXRvciBvbiB0aGUgc2FtZVxuXHRcdFx0ICogcGFnZSFcblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGVydHkgcmVtb3ZlUGx1Z2luc1xuXHRcdFx0ICogQGRlZmF1bHQgJ2NvbnRleHRtZW51LHRvb2xiYXIsZWxlbWVudHNwYXRoLHJlc2l6ZSxsaXN0c3R5bGUsbGluaydcblx0XHRcdCAqIEB3cml0ZU9uY2Vcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKi9cblx0XHRcdHJlbW92ZVBsdWdpbnM6IHtcblx0XHRcdFx0dmFsaWRhdG9yOiBMYW5nLmlzU3RyaW5nLFxuXHRcdFx0XHR2YWx1ZTogJ2NvbnRleHRtZW51LHRvb2xiYXIsZWxlbWVudHNwYXRoLHJlc2l6ZSxsaXN0c3R5bGUsbGluaycsXG5cdFx0XHRcdHdyaXRlT25jZTogdHJ1ZSxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQXJyYXkgb2YgbWFudWFsIHNlbGVjdGlvbiB0cmlnZ2Vycy4gVGhleSBjYW4gYmUgY29uZmlndXJlZCB0byBtYW51YWxseSBzaG93IGEgc3BlY2lmaWMgc2VsZWN0aW9uIHRvb2xiYXJcblx0XHRcdCAqIGJ5IGZvcmNpbmcgdGhlIHNlbGVjdGlvbiB0eXBlLiBBIHNlbGVjdGlvbktleXN0cm9rZSBpdGVtIGNvbnNpc3RzIG9mIGEga2V5cyBwcm9wZXJ0eSB3aXRoIGEgW0NLRWRpdG9yIGtleXN0cm9rZVxuXHRcdFx0ICogZGVmaW5pdGlvbl0oaHR0cDovL2RvY3MuY2tlZGl0b3IuY29tLyMhL2FwaS9DS0VESVRPUi5jb25maWctY2ZnLWtleXN0cm9rZXMpIGFuZCBhIHNlbGVjdGlvbiBwcm9wZXJ0eSB3aXRoXG5cdFx0XHQgKiB0aGUgc2VsZWN0aW9uIG5hbWUgdG8gdHJpZ2dlci5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGVydHkgc2VsZWN0aW9uS2V5c3Ryb2tlc1xuXHRcdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdFx0ICovXG5cdFx0XHRzZWxlY3Rpb25LZXlzdHJva2VzOiB7XG5cdFx0XHRcdHZhbGlkYXRvcjogTGFuZy5pc0FycmF5LFxuXHRcdFx0XHR2YWx1ZTogW1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGtleXM6IENLRURJVE9SLkNUUkwgKyA3NiAvKiBMKi8sXG5cdFx0XHRcdFx0XHRzZWxlY3Rpb246ICdsaW5rJyxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGtleXM6IENLRURJVE9SLkNUUkwgKyBDS0VESVRPUi5TSElGVCArIDc2IC8qIEwqLyxcblx0XHRcdFx0XHRcdHNlbGVjdGlvbjogJ2VtYmVkJyxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRdLFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgcGF0aCB0byB0aGUgc3ByaXRlbWFwIFNWRyB1c2VkIGZvciBpY29uc1xuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSBzcHJpdGVtYXBcblx0XHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdFx0ICogQHdyaXRlT25jZVxuXHRcdFx0ICovXG5cdFx0XHRzcHJpdGVtYXA6IHtcblx0XHRcdFx0dmFsaWRhdG9yOiBMYW5nLmlzU3RyaW5nLFxuXHRcdFx0XHR2YWx1ZTpcblx0XHRcdFx0XHQod2luZG93LkFMTE9ZRURJVE9SX0JBU0VQQVRIIHx8ICdhbGxveS1lZGl0b3IvJykgK1xuXHRcdFx0XHRcdCdhc3NldHMvaWNvbnMvaWNvbnMuc3ZnJyxcblx0XHRcdFx0d3JpdGVPbmNlOiB0cnVlLFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgTm9kZSBJRCBvciBIVE1sIG5vZGUsIHdoaWNoIEFsbG95RWRpdG9yIHNob3VsZCB1c2UgYXMgYW4gZWRpdGFibGUgYXJlYS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGVydHkgc3JjTm9kZVxuXHRcdFx0ICogQHR5cGUgU3RyaW5nIHwgTm9kZVxuXHRcdFx0ICogQHdyaXRlT25jZVxuXHRcdFx0ICovXG5cdFx0XHRzcmNOb2RlOiB7XG5cdFx0XHRcdHNldHRlcjogJ190b0VsZW1lbnQnLFxuXHRcdFx0XHR3cml0ZU9uY2U6IHRydWUsXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSB0b29sYmFycyBjb25maWd1cmF0aW9uIGZvciB0aGlzIGVkaXRvciBpbnN0YW5jZVxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB0b29sYmFyc1xuXHRcdFx0ICovXG5cdFx0XHR0b29sYmFyczoge1xuXHRcdFx0XHR2YWxpZGF0b3I6ICdfdmFsaWRhdGVUb29sYmFycycsXG5cdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0YWRkOiB7XG5cdFx0XHRcdFx0XHRidXR0b25zOiBbXG5cdFx0XHRcdFx0XHRcdCdpbWFnZUZyb21GaWxlJyxcblx0XHRcdFx0XHRcdFx0J2VtYmVkJyxcblx0XHRcdFx0XHRcdFx0J2NhbWVyYScsXG5cdFx0XHRcdFx0XHRcdCdobGluZScsXG5cdFx0XHRcdFx0XHRcdCd0YWJsZScsXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdFx0dGFiSW5kZXg6IDIsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZXM6IHtcblx0XHRcdFx0XHRcdHNlbGVjdGlvbnM6IFNlbGVjdGlvbnMsXG5cdFx0XHRcdFx0XHR0YWJJbmRleDogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9LFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgTm9kZSBJRCBvciBIVE1sIG5vZGUsIHdoZXJlIEFsbG95RWRpdG9yJ3MgVUkgc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSB1aU5vZGVcblx0XHRcdCAqIEB0eXBlIFN0cmluZyB8IE5vZGVcblx0XHRcdCAqIEB3cml0ZU9uY2Vcblx0XHRcdCAqL1xuXHRcdFx0dWlOb2RlOiB7XG5cdFx0XHRcdHNldHRlcjogJ190b0VsZW1lbnQnLFxuXHRcdFx0XHR3cml0ZU9uY2U6IHRydWUsXG5cdFx0XHR9LFxuXHRcdH0sXG5cdH1cbik7XG5cbkNLRURJVE9SLmV2ZW50LmltcGxlbWVudE9uKENvcmUpO1xuXG5leHBvcnQgZGVmYXVsdCBDb3JlO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFJlYWN0IGNvbnRleHQgdG8gYXZvaWQgZXhwbGljaXRseSBwYXNzaW5nIHRoZSBlZGl0b3IgaW5zdGFuY2UgYWxsXG4gKiB0aHJvdWdoIHRoZSBjb21wb25lbnQgaGllcmFyY2h5IHZpYSBwcm9wcy5cbiAqL1xuY29uc3QgRWRpdG9yQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pO1xuXG4vKipcbiAqIEhlbHBlciB0aGF0IHBhc3NlcyB0aGUgZWRpdG9yIGNvbnRleHQgaW4gdmlhIGEgcHJvcC5cbiAqXG4gKiBDb250ZXh0IGNhbiBvbmx5IGJlIGFjY2Vzc2VkIGluIGByZW5kZXIoKWAgYW5kIGluIGxpZmVjeWNsZSBtZXRob2RzXG4gKiAoYGNvbXBvbmVudERpZE1vdW50KClgIGV0YykuIElmIGEgY29tcG9uZW50IG5lZWRzIHRvIGFjY2VzcyBjb250ZXh0XG4gKiBlbHNld2hlcmUsIHN1Y2ggYXMgaW4gYSBjb25zdHJ1Y3RvciwgdGhlIGNvbnRleHQgbmVlZHMgdG8gYmUgcGFzc2VkXG4gKiBpbiB2aWEgYSBwcm9wLlxuICovXG5FZGl0b3JDb250ZXh0LnRvUHJvcHMgPSBDb21wb25lbnQgPT4ge1xuXHRjb25zdCBmb3J3YXJkaW5nQ29tcG9uZW50ID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gKFxuXHRcdDxFZGl0b3JDb250ZXh0LkNvbnN1bWVyPlxuXHRcdFx0e2NvbnRleHQgPT4gPENvbXBvbmVudCB7Li4ucHJvcHN9IGNvbnRleHQ9e2NvbnRleHR9IHJlZj17cmVmfSAvPn1cblx0XHQ8L0VkaXRvckNvbnRleHQuQ29uc3VtZXI+XG5cdCkpO1xuXHRmb3J3YXJkaW5nQ29tcG9uZW50LmtleSA9IENvbXBvbmVudC5rZXk7XG5cblx0cmV0dXJuIGZvcndhcmRpbmdDb21wb25lbnQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFZGl0b3JDb250ZXh0O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgKiBhcyBCYXNlIGZyb20gJy4uL2NvbXBvbmVudHMvYmFzZSc7XG5pbXBvcnQgQnV0dG9ucyBmcm9tICcuLi9jb21wb25lbnRzL2J1dHRvbnMnO1xuaW1wb3J0ICogYXMgQ29tcGF0IGZyb20gJy4uL2NvbXBvbmVudHMvY29tcGF0JztcbmltcG9ydCBUb29sYmFycyBmcm9tICcuLi9jb21wb25lbnRzL3Rvb2xiYXJzJztcbmltcG9ydCBBdHRyaWJ1dGUgZnJvbSAnLi4vb29wL2F0dHJpYnV0ZSc7XG5pbXBvcnQgTGFuZyBmcm9tICcuLi9vb3AvbGFuZyc7XG5pbXBvcnQgZXh0ZW5kIGZyb20gJy4uL29vcC9vb3AnO1xuaW1wb3J0IFNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyBmcm9tICcuLi9zZWxlY3Rpb25zL3NlbGVjdGlvbi1hcnJvd2JveCc7XG5pbXBvcnQgU2VsZWN0aW9uU2V0UG9zaXRpb24gZnJvbSAnLi4vc2VsZWN0aW9ucy9zZWxlY3Rpb24tcG9zaXRpb24nO1xuaW1wb3J0IFNlbGVjdGlvblRlc3QgZnJvbSAnLi4vc2VsZWN0aW9ucy9zZWxlY3Rpb24tdGVzdCc7XG5pbXBvcnQgU2VsZWN0aW9ucyBmcm9tICcuLi9zZWxlY3Rpb25zL3NlbGVjdGlvbnMnO1xuaW1wb3J0IENvcmUgZnJvbSAnLi9jb3JlJztcblxuaW1wb3J0ICcuLi9wbHVnaW5zJztcblxuLy8gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGN1cnJlbnRseSByZWdpc3RlcmVkIHBsdWdpbnMgaW4gQWxsb3lFZGl0b3IuXG5cbmNvbnN0IEJSSURHRV9CVVRUT05TID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBBbGxveUVkaXRvci5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgZWRpdGFibGVcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7U3RyaW5nfE5vZGV9IG5vZGUgVGhlIE5vZGUgSUQgb3IgSFRNbCBub2RlLCB3aGljaCBBbGxveUVkaXRvciBzaG91bGQgdXNlIGFzIGFuIGVkaXRhYmxlIGFyZWEuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gYXR0cmlidXRlcyBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgQWxsb3lFZGl0b3IuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIGluc3RhbmNlIG9mIHt7I2Nyb3NzTGluayBcIkNvcmVcIn19e3svY3Jvc3NMaW5rfX1cbiAqL1xuY29uc3QgZWRpdGFibGUgPSBmdW5jdGlvbihub2RlLCBjb25maWcpIHtcblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXHRjb25maWcuc3JjTm9kZSA9IG5vZGU7XG5cblx0QWxsb3lFZGl0b3IuaW1wbGVtZW50RXZlbnRUYXJnZXQoKTtcblxuXHRyZXR1cm4gbmV3IENvcmUoY29uZmlnKTtcbn07XG5cbi8qKlxuICogVGhlIGZ1bGwgVVJMIGZvciB0aGUgQWxsb3lFZGl0b3IgaW5zdGFsbGF0aW9uIGRpcmVjdG9yeS5cbiAqIEl0IGlzIHBvc3NpYmxlIHRvIG1hbnVhbGx5IHByb3ZpZGUgdGhlIGJhc2UgcGF0aCBieSBzZXR0aW5nIGFcbiAqIGdsb2JhbCB2YXJpYWJsZSBuYW1lZCBgQUxMT1lFRElUT1JfQkFTRVBBVEhgLiBUaGlzIGdsb2JhbCB2YXJpYWJsZVxuICogbXVzdCBiZSBzZXQgKipiZWZvcmUqKiB0aGUgZWRpdG9yIHNjcmlwdCBsb2FkaW5nLlxuICpcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICogQG1ldGhvZCBnZXRCYXNlUGF0aFxuICogQHN0YXRpY1xuICogQHJldHVybiB7U3RyaW5nfSBUaGUgZm91bmQgYmFzZSBwYXRoXG4gKi9cbmNvbnN0IGdldEJhc2VQYXRoID0gZnVuY3Rpb24oKSB7XG5cdC8vIEZpbmQgb3V0IHRoZSBlZGl0b3IgZGlyZWN0b3J5IHBhdGgsIGJhc2VkIG9uIGl0cyA8c2NyaXB0PiB0YWcuXG5cblx0bGV0IHBhdGggPSB3aW5kb3cuQUxMT1lFRElUT1JfQkFTRVBBVEggfHwgJyc7XG5cblx0aWYgKCFwYXRoKSB7XG5cdFx0Y29uc3Qgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBzY3JpcHRzW2ldLnNyYy5tYXRjaChBbGxveUVkaXRvci5yZWdleEJhc2VQYXRoKTtcblxuXHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdHBhdGggPSBtYXRjaFsxXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gSW4gSUUgKG9ubHkpIHRoZSBzY3JpcHQuc3JjIHN0cmluZyBpcyB0aGUgcmF3IHZhbHVlIGVudGVyZWQgaW4gdGhlXG5cdC8vIEhUTUwgc291cmNlLiBPdGhlciBicm93c2VycyByZXR1cm4gdGhlIGZ1bGwgcmVzb2x2ZWQgVVJMIGluc3RlYWQuXG5cblx0aWYgKHBhdGguaW5kZXhPZignOi8nKSA9PT0gLTEgJiYgcGF0aC5zbGljZSgwLCAyKSAhPT0gJy8vJykge1xuXHRcdC8vIEFic29sdXRlIHBhdGguXG5cblx0XHRpZiAocGF0aC5pbmRleE9mKCcvJykgPT09IDApIHtcblx0XHRcdHBhdGggPSBsb2NhdGlvbi5ocmVmLm1hdGNoKC9eLio/OlxcL1xcL1teL10qLylbMF0gKyBwYXRoO1xuXHRcdH1cblxuXHRcdC8vIFJlbGF0aXZlIHBhdGguXG5cdFx0ZWxzZSB7XG5cdFx0XHRwYXRoID0gbG9jYXRpb24uaHJlZi5tYXRjaCgvXlteP10qXFwvKD86KS8pWzBdICsgcGF0aDtcblx0XHR9XG5cdH1cblxuXHRpZiAoIXBhdGgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHQnVGhlIEFsbG95RWRpdG9yIGluc3RhbGxhdGlvbiBwYXRoIGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGRldGVjdGVkLiBQbGVhc2Ugc2V0IHRoZSBnbG9iYWwgdmFyaWFibGUgXCJBTExPWUVESVRPUl9CQVNFUEFUSFwiIGJlZm9yZSBjcmVhdGluZyBlZGl0b3IgaW5zdGFuY2VzLidcblx0XHQpO1xuXHR9XG5cblx0cmV0dXJuIHBhdGg7XG59O1xuXG4vKipcbiAqIERldGVjdHMgYW5kIGxvYWQgdGhlIGNvcnJlc3BvbmRpbmcgbGFuZ3VhZ2UgZmlsZSBpZiBBbGxveUVkaXRvciBsYW5ndWFnZSBzdHJpbmdzIGFyZSBub3QgYWxyZWFkeSBwcmVzZW50LlxuICogVGhlIGZ1bmN0aW9uIGZpcmVzIGEge3sjY3Jvc3NMaW5rIFwiQWxsb3lFZGl0b3IvbGFuZ3VhZ2VSZXNvdXJjZXNMb2FkZWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnRcbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgbG9hZExhbmd1YWdlUmVzb3VyY2VzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBBbGxveUVkaXRvciBsb2FkcyB0aGUgbGFuZ3VhZ2UgcmVzb3VyY2UuXG4gKi9cbmNvbnN0IGxvYWRMYW5ndWFnZVJlc291cmNlcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdEFsbG95RWRpdG9yLmltcGxlbWVudEV2ZW50VGFyZ2V0KCk7XG5cblx0aWYgKExhbmcuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcblx0XHRpZiAoQWxsb3lFZGl0b3IuU3RyaW5ncykge1xuXHRcdFx0c2V0VGltZW91dChjYWxsYmFjaywgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFsbG95RWRpdG9yLm9uY2UoJ2xhbmd1YWdlUmVzb3VyY2VzTG9hZGVkJywgKCkgPT4ge1xuXHRcdFx0XHRzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGlmICghQWxsb3lFZGl0b3IuX2xhbmdSZXNvdXJjZVJlcXVlc3RlZCkge1xuXHRcdEFsbG95RWRpdG9yLl9sYW5nUmVzb3VyY2VSZXF1ZXN0ZWQgPSB0cnVlO1xuXG5cdFx0Y29uc3QgbGFuZ3VhZ2VzID0gW1xuXHRcdFx0J2FmJyxcblx0XHRcdCdhcicsXG5cdFx0XHQnYmcnLFxuXHRcdFx0J2JuJyxcblx0XHRcdCdicycsXG5cdFx0XHQnY2EnLFxuXHRcdFx0J2NzJyxcblx0XHRcdCdjeScsXG5cdFx0XHQnZGEnLFxuXHRcdFx0J2RlJyxcblx0XHRcdCdlbCcsXG5cdFx0XHQnZW4tYXUnLFxuXHRcdFx0J2VuLWNhJyxcblx0XHRcdCdlbi1nYicsXG5cdFx0XHQnZW4nLFxuXHRcdFx0J2VvJyxcblx0XHRcdCdlcycsXG5cdFx0XHQnZXQnLFxuXHRcdFx0J2V1Jyxcblx0XHRcdCdmYScsXG5cdFx0XHQnZmknLFxuXHRcdFx0J2ZvJyxcblx0XHRcdCdmci1jYScsXG5cdFx0XHQnZnInLFxuXHRcdFx0J2dsJyxcblx0XHRcdCdndScsXG5cdFx0XHQnaGUnLFxuXHRcdFx0J2hpJyxcblx0XHRcdCdocicsXG5cdFx0XHQnaHUnLFxuXHRcdFx0J2lkJyxcblx0XHRcdCdpcycsXG5cdFx0XHQnaXQnLFxuXHRcdFx0J2phJyxcblx0XHRcdCdrYScsXG5cdFx0XHQna20nLFxuXHRcdFx0J2tvJyxcblx0XHRcdCdrdScsXG5cdFx0XHQnbHQnLFxuXHRcdFx0J2x2Jyxcblx0XHRcdCdtaycsXG5cdFx0XHQnbW4nLFxuXHRcdFx0J21zJyxcblx0XHRcdCduYicsXG5cdFx0XHQnbmwnLFxuXHRcdFx0J25vJyxcblx0XHRcdCdwbCcsXG5cdFx0XHQncHQtYnInLFxuXHRcdFx0J3B0Jyxcblx0XHRcdCdybycsXG5cdFx0XHQncnUnLFxuXHRcdFx0J3NpJyxcblx0XHRcdCdzaycsXG5cdFx0XHQnc2wnLFxuXHRcdFx0J3NxJyxcblx0XHRcdCdzci1sYXRuJyxcblx0XHRcdCdzcicsXG5cdFx0XHQnc3YnLFxuXHRcdFx0J3RoJyxcblx0XHRcdCd0cicsXG5cdFx0XHQndHQnLFxuXHRcdFx0J3VnJyxcblx0XHRcdCd1aycsXG5cdFx0XHQndmknLFxuXHRcdFx0J3poLWNuJyxcblx0XHRcdCd6aCcsXG5cdFx0XTtcblxuXHRcdGNvbnN0IHVzZXJMYW5ndWFnZSA9XG5cdFx0XHRuYXZpZ2F0b3IubGFuZ3VhZ2UgfHwgbmF2aWdhdG9yLnVzZXJMYW5ndWFnZSB8fCAnZW4nO1xuXG5cdFx0Y29uc3QgcGFydHMgPSB1c2VyTGFuZ3VhZ2Vcblx0XHRcdC50b0xvd2VyQ2FzZSgpXG5cdFx0XHQubWF0Y2goLyhbYS16XSspKD86LShbYS16XSspKT8vKTtcblx0XHRsZXQgbGFuZyA9IHBhcnRzWzFdO1xuXHRcdGNvbnN0IGxvY2FsZSA9IHBhcnRzWzJdO1xuXG5cdFx0aWYgKGxhbmd1YWdlcy5pbmRleE9mKGxhbmcgKyAnLScgKyBsb2NhbGUpID49IDApIHtcblx0XHRcdGxhbmcgPSBsYW5nICsgJy0nICsgbG9jYWxlO1xuXHRcdH0gZWxzZSBpZiAobGFuZ3VhZ2VzLmluZGV4T2YobGFuZykgPT09IC0xKSB7XG5cdFx0XHRsYW5nID0gJ2VuJztcblx0XHR9XG5cblx0XHRDS0VESVRPUi5zY3JpcHRMb2FkZXIubG9hZChcblx0XHRcdEFsbG95RWRpdG9yLmdldFVybCgnbGFuZy9hbGxveS1lZGl0b3IvJyArIGxhbmcgKyAnLmpzJyksXG5cdFx0XHRsb2FkZWQgPT4ge1xuXHRcdFx0XHRpZiAobG9hZGVkKSB7XG5cdFx0XHRcdFx0QWxsb3lFZGl0b3IuZmlyZSgnbGFuZ3VhZ2VSZXNvdXJjZXNMb2FkZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXHRcdFx0dGhpcyAvLyBBbHdheXMgYEFsbG95RWRpdG9yYC5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cdFx0KTtcblx0fVxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBmdWxsIFVSTCBmb3IgQWxsb3lFZGl0b3IgcmVzb3VyY2VzLiBCeSBkZWZhdWx0LCBVUkxzXG4gKiByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIGNvbnRhaW4gYSBxdWVyeXN0cmluZyBwYXJhbWV0ZXIgKFwidFwiKVxuICogc2V0IHRvIHRoZSB7QGxpbmsgQ0tFRElUT1IjdGltZXN0YW1wfSB2YWx1ZS5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgZ2V0VXJsXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVzb3VyY2UgVGhlIHJlc291cmNlIHdob3NlIGZ1bGwgVVJMIHdlIHdhbnQgdG8gZ2V0LlxuICogSXQgbWF5IGJlIGEgZnVsbCwgYWJzb2x1dGUsIG9yIHJlbGF0aXZlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGZ1bGwgVVJMLlxuICovXG5jb25zdCBnZXRVcmwgPSBmdW5jdGlvbihyZXNvdXJjZSkge1xuXHRjb25zdCBiYXNlUGF0aCA9IEFsbG95RWRpdG9yLmdldEJhc2VQYXRoKCk7XG5cblx0Ly8gSWYgdGhpcyBpcyBub3QgYSBmdWxsIG9yIGFic29sdXRlIHBhdGguXG5cblx0aWYgKHJlc291cmNlLmluZGV4T2YoJzovJykgPT09IC0xICYmIHJlc291cmNlLmluZGV4T2YoJy8nKSAhPT0gMCkge1xuXHRcdHJlc291cmNlID0gYmFzZVBhdGggKyByZXNvdXJjZTtcblx0fVxuXG5cdC8vIEFkZCB0aGUgdGltZXN0YW1wLCBleGNlcHQgZm9yIGRpcmVjdG9yaWVzLlxuXG5cdGlmIChcblx0XHRDS0VESVRPUi50aW1lc3RhbXAgJiZcblx0XHRyZXNvdXJjZS5jaGFyQXQocmVzb3VyY2UubGVuZ3RoIC0gMSkgIT09ICcvJyAmJlxuXHRcdCEvWyY/XXQ9Ly50ZXN0KHJlc291cmNlKVxuXHQpIHtcblx0XHRyZXNvdXJjZSArPVxuXHRcdFx0KHJlc291cmNlLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nKSArXG5cdFx0XHQndD0nICtcblx0XHRcdENLRURJVE9SLnRpbWVzdGFtcDtcblx0fVxuXG5cdHJldHVybiByZXNvdXJjZTtcbn07XG5cbi8qKlxuICogSW1wbGVtZW50cyBldmVudCBmaXJpbmcgYW5kIHN1YnNjcmliaW5nIHZpYSBDS0VESVRPUi5ldmVudC5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgaW1wbGVtZW50RXZlbnRUYXJnZXRcbiAqIEBzdGF0aWNcbiAqL1xuY29uc3QgaW1wbGVtZW50RXZlbnRUYXJnZXQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCFBbGxveUVkaXRvci5maXJlICYmICFBbGxveUVkaXRvci5vbikge1xuXHRcdENLRURJVE9SLmV2ZW50LmltcGxlbWVudE9uKEFsbG95RWRpdG9yKTtcblx0fVxufTtcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gd2hpY2ggc2hvdWxkIG1hdGNoIHRoZSBzY3JpcHQgd2hpY2ggaGF2ZSBiZWVuIHVzZWQgdG8gbG9hZCBBbGxveUVkaXRvci5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBwcm9wZXJ0eSByZWdleEJhc2VQYXRoXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHN0YXRpY1xuICovXG5jb25zdCByZWdleEJhc2VQYXRoID0gLyhefC4qW1xcXFwvXSkoPzphbGxveS1lZGl0b3JbXi9dK3xhbGxveS1lZGl0b3IpXFwuanMoPzpcXD8uKnw7LiopPyQvaTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIEFsbG95RWRpdG9yIGRldGVjdHMgdGhlIGJyb3dzZXIgbGFuZ3VhZ2UgYW5kIGxvYWRzIHRoZSBjb3JyZXNwb25kaW5nIGxhbmd1YWdlIGZpbGUuIE9uY2UgdGhpcyBldmVudFxuICogaXMgZmlyZWQsIEFsbG95RWRpdG9yLlN0cmluZ3Mgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBldmVudCBsYW5ndWFnZVJlc291cmNlc0xvYWRlZFxuICovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVxdWlyZWQgcGx1Z2luIG5hbWVzIG5lZWRlZCBmb3IgYSBnaXZlbiBwbHVnaW5cbiAqIGlmIGl0IGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBvciBhbiBlbXB0eSBhcnJheS5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgZ2V0QnV0dG9uc1xuICogQHBhcmFtIHtBcnJheX0gYnV0dG9ucyBBbiBhcnJheSBvZiBidXR0b25zIG9yIHBsdWdpbiBuYW1lcy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGludm9rZWQgdG8gcmVzb2x2ZSB0aGUgcmVxdWVzdGVkIGJ1dHRvbiBuYW1lcy5cbiAqIEBzdGF0aWNcbiAqL1xuY29uc3QgZ2V0QnV0dG9ucyA9IGZ1bmN0aW9uKGJ1dHRvbnMpIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBidXR0b25zLnJlZHVjZSgoYWNjLCB2YWwpID0+IHtcblx0XHRcdHZhbCA9IEJSSURHRV9CVVRUT05TW3ZhbF0gfHwgW3ZhbF07XG5cblx0XHRcdHJldHVybiBhY2MuY29uY2F0KHZhbCk7XG5cdFx0fSwgW10pO1xuXHR9O1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGJ1dHRvbiBhbmQgdHJ5IHRvIGdldCBpdHMgcmVxdWlyZWQgcGx1Z2lucy5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgcmVnaXN0ZXJCcmlkZ2VCdXR0b25cbiAqIEBwYXJhbSB7U3RyaW5nfSBidXR0b25OYW1lIFRoZSBuYW1lIG9mIHRoZSBidXR0b24uXG4gKiBAcGFyYW0ge1N0cmluZ30gcGx1Z2luTmFtZSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRoYXQgcmVnaXN0ZXJzIHRoZSBidXR0b24uXG4gKiBAc3RhdGljXG4gKi9cbmNvbnN0IHJlZ2lzdGVyQnJpZGdlQnV0dG9uID0gZnVuY3Rpb24oYnV0dG9uTmFtZSwgcGx1Z2luTmFtZSkge1xuXHRpZiAoIUJSSURHRV9CVVRUT05TW3BsdWdpbk5hbWVdKSB7XG5cdFx0QlJJREdFX0JVVFRPTlNbcGx1Z2luTmFtZV0gPSBbXTtcblx0fVxuXG5cdEJSSURHRV9CVVRUT05TW3BsdWdpbk5hbWVdLnB1c2goYnV0dG9uTmFtZSk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgT09QXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqL1xuY29uc3QgT09QID0ge1xuXHRleHRlbmQsXG59O1xuXG5leHBvcnQge1xuXHRBdHRyaWJ1dGUsXG5cdEJhc2UsXG5cdEJ1dHRvbnMsXG5cdENvbXBhdCxcblx0Q29yZSxcblx0TGFuZyxcblx0T09QLFxuXHRTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXMsXG5cdFNlbGVjdGlvblNldFBvc2l0aW9uLFxuXHRTZWxlY3Rpb25UZXN0LFxuXHRTZWxlY3Rpb25zLFxuXHRUb29sYmFycyxcblx0ZWRpdGFibGUsXG5cdGdldEJhc2VQYXRoLFxuXHRnZXRCdXR0b25zLFxuXHRnZXRVcmwsXG5cdGltcGxlbWVudEV2ZW50VGFyZ2V0LFxuXHRsb2FkTGFuZ3VhZ2VSZXNvdXJjZXMsXG5cdHJlZ2V4QmFzZVBhdGgsXG5cdHJlZ2lzdGVyQnJpZGdlQnV0dG9uLFxufTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IHJlbW92ZUltYWdlQ29tbWFuZCBmcm9tICcuL3JlbW92ZS1pbWFnZSc7XG5cbmV4cG9ydCB7cmVtb3ZlSW1hZ2VDb21tYW5kfTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuY29uc3QgcmVtb3ZlSW1hZ2VDb21tYW5kID0ge1xuXHRleGVjOiBlZGl0b3IgPT4ge1xuXHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdGlmIChzZWxlY3Rpb24pIHtcblx0XHRcdGNvbnN0IHJhbmdlcyA9IHNlbGVjdGlvbi5nZXRSYW5nZXMoKTtcblx0XHRcdGNvbnN0IHN0YXJ0Q29udGFpbmVyID0gcmFuZ2VzWzBdLnN0YXJ0Q29udGFpbmVyO1xuXG5cdFx0XHRjb25zdCBuZXh0UmFuZ2UgPSBuZXcgQ0tFRElUT1IuZG9tLnJhbmdlKHN0YXJ0Q29udGFpbmVyKTtcblx0XHRcdG5leHRSYW5nZS5zZXRTdGFydChzdGFydENvbnRhaW5lciwgMCk7XG5cdFx0XHRuZXh0UmFuZ2Uuc2V0RW5kKHN0YXJ0Q29udGFpbmVyLCAwKTtcblxuXHRcdFx0Y29uc3Qgc2VsZWN0ZWRFbGVtZW50ID0gc2VsZWN0aW9uLmdldFNlbGVjdGVkRWxlbWVudCgpO1xuXG5cdFx0XHRpZiAoc2VsZWN0ZWRFbGVtZW50ICYmIHNlbGVjdGVkRWxlbWVudC5nZXROYW1lKCkgPT09ICdpbWcnKSB7XG5cdFx0XHRcdGNvbnN0IG5hdGl2ZSA9IHNlbGVjdGlvbi5nZXROYXRpdmUoKTtcblx0XHRcdFx0aWYgKG5hdGl2ZSkge1xuXHRcdFx0XHRcdG5hdGl2ZS5yZW1vdmVBbGxSYW5nZXMoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNlbGVjdGlvbi5zZWxlY3RSYW5nZXMoW25leHRSYW5nZV0pO1xuXG5cdFx0XHRcdHNlbGVjdGVkRWxlbWVudC5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCByZW1vdmVJbWFnZUNvbW1hbmQ7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuXG4vKipcbiAqIEJ1dHRvbkFjdGlvblN0eWxlIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBhcHBseWluZyBzdHlsZSBpbXBsZW1lbnRhdGlvbiBmb3IgYVxuICogYnV0dG9uIGJhc2VkIG9uIHRoZSBgYXBwbHlTdHlsZWAgYW5kIGByZW1vdmVTdHlsZWAgQVBJIG9mIENLRURJVE9SLlxuICpcbiAqIFRvIGV4ZWN1dGUgcHJvcGVybHksIHRoZSBjb21wb25lbnQgaGFzIHRvIGV4cG9zZSB0aGUgZm9sbG93aW5nIG1ldGhvZHMgd2hpY2ggY2FuIGJlIG9idGFpbmVkXG4gKiBvdXQgb2YgdGhlIGJveCB1c2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiQnV0dG9uU3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gbWl4aW46XG4gKiAtIGBGdW5jdGlvbmAge3sjY3Jvc3NMaW5rIFwiQnV0dG9uU3R5bGUvaXNBY3RpdmVcIn19e3svY3Jvc3NMaW5rfX0gdG8gY2hlY2sgdGhlIGFjdGl2ZSBzdGF0ZVxuICogLSBgRnVuY3Rpb25gIHt7I2Nyb3NzTGluayBcIkJ1dHRvblN0eWxlL2dldFN0eWxlXCJ9fXt7L2Nyb3NzTGlua319IHRvIHJldHVybiB0aGUgc3R5bGUgdGhhdCBzaG91bGQgYmUgYXBwbGllZFxuICpcbiAqIEBjbGFzcyBCdXR0b25BY3Rpb25TdHlsZVxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+XG5cdGNsYXNzIEJ1dHRvbkFjdGlvblN0eWxlIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgb3IgYXBwbGllcyB0aGUgY29tcG9uZW50IHN0eWxlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25BY3Rpb25TdHlsZVxuXHRcdCAqIEBtZXRob2QgYXBwbHlTdHlsZVxuXHRcdCAqL1xuXHRcdGFwcGx5U3R5bGUgPSAoKSA9PiB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdExhbmcuaXNGdW5jdGlvbih0aGlzLmlzQWN0aXZlKSAmJlxuXHRcdFx0XHRMYW5nLmlzRnVuY3Rpb24odGhpcy5nZXRTdHlsZSlcblx0XHRcdCkge1xuXHRcdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdFx0ZWRpdG9yLmdldFNlbGVjdGlvbigpLmxvY2soKTtcblxuXHRcdFx0XHRpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG5cdFx0XHRcdFx0ZWRpdG9yLnJlbW92ZVN0eWxlKHRoaXMuZ2V0U3R5bGUoKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWRpdG9yLmFwcGx5U3R5bGUodGhpcy5nZXRTdHlsZSgpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVkaXRvci5nZXRTZWxlY3Rpb24oKS51bmxvY2soKTtcblxuXHRcdFx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5cbi8qKlxuICogQnV0dG9uQ29tbWFuZEFjdGl2ZSBpcyBhIG1peGluIHRoYXQgcHJvdmlkZXMgYW4gYGlzQWN0aXZlYCBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmXG4gKiBhIGNvbnRleHQtYXdhcmUgY29tbWFuZCBpcyBjdXJyZW50bHkgaW4gYW4gYWN0aXZlIHN0YXRlLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT5cblx0Y2xhc3MgQnV0dG9uQ29tbWFuZEFjdGl2ZSBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuXHRcdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0XHQvKipcblx0XHQgKiBDaGVja3MgaWYgdGhlIGNvbW1hbmQgaXMgYWN0aXZlIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kQWN0aXZlXG5cdFx0ICogQG1ldGhvZCBpc0FjdGl2ZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbW1hbmQgaXMgYWN0aXZlLCBmYWxzZSBvdGhlcndpc2UuXG5cdFx0ICovXG5cdFx0aXNBY3RpdmUoKSB7XG5cdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdGNvbnN0IGNvbW1hbmQgPSBlZGl0b3IuZ2V0Q29tbWFuZCh0aGlzLnByb3BzLmNvbW1hbmQpO1xuXG5cdFx0XHRyZXR1cm4gY29tbWFuZCA/IGNvbW1hbmQuc3RhdGUgPT09IENLRURJVE9SLlRSSVNUQVRFX09OIDogZmFsc2U7XG5cdFx0fVxuXHR9O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcblxuLyoqXG4gKiBCdXR0b25Db21tYW5kIGlzIGEgbWl4aW4gdGhhdCBleGVjdXRlcyBhIGNvbW1hbmQgdmlhIENLRURJVE9SJ3MgQVBJLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db21tYW5kXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT5cblx0Y2xhc3MgQnV0dG9uQ29tbWFuZCBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuXHRcdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0XHQvKipcblx0XHQgKiBFeGVjdXRlcyBhIENLRWRpdG9yIGNvbW1hbmQgYW5kIGZpcmVzIGBhY3Rpb25QZXJmb3JtZWRgIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRcblx0XHQgKiBAcGFyYW0ge09iamVjdD19IGRhdGEgT3B0aW9uYWwgZGF0YSB0byBiZSBwYXNzZWQgdG8gQ0tFRElUT1IncyBgZXhlY0NvbW1hbmRgIG1ldGhvZC5cblx0XHQgKiBAbWV0aG9kIGV4ZWNDb21tYW5kXG5cdFx0ICovXG5cdFx0ZXhlY0NvbW1hbmQgPSBkYXRhID0+IHtcblx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0ZWRpdG9yLmV4ZWNDb21tYW5kKHRoaXMucHJvcHMuY29tbWFuZCwgZGF0YSk7XG5cblx0XHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0XHR9O1xuXHR9O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nJztcblxuLyoqXG4gKiBCdXR0b25LZXlzdHJva2UgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGEgYGtleXN0cm9rZWAgcHJvcCB0aGF0IGFsbG93cyBjb25maWd1cmluZ1xuICogYSBmdW5jdGlvbiBvZiB0aGUgaW5zdGFuY2UgdG8gYmUgaW52b2tlZCB1cG9uIHRoZSBrZXlzdHJva2UgYWN0aXZhdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uS2V5c3Ryb2tlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT5cblx0Y2xhc3MgQnV0dG9uS2V5c3Ryb2tlIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRcdC8qKlxuXHRcdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBib3RoIG9uIHRoZSBjbGllbnQgYW5kIHNlcnZlciwgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uS2V5c3Ryb2tlXG5cdFx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsTW91bnRcblx0XHQgKi9cblx0XHRjb21wb25lbnRXaWxsTW91bnQoKSB7XG5cdFx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKHN1cGVyLmNvbXBvbmVudFdpbGxNb3VudCkpIHtcblx0XHRcdFx0c3VwZXIuY29tcG9uZW50V2lsbE1vdW50KCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRcdGNvbnN0IGtleXN0cm9rZSA9IHRoaXMucHJvcHMua2V5c3Ryb2tlO1xuXG5cdFx0XHRjb25zdCBjb21tYW5kTmFtZSA9IGBrZXlzdHJva2U6JHtrZXlzdHJva2UubmFtZX1gO1xuXG5cdFx0XHRsZXQgY29tbWFuZCA9IG5hdGl2ZUVkaXRvci5nZXRDb21tYW5kKGNvbW1hbmROYW1lKTtcblxuXHRcdFx0aWYgKCFjb21tYW5kKSB7XG5cdFx0XHRcdGNvbW1hbmQgPSBuZXcgQ0tFRElUT1IuY29tbWFuZChuYXRpdmVFZGl0b3IsIHtcblx0XHRcdFx0XHRleGVjOiBmdW5jdGlvbihlZGl0b3IpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGtleXN0cm9rZUZuID0ga2V5c3Ryb2tlLmZuO1xuXG5cdFx0XHRcdFx0XHRpZiAoTGFuZy5pc1N0cmluZyhrZXlzdHJva2VGbikpIHtcblx0XHRcdFx0XHRcdFx0dGhpc1trZXlzdHJva2VGbl0uY2FsbCh0aGlzLCBlZGl0b3IpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChMYW5nLmlzRnVuY3Rpb24oa2V5c3Ryb2tlRm4pKSB7XG5cdFx0XHRcdFx0XHRcdGtleXN0cm9rZUZuLmNhbGwodGhpcywgZWRpdG9yKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LmJpbmQodGhpcyksXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdG5hdGl2ZUVkaXRvci5hZGRDb21tYW5kKGNvbW1hbmROYW1lLCBjb21tYW5kKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZGVmYXVsdEtleXN0cm9rZUNvbW1hbmQgPVxuXHRcdFx0XHRuYXRpdmVFZGl0b3Iua2V5c3Ryb2tlSGFuZGxlci5rZXlzdHJva2VzW2tleXN0cm9rZS5rZXlzXTtcblxuXHRcdFx0bmF0aXZlRWRpdG9yLnNldEtleXN0cm9rZShrZXlzdHJva2Uua2V5cywgY29tbWFuZE5hbWUpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGZyb20gdGhlIERPTS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25LZXlzdHJva2Vcblx0XHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxVbm1vdW50XG5cdFx0ICovXG5cdFx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKHN1cGVyLmNvbXBvbmVudFdpbGxVbm1vdW50KSkge1xuXHRcdFx0XHRzdXBlci5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNvbnRleHQuZWRpdG9yXG5cdFx0XHRcdC5nZXQoJ25hdGl2ZUVkaXRvcicpXG5cdFx0XHRcdC5zZXRLZXlzdHJva2UoXG5cdFx0XHRcdFx0dGhpcy5wcm9wcy5rZXlzdHJva2Uua2V5cyxcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0S2V5c3Ryb2tlQ29tbWFuZFxuXHRcdFx0XHQpO1xuXHRcdH1cblx0fTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5cbi8qKlxuICogQnV0dG9uQ2ZnUHJvcHMgaXMgYSBjbGFzcyB0aGF0IHByb3ZpZGVzIGEgbWVyZ2VCdXR0b25DZmdQcm9wcyBtZXRob2QgZm9yXG4gKiBtZXJnaW5nIFJlYWN0IHByb3BzIGFuZCB0aGUgbmF0aXZlIENLRURJVE9SJ3MgYnV0dG9uQ2ZnLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Qcm9wc1xuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+XG5cdGNsYXNzIEJ1dHRvblByb3BzIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRcdC8qKlxuXHRcdCAqIE1lcmdlcyB0aGUgcHJvcGVydGllcywgcGFzc2VkIHRvIHRoZSBjdXJyZW50IGNvbXBvbmVudCB3aXRoIHVzZXIncyBjb25maWd1cmF0aW9uXG5cdFx0ICogdmlhIGBidXR0b25DZmdgIHByb3BlcnR5LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvblByb3BzXG5cdFx0ICogQG1ldGhvZCBtZXJnZUJ1dHRvbkNmZ1Byb3BzXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFRoZSBwcm9wZXJ0aWVzIHRvIGJlIG1lcmdlZCB3aXRoIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uIGZvciB0aGlzXG5cdFx0ICogYnV0dG9uLiBJZiBub3QgcGFzc2VkLCB0aGUgdXNlciBjb25maWd1cmF0aW9uIHdpbGwgYmUgbWVyZ2VkIHdpdGggYHRoaXMucHJvcHNgXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgbWVyZ2VkIHByb3BlcnRpZXNcblx0XHQgKi9cblx0XHRtZXJnZUJ1dHRvbkNmZ1Byb3BzKHByb3BzID0gdGhpcy5wcm9wcykge1xuXHRcdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdFx0Y29uc3QgYnV0dG9uQ2ZnID0gbmF0aXZlRWRpdG9yLmNvbmZpZy5idXR0b25DZmcgfHwge307XG5cblx0XHRcdHJldHVybiBDS0VESVRPUi50b29scy5tZXJnZShwcm9wcywgYnV0dG9uQ2ZnWydsaW5rRWRpdCddKTtcblx0XHR9XG5cdH07XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nJztcblxuLyoqXG4gKiBCdXR0b25TdGF0ZUNsYXNzZXMgaXMgYSBtaXhpbiB0aGF0IGRlY29yYXRlcyB0aGUgZG9tRWxlbWVudCBvZiBhIGNvbXBvbmVudFxuICogd2l0aCBkaWZmZXJlbnQgQ1NTIGNsYXNzZXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogVG8gY2hlY2sgZm9yIHN0YXRlLCB0aGUgY29tcG9uZW50IGNhbiBleHBvc2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICogLSBgRnVuY3Rpb25gICoqaXNBY3RpdmUqKiB0byBjaGVjayB0aGUgYWN0aXZlIHN0YXRlXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+XG5cdGNsYXNzIEJ1dHRvblN0YXRlQ2xhc3NlcyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIGxpc3Qgb2Ygc3RhdGUgY2xhc3NlcyBhc3NvY2lhdGVkIHRvIHRoZSBjdXJyZW50IGVsZW1lbnQncyBzdGF0ZSwgYWNjb3JkaW5nXG5cdFx0ICogdG8gdGhlIHJlc3VsdHMgb2YgdGhlIGlzQWN0aXZlIG1ldGhvZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25TdGF0ZUNsYXNzZXNcblx0XHQgKiBAbWV0aG9kIGdldFN0YXRlQ2xhc3Nlc1xuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgd2l0aCB0aGUgc3RhdGUgQ1NTIGNsYXNzZXMuXG5cdFx0ICovXG5cdFx0Z2V0U3RhdGVDbGFzc2VzKCkge1xuXHRcdFx0bGV0IHN0YXRlQ2xhc3NlcyA9ICcnO1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgYWN0aXZlIHN0YXRlXG5cblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24odGhpcy5pc0FjdGl2ZSkgJiYgdGhpcy5pc0FjdGl2ZSgpKSB7XG5cdFx0XHRcdHN0YXRlQ2xhc3NlcyArPSAnYWUtYnV0dG9uLXByZXNzZWQnO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc3RhdGVDbGFzc2VzO1xuXHRcdH1cblx0fTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5cbi8qKlxuICogQnV0dG9uU3R5bGUgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGEgc3R5bGUgcHJvcCBhbmQgc29tZSBtZXRob2RzIHRvIGFwcGx5IHRoZSByZXN1bHRpbmdcbiAqIHN0eWxlIGFuZCBjaGVja2luZyBpZiBpdCBpcyBwcmVzZW50IGluIGEgZ2l2ZW4gcGF0aCBvciBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0eWxlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT5cblx0Y2xhc3MgQnV0dG9uU3R5bGUgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcblx0XHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdFx0LyoqXG5cdFx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIGJvdGggb24gdGhlIGNsaWVudCBhbmQgc2VydmVyLCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuXHRcdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbE1vdW50XG5cdFx0ICovXG5cdFx0Y29tcG9uZW50V2lsbE1vdW50KCkge1xuXHRcdFx0aWYgKExhbmcuaXNGdW5jdGlvbihzdXBlci5jb21wb25lbnRXaWxsTW91bnQpKSB7XG5cdFx0XHRcdHN1cGVyLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgc3R5bGUgPSB0aGlzLnByb3BzLnN0eWxlO1xuXG5cdFx0XHRpZiAoTGFuZy5pc1N0cmluZyhzdHlsZSkpIHtcblx0XHRcdFx0Y29uc3QgcGFydHMgPSBzdHlsZS5zcGxpdCgnLicpO1xuXHRcdFx0XHRsZXQgY3VycmVudE1lbWJlciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKVxuXHRcdFx0XHRcdC5jb25maWc7XG5cdFx0XHRcdGxldCBwcm9wZXJ0eSA9IHBhcnRzLnNoaWZ0KCk7XG5cblx0XHRcdFx0d2hpbGUgKFxuXHRcdFx0XHRcdHByb3BlcnR5ICYmXG5cdFx0XHRcdFx0TGFuZy5pc09iamVjdChjdXJyZW50TWVtYmVyKSAmJlxuXHRcdFx0XHRcdExhbmcuaXNPYmplY3QoY3VycmVudE1lbWJlcltwcm9wZXJ0eV0pXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGN1cnJlbnRNZW1iZXIgPSBjdXJyZW50TWVtYmVyW3Byb3BlcnR5XTtcblx0XHRcdFx0XHRwcm9wZXJ0eSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoTGFuZy5pc09iamVjdChjdXJyZW50TWVtYmVyKSkge1xuXHRcdFx0XHRcdHN0eWxlID0gY3VycmVudE1lbWJlcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZShzdHlsZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZnJvbSB0aGUgRE9NLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlXG5cdFx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsVW5tb3VudFxuXHRcdCAqL1xuXHRcdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdFx0aWYgKExhbmcuaXNGdW5jdGlvbihzdXBlci5jb21wb25lbnRXaWxsVW5tb3VudCkpIHtcblx0XHRcdFx0c3VwZXIuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc3R5bGUgPSBudWxsO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgaW5zdGFuY2Ugb2YgQ0tFRElUT1Iuc3R5bGUgd2hpY2ggcmVwcmVzZW50cyB0aGUgY3VycmVudCBidXR0b24gc3R5bGUuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVcblx0XHQgKiBAbWV0aG9kIGdldFN0eWxlXG5cdFx0ICogQHJldHVybiB7Q0tFRElUT1Iuc3R5bGV9IFRoZSBjdXJyZW50IHN0eWxlIHJlcHJlc2VudGF0aW9uLlxuXHRcdCAqL1xuXHRcdGdldFN0eWxlKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N0eWxlO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrcyBpZiBzdHlsZSBpcyBhY3RpdmUgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlXG5cdFx0ICogQG1ldGhvZCBpc0FjdGl2ZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgc3R5bGUgaXMgYWN0aXZlLCBmYWxzZSBvdGhlcndpc2UuXG5cdFx0ICovXG5cdFx0aXNBY3RpdmUoKSB7XG5cdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0XHRjb25zdCBlbGVtZW50UGF0aCA9IGVkaXRvci5lbGVtZW50UGF0aCgpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmNoZWNrQWN0aXZlKGVsZW1lbnRQYXRoLCBlZGl0b3IpO1xuXHRcdH1cblx0fTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuZXhwb3J0IHtkZWZhdWx0IGFzIEJ1dHRvbkFjdGlvblN0eWxlfSBmcm9tICcuL2J1dHRvbi1hY3Rpb24tc3R5bGUnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEJ1dHRvbkNvbW1hbmRBY3RpdmV9IGZyb20gJy4vYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBCdXR0b25Db21tYW5kfSBmcm9tICcuL2J1dHRvbi1jb21tYW5kJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBCdXR0b25LZXlzdHJva2V9IGZyb20gJy4vYnV0dG9uLWtleXN0cm9rZSc7XG5leHBvcnQge2RlZmF1bHQgYXMgQnV0dG9uUHJvcHN9IGZyb20gJy4vYnV0dG9uLXByb3BzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBCdXR0b25TdGF0ZUNsYXNzZXN9IGZyb20gJy4vYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEJ1dHRvblN0eWxlfSBmcm9tICcuL2J1dHRvbi1zdHlsZSc7XG5leHBvcnQge2RlZmF1bHQgYXMgVG9vbGJhckJ1dHRvbnN9IGZyb20gJy4vdG9vbGJhci1idXR0b25zJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBXaWRnZXREcm9wZG93bn0gZnJvbSAnLi93aWRnZXQtZHJvcGRvd24nO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFdpZGdldEV4Y2x1c2l2ZX0gZnJvbSAnLi93aWRnZXQtZXhjbHVzaXZlJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBXaWRnZXRGb2N1c01hbmFnZXJ9IGZyb20gJy4vd2lkZ2V0LWZvY3VzLW1hbmFnZXInO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuXG4vKipcbiAqIFRvb2xiYXJCdXR0b25zIHByb3ZpZGVzIGEgbGlzdCBvZiBidXR0b25zIHdoaWNoIGhhdmUgdG8gYmUgZGlzcGxheWVkXG4gKiBvbiB0aGUgY3VycmVudCB0b29sYmFyIGRlcGVuZGluZyBvbiB1c2VyIHByZWZlcmVuY2VzIGFuZCBnaXZlbiBzdGF0ZS5cbiAqXG4gKiBAY2xhc3MgVG9vbGJhckJ1dHRvbnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PlxuXHRjbGFzcyBUb29sYmFyQnV0dG9ucyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuXHRcdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0XHQvKipcblx0XHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlXG5cdFx0ICogdG9vbGJhci5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBUb29sYmFyQnV0dG9uc1xuXHRcdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdFx0ICovXG5cdFx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRcdC4uLldyYXBwZWRDb21wb25lbnQuZGVmYXVsdFByb3BzLFxuXHRcdFx0Z3V0dGVyOiB7XG5cdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdHRvcDogMTAsXG5cdFx0XHR9LFxuXHRcdFx0Y29uc3RyYWluVG9WaWV3cG9ydDogdHJ1ZSxcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQ2FuY2VscyBhbiBzY2hlZHVsZWQgYW5pbWF0aW9uIGZyYW1lLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFRvb2xiYXJCdXR0b25zXG5cdFx0ICogQG1ldGhvZCBjYW5jZWxBbmltYXRpb25cblx0XHQgKi9cblx0XHRjYW5jZWxBbmltYXRpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5fYW5pbWF0aW9uRnJhbWVJZCkge1xuXHRcdFx0XHR3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbWF0aW9uRnJhbWVJZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgZGlzcGxheWluZyB0b29sYmFyIEFycm93IGJveCBvbiB0b3Agb3Igb24gYm90dG9tIG9mIHRoZSB0b29sYmFyXG5cdFx0ICogZGVwZW5kaW5nIG9uIHRoZSBwb2ludCBvZiB1c2VyIGludGVyYWN0aW9uIHdpdGggdGhlIGVkaXRvci5cblx0XHQgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGFycm93IGJveCBjbGFzc2VzIGFzc29jaWF0ZWQgdG8gdGhlIGN1cnJlbnQgZWxlbWVudCdzIHN0YXRlLiBJdCByZWxpZXNcblx0XHQgKiBvbiB0aGUgZ2V0SW50ZXJhY3Rpb25Qb2ludCBtZXRob2QgdG8gY2FsY3VsYXRlIHRoZSBzZWxlY3Rpb24gZGlyZWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFRvb2xiYXJCdXR0b25zXG5cdFx0ICogQG1ldGhvZCBnZXRBcnJvd0JveENsYXNzZXNcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHdpdGggdGhlIGFycm93IGJveCBDU1MgY2xhc3Nlcy5cblx0XHQgKi9cblx0XHRnZXRBcnJvd0JveENsYXNzZXMoKSB7XG5cdFx0XHRsZXQgYXJyb3dCb3hDbGFzc2VzID0gJ2FlLWFycm93LWJveCc7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0dGhpcy5nZXRJbnRlcmFjdGlvblBvaW50KCkuZGlyZWN0aW9uID09PVxuXHRcdFx0XHRDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTVxuXHRcdFx0KSB7XG5cdFx0XHRcdGFycm93Qm94Q2xhc3NlcyArPSAnIGFlLWFycm93LWJveC10b3AnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXJyb3dCb3hDbGFzc2VzICs9ICcgYWUtYXJyb3ctYm94LWJvdHRvbSc7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhcnJvd0JveENsYXNzZXM7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50IGluIHBhZ2UgY29vcmRpbmF0ZXMsXG5cdFx0ICogcmVzdHJpY3RlZCB0byBmaXQgdG8gZ2l2ZW4gdmlld3BvcnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgVG9vbGJhckJ1dHRvbnNcblx0XHQgKiBAbWV0aG9kIGdldENvbnN0cmFpbmVkUG9zaXRpb25cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gYXR0cnMgVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzLCBwcm92aWRlZCBhcyBudW1iZXJzOlxuXHRcdCAqIC0gaGVpZ2h0XG5cdFx0ICogLSBsZWZ0XG5cdFx0ICogLSB0b3Bcblx0XHQgKiAtIHdpZHRoXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHZpZXdQYW5lU2l6ZSBPcHRpb25hbC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgY3VycmVudCB2aWV3cG9ydCB3aWxsIGJlIHVzZWQuIFNob3VsZCBjb250YWluIGF0IGxlYXN0IHRoZXNlIHByb3BlcnRpZXM6XG5cdFx0ICogLSB3aWR0aFxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggYHhgIGFuZCBgeWAgcHJvcGVydGllcywgd2hpY2ggcmVwcmVzZW50IHRoZSBjb25zdHJhaW5lZCBwb3NpdGlvbiBvZiB0aGVcblx0XHQgKiBlbGVtZW50LlxuXHRcdCAqL1xuXHRcdGdldENvbnN0cmFpbmVkUG9zaXRpb24oYXR0cnMsIHZpZXdQYW5lU2l6ZSkge1xuXHRcdFx0dmlld1BhbmVTaXplID1cblx0XHRcdFx0dmlld1BhbmVTaXplIHx8XG5cdFx0XHRcdG5ldyBDS0VESVRPUi5kb20ud2luZG93KHdpbmRvdykuZ2V0Vmlld1BhbmVTaXplKCk7XG5cblx0XHRcdGxldCB4ID0gYXR0cnMubGVmdDtcblx0XHRcdGxldCB5ID0gYXR0cnMudG9wO1xuXG5cdFx0XHRpZiAoYXR0cnMubGVmdCArIGF0dHJzLndpZHRoID4gdmlld1BhbmVTaXplLndpZHRoKSB7XG5cdFx0XHRcdHggLT0gYXR0cnMubGVmdCArIGF0dHJzLndpZHRoIC0gdmlld1BhbmVTaXplLndpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoeSA8IDApIHtcblx0XHRcdFx0eSA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHgsXG5cdFx0XHRcdHksXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uLCBpbiBwYWdlIGNvb3JkaW5hdGVzLCBhY2NvcmRpbmcgdG8gd2hpY2ggYSB0b29sYmFyIHNob3VsZCBhcHBlYXIuXG5cdFx0ICogRGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNlbGVjdGlvbiwgdGhlIHdkaWdldCBtYXkgYXBwZWFyIGFib3ZlIG9mIG9yIG9uIGJvdHRvbSBvZiB0aGUgc2VsZWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogSXQgZGVwZW5kcyBvbiB0aGUgcHJvcHMgZWRpdG9yRXZlbnQgdG8gYW5hbHl6ZSB0aGUgZm9sbG93aW5nIHVzZXItaW50ZXJhY3Rpb24gcGFyYW1ldGVyczpcblx0XHQgKiAtIHtPYmplY3R9IHNlbGVjdGlvbkRhdGEgVGhlIGRhdGEgYWJvdXQgdGhlIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yIGFzIHJldHVybmVkIGZyb21cblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRTZWxlY3Rpb25EYXRhOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIC0ge051bWJlcn0gcG9zIENvbnRhaW5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9zaXRpb24sIGNvbnNpZGVyZWQgYXMgbW9zdCBhcHByb3ByaWF0ZS5cblx0XHQgKiBUaGlzIG1heSBiZSB0aGUgcG9pbnQgd2hlcmUgdGhlIHVzZXIgcmVsZWFzZWQgdGhlIG1vdXNlLCBvciBqdXN0IHRoZSBiZWdpbm5pbmcgb3IgdGhlIGVuZCBvZlxuXHRcdCAqIHRoZSBzZWxlY3Rpb24uXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWV0aG9kIGdldEludGVyYWN0aW9uUG9pbnRcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IEFuIE9iamVjdCB3aGljaCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cdFx0ICogZGlyZWN0aW9uLCB4LCB5LCB3aGVyZSB4IGFuZCB5IGFyZSBpbiBwYWdlIGNvb3JkaW5hdGVzIGFuZCBkaXJlY3Rpb24gY2FuIGJlIG9uZSBvZiB0aGVzZTpcblx0XHQgKiBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCBvciBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTVxuXHRcdCAqL1xuXHRcdGdldEludGVyYWN0aW9uUG9pbnQoKSB7XG5cdFx0XHRjb25zdCBldmVudFBheWxvYWQgPSB0aGlzLnByb3BzLmVkaXRvckV2ZW50XG5cdFx0XHRcdD8gdGhpcy5wcm9wcy5lZGl0b3JFdmVudC5kYXRhXG5cdFx0XHRcdDogbnVsbDtcblxuXHRcdFx0aWYgKCFldmVudFBheWxvYWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxlY3Rpb25EYXRhID0gZXZlbnRQYXlsb2FkLnNlbGVjdGlvbkRhdGE7XG5cblx0XHRcdGNvbnN0IG5hdGl2ZUV2ZW50ID0gZXZlbnRQYXlsb2FkLm5hdGl2ZUV2ZW50O1xuXG5cdFx0XHRjb25zdCBwb3MgPSB7XG5cdFx0XHRcdHg6IGV2ZW50UGF5bG9hZC5uYXRpdmVFdmVudC5wYWdlWCxcblx0XHRcdFx0eTogc2VsZWN0aW9uRGF0YS5yZWdpb24udG9wLFxuXHRcdFx0fTtcblxuXHRcdFx0bGV0IGRpcmVjdGlvbiA9IHNlbGVjdGlvbkRhdGEucmVnaW9uLmRpcmVjdGlvbjtcblxuXHRcdFx0Y29uc3QgZW5kUmVjdCA9IHNlbGVjdGlvbkRhdGEucmVnaW9uLmVuZFJlY3Q7XG5cblx0XHRcdGNvbnN0IHN0YXJ0UmVjdCA9IHNlbGVjdGlvbkRhdGEucmVnaW9uLnN0YXJ0UmVjdDtcblxuXHRcdFx0aWYgKGVuZFJlY3QgJiYgc3RhcnRSZWN0ICYmIHN0YXJ0UmVjdC50b3AgPT09IGVuZFJlY3QudG9wKSB7XG5cdFx0XHRcdGRpcmVjdGlvbiA9IENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgeDtcblx0XHRcdGxldCB5O1xuXG5cdFx0XHQvLyBJZiB3ZSBoYXZlIHRoZSBwb2ludCB3aGVyZSB1c2VyIHJlbGVhc2VkIHRoZSBtb3VzZSwgc2hvdyBUb29sYmFyIGF0IHRoaXMgcG9pbnRcblx0XHRcdC8vIG90aGVyd2lzZSBzaG93IGl0IG9uIHRoZSBtaWRkbGUgb2YgdGhlIHNlbGVjdGlvbi5cblxuXHRcdFx0aWYgKHBvcy54ICYmIHBvcy55KSB7XG5cdFx0XHRcdHggPSB0aGlzLl9nZXRYUG9pbnQoc2VsZWN0aW9uRGF0YSwgcG9zLngpO1xuXG5cdFx0XHRcdGlmIChkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QKSB7XG5cdFx0XHRcdFx0eSA9IE1hdGgubWluKHBvcy55LCBzZWxlY3Rpb25EYXRhLnJlZ2lvbi50b3ApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHkgPSBNYXRoLm1heChcblx0XHRcdFx0XHRcdHBvcy55LFxuXHRcdFx0XHRcdFx0dGhpcy5fZ2V0WVBvaW50KHNlbGVjdGlvbkRhdGEsIG5hdGl2ZUV2ZW50KVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHggPSBzZWxlY3Rpb25EYXRhLnJlZ2lvbi5sZWZ0ICsgc2VsZWN0aW9uRGF0YS5yZWdpb24ud2lkdGggLyAyO1xuXG5cdFx0XHRcdGlmIChkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NKSB7XG5cdFx0XHRcdFx0eSA9IHRoaXMuX2dldFlQb2ludChzZWxlY3Rpb25EYXRhLCBuYXRpdmVFdmVudCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eSA9IHNlbGVjdGlvbkRhdGEucmVnaW9uLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkaXJlY3Rpb24sXG5cdFx0XHRcdHgsXG5cdFx0XHRcdHksXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sYmFyLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1ldGhvZCBfZ2V0WFBvaW50XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50WCBUaGUgWCBjb29yZGluYXRlIHJlY2VpdmVkIGZyb20gdGhlIG5hdGl2ZSBldmVudCAobW91c2V1cCkuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHNlbGVjdGlvbkRhdGEgVGhlIGRhdGEgYWJvdXQgdGhlIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yIGFzIHJldHVybmVkIGZyb20ge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9zZWxlY3Rpb25yZWdpb24vZ2V0U2VsZWN0aW9uRGF0YTptZXRob2RcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgY2FsY3VsYXRlZCBYIHBvaW50IGluIHBhZ2UgY29vcmRpbmF0ZXMuXG5cdFx0ICovXG5cdFx0X2dldFhQb2ludChzZWxlY3Rpb25EYXRhLCBldmVudFgpIHtcblx0XHRcdGNvbnN0IHJlZ2lvbiA9IHNlbGVjdGlvbkRhdGEucmVnaW9uO1xuXG5cdFx0XHRjb25zdCBsZWZ0ID0gcmVnaW9uLnN0YXJ0UmVjdCA/IHJlZ2lvbi5zdGFydFJlY3QubGVmdCA6IHJlZ2lvbi5sZWZ0O1xuXHRcdFx0Y29uc3QgcmlnaHQgPSByZWdpb24uZW5kUmVjdCA/IHJlZ2lvbi5lbmRSZWN0LnJpZ2h0IDogcmVnaW9uLnJpZ2h0O1xuXG5cdFx0XHRsZXQgeDtcblxuXHRcdFx0aWYgKGxlZnQgPCBldmVudFggJiYgcmlnaHQgPiBldmVudFgpIHtcblx0XHRcdFx0eCA9IGV2ZW50WDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IGxlZnREaXN0ID0gTWF0aC5hYnMobGVmdCAtIGV2ZW50WCk7XG5cdFx0XHRcdGNvbnN0IHJpZ2h0RGlzdCA9IE1hdGguYWJzKHJpZ2h0IC0gZXZlbnRYKTtcblxuXHRcdFx0XHRpZiAobGVmdERpc3QgPCByaWdodERpc3QpIHtcblx0XHRcdFx0XHQvLyB1c2VyIHJhaXNlZCB0aGUgbW91c2Ugb24gbGVmdCBvbiB0aGUgc2VsZWN0aW9uXG5cblx0XHRcdFx0XHR4ID0gbGVmdDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4ID0gcmlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHg7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2xiYXIuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWV0aG9kIF9nZXRZUG9pbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbmF0aXZlRXZlbnQgVGhlIGRhdGEgYWJvdXQgZXZlbnQgaXMgZmlyZWRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0aW9uRGF0YSBUaGUgZGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgYXMgcmV0dXJuZWQgZnJvbSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRTZWxlY3Rpb25EYXRhOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjYWxjdWxhdGVkIFkgcG9pbnQgaW4gcGFnZSBjb29yZGluYXRlcy5cblx0XHQgKi9cblx0XHRfZ2V0WVBvaW50KHNlbGVjdGlvbkRhdGEsIG5hdGl2ZUV2ZW50KSB7XG5cdFx0XHRsZXQgeSA9IDA7XG5cblx0XHRcdGlmIChzZWxlY3Rpb25EYXRhICYmIG5hdGl2ZUV2ZW50KSB7XG5cdFx0XHRcdGNvbnN0IGVsZW1lbnRUYXJnZXQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoXG5cdFx0XHRcdFx0bmF0aXZlRXZlbnQudGFyZ2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGVsZW1lbnRUYXJnZXQuJCAmJlxuXHRcdFx0XHRcdGVsZW1lbnRUYXJnZXQuZ2V0U3R5bGUoJ292ZXJmbG93JykgPT09ICdhdXRvJ1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHR5ID1cblx0XHRcdFx0XHRcdG5hdGl2ZUV2ZW50LnRhcmdldC5vZmZzZXRUb3AgK1xuXHRcdFx0XHRcdFx0bmF0aXZlRXZlbnQudGFyZ2V0Lm9mZnNldEhlaWdodDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uYm90dG9tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB5O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sYmFyIHRha2luZyBpbiBjb25zaWRlcmF0aW9uIHRoZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIlRvb2xiYXJCdXR0b25zL2d1dHRlcjphdHRyaWJ1dGVcIn19e3svY3Jvc3NMaW5rfX0gYXR0cmlidXRlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFRvb2xiYXJCdXR0b25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBtZXRob2QgIGdldFdpZGdldFhZUG9pbnRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gbGVmdCBUaGUgbGVmdCBvZmZzZXQgaW4gcGFnZSBjb29yZGluYXRlcyB3aGVyZSBUb29sYmFyIHNob3VsZCBiZSBzaG93bi5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gdG9wIFRoZSB0b3Agb2Zmc2V0IGluIHBhZ2UgY29vcmRpbmF0ZXMgd2hlcmUgVG9vbGJhciBzaG91bGQgYmUgc2hvd24uXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIG9mIHRoZSBzZWxlY3Rpb24uIE1heSBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcblx0XHQgKiBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCBvciBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTVxuXHRcdCAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSB3aXRoIGxlZnQgYW5kIHRvcCBvZmZzZXRzIGluIHBhZ2UgY29vcmRpbmF0ZXMuXG5cdFx0ICovXG5cdFx0Z2V0V2lkZ2V0WFlQb2ludChsZWZ0LCB0b3AsIGRpcmVjdGlvbikge1xuXHRcdFx0Y29uc3QgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG5cdFx0XHRjb25zdCBndXR0ZXIgPSB0aGlzLnByb3BzLmd1dHRlcjtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NIHx8XG5cdFx0XHRcdGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1Bcblx0XHRcdCkge1xuXHRcdFx0XHRsZWZ0ID0gbGVmdCAtIGd1dHRlci5sZWZ0IC0gZG9tTm9kZS5vZmZzZXRXaWR0aCAvIDI7XG5cblx0XHRcdFx0dG9wID1cblx0XHRcdFx0XHRkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NXG5cdFx0XHRcdFx0XHQ/IHRvcCArIGd1dHRlci50b3Bcblx0XHRcdFx0XHRcdDogdG9wIC0gZG9tTm9kZS5vZmZzZXRIZWlnaHQgLSBndXR0ZXIudG9wO1xuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0ZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fTEVGVF9UT19SSUdIVCB8fFxuXHRcdFx0XHRkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9SSUdIVF9UT19MRUZUXG5cdFx0XHQpIHtcblx0XHRcdFx0bGVmdCA9XG5cdFx0XHRcdFx0ZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fTEVGVF9UT19SSUdIVFxuXHRcdFx0XHRcdFx0PyBsZWZ0ICsgZ3V0dGVyLmxlZnQgKyBkb21Ob2RlLm9mZnNldEhlaWdodCAvIDJcblx0XHRcdFx0XHRcdDogbGVmdCAtICgzICogZG9tTm9kZS5vZmZzZXRIZWlnaHQpIC8gMiAtIGd1dHRlci5sZWZ0O1xuXG5cdFx0XHRcdHRvcCA9IHRvcCAtIGd1dHRlci50b3AgLSBkb21Ob2RlLm9mZnNldEhlaWdodCAvIDI7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChsZWZ0IDwgMCkge1xuXHRcdFx0XHRsZWZ0ID0gMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRvcCA8IDApIHtcblx0XHRcdFx0dG9wID0gMDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFtsZWZ0LCB0b3BdO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdG9vbGJhciBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2Vcblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBUb29sYmFyQnV0dG9uc1xuXHRcdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdG9vbGJhciBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2Vcblx0XHQgKi9cblx0XHRpc1Zpc2libGUoKSB7XG5cdFx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cblx0XHRcdGlmIChkb21Ob2RlKSB7XG5cdFx0XHRcdGNvbnN0IGRvbUVsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZG9tTm9kZSk7XG5cblx0XHRcdFx0cmV0dXJuIGRvbUVsZW1lbnQuaGFzQ2xhc3MoJ2FsbG95LWVkaXRvci12aXNpYmxlJyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBNb3ZlcyBhIHRvb2xiYXIgZnJvbSBhIHN0YXJ0aW5nIHBvaW50IHRvIGEgZGVzdGluYXRpb24gcG9pbnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgVG9vbGJhckJ1dHRvbnNcblx0XHQgKiBAbWV0aG9kIG1vdmVUb1BvaW50XG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSBzdGFydFBvaW50IFRoZSBzdGFydGluZyBwb2ludCBmb3IgdGhlIG1vdmVtZW50LlxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gZW5kUG9pbnQgVGhlIGRlc3RpbmF0aW9uIHBvaW50IGZvciB0aGUgbW92ZW1lbnQuXG5cdFx0ICovXG5cdFx0bW92ZVRvUG9pbnQoc3RhcnRQb2ludCwgZW5kUG9pbnQpIHtcblx0XHRcdGNvbnN0IGRvbUVsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoXG5cdFx0XHRcdFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpXG5cdFx0XHQpO1xuXG5cdFx0XHRkb21FbGVtZW50LnNldFN0eWxlcyh7XG5cdFx0XHRcdGxlZnQ6IHN0YXJ0UG9pbnRbMF0gKyAncHgnLFxuXHRcdFx0XHR0b3A6IHN0YXJ0UG9pbnRbMV0gKyAncHgnLFxuXHRcdFx0XHRvcGFjaXR5OiAwLFxuXHRcdFx0XHRwb2ludGVyRXZlbnRzOiAnbm9uZScsXG5cdFx0XHR9KTtcblxuXHRcdFx0ZG9tRWxlbWVudC5yZW1vdmVDbGFzcygnYWxsb3ktZWRpdG9yLWludmlzaWJsZScpO1xuXG5cdFx0XHR0aGlzLl9hbmltYXRpb25GcmFtZUlkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG5cdFx0XHRcdGRvbUVsZW1lbnQuYWRkQ2xhc3MoJ2FlLXRvb2xiYXItdHJhbnNpdGlvbicpO1xuXHRcdFx0XHRkb21FbGVtZW50LmFkZENsYXNzKCdhbGxveS1lZGl0b3ItdmlzaWJsZScpO1xuXHRcdFx0XHRkb21FbGVtZW50LnNldFN0eWxlcyh7XG5cdFx0XHRcdFx0bGVmdDogZW5kUG9pbnRbMF0gKyAncHgnLFxuXHRcdFx0XHRcdHRvcDogZW5kUG9pbnRbMV0gKyAncHgnLFxuXHRcdFx0XHRcdG9wYWNpdHk6IDEsXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIDE1MG1zIHRvIG1hdGNoIHRyYW5zaXRpb24tZHVyYXRpb24gZm9yIC5hZS10b29sYmFyLXRyYW5zaXRpb246XG5cblx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0ZG9tRWxlbWVudC5zZXRTdHlsZXMoe1xuXHRcdFx0XHRcdFx0cG9pbnRlckV2ZW50czogJycsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0sIDE1MCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBTaG93cyB0aGUgdG9vbGJhciB3aXRoIHRoZSBkZWZhdWx0IGFuaW1hdGlvbiB0cmFuc2l0aW9uLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFRvb2xiYXJCdXR0b25zXG5cdFx0ICogQG1ldGhvZCBzaG93XG5cdFx0ICovXG5cdFx0c2hvdygpIHtcblx0XHRcdGNvbnN0IGRvbU5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcblx0XHRcdGNvbnN0IHVpTm9kZSA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCd1aU5vZGUnKTtcblxuXHRcdFx0Y29uc3Qgc2Nyb2xsVG9wID0gdWlOb2RlID8gdWlOb2RlLnNjcm9sbFRvcCA6IDA7XG5cblx0XHRcdGlmICghdGhpcy5pc1Zpc2libGUoKSAmJiBkb21Ob2RlKSB7XG5cdFx0XHRcdGNvbnN0IGludGVyYWN0aW9uUG9pbnQgPSB0aGlzLmdldEludGVyYWN0aW9uUG9pbnQoKTtcblxuXHRcdFx0XHRpZiAoaW50ZXJhY3Rpb25Qb2ludCkge1xuXHRcdFx0XHRcdGNvbnN0IGRvbUVsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZG9tTm9kZSk7XG5cblx0XHRcdFx0XHRsZXQgZmluYWxYO1xuXHRcdFx0XHRcdGxldCBmaW5hbFk7XG5cdFx0XHRcdFx0bGV0IGluaXRpYWxYO1xuXHRcdFx0XHRcdGxldCBpbml0aWFsWTtcblxuXHRcdFx0XHRcdGZpbmFsWCA9IGluaXRpYWxYID0gcGFyc2VGbG9hdChkb21FbGVtZW50LmdldFN0eWxlKCdsZWZ0JykpO1xuXHRcdFx0XHRcdGZpbmFsWSA9IGluaXRpYWxZID0gcGFyc2VGbG9hdChkb21FbGVtZW50LmdldFN0eWxlKCd0b3AnKSk7XG5cblx0XHRcdFx0XHRpZiAodGhpcy5wcm9wcy5jb25zdHJhaW5Ub1ZpZXdwb3J0KSB7XG5cdFx0XHRcdFx0XHRjb25zdCByZXMgPSB0aGlzLmdldENvbnN0cmFpbmVkUG9zaXRpb24oe1xuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IHBhcnNlRmxvYXQoZG9tTm9kZS5vZmZzZXRIZWlnaHQpLFxuXHRcdFx0XHRcdFx0XHRsZWZ0OiBmaW5hbFgsXG5cdFx0XHRcdFx0XHRcdHRvcDogZmluYWxZLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogcGFyc2VGbG9hdChkb21Ob2RlLm9mZnNldFdpZHRoKSxcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRmaW5hbFggPSByZXMueDtcblx0XHRcdFx0XHRcdGZpbmFsWSA9IHJlcy55O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdGludGVyYWN0aW9uUG9pbnQuZGlyZWN0aW9uID09PVxuXHRcdFx0XHRcdFx0Q0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT01cblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdGluaXRpYWxZID1cblx0XHRcdFx0XHRcdFx0dGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhLnJlZ2lvbi5ib3R0b20gKyBzY3JvbGxUb3A7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGluaXRpYWxZID1cblx0XHRcdFx0XHRcdFx0dGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhLnJlZ2lvbi50b3AgKyBzY3JvbGxUb3A7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5tb3ZlVG9Qb2ludChbaW5pdGlhbFgsIGluaXRpYWxZXSwgW2ZpbmFsWCwgZmluYWxZXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSB0b29sYmFyIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IGludGVyYWN0aW9uIHBvaW50LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFRvb2xiYXJCdXR0b25zXG5cdFx0ICogQG1ldGhvZCB1cGRhdGVQb3NpdGlvblxuXHRcdCAqL1xuXHRcdHVwZGF0ZVBvc2l0aW9uKCkge1xuXHRcdFx0Y29uc3QgaW50ZXJhY3Rpb25Qb2ludCA9IHRoaXMuZ2V0SW50ZXJhY3Rpb25Qb2ludCgpO1xuXG5cdFx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cblx0XHRcdGlmIChpbnRlcmFjdGlvblBvaW50ICYmIGRvbU5vZGUpIHtcblx0XHRcdFx0Y29uc3QgdWlOb2RlID1cblx0XHRcdFx0XHR0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgndWlOb2RlJykgfHwgZG9jdW1lbnQuYm9keTtcblx0XHRcdFx0Y29uc3QgdWlOb2RlU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHVpTm9kZSk7XG5cdFx0XHRcdGNvbnN0IHVpTm9kZU1hcmdpbkxlZnQgPSBwYXJzZUludChcblx0XHRcdFx0XHR1aU5vZGVTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tbGVmdCcpLFxuXHRcdFx0XHRcdDEwXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnN0IHVpTm9kZU1hcmdpblJpZ2h0ID0gcGFyc2VJbnQoXG5cdFx0XHRcdFx0dWlOb2RlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXJpZ2h0JyksXG5cdFx0XHRcdFx0MTBcblx0XHRcdFx0KTtcblx0XHRcdFx0Y29uc3QgdG90YWxXaWR0aCA9XG5cdFx0XHRcdFx0dWlOb2RlTWFyZ2luTGVmdCArXG5cdFx0XHRcdFx0ZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCArXG5cdFx0XHRcdFx0dWlOb2RlTWFyZ2luUmlnaHQ7XG5cblx0XHRcdFx0Y29uc3Qgc2Nyb2xsVG9wID1cblx0XHRcdFx0XHR1aU5vZGUudGFnTmFtZSAhPT0gJ0JPRFknID8gdWlOb2RlLnNjcm9sbFRvcCA6IDA7XG5cblx0XHRcdFx0Y29uc3QgeHkgPSB0aGlzLmdldFdpZGdldFhZUG9pbnQoXG5cdFx0XHRcdFx0aW50ZXJhY3Rpb25Qb2ludC54LFxuXHRcdFx0XHRcdGludGVyYWN0aW9uUG9pbnQueSxcblx0XHRcdFx0XHRpbnRlcmFjdGlvblBvaW50LmRpcmVjdGlvblxuXHRcdFx0XHQpO1xuXHRcdFx0XHR4eVsxXSArPSBzY3JvbGxUb3A7XG5cblx0XHRcdFx0aWYgKHh5WzBdIDwgMCkge1xuXHRcdFx0XHRcdHh5WzBdID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoeHlbMF0gPiB0b3RhbFdpZHRoIC0gZG9tTm9kZS5vZmZzZXRXaWR0aCkge1xuXHRcdFx0XHRcdHh5WzBdID0gdG90YWxXaWR0aCAtIGRvbU5vZGUub2Zmc2V0V2lkdGg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZG9tTm9kZSkuc2V0U3R5bGVzKHtcblx0XHRcdFx0XHRsZWZ0OiB4eVswXSArICdweCcsXG5cdFx0XHRcdFx0dG9wOiB4eVsxXSArICdweCcsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEFuYWx5c2VzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBhbmQgcmV0dXJucyB0aGUgYnV0dG9ucyBvciBidXR0b24gZ3JvdXBzIHRvIGJlIHJlbmRlcmVkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1ldGhvZCBnZXRUb29sYmFyQnV0dG9uR3JvdXBzXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gYnV0dG9ucyBUaGUgYnV0dG9ucyBjb3VsZCBiZSBzaG93biwgcHJpb3IgdG8gdGhlIHN0YXRlIGZpbHRlcmluZy5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gYWRkaXRpb25hbFByb3BzIEFkZGl0aW9uYWwgcHJvcHMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIGRvd24gdG8gdGhlIGJ1dHRvbnMuXG5cdFx0ICogQHJldHVybiB7QXJyYXl9IEFuIEFycmF5IHdoaWNoIGNvbnRhaW5zIHRoZSBidXR0b25zIG9yIGJ1dHRvbiBncm91cHMgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdFx0ICovXG5cdFx0Z2V0VG9vbGJhckJ1dHRvbkdyb3VwcyhidXR0b25zLCBhZGRpdGlvbmFsUHJvcHMpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oYnV0dG9ucykpIHtcblx0XHRcdFx0YnV0dG9ucyA9IGJ1dHRvbnMuY2FsbCh0aGlzKSB8fCBbXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJ1dHRvbnMucmVkdWNlKChsaXN0LCBidXR0b24pID0+IHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYnV0dG9uKSkge1xuXHRcdFx0XHRcdGxpc3QucHVzaCh0aGlzLmdldFRvb2xiYXJCdXR0b25zKGJ1dHRvbiwgYWRkaXRpb25hbFByb3BzKSk7XG5cblx0XHRcdFx0XHRyZXR1cm4gbGlzdDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRUb29sYmFyQnV0dG9ucyhidXR0b25zLCBhZGRpdGlvbmFsUHJvcHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBbXSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQW5hbHl6ZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGFuZCB0aGUgYnV0dG9ucyBleGNsdXNpdmUgbW9kZSB2YWx1ZSB0byBmaWd1cmUgb3V0IHdoaWNoXG5cdFx0ICogYnV0dG9ucyBzaG91bGQgYmUgcHJlc2VudCBpbiBhIGdpdmVuIHN0YXRlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFRvb2xiYXJCdXR0b25zXG5cdFx0ICogQG1ldGhvZCBnZXRUb29sYmFyQnV0dG9uc1xuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IGJ1dHRvbnMgVGhlIGJ1dHRvbnMgY291bGQgYmUgc2hvd24sIHByaW9yIHRvIHRoZSBzdGF0ZSBmaWx0ZXJpbmcuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGFkZGl0aW9uYWxQcm9wcyBBZGRpdGlvbmFsIHByb3BzIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCBkb3duIHRvIHRoZSBidXR0b25zLlxuXHRcdCAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSB3aGljaCBjb250YWlucyB0aGUgYnV0dG9ucyB0aGF0IHNob3VsZCBiZSByZW5kZXJlZC5cblx0XHQgKi9cblx0XHRnZXRUb29sYmFyQnV0dG9ucyhidXR0b25zLCBhZGRpdGlvbmFsUHJvcHMpIHtcblx0XHRcdGNvbnN0IGJ1dHRvblByb3BzID0ge307XG5cblx0XHRcdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRcdGNvbnN0IGJ1dHRvbkNmZyA9IG5hdGl2ZUVkaXRvci5jb25maWcuYnV0dG9uQ2ZnIHx8IHt9O1xuXG5cdFx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKGJ1dHRvbnMpKSB7XG5cdFx0XHRcdGJ1dHRvbnMgPSBidXR0b25zLmNhbGwodGhpcykgfHwgW107XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRvb2xiYXJCdXR0b25zID0gdGhpcy5maWx0ZXJFeGNsdXNpdmUoXG5cdFx0XHRcdGJ1dHRvbnNcblx0XHRcdFx0XHQuZmlsdGVyKGJ1dHRvbiA9PiB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHRidXR0b24gJiZcblx0XHRcdFx0XHRcdFx0KEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uXSB8fFxuXHRcdFx0XHRcdFx0XHRcdEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uLm5hbWVdKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5tYXAoYnV0dG9uID0+IHtcblx0XHRcdFx0XHRcdGlmIChMYW5nLmlzU3RyaW5nKGJ1dHRvbikpIHtcblx0XHRcdFx0XHRcdFx0YnV0dG9uUHJvcHNbYnV0dG9uXSA9IGJ1dHRvbkNmZ1tidXR0b25dO1xuXHRcdFx0XHRcdFx0XHRidXR0b24gPSBBbGxveUVkaXRvci5CdXR0b25zW2J1dHRvbl07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKExhbmcuaXNTdHJpbmcoYnV0dG9uLm5hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdGJ1dHRvblByb3BzW1xuXHRcdFx0XHRcdFx0XHRcdEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uLm5hbWVdLmtleVxuXHRcdFx0XHRcdFx0XHRdID0gQ0tFRElUT1IudG9vbHMubWVyZ2UoXG5cdFx0XHRcdFx0XHRcdFx0YnV0dG9uQ2ZnW2J1dHRvbl0sXG5cdFx0XHRcdFx0XHRcdFx0YnV0dG9uLmNmZ1xuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRidXR0b24gPSBBbGxveUVkaXRvci5CdXR0b25zW2J1dHRvbi5uYW1lXTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIGJ1dHRvbjtcblx0XHRcdFx0XHR9KVxuXHRcdFx0KS5tYXAoZnVuY3Rpb24oYnV0dG9uLCBpbmRleCkge1xuXHRcdFx0XHRsZXQgcHJvcHMgPSB0aGlzLm1lcmdlRXhjbHVzaXZlUHJvcHMoXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZWRpdG9yOiB0aGlzLmNvbnRleHQuZWRpdG9yLFxuXHRcdFx0XHRcdFx0a2V5OlxuXHRcdFx0XHRcdFx0XHRidXR0b24ua2V5ICE9PSAnc2VwYXJhdG9yJ1xuXHRcdFx0XHRcdFx0XHRcdD8gYnV0dG9uLmtleVxuXHRcdFx0XHRcdFx0XHRcdDogYCR7YnV0dG9uLmtleX0tJHtpbmRleH1gLFxuXHRcdFx0XHRcdFx0dGFiS2V5OiBidXR0b24ua2V5LFxuXHRcdFx0XHRcdFx0dGFiSW5kZXg6XG5cdFx0XHRcdFx0XHRcdHRoaXMucHJvcHMudHJpZ2dlciAmJlxuXHRcdFx0XHRcdFx0XHR0aGlzLnByb3BzLnRyaWdnZXIucHJvcHMudGFiS2V5ID09PSBidXR0b24ua2V5XG5cdFx0XHRcdFx0XHRcdFx0PyAwXG5cdFx0XHRcdFx0XHRcdFx0OiAtMSxcblx0XHRcdFx0XHRcdHRyaWdnZXI6IHRoaXMucHJvcHMudHJpZ2dlcixcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGJ1dHRvbi5rZXlcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRwcm9wcyA9IHRoaXMubWVyZ2VEcm9wZG93blByb3BzKHByb3BzLCBidXR0b24ua2V5KTtcblxuXHRcdFx0XHRpZiAoYWRkaXRpb25hbFByb3BzKSB7XG5cdFx0XHRcdFx0cHJvcHMgPSBDS0VESVRPUi50b29scy5tZXJnZShwcm9wcywgYWRkaXRpb25hbFByb3BzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHByb3BzID0gQ0tFRElUT1IudG9vbHMubWVyZ2UocHJvcHMsIGJ1dHRvblByb3BzW2J1dHRvbi5rZXldKTtcblxuXHRcdFx0XHRyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChidXR0b24sIHByb3BzKTtcblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHRyZXR1cm4gdG9vbGJhckJ1dHRvbnM7XG5cdFx0fVxuXHR9O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIG1hbmFnaW5nIGRpZmZlcmVudCBkcm9wZG93bnMgaW5zaWRlIGEgd2lkZ2V0LlxuICpcbiAqIEBjbGFzcyBXaWRnZXREcm9wZG93blxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+XG5cdGNsYXNzIFdpZGdldERyb3Bkb3duIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdFx0dGhpcy5zdGF0ZSA9IHtcblx0XHRcdFx0Li4udGhpcy5zdGF0ZSxcblx0XHRcdFx0ZHJvcGRvd25UcmlnZ2VyOiBudWxsLFxuXHRcdFx0XHRpdGVtRHJvcGRvd246IG51bGwsXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIExpZmVjeWNsZS4gSW52b2tlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlY2VpdmluZyBuZXcgcHJvcHMuXG5cdFx0ICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG5cdFx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG5cdFx0ICovXG5cdFx0Y29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykpIHtcblx0XHRcdFx0c3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0ZHJvcGRvd25UcmlnZ2VyOiBudWxsLFxuXHRcdFx0XHRpdGVtRHJvcGRvd246IG51bGwsXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBNZXJnZXMgdGhlIHByb3ZpZGVkIG9iamVjdCB3aXRoIHR3byBtb3JlIHByb3BlcnRpZXM6XG5cdFx0ICogLSBleHBhbmRlZCAtIGJvb2xlYW4gZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgYW4gd2lkZ2V0IHNob3VsZCBiZSByZW5kZXJlZCBleGNsdXNpdmVseS5cblx0XHQgKiAtIHRvZ2dsZURyb3Bkb3duIC0gZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSB1c2VkIGJ5IGFuIHdpZGdldCBpbiBvcmRlciB0byBvYnRhaW4gZXhjbHVzaXZlIHN0YXRlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG5cdFx0ICogQG1ldGhvZCBtZXJnZURyb3Bkb3duUHJvcHNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBwcm9wZXJ0aWVzIGNvbnRhaW5lciB3aGljaCBzaG91bGQgYmUgbWVyZ2VkIHdpdGggdGhlIHByb3BlcnRpZXMsIHJlbGF0ZWRcblx0XHQgKiAgICB0byBkcm9wZG93biBzdGF0ZS5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbUtleSBUaGV5IGtleSBvZiBhbiBSZWFjdCBXaWRnZXQgd2hpY2ggY29udGFpbnMgdGhlIGRyb3Bkb3duLlxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1lcmdlZCBvYmplY3QuXG5cdFx0ICovXG5cdFx0bWVyZ2VEcm9wZG93blByb3BzID0gKG9iaiwgaXRlbUtleSkgPT4ge1xuXHRcdFx0cmV0dXJuIENLRURJVE9SLnRvb2xzLm1lcmdlKG9iaiwge1xuXHRcdFx0XHRleHBhbmRlZDogdGhpcy5zdGF0ZS5pdGVtRHJvcGRvd24gPT09IGl0ZW1LZXkgPyB0cnVlIDogZmFsc2UsXG5cdFx0XHRcdHRhYkluZGV4OiB0aGlzLnN0YXRlLmRyb3Bkb3duVHJpZ2dlciA9PT0gaXRlbUtleSA/IDAgOiAtMSxcblx0XHRcdFx0dG9nZ2xlRHJvcGRvd246IHRoaXMudG9nZ2xlRHJvcGRvd24uYmluZCh0aGlzLCBpdGVtS2V5KSxcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBTZXRzIHRoZSBhY3RpdmUgZHJvcGRvd24gb2YgdGhlIHdpZGdldCBvciBkaXNjYXJkcyB0aGUgdG9nZ2xlZCBpdGVtIGZyb20gdGhlIHN0YXRlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG5cdFx0ICogQG1ldGhvZCB0b2dnbGVEcm9wZG93blxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRHJvcGRvd24gVGhlIHdpZGdldCB3aGljaCByZXF1ZXN0cyB0byB0b2dnbGUgaXRzIGRyb3Bkb3duLlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB0b2dnbGVEaXJlY3Rpb24gVXNlciBtb3ZlbWVudCBkaXJlY3Rpb24gd2hlbiB0b2dnbGVkIHZpYSBrZXlib2FyZC5cblx0XHQgKi9cblx0XHR0b2dnbGVEcm9wZG93biA9IChpdGVtRHJvcGRvd24sIHRvZ2dsZURpcmVjdGlvbikgPT4ge1xuXHRcdFx0dGhpcy5zZXRTdGF0ZShcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGRyb3Bkb3duVHJpZ2dlcjogaXRlbURyb3Bkb3duLFxuXHRcdFx0XHRcdGl0ZW1Ecm9wZG93bjpcblx0XHRcdFx0XHRcdGl0ZW1Ecm9wZG93biAhPT0gdGhpcy5zdGF0ZS5pdGVtRHJvcGRvd25cblx0XHRcdFx0XHRcdFx0PyBpdGVtRHJvcGRvd25cblx0XHRcdFx0XHRcdFx0OiBudWxsLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHQoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLnN0YXRlLml0ZW1Ecm9wZG93bikge1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMubW92ZUZvY3VzKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMubW92ZUZvY3VzKHRvZ2dsZURpcmVjdGlvbik7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9O1xuXHR9O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5cbi8qKlxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgbWFuYWdpbmcgZXhjbHVzaXZlIHN0YXRlIG9mIGFuIHdpZGdldC5cbiAqIFRoZSBleGNsdXNpdmUgc3RhdGUgbWVhbnMgdGhhdCBhIGJ1dHRvbiBtYXkgcmVxdWVzdCB0byBiZSB0aGUgb25seSByZW5kZXJlZFxuICogd2lkZ2V0IGluIGl0cyBwYXJlbnQgY29udGFpbmVyLiBXaWRnZXRFeGNsdXNpdmUgd2lsbCBtYW5hZ2UgdGhpcyBzdGF0ZSBieVxuICogZmlsdGVyaW5nIGFuZCBzdXBwcmVzc2luZyB0aGUgb3RoZXIgc2libGluZyB3aWRnZXRzIGZyb20gZGlzcGxheWluZy5cbiAqXG4gKiBAY2xhc3MgV2lkZ2V0RXhjbHVzaXZlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT5cblx0Y2xhc3MgV2lkZ2V0RXhjbHVzaXZlIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0LyoqXG5cdFx0ICogQ2FuY2VscyB0aGUgZXhjbHVzaXZlIHN0YXRlIG9mIGFuIHdpZGdldC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcblx0XHQgKiBAbWV0aG9kIGNhbmNlbEV4Y2x1c2l2ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRXhjbHVzaXZlIFRoZSB3aWRnZXQgd2hpY2ggZXhjbHVzaXZlIHN0YXRlIHNob3VsZCBiZSBjYW5jZWxlZC5cblx0XHQgKi9cblx0XHRjYW5jZWxFeGNsdXNpdmUoaXRlbUV4Y2x1c2l2ZSkge1xuXHRcdFx0aWYgKHRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSA9PT0gaXRlbUV4Y2x1c2l2ZSkge1xuXHRcdFx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0XHRpdGVtRXhjbHVzaXZlOiBudWxsLFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBMaWZlY3ljbGUuIEludm9rZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZWNlaXZpbmcgbmV3IHByb3BzLlxuXHRcdCAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cblx0XHQgKiBDYWxsaW5nIHRoaXMuc2V0U3RhdGUoKSB3aXRoaW4gdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCB0cmlnZ2VyIGFuIGFkZGl0aW9uYWwgcmVuZGVyLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEV4Y2x1c2l2ZVxuXHRcdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBuZXh0UHJvcHMgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgc2V0IG9mIHByb3BlcnRpZXMuXG5cdFx0ICovXG5cdFx0Y29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykpIHtcblx0XHRcdFx0c3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZWNlaXZpbmcgcHJvcGVydGllcyBtZWFucyB0aGF0IHRoZSBjb21wb25lbnQgaXMgYmVpbmcgcmUtcmVuZGVyZWQuXG5cdFx0XHQvLyBSZS1yZW5kZXJpbmcgaXMgdHJpZ2dlcmVkIGJ5IGVkaXRvckludGVyYWN0aW9uLCBzbyB3ZSBoYXZlIHRvXG5cdFx0XHQvLyByZXNldCB0aGUgZXhjbHVzaXZlIHN0YXRlIGFuZCByZW5kZXIgdGhlIFVJIGFjY29yZGluZyB0byB0aGUgbmV3IHNlbGVjdGlvbi5cblxuXHRcdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRcdGl0ZW1FeGNsdXNpdmU6IG51bGwsXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBGaWx0ZXJzIHRoZSBpdGVtcyBhbmQgcmV0dXJucyBvbmx5IHRob3NlIHdpdGggZXhjbHVzaXZlIHN0YXRlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEV4Y2x1c2l2ZVxuXHRcdCAqIEBtZXRob2QgZmlsdGVyRXhjbHVzaXZlXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gaXRlbXMgVGhlIHdpZGdldHMgdG8gYmUgZmlsdGVyZWQuXG5cdFx0ICogQHJldHVybiB7QXJyYXl8T2JqZWN0fSBUaGUgaXRlbSB3aXRoIGV4ZWN1dGl2ZSBzdGF0ZS5cblx0XHQgKi9cblx0XHRmaWx0ZXJFeGNsdXNpdmUoaXRlbXMpIHtcblx0XHRcdHJldHVybiBpdGVtcy5maWx0ZXIoaXRlbSA9PiB7XG5cdFx0XHRcdGlmICh0aGlzLnN0YXRlLml0ZW1FeGNsdXNpdmUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5zdGF0ZS5pdGVtRXhjbHVzaXZlID09PSBpdGVtLmtleSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBNZXJnZXMgdGhlIHByb3ZpZGVkIG9iamVjdCB3aXRoIHRocmVlIG1vcmUgcHJvcGVydGllczpcblx0XHQgKiAtIGNhbmNlbEV4Y2x1c2l2ZSAtIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgdXNlZCBieSBhIHdpZGdldCBpbiBvcmRlciB0byBjYW5jZWwgZXhlY3V0aXZlIHN0YXRlLlxuXHRcdCAqIC0gcmVuZGVyRXhjbHVzaXZlIC0gYm9vbGVhbiBmbGFnIHdoaWNoIGluZGljYXRlcyBpZiBhbiB3aWRnZXQgc2hvdWxkIGJlIHJlbmRlcmVkIGV4Y2x1c2l2ZWx5LlxuXHRcdCAqIC0gcmVxdWVzdEV4Y2x1c2l2ZSAtIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgdXNlZCBieSBhIHdpZGdldCBpbiBvcmRlciB0byBvYnRhaW4gZXhjbHVzaXZlIHN0YXRlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEV4Y2x1c2l2ZVxuXHRcdCAqIEBtZXRob2QgbWVyZ2VFeGNsdXNpdmVQcm9wc1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIHByb3BlcnRpZXMgY29udGFpbmVyIHdoaWNoIHNob3VsZCBiZSBtZXJnZWQgd2l0aCB0aGUgcHJvcGVydGllcywgcmVsYXRlZFxuXHRcdCAqICAgIHRvIGV4Y2x1c2l2ZSBzdGF0ZS5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbUtleSBUaGV5IGtleSBvZiBhbiBSZWFjdCBXaWRnZXQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkIGV4Y2x1c2l2ZWx5LlxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1lcmdlZCBvYmplY3QuXG5cdFx0ICovXG5cdFx0bWVyZ2VFeGNsdXNpdmVQcm9wcyhvYmosIGl0ZW1LZXkpIHtcblx0XHRcdHJldHVybiBDS0VESVRPUi50b29scy5tZXJnZShvYmosIHtcblx0XHRcdFx0Y2FuY2VsRXhjbHVzaXZlOiB0aGlzLmNhbmNlbEV4Y2x1c2l2ZS5iaW5kKHRoaXMsIGl0ZW1LZXkpLFxuXHRcdFx0XHRyZW5kZXJFeGNsdXNpdmU6IHRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSA9PT0gaXRlbUtleSxcblx0XHRcdFx0cmVxdWVzdEV4Y2x1c2l2ZTogdGhpcy5yZXF1ZXN0RXhjbHVzaXZlLmJpbmQodGhpcywgaXRlbUtleSksXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXF1ZXN0cyBhbmQgc2V0cyBleGNsdXNpdmUgc3RhdGUgb2YgYW4gd2lkZ2V0LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEV4Y2x1c2l2ZVxuXHRcdCAqIEBtZXRob2QgcmVxdWVzdEV4Y2x1c2l2ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRXhjbHVzaXZlIFRoZSB3aWRnZXQgd2hpY2ggcmVxdWVzdHMgZXhjbHVzaXZlIHN0YXRlLlxuXHRcdCAqL1xuXHRcdHJlcXVlc3RFeGNsdXNpdmUgPSBpdGVtRXhjbHVzaXZlID0+IHtcblx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRpdGVtRXhjbHVzaXZlLFxuXHRcdFx0fSk7XG5cdFx0fTtcblx0fTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbmltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nJztcblxuY29uc3QgRElSRUNUSU9OX05PTkUgPSAwO1xuY29uc3QgRElSRUNUSU9OX05FWFQgPSAxO1xuY29uc3QgRElSRUNUSU9OX1BSRVYgPSAtMTtcblxuY29uc3QgQUNUSU9OX05PTkUgPSAwO1xuY29uc3QgQUNUSU9OX01PVkVfRk9DVVMgPSAxO1xuY29uc3QgQUNUSU9OX0RJU01JU1NfRk9DVVMgPSAyO1xuXG4vKipcbiAqIFdpZGdldEZvY3VzTWFuYWdlciBpcyBhIG1peGluIHRoYXQgcHJvdmlkZXMga2V5Ym9hcmQgbmF2aWdhdGlvbiBpbnNpZGUgYSB3aWRnZXQuIFRvIGRvIHRoaXMsXG4gKiBpdCBleHBvc2VzIHRoZSBmb2xsb3dpbmcgcHJvcHMgYW5kIG1ldGhvZHM6XG4gKlxuICogQGNsYXNzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+XG5cdGNsYXNzIFdpZGdldEZvY3VzTWFuYWdlciBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuXHRcdC8qKlxuXHRcdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdFx0ICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuXHRcdCAqL1xuXHRcdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdFx0aWYgKExhbmcuaXNGdW5jdGlvbihzdXBlci5jb21wb25lbnREaWRNb3VudCkpIHtcblx0XHRcdFx0c3VwZXIuY29tcG9uZW50RGlkTW91bnQoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50J3MgdXBkYXRlcyBhcmUgZmx1c2hlZCB0byB0aGUgRE9NLlxuXHRcdCAqIFJlZnJlc2hlcyB0aGUgZGVzY2VuZGFudHMgbGlzdC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0XHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZFVwZGF0ZVxuXHRcdCAqL1xuXHRcdGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50RGlkVXBkYXRlKSkge1xuXHRcdFx0XHRzdXBlci5jb21wb25lbnREaWRVcGRhdGUoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEZvY3VzZXMgdGhlIGN1cnJlbnQgYWN0aXZlIGRlc2NlbmRhbnQuXG5cdFx0ICpcblx0XHQgKiBTZXZlcmFsIFdpZGdldHMgY2FuIGJlIG5lc3RlZCBpbiBhIGNvbXBvbmVudCBoaWVyYXJjaHkgYnkgYXR0YWNoaW5nIHRoaXMgZm9jdXMgbWV0aG9kIHRvXG5cdFx0ICogdGhlIHdpZGdldCBET00gbm9kZSwgdHJhbnNmZXJyaW5nIHRoZSBET00gZm9jdXMgY29udHJvbCB0byB0aGUgaW5uZXIgRm9jdXNNYW5hZ2VyLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBtZXRob2QgZm9jdXNcblx0XHQgKi9cblx0XHRmb2N1cyA9IGV2ZW50ID0+IHtcblx0XHRcdGlmICghZXZlbnQgfHwgdGhpcy5faXNWYWxpZFRhcmdldChldmVudC50YXJnZXQpKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kZXNjZW5kYW50cyAmJiB0aGlzLl9kZXNjZW5kYW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRjb25zdCBhY3RpdmVEZXNjZW5kYW50RWwgPSB0aGlzLl9kZXNjZW5kYW50c1tcblx0XHRcdFx0XHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnRcblx0XHRcdFx0XHRdO1xuXG5cdFx0XHRcdFx0Ly8gV2hlbiB1c2VyIGNsaWNrcyB3aXRoIHRoZSBtb3VzZSwgdGhlIGFjdGl2ZUVsZW1lbnQgaXMgYWxyZWFkeSBzZXQgYW5kIHRoZXJlXG5cdFx0XHRcdFx0Ly8gaXMgbm8gbmVlZCB0byBmb2N1cyBpdC4gRm9jdXNpbmcgb2YgdGhlIGFjdGl2ZSBkZXNjZW5kYW50ICh1c3VhbGx5IHNvbWUgYnV0dG9uKSBpcyByZXF1aXJlZFxuXHRcdFx0XHRcdC8vIGluIGNhc2Ugb2Yga2V5Ym9hcmQgbmF2aWdhdGlvbiwgYmVjYXVzZSB0aGUgZm9jdXNlZCBlbGVtZW50IG1pZ2h0IGJlIG5vdCB0aGUgZmlyc3QgYnV0dG9uLFxuXHRcdFx0XHRcdC8vIGJ1dCB0aGUgZGl2IGVsZW1lbnQsIHdoaWNoIGNvbnRhaW5zIHRoZSBidXR0b24uXG5cblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBhY3RpdmVEZXNjZW5kYW50RWwgJiZcblx0XHRcdFx0XHRcdCF0aGlzLnByb3BzLmZvY3VzRmlyc3RDaGlsZFxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHR0aGlzLl9kZXNjZW5kYW50cy5pbmRleE9mKFxuXHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcblx0XHRcdFx0XHRcdFx0KSA9PT0gLTFcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRhY3RpdmVEZXNjZW5kYW50RWwuZm9jdXMoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZXZlbnQpIHtcblx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlcyB0aGUga2V5IGV2ZW50cyBvbiBhIERPTSBub2RlIHRvIGV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIG5hdmlnYXRpb24gd2hlbiBuZWVkZWQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBLZXlib2FyZCBldmVudCB0aGF0IHdhcyBkZXRlY3RlZCBvbiB0aGUgd2lkZ2V0IERPTSBub2RlLlxuXHRcdCAqIEBtZXRob2QgaGFuZGxlS2V5XG5cdFx0ICovXG5cdFx0aGFuZGxlS2V5ID0gZXZlbnQgPT4ge1xuXHRcdFx0aWYgKHRoaXMuX2lzVmFsaWRUYXJnZXQoZXZlbnQudGFyZ2V0KSAmJiB0aGlzLl9kZXNjZW5kYW50cykge1xuXHRcdFx0XHRjb25zdCBhY3Rpb24gPSB0aGlzLl9nZXRGb2N1c0FjdGlvbihldmVudCk7XG5cblx0XHRcdFx0aWYgKGFjdGlvbi50eXBlKSB7XG5cdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHRcdGlmIChhY3Rpb24udHlwZSA9PT0gQUNUSU9OX01PVkVfRk9DVVMpIHtcblx0XHRcdFx0XHRcdHRoaXMuX21vdmVGb2N1cyhhY3Rpb24uZGlyZWN0aW9uKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoYWN0aW9uLnR5cGUgPT09IEFDVElPTl9ESVNNSVNTX0ZPQ1VTKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnByb3BzLm9uRGlzbWlzcyhhY3Rpb24uZGlyZWN0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogTW92ZXMgdGhlIGZvY3VzIGFtb25nIGRlc2NlbmRhbnRzIGluIHRoZSBlc3BlY2lmaWVkIGRpcmVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0XHQgKiBAbWV0aG9kIG1vdmVGb2N1c1xuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiAoMSBvciAtMSkgb2YgdGhlIGZvY3VzIG1vdmVtZW50IGFtb25nIGRlc2NlbmRhbnRzLlxuXHRcdCAqL1xuXHRcdG1vdmVGb2N1cyhkaXJlY3Rpb24pIHtcblx0XHRcdGRpcmVjdGlvbiA9IExhbmcuaXNOdW1iZXIoZGlyZWN0aW9uKSA/IGRpcmVjdGlvbiA6IDA7XG5cblx0XHRcdHRoaXMuX21vdmVGb2N1cyhkaXJlY3Rpb24pO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIGFjdGlvbiwgaWYgYW55LCB0aGF0IGEga2V5Ym9hcmQgZXZlbnQgaW4gdGhlIGN1cnJlbnQgZm9jdXMgbWFuYWdlciBzdGF0ZVxuXHRcdCAqIHNob3VsZCBwcm9kdWNlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBtZXRob2QgX2dldEZvY3VzQWN0aW9uXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBLZXlib2FyZCBldmVudC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBhY3Rpb24gb2JqZWN0IHdpdGggdHlwZSBhbmQgZGlyZWN0aW9uIHByb3BlcnRpZXMuXG5cdFx0ICovXG5cdFx0X2dldEZvY3VzQWN0aW9uKGV2ZW50KSB7XG5cdFx0XHRjb25zdCBhY3Rpb24gPSB7XG5cdFx0XHRcdHR5cGU6IEFDVElPTl9OT05FLFxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKHRoaXMucHJvcHMua2V5cykge1xuXHRcdFx0XHRjb25zdCBkaXJlY3Rpb24gPSB0aGlzLl9nZXRGb2N1c01vdmVEaXJlY3Rpb24oZXZlbnQpO1xuXG5cdFx0XHRcdGlmIChkaXJlY3Rpb24pIHtcblx0XHRcdFx0XHRhY3Rpb24uZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuXHRcdFx0XHRcdGFjdGlvbi50eXBlID0gQUNUSU9OX01PVkVfRk9DVVM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBkaXNtaXNzQWN0aW9uID0gdGhpcy5fZ2V0Rm9jdXNEaXNtaXNzQWN0aW9uKFxuXHRcdFx0XHRcdGV2ZW50LFxuXHRcdFx0XHRcdGRpcmVjdGlvblxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmIChkaXNtaXNzQWN0aW9uLmRpc21pc3MpIHtcblx0XHRcdFx0XHRhY3Rpb24uZGlyZWN0aW9uID0gZGlzbWlzc0FjdGlvbi5kaXJlY3Rpb247XG5cdFx0XHRcdFx0YWN0aW9uLnR5cGUgPSBBQ1RJT05fRElTTUlTU19GT0NVUztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYWN0aW9uO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIGRpc21pc3MgYWN0aW9uLCBpZiBhbnksIHRoZSBmb2N1cyBtYW5hZ2VyIHNob3VsZCBleGVjdXRlIHRvIHlpZWxkIHRoZSBmb2N1cy4gVGhpc1xuXHRcdCAqIHdpbGwgaGFwcGVuIGluIGFueSBvZiB0aGVzZSBzY2VuYXJpb3MgaWYgYSBkaXNtaXNzIGNhbGxiYWNrIGhhcyBiZWVuIHNwZWNpZmllZDpcblx0XHQgKiAtIEEgZGlzbWlzcyBrZXkgaGFzIGJlZW4gcHJlc3NlZFxuXHRcdCAqIC0gSW4gYSBub24tY2lyY3VsYXIgZm9jdXMgbWFuYWdlciwgd2hlbjpcblx0XHQgKiAgICAgLSBUaGUgYWN0aXZlIGRlc2NlbmRhbnQgaXMgdGhlIGZpcnN0IG9uZSBhbmQgYSBwcmV2IGtleSBoYXMgYmVlbiBwcmVzc2VkLlxuXHRcdCAqICAgICAtIFRoZSBhY3RpdmUgZGVzY2VuZGFudCBpcyB0aGUgbGFzdCBvbmUgYW5kIGEgbmV4dCBrZXkgaGFzIGJlZW4gcHJlc3NlZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0XHQgKiBAbWV0aG9kIF9nZXRGb2N1c0Rpc21pc3NBY3Rpb25cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gZm9jdXNNb3ZlRGlyZWN0aW9uIFRoZSBmb2N1cyBtb3ZlbWVudCBkaXJlY3Rpb24gKGlmIGFueSkuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBLZXlib2FyZCBldmVudC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBBIGRpc21pc3MgYWN0aW9uIHdpdGggZGlzbWlzcyBhbmQgZGlyZWN0aW9uIHByb3BlcnRpZXMuXG5cdFx0ICovXG5cdFx0X2dldEZvY3VzRGlzbWlzc0FjdGlvbihldmVudCwgZm9jdXNNb3ZlRGlyZWN0aW9uKSB7XG5cdFx0XHRjb25zdCBkaXNtaXNzQWN0aW9uID0ge1xuXHRcdFx0XHRkaXJlY3Rpb246IGZvY3VzTW92ZURpcmVjdGlvbixcblx0XHRcdFx0ZGlzbWlzczogZmFsc2UsXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAodGhpcy5wcm9wcy5vbkRpc21pc3MpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2lzVmFsaWRLZXkoZXZlbnQua2V5Q29kZSwgdGhpcy5wcm9wcy5rZXlzLmRpc21pc3MpKSB7XG5cdFx0XHRcdFx0ZGlzbWlzc0FjdGlvbi5kaXNtaXNzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy5faXNWYWxpZEtleShldmVudC5rZXlDb2RlLCB0aGlzLnByb3BzLmtleXMuZGlzbWlzc05leHQpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGRpc21pc3NBY3Rpb24uZGlzbWlzcyA9IHRydWU7XG5cdFx0XHRcdFx0ZGlzbWlzc0FjdGlvbi5kaXJlY3Rpb24gPSBESVJFQ1RJT05fTkVYVDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy5faXNWYWxpZEtleShldmVudC5rZXlDb2RlLCB0aGlzLnByb3BzLmtleXMuZGlzbWlzc1ByZXYpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGRpc21pc3NBY3Rpb24uZGlzbWlzcyA9IHRydWU7XG5cdFx0XHRcdFx0ZGlzbWlzc0FjdGlvbi5kaXJlY3Rpb24gPSBESVJFQ1RJT05fUFJFVjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQhZGlzbWlzc0FjdGlvbi5kaXNtaXNzICYmXG5cdFx0XHRcdFx0IXRoaXMucHJvcHMuY2lyY3VsYXIgJiZcblx0XHRcdFx0XHRmb2N1c01vdmVEaXJlY3Rpb25cblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZGlzbWlzc0FjdGlvbi5kaXNtaXNzID1cblx0XHRcdFx0XHRcdChmb2N1c01vdmVEaXJlY3Rpb24gPT09IERJUkVDVElPTl9QUkVWICYmXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgPT09IDApIHx8XG5cdFx0XHRcdFx0XHQoZm9jdXNNb3ZlRGlyZWN0aW9uID09PSBESVJFQ1RJT05fTkVYVCAmJlxuXHRcdFx0XHRcdFx0XHR0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID09PVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2Rlc2NlbmRhbnRzLmxlbmd0aCAtIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkaXNtaXNzQWN0aW9uO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIGRpcmVjdGlvbiwgaWYgYW55LCBpbiB3aGljaCB0aGUgZm9jdXMgc2hvdWxkIGJlIG1vdmVkLiBJbiBwcmVzZW5jZSBvZiB0aGVcblx0XHQgKiBzaGlmdCBrZXkgbW9kaWZpZXIsIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG1vdmVtZW50IGlzIGludmVydGVkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBtZXRob2QgX2dldEZvY3VzTW92ZURpcmVjdGlvblxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgS2V5Ym9hcmQgZXZlbnQuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNvbXB1dGVkIGRpcmVjdGlvbiBvZiB0aGUgZXhwZWN0ZWQgZm9jdXMgbW92ZW1lbnQuXG5cdFx0ICovXG5cdFx0X2dldEZvY3VzTW92ZURpcmVjdGlvbihldmVudCkge1xuXHRcdFx0bGV0IGRpcmVjdGlvbiA9IERJUkVDVElPTl9OT05FO1xuXG5cdFx0XHRpZiAodGhpcy5faXNWYWxpZEtleShldmVudC5rZXlDb2RlLCB0aGlzLnByb3BzLmtleXMubmV4dCkpIHtcblx0XHRcdFx0ZGlyZWN0aW9uID0gRElSRUNUSU9OX05FWFQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5faXNWYWxpZEtleShldmVudC5rZXlDb2RlLCB0aGlzLnByb3BzLmtleXMucHJldikpIHtcblx0XHRcdFx0ZGlyZWN0aW9uID0gRElSRUNUSU9OX1BSRVY7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChldmVudC5zaGlmS2V5KSB7XG5cdFx0XHRcdGRpcmVjdGlvbiAqPSAtMTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRpcmVjdGlvbjtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYgYSBnaXZlbiBrZXlDb2RlIGlzIHZhbGlkIGZvciB0aGUgZ2l2ZW4gc2V0IG9mIGtleXMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdFx0ICogQG1ldGhvZCBfaXNWYWxpZEtleVxuXHRcdCAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfSBrZXlzIEEga2V5IHNldC4gQ2FuIGJlIGEgbnVtYmVyIGFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBhbGxvd2VkIGtleUNvZGVzLlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBrZXlDb2RlIEFuIGV2ZW50IGtleUNvZGUuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoZSBrZXkgaXMgdmFsaWQuXG5cdFx0ICovXG5cdFx0X2lzVmFsaWRLZXkoa2V5Q29kZSwga2V5cykge1xuXHRcdFx0cmV0dXJuIExhbmcuaXNBcnJheShrZXlzKVxuXHRcdFx0XHQ/IGtleXMuaW5kZXhPZihrZXlDb2RlKSAhPT0gLTFcblx0XHRcdFx0OiBrZXlDb2RlID09PSBrZXlzO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiBhIGdpdmVuIGVsZW1lbnQgaXMgdmFsaWQgZm9yIGZvY3VzIG1hbmFnZW1lbnQuIFVzZXIgaW5wdXQgZWxlbWVudHMgc3VjaCBhc1xuXHRcdCAqIGlucHV0LCBzZWxlY3Qgb3IgdGV4dGFyZWEgYXJlIGV4Y2x1ZGVkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBtZXRob2QgX2lzVmFsaWRLZXlcblx0XHQgKiBAcGFyYW0ge0RPTU5vZGV9IGVsZW1lbnQgQSBET00gZWxlbWVudC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgaWYgdGhlIGVsZW1lbnQgaXMgdmFsaWQuXG5cdFx0ICovXG5cdFx0X2lzVmFsaWRUYXJnZXQoZWxlbWVudCkge1xuXHRcdFx0Y29uc3QgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHR0YWdOYW1lICE9PSAnaW5wdXQnICYmXG5cdFx0XHRcdHRhZ05hbWUgIT09ICdzZWxlY3QnICYmXG5cdFx0XHRcdHRhZ05hbWUgIT09ICd0ZXh0YXJlYSdcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogTW92ZXMgdGhlIGZvY3VzIGFtb25nIGRlc2NlbmRhbnRzIGluIHRoZSBlc3BlY2lmaWVkIGRpcmVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0XHQgKiBAbWV0aG9kIF9tb3ZlRm9jdXNcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gKDEgb3IgLTEpIG9mIHRoZSBmb2N1cyBtb3ZlbWVudCBhbW9uZyBkZXNjZW5kYW50cy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X21vdmVGb2N1cyhkaXJlY3Rpb24pIHtcblx0XHRcdGNvbnN0IG51bURlc2NlbmRhbnRzID0gdGhpcy5fZGVzY2VuZGFudHMubGVuZ3RoO1xuXG5cdFx0XHRsZXQgZGVzY2VuZGFudCA9IHRoaXMuX2Rlc2NlbmRhbnRzW3RoaXMuX2FjdGl2ZURlc2NlbmRhbnRdO1xuXG5cdFx0XHRkZXNjZW5kYW50LnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAtMSk7XG5cblx0XHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgKz0gZGlyZWN0aW9uO1xuXG5cdFx0XHRpZiAodGhpcy5wcm9wcy5jaXJjdWxhcikge1xuXHRcdFx0XHQvLyBDYWxjdWxhdGUgcHJvcGVyIG1vZHVsbyByZXN1bHQgc2luY2UgcmVtYWluZGVyIG9wZXJhdG9yIGRvZXNuJ3QgYmVoYXZlIGluIHRoZVxuXHRcdFx0XHQvLyBzYW1lIHdheSBmb3IgbmVnYXRpdmUgbnVtYmVyc1xuXG5cdFx0XHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgPVxuXHRcdFx0XHRcdCgodGhpcy5fYWN0aXZlRGVzY2VuZGFudCAlIG51bURlc2NlbmRhbnRzKSArXG5cdFx0XHRcdFx0XHRudW1EZXNjZW5kYW50cykgJVxuXHRcdFx0XHRcdG51bURlc2NlbmRhbnRzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZlRGVzY2VuZGFudCA9IE1hdGgubWF4KFxuXHRcdFx0XHRcdE1hdGgubWluKHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQsIG51bURlc2NlbmRhbnRzIC0gMSksXG5cdFx0XHRcdFx0MFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZXNjZW5kYW50ID0gdGhpcy5fZGVzY2VuZGFudHNbdGhpcy5fYWN0aXZlRGVzY2VuZGFudF07XG5cblx0XHRcdGRlc2NlbmRhbnQuc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIDApO1xuXHRcdFx0ZGVzY2VuZGFudC5mb2N1cygpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJlZnJlc2hlcyB0aGUgZGVzY2VuZGFudHMgbGlzdCBieSBleGVjdXRpbmcgdGhlIENTUyBzZWxlY3RvciBhZ2FpbiBhbmQgcmVzZXRzIHRoZSBkZXNjZW5kYW50cyB0YWJJbmRleC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0XHQgKiBAbWV0aG9kIF9yZWZyZXNoXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9yZWZyZXNoKCkge1xuXHRcdFx0Y29uc3QgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG5cdFx0XHRpZiAoZG9tTm9kZSkge1xuXHRcdFx0XHRjb25zdCBkZXNjZW5kYW50cyA9IGRvbU5vZGUucXVlcnlTZWxlY3RvckFsbChcblx0XHRcdFx0XHR0aGlzLnByb3BzLmRlc2NlbmRhbnRzXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0bGV0IHByaW9yaXR5RGVzY2VuZGFudHMgPSBbXTtcblxuXHRcdFx0XHR0aGlzLl9kZXNjZW5kYW50cyA9IFtdO1xuXG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRlc2NlbmRhbnRzKS5mb3JFYWNoKGl0ZW0gPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGRhdGFUYWJJbmRleCA9IGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLXRhYmluZGV4Jyk7XG5cblx0XHRcdFx0XHRpZiAoZGF0YVRhYkluZGV4KSB7XG5cdFx0XHRcdFx0XHRwcmlvcml0eURlc2NlbmRhbnRzLnB1c2goaXRlbSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuX2Rlc2NlbmRhbnRzLnB1c2goaXRlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRwcmlvcml0eURlc2NlbmRhbnRzID0gcHJpb3JpdHlEZXNjZW5kYW50cy5zb3J0KChhLCBiKSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdExhbmcudG9JbnQoYS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFiaW5kZXgnKSkgPlxuXHRcdFx0XHRcdFx0TGFuZy50b0ludChiLmdldEF0dHJpYnV0ZSgnZGF0YS10YWJpbmRleCcpKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRoaXMuX2Rlc2NlbmRhbnRzID0gcHJpb3JpdHlEZXNjZW5kYW50cy5jb25jYXQoXG5cdFx0XHRcdFx0dGhpcy5fZGVzY2VuZGFudHNcblx0XHRcdFx0KTtcblxuXHRcdFx0XHR0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID0gMDtcblxuXHRcdFx0XHR0aGlzLl9kZXNjZW5kYW50cy5zb21lKChpdGVtLCBpbmRleCkgPT4ge1xuXHRcdFx0XHRcdGlmIChpdGVtLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSA9PT0gJzAnKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID0gaW5kZXg7XG5cdFx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25BY2Nlc3NpYmlsaXR5SW1hZ2VBbHQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2hhbmdpbmcgdGV4dCBjb2xvciBpbiBhIGRvY3VtZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25BY2Nlc3NpYmlsaXR5SW1hZ2VBbHRcbiAqXG4gKi9cbmNsYXNzIEJ1dHRvbkFjY2Vzc2liaWxpdHlJbWFnZUFsdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0c3RhdGljIGtleSA9ICdpbWFnZUFsdCc7XG5cblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHR0aGlzLnN0YXRlID0gdGhpcy5fZ2V0SW5pdGlhbFN0YXRlKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogRm9jdXNlcyBvbiB0aGUgbGluayBpbnB1dCB0byBpbW1lZGlhdGVseSBhbGxvdyBlZGl0aW5nLiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGUgY29tcG9uZW50XG5cdCAqIGlzIHJlbmRlcmVkIGluIGV4Y2x1c2l2ZSBtb2RlIHRvIHByZXZlbnQgYWdncmVzc2l2ZSBmb2N1cyBzdGVhbGluZy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25BY2Nlc3NpYmlsaXR5SW1hZ2VBbHRcblx0ICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0aWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlIHx8IHRoaXMucHJvcHMubWFudWFsU2VsZWN0aW9uKSB7XG5cdFx0XHQvLyBXZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZSBiZWZvcmUgZm9jdXNpbmcgdG8gYXZvaWQgdW5kZXNpcmVkXG5cdFx0XHQvLyBzY3JvbGxzIG9uIHRoZSBwYWdlXG5cblx0XHRcdHRoaXMuX2ZvY3VzQWx0SW5wdXQoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVjZWl2aW5nIG5ldyBwcm9wcy5cblx0ICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkFjY2Vzc2liaWxpdHlJbWFnZUFsdFxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcblx0ICovXG5cdGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKSB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh0aGlzLl9nZXRJbml0aWFsU3RhdGUoKSk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhpcy5zdGF0ZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25BY2Nlc3NpYmlsaXR5SW1hZ2VBbHRcblx0ICogQG1ldGhvZCBfZ2V0SW5pdGlhbFN0YXRlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKi9cblx0X2dldEluaXRpYWxTdGF0ZSgpIHtcblx0XHQvLyBDYW4ndCBhY2Nlc3MgY29udGV4dCBmcm9tIGNvbnRydWN0b3IsIHNvIGdldCBlZGl0b3IgZnJvbSBwcm9wcy5cblxuXHRcdGNvbnN0IHtlZGl0b3J9ID0gdGhpcy5wcm9wcy5jb250ZXh0O1xuXG5cdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJykuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRjb25zdCBlbGVtZW50ID1cblx0XHRcdHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKSB8fCBzZWxlY3Rpb24uZ2V0U3RhcnRFbGVtZW50KCk7XG5cblx0XHR0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcblxuXHRcdGNvbnN0IGltYWdlRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQuZmluZE9uZSgnaW1nJyk7XG5cblx0XHRjb25zdCBpbWFnZUFsdCA9IGltYWdlRWxlbWVudFxuXHRcdFx0PyBpbWFnZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhbHQnKVxuXHRcdFx0OiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnYWx0Jyk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0aW1hZ2VBbHQsXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZWRpdC1saW5rXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItaW5wdXQgeHhsXCI+XG5cdFx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdFx0YXJpYS1sYWJlbD1cImFsdFwiXG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWlucHV0XCJcblx0XHRcdFx0XHRcdFx0b25DaGFuZ2U9e3RoaXMuX2hhbmRsZUFsdENoYW5nZX1cblx0XHRcdFx0XHRcdFx0b25LZXlEb3duPXt0aGlzLl9oYW5kbGVLZXlEb3dufVxuXHRcdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj1cImFsdFwiXG5cdFx0XHRcdFx0XHRcdHJlZj1cInJlZkFsdElucHV0XCJcblx0XHRcdFx0XHRcdFx0dGl0bGU9XCJhbHRcIlxuXHRcdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHRcdHZhbHVlPXt0aGlzLnN0YXRlLmltYWdlQWx0fVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbmZpcm19XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdFx0b25DbGljaz17dGhpcy5fdXBkYXRlSW1hZ2VBbHR9XG5cdFx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5jb25maXJtfT5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNoZWNrXCIgLz5cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9yZXF1ZXN0RXhjbHVzaXZlfVxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fT5cblx0XHRcdFx0XHQ8c21hbGwgY2xhc3NOYW1lPVwiYWUtaWNvbiBzbWFsbFwiPkFsdDwvc21hbGw+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRm9jdXNlcyB0aGUgdXNlciBjdXJzb3Igb24gdGhlIHdpZGdldCdzIGlucHV0LlxuXHQgKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX2ZvY3VzQWx0SW5wdXRcblx0ICovXG5cdF9mb2N1c0FsdElucHV0KCkge1xuXHRcdGNvbnN0IGluc3RhbmNlID0gdGhpcztcblxuXHRcdGNvbnN0IGZvY3VzQWx0RWwgPSBmdW5jdGlvbigpIHtcblx0XHRcdFJlYWN0RE9NLmZpbmRET01Ob2RlKGluc3RhbmNlLnJlZnMucmVmQWx0SW5wdXQpLmZvY3VzKCk7XG5cdFx0fTtcblxuXHRcdGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZvY3VzQWx0RWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZXRUaW1lb3V0KGZvY3VzQWx0RWwsIDApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFdmVudCBhdHRhY2hlZCB0byBhbHQgaW5wdXQgdGhhdCBmaXJlcyB3aGVuIGl0cyB2YWx1ZSBpcyBjaGFuZ2VkXG5cdCAqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCAgX2hhbmRsZUFsdENoYW5nZVxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG5cdCAqL1xuXHRfaGFuZGxlQWx0Q2hhbmdlID0gZXZlbnQgPT4ge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0aW1hZ2VBbHQ6IGV2ZW50LnRhcmdldC52YWx1ZSxcblx0XHR9KTtcblxuXHRcdHRoaXMuX2ZvY3VzQWx0SW5wdXQoKTtcblx0fTtcblxuXHQvKipcblx0ICogRXZlbnQgYXR0YWNoZWQgdG8gYWwgdGlucHV0IHRoYXQgZmlyZXMgd2hlbiBrZXkgaXMgZG93blxuXHQgKiBUaGlzIG1ldGhvZCBjaGVjayB0aGF0IGVudGVyIGtleSBpcyBwdXNoZWQgdG8gdXBkYXRlIHRoZSBjb21wb25lbnTCtHMgc3RhdGVcblx0ICpcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kICBfaGFuZGxlS2V5RG93blxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG5cdCAqL1xuXHRfaGFuZGxlS2V5RG93biA9IGV2ZW50ID0+IHtcblx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUltYWdlQWx0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0cyB0aGUgbGluayBidXR0b24gdG8gYmUgcmVuZGVyZWQgaW4gZXhjbHVzaXZlIG1vZGUgdG8gYWxsb3cgdGhlIGNyZWF0aW9uIG9mIGEgbGluay5cblx0ICpcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF9yZXF1ZXN0RXhjbHVzaXZlXG5cdCAqL1xuXHRfcmVxdWVzdEV4Y2x1c2l2ZSA9ICgpID0+IHtcblx0XHR0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmUoQnV0dG9uQWNjZXNzaWJpbGl0eUltYWdlQWx0LmtleSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1ldGhvZCBjYWxsZWQgYnkgY2xpY2tpbmcgb2sgYnV0dG9uIG9yIHB1c2hpbmcga2V5IGVudGVyIHRvIHVwZGF0ZSBpbWFnZUFsdCBzdGF0ZSBhbmQgdG8gdXBkYXRlIGFsdCBwcm9wZXJ0eSBmcm9tIHRoZSBpbWFnZSB0aGF0IGlzIHNlbGVjdGVkXG5cdCAqIFRoaXMgbWV0aG9kIGNhbGxzIGNhbmNlbEV4Y2x1c2l2ZSB0byBzaG93IHRoZSBwcmV2aW91cyB0b29sYmFyIGJlZm9yZSBlbnRlciB0byBlZGl0IGFsdCBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgIF91cGRhdGVJbWFnZUFsdFxuXHQgKi9cblx0X3VwZGF0ZUltYWdlQWx0ID0gKCkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGNvbnN0IGltYWdlQWx0ID0gdGhpcy5yZWZzLnJlZkFsdElucHV0LnZhbHVlO1xuXG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRpbWFnZUFsdCxcblx0XHR9KTtcblxuXHRcdGNvbnN0IGltYWdlRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQuZmluZE9uZSgnaW1nJyk7XG5cdFx0Y29uc3QgaW1hZ2UgPSBpbWFnZUVsZW1lbnQgPyBpbWFnZUVsZW1lbnQgOiB0aGlzLl9lbGVtZW50O1xuXG5cdFx0aW1hZ2Uuc2V0QXR0cmlidXRlKCdhbHQnLCBpbWFnZUFsdCk7XG5cblx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cblx0XHQvLyBXZSBuZWVkIHRvIGNhbmNlbEV4Y2x1c2l2ZSB3aXRoIHRoZSBib3VuZCBwYXJhbWV0ZXJzIGluIGNhc2UgdGhlIGJ1dHRvbiBpcyB1c2VkXG5cdFx0Ly8gaW5zaWRlIGFub3RoZXIgaW4gZXhjbHVzaXZlIG1vZGUgKHN1Y2ggaXMgdGhlIGNhc2Ugb2YgdGhlIGFsdCBidXR0b24pXG5cblx0XHR0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBFZGl0b3JDb250ZXh0LnRvUHJvcHMoQnV0dG9uQWNjZXNzaWJpbGl0eUltYWdlQWx0KTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3QgZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QuanN4JztcblxuY2xhc3MgQnV0dG9uQmFja2dyb3VuZENvbG9yIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRzdGF0aWMga2V5ID0gJ2JhY2tncm91bmRDb2xvcic7XG5cblx0c3RhdGljIHByb3BUeXBlcyA9IHtcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3R5bGVzIGxpc3QgaXMgZXhwYW5kZWQgb3Igbm90LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkJhY2tncm91bmRDb2xvclxuXHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZXhwYW5kZWRcblx0XHQgKi9cblx0XHRleHBhbmRlZDogUHJvcFR5cGVzLmJvb2wsXG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGFiZWwgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgYWNjZXNzaWJpbGl0eSBwdXJwb3Nlcy5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25CYWNrZ3JvdW5kQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gbGFiZWxcblx0XHQgKi9cblx0XHRsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSByZW1vdmUgc3R5bGVzIGl0ZW0gc2hvdWxkIGFwcGVhciBpbiB0aGUgc3R5bGVzIGxpc3QuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQmFja2dyb3VuZENvbG9yXG5cdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBzaG93UmVtb3ZlU3R5bGVzSXRlbVxuXHRcdCAqL1xuXHRcdHNob3dSZW1vdmVTdHlsZXNJdGVtOiBQcm9wVHlwZXMuYm9vbCxcblxuXHRcdC8qKlxuXHRcdCAqIExpc3Qgb2YgdGhlIHN0eWxlcyB0aGUgYnV0dG9uIGlzIGFibGUgdG8gaGFuZGxlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkJhY2tncm91bmRDb2xvclxuXHRcdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IHN0eWxlc1xuXHRcdCAqL1xuXHRcdHN0eWxlczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9iamVjdCksXG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGFiSW5kZXggb2YgdGhlIGJ1dHRvbiBpbiBpdHMgdG9vbGJhciBjdXJyZW50IHN0YXRlLiBBIHZhbHVlIG90aGVyIHRoYW4gLTFcblx0XHQgKiBtZWFucyB0aGF0IHRoZSBidXR0b24gaGFzIGZvY3VzIGFuZCBpcyB0aGUgYWN0aXZlIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQmFja2dyb3VuZENvbG9yXG5cdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IHRhYkluZGV4XG5cdFx0ICovXG5cdFx0dGFiSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG5cblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayBwcm92aWRlZCBieSB0aGUgYnV0dG9uIGhvc3QgdG8gbm90aWZ5IHdoZW4gdGhlIHN0eWxlcyBsaXN0IGhhcyBiZWVuIGV4cGFuZGVkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkJhY2tncm91bmRDb2xvclxuXHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHRvZ2dsZURyb3Bkb3duXG5cdFx0ICovXG5cdFx0dG9nZ2xlRHJvcGRvd246IFByb3BUeXBlcy5mdW5jLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGxldCBhY3RpdmVDb2xvciA9IEFsbG95RWRpdG9yLlN0cmluZ3Mubm9ybWFsO1xuXG5cdFx0bGV0IGFjdGl2ZUNvbG9yQ2xhc3MgPSAnJztcblxuXHRcdGNvbnN0IGNvbG9ycyA9IHRoaXMuX2dldENvbG9ycygpO1xuXG5cdFx0Y29uc3QgaXRlbVN0eWxlID0ge1xuXHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRjbGFzczogJycsXG5cdFx0XHR9LFxuXHRcdH07XG5cblx0XHRjb2xvcnMuZm9yRWFjaChpdGVtID0+IHtcblx0XHRcdGl0ZW1TdHlsZS5hdHRyaWJ1dGVzLmNsYXNzID0gaXRlbS5zdHlsZUNsYXNzO1xuXG5cdFx0XHRpZiAodGhpcy5fY2hlY2tBY3RpdmUoaXRlbVN0eWxlKSkge1xuXHRcdFx0XHRhY3RpdmVDb2xvciA9IGl0ZW0ubmFtZTtcblxuXHRcdFx0XHRhY3RpdmVDb2xvckNsYXNzID0gaXRlbS5zdHlsZS5hdHRyaWJ1dGVzLmNsYXNzO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Y29uc3Qge2V4cGFuZGVkLCB0YWJJbmRleCwgdG9nZ2xlRHJvcGRvd259ID0gdGhpcy5wcm9wcztcblxuXHRcdGNvbnN0IGJ1dHRvblN0eWxlc1Byb3BzID0ge1xuXHRcdFx0YWN0aXZlU3R5bGU6IGFjdGl2ZUNvbG9yLFxuXHRcdFx0b25EaXNtaXNzOiB0b2dnbGVEcm9wZG93bixcblx0XHRcdHNob3dSZW1vdmVTdHlsZXNJdGVtOiBmYWxzZSxcblx0XHRcdHN0eWxlczogY29sb3JzLFxuXHRcdH07XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXIgYWUtaGFzLWRyb3Bkb3duXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXtleHBhbmRlZH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdHJvbGU9XCJjb21ib2JveFwiXG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RhYkluZGV4fT5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9e2FjdGl2ZUNvbG9yQ2xhc3N9PlxuXHRcdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwidGV4dGJveFwiIC8+XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0e2V4cGFuZGVkICYmIDxCdXR0b25TdHlsZXNMaXN0IHsuLi5idXR0b25TdHlsZXNQcm9wc30gLz59XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0X2FwcGx5U3R5bGUoY2xhc3NOYW1lKSB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0Y29uc3Qgc3R5bGVDb25maWcgPSB7XG5cdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdGNsYXNzOiBjbGFzc05hbWUsXG5cdFx0XHR9LFxuXHRcdH07XG5cblx0XHRlZGl0b3IuZ2V0U2VsZWN0aW9uKCkubG9jaygpO1xuXG5cdFx0dGhpcy5fZ2V0Q29sb3JzKCkuZm9yRWFjaChpdGVtID0+IHtcblx0XHRcdHN0eWxlQ29uZmlnLmF0dHJpYnV0ZXMuY2xhc3MgPSBpdGVtLnN0eWxlQ2xhc3M7XG5cblx0XHRcdGlmICh0aGlzLl9jaGVja0FjdGl2ZShzdHlsZUNvbmZpZykpIHtcblx0XHRcdFx0ZWRpdG9yLnJlbW92ZVN0eWxlKG5ldyBDS0VESVRPUi5zdHlsZShzdHlsZUNvbmZpZykpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0c3R5bGVDb25maWcuYXR0cmlidXRlcy5jbGFzcyA9IGNsYXNzTmFtZTtcblxuXHRcdGNvbnN0IHN0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKHN0eWxlQ29uZmlnKTtcblxuXHRcdGVkaXRvci5hcHBseVN0eWxlKHN0eWxlKTtcblxuXHRcdGVkaXRvci5nZXRTZWxlY3Rpb24oKS51bmxvY2soKTtcblxuXHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGNvbG9yIGRlZmluaXRpb24gaXMgYXBwbGllZCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gaW4gdGhlIGVkaXRvci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25CYWNrZ3JvdW5kQ29sb3Jcblx0ICogQG1ldGhvZCBfY2hlY2tBY3RpdmVcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0eWxlQ29uZmlnIGNvbG9yIGRlZmluaXRpb24gYXMgcGVyIGh0dHA6Ly9kb2NzLmNrZWRpdG9yLmNvbS8jIS9hcGkvQ0tFRElUT1Iuc3R5bGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb2xvciBpcyBhcHBsaWVkIHRvIHRoZSBzZWxlY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG5cdF9jaGVja0FjdGl2ZShzdHlsZUNvbmZpZykge1xuXHRcdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdC8vIFN0eWxlcyB3aXRoIHdpbGRjYXJkIGVsZW1lbnQgKCopIHdvbid0IGJlIGNvbnNpZGVyZWQgYWN0aXZlIGJ5IENLRWRpdG9yLiBEZWZhdWx0aW5nXG5cdFx0Ly8gdG8gYSAnc3BhbicgZWxlbWVudCB3b3JrcyBmb3IgbW9zdCBvZiB0aG9zZSBjYXNlcyB3aXRoIG5vIGRlZmluZWQgZWxlbWVudC5cblxuXHRcdHN0eWxlQ29uZmlnID0gQ0tFRElUT1IudG9vbHMubWVyZ2Uoe2VsZW1lbnQ6ICdzcGFuJ30sIHN0eWxlQ29uZmlnKTtcblxuXHRcdGNvbnN0IHN0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKHN0eWxlQ29uZmlnKTtcblxuXHRcdHJldHVybiBzdHlsZS5jaGVja0FjdGl2ZShuYXRpdmVFZGl0b3IuZWxlbWVudFBhdGgoKSwgbmF0aXZlRWRpdG9yKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNvbG9ycy4gRWFjaCBjb2xvciBjb25zaXN0cyBvZiB0d28gcHJvcGVydGllczpcblx0ICogLSBuYW1lIC0gdGhlIHN0eWxlIG5hbWUsIGZvciBleGFtcGxlIFwiZGVmYXVsdFwiXG5cdCAqIC0gc3R5bGUgLSBhbiBvYmplY3Qgd2l0aCBvbmUgcHJvcGVydHksIGNhbGxlZCBgZWxlbWVudGAgd2hpY2ggdmFsdWVcblx0ICogcmVwcmVzZW50cyB0aGUgc3R5bGUgd2hpY2ggaGF2ZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkJhY2tncm91bmRDb2xvclxuXHQgKiBAbWV0aG9kIF9nZXRDb2xvclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0FycmF5PG9iamVjdD59IEFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgY29sb3JzLlxuXHQgKi9cblx0X2dldENvbG9ycygpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5wcm9wcy5zdHlsZXMgfHwgW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5ub3JtYWwsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRcdFx0Y2xhc3M6ICd0ZXh0LWJvZHknLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlQ2xhc3M6ICcnLFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLnByaW1hcnksXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRcdFx0Y2xhc3M6ICd0ZXh0LXByaW1hcnknLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlQ2xhc3M6ICdiZy1wcmltYXJ5Jyxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ2JnLXByaW1hcnknKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MuZGlzYWJsZWQsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRcdFx0Y2xhc3M6ICd0ZXh0LXNlY29uZGFyeScsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVDbGFzczogJ2JnLXNlY29uZGFyeScsXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICdiZy1zZWNvbmRhcnknKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3Muc3VjY2Vzcyxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtc3VjY2VzcycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVDbGFzczogJ2JnLXN1Y2Nlc3MnLFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnYmctc3VjY2VzcycpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5kYW5nZXIsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRcdFx0Y2xhc3M6ICd0ZXh0LWRhbmdlcicsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVDbGFzczogJ2JnLWRhbmdlcicsXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICdiZy1kYW5nZXInKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3Mud2FybmluZyxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtd2FybmluZycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVDbGFzczogJ2JnLXdhcm5pbmcnLFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnYmctd2FybmluZycpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5pbmZvLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC1pbmZvJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUNsYXNzOiAnYmctaW5mbycsXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICdiZy1pbmZvJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25CYWNrZ3JvdW5kQ29sb3I7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbktleXN0cm9rZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1rZXlzdHJva2UnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkJvbGQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3Igc3R5bGluZyBhbiBzZWxlY3Rpb24gd2l0aCBzdHJvbmcgKGJvbGQpIHN0eWxlLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Cb2xkXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25LZXlzdHJva2VcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uQm9sZCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Cb2xkXG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ2JvbGQnLFxuXHRcdGtleXN0cm9rZToge1xuXHRcdFx0Zm46ICdleGVjQ29tbWFuZCcsXG5cdFx0XHRrZXlzOiBDS0VESVRPUi5DVFJMICsgNjYgLyogQiovLFxuXHRcdFx0bmFtZTogJ2JvbGQnLFxuXHRcdH0sXG5cdFx0c3R5bGU6ICdjb3JlU3R5bGVzX2JvbGQnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgYm9sZFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQm9sZFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnYm9sZCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Cb2xkXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAgJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmJvbGR9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWJvbGRcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYm9sZH0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImJvbGRcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuXHRCdXR0b25LZXlzdHJva2UoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblN0eWxlKEJ1dHRvbkJvbGQpKSlcbik7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25DYW1lcmFJbWFnZSBjbGFzcyB0YWtlcyBwaG90byBmcm9tIGNhbWVyYSBhbmQgaW5zZXJ0cyBpdCB0byB0aGUgY29udGVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQ2FtZXJhSW1hZ2VcbiAqL1xuY2xhc3MgQnV0dG9uQ2FtZXJhSW1hZ2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHR2aWRlb1dpZHRoOiAzMjAsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBjYW1lcmFJbWFnZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ2FtZXJhSW1hZ2Vcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2NhbWVyYUltYWdlJztcblxuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblx0XHR0aGlzLl9idXR0b25UYWtlUGhvdG9SZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcblx0XHR0aGlzLl9jYW52YXNDb250YWluZXJSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcblx0XHR0aGlzLl92aWRlb0NvbnRhaW5lclJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdCAqXG5cdCAqIEZvY3VzZXMgdGhlIHRha2UgcGhvdG8gYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcblx0ICovXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdHRoaXMuX2J1dHRvblRha2VQaG90b1JlZi5jdXJyZW50LmZvY3VzKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZnJvbSB0aGUgRE9NLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG5cdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcblx0ICovXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdGlmICh0aGlzLl9zdHJlYW0pIHtcblx0XHRcdGlmICh0aGlzLl9zdHJlYW0uc3RvcCkge1xuXHRcdFx0XHR0aGlzLl9zdHJlYW0uc3RvcCgpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9zdHJlYW0uZ2V0VmlkZW9UcmFja3MpIHtcblx0XHRcdFx0dGhpcy5fc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG5cdFx0XHRcdFx0dHJhY2suc3RvcCgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3N0cmVhbSA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBnZXRVc2VyTWVkaWEgPVxuXHRcdFx0bmF2aWdhdG9yLmdldFVzZXJNZWRpYSB8fFxuXHRcdFx0bmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fFxuXHRcdFx0bmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSB8fFxuXHRcdFx0bmF2aWdhdG9yLm1zR2V0VXNlck1lZGlhO1xuXG5cdFx0Z2V0VXNlck1lZGlhLmNhbGwoXG5cdFx0XHRuYXZpZ2F0b3IsXG5cdFx0XHR7XG5cdFx0XHRcdHZpZGVvOiB0cnVlLFxuXHRcdFx0XHRhdWRpbzogZmFsc2UsXG5cdFx0XHR9LFxuXHRcdFx0dGhpcy5faGFuZGxlU3RyZWFtU3VjY2Vzcyxcblx0XHRcdHRoaXMuX2hhbmRsZVN0cmVhbUVycm9yXG5cdFx0KTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNhbWVyYVwiPlxuXHRcdFx0XHQ8dmlkZW8gcmVmPXt0aGlzLl92aWRlb0NvbnRhaW5lclJlZn0+XG5cdFx0XHRcdFx0VmlkZW8gc3RyZWFtIG5vdCBhdmFpbGFibGUuXG5cdFx0XHRcdDwvdmlkZW8+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1jYW1lcmEtc2hvb3RcIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMudGFrZVBob3RvfVxuXHRcdFx0XHRcdHJlZj17dGhpcy5fYnV0dG9uVGFrZVBob3RvUmVmfT5cblx0XHRcdFx0XHRUYWtlIHBob3RvXG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHQ8Y2FudmFzXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtY2FtZXJhLWNhbnZhc1wiXG5cdFx0XHRcdFx0cmVmPXt0aGlzLl9jYW52YXNDb250YWluZXJSZWZ9XG5cdFx0XHRcdC8+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRha2VzIHBob3RvIGZyb20gdGhlIHZpZGVvIHN0cmVhbSBhbmQgaW5zZXJ0cyBpbiBpbnRvIGVkaXRvcidzIGNvbnRlbnQuXG5cdCAqXG5cdCAqIEBmaXJlcyBCdXR0b25DYW1lcmFJbWFnZSNpbWFnZUNhbWVyYUFkZFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG5cdCAqIEBtZXRob2QgdGFrZVBob3RvXG5cdCAqL1xuXHR0YWtlUGhvdG8gPSAoKSA9PiB7XG5cdFx0Y29uc3QgdmlkZW9FbCA9IHRoaXMuX3ZpZGVvQ29udGFpbmVyUmVmLmN1cnJlbnQ7XG5cdFx0Y29uc3QgY2FudmFzRWwgPSB0aGlzLl9jYW52YXNDb250YWluZXJSZWYuY3VycmVudDtcblxuXHRcdGNvbnN0IGNvbnRleHQgPSBjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuXG5cdFx0Y29uc3QgaGVpZ2h0ID0gdGhpcy5fdmlkZW9IZWlnaHQ7XG5cdFx0Y29uc3Qgd2lkdGggPSB0aGlzLnByb3BzLnZpZGVvV2lkdGg7XG5cblx0XHRpZiAod2lkdGggJiYgaGVpZ2h0KSB7XG5cdFx0XHRjYW52YXNFbC53aWR0aCA9IHdpZHRoO1xuXHRcdFx0Y2FudmFzRWwuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0XHRjb250ZXh0LmRyYXdJbWFnZSh2aWRlb0VsLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuXHRcdFx0Y29uc3QgaW1nVVJMID0gY2FudmFzRWwudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcblxuXHRcdFx0Y29uc3QgZWwgPSBDS0VESVRPUi5kb20uZWxlbWVudC5jcmVhdGVGcm9tSHRtbChcblx0XHRcdFx0JzxpbWcgc3JjPVwiJyArIGltZ1VSTCArICdcIj4nXG5cdFx0XHQpO1xuXG5cdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdGVkaXRvci5pbnNlcnRFbGVtZW50KGVsKTtcblxuXHRcdFx0dGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcblxuXHRcdFx0ZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXG5cdFx0XHRlZGl0b3IuZmlyZSgnaW1hZ2VDYW1lcmFBZGQnLCBlbCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwbGF5cyBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdmlkZW8gc3RyZWFtIGNhcHR1cmluZyBmYWlsdXJlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG5cdCAqIEBtZXRob2QgX2hhbmRsZVN0cmVhbUVycm9yXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGVycm9yIFRoZSBmaXJlZCBldmVudCBpbiBjYXNlIG9mIGVycm9yLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfaGFuZGxlU3RyZWFtRXJyb3IgPSBlcnJvciA9PiB7XG5cdFx0d2luZG93LmFsZXJ0KCdBbiBlcnJvciBvY2N1cnJlZCEgJyArIGVycm9yKTtcblx0fTtcblxuXHQvKipcblx0ICogU3RhcnRzIHN0cmVhbWluZyB2aWRlbyBpbiB0aGUgdmlkZW8gZWxlbWVudCBhbmQgc2V0cyB3aWR0aC9oZWlnaHQgdG8gdGhlIHZpZGVvXG5cdCAqIGFuZCBjYW52YXMgZWxlbWVudHMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ2FtZXJhSW1hZ2Vcblx0ICogQG1ldGhvZCBfaGFuZGxlU3RyZWFtU3VjY2Vzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtIFRoZSB2aWRlbyBzdHJlYW1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2hhbmRsZVN0cmVhbVN1Y2Nlc3MgPSBzdHJlYW0gPT4ge1xuXHRcdGNvbnN0IHZpZGVvRWwgPSB0aGlzLl92aWRlb0NvbnRhaW5lclJlZi5jdXJyZW50O1xuXHRcdGNvbnN0IGNhbnZhc0VsID0gdGhpcy5fY2FudmFzQ29udGFpbmVyUmVmLmN1cnJlbnQ7XG5cblx0XHR2aWRlb0VsLmFkZEV2ZW50TGlzdGVuZXIoXG5cdFx0XHQnY2FucGxheScsXG5cdFx0XHQoKSA9PiB7XG5cdFx0XHRcdGxldCBoZWlnaHQgPVxuXHRcdFx0XHRcdHZpZGVvRWwudmlkZW9IZWlnaHQgL1xuXHRcdFx0XHRcdCh2aWRlb0VsLnZpZGVvV2lkdGggLyB0aGlzLnByb3BzLnZpZGVvV2lkdGgpO1xuXG5cdFx0XHRcdGlmIChpc05hTihoZWlnaHQpKSB7XG5cdFx0XHRcdFx0aGVpZ2h0ID0gdGhpcy5wcm9wcy52aWRlb1dpZHRoIC8gKDQgLyAzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZpZGVvRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMucHJvcHMudmlkZW9XaWR0aCk7XG5cdFx0XHRcdHZpZGVvRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHQpO1xuXHRcdFx0XHRjYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5wcm9wcy52aWRlb1dpZHRoKTtcblx0XHRcdFx0Y2FudmFzRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHQpO1xuXG5cdFx0XHRcdHRoaXMuX3ZpZGVvSGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0fSxcblx0XHRcdGZhbHNlXG5cdFx0KTtcblxuXHRcdHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcblxuXHRcdGlmIChuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhKSB7XG5cdFx0XHR2aWRlb0VsLm1velNyY09iamVjdCA9IHN0cmVhbTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmlkZW9FbC5zcmNPYmplY3QgPSBzdHJlYW07XG5cdFx0fVxuXG5cdFx0dmlkZW9FbC5wbGF5KCk7XG5cblx0XHR0aGlzLl9idXR0b25UYWtlUGhvdG9SZWYuY3VycmVudC5kaXNhYmxlZCA9IGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGaXJlZCB3aGVuIGFuIGltYWdlIGlzIGJlaW5nIHRha2VuIGZyb20gdGhlIGNhbWVyYSBhbmQgYWRkZWQgYXMgYW4gZWxlbWVudCB0byB0aGUgZWRpdG9yLlxuXHQgKlxuXHQgKiBAZXZlbnQgQnV0dG9uQ2FtZXJhSW1hZ2UjaW1hZ2VDYW1lcmFBZGRcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGVsIFRoZSBjcmVhdGVkIGltZyBlbGVtZW50IGluIGVkaXRvci5cblx0ICovXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNhbWVyYUltYWdlO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ2FtZXJhSW1hZ2UgZnJvbSAnLi9idXR0b24tY2FtZXJhLWltYWdlLmpzeCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkNhbWVyYSBjbGFzcyByZW5kZXJzIGluIHR3byBkaWZmZXJlbnQgd2F5czpcbiAqXG4gKiAtIE5vcm1hbDogSnVzdCBhIGJ1dHRvbiB0aGF0IGFsbG93cyB0byBzd2l0Y2ggdG8gdGhlIGVkaXRpb24gbW9kZS5cbiAqIC0gRXhjbHVzaXZlOiBSZW5kZXJzIEJ1dHRvbkNhbWVyYUltYWdlIGluIG9yZGVyIHRvIHRha2UgcGhvdG8gZnJvbSB0aGUgY2FtZXJhLlxuICpcbiAqIEBjbGFzcyBCdXR0b25DYW1lcmFcbiAqL1xuY2xhc3MgQnV0dG9uQ2FtZXJhIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBjYW1lcmFcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnY2FtZXJhJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcblx0XHRcdHJldHVybiA8QnV0dG9uQ2FtZXJhSW1hZ2Ugey4uLnRoaXMucHJvcHN9IC8+O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBkaXNhYmxlZCA9ICEoXG5cdFx0XHRcdG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHxcblx0XHRcdFx0KG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgJiZcblx0XHRcdFx0XHRsb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzJykgfHxcblx0XHRcdFx0bmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSB8fFxuXHRcdFx0XHRuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWFcblx0XHRcdCk7XG5cblx0XHRcdGNvbnN0IGxhYmVsID0gZGlzYWJsZWRcblx0XHRcdFx0PyBBbGxveUVkaXRvci5TdHJpbmdzLmNhbWVyYURpc2FibGVkXG5cdFx0XHRcdDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jYW1lcmE7XG5cblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtsYWJlbH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1pbWFnZS1jYW1lcmFcIlxuXHRcdFx0XHRcdGRpc2FibGVkPXtkaXNhYmxlZH1cblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmUuYmluZChCdXR0b25DYW1lcmEua2V5KX1cblx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHR0aXRsZT17bGFiZWx9PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNhbWVyYVwiIC8+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0KTtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ2FtZXJhO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQWN0aW9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tYWN0aW9uLXN0eWxlJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Db2RlIGNsYXNzIHByb3ZpZGVzIHdyYXBzIGEgc2VsZWN0aW9uIGluIGBwcmVgIGVsZW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkNvZGVcbiAqIEB1c2VzIEJ1dHRvbkFjdGlvblN0eWxlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvbkNvZGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29kZVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdHN0eWxlOiB7XG5cdFx0XHRlbGVtZW50OiAncHJlJyxcblx0XHR9LFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgY29kZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29kZVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnY29kZSc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db2RlXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29kZX1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tY29kZVwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuYXBwbHlTdHlsZX1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvZGV9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJjb2RlXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQWN0aW9uU3R5bGUoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblN0eWxlKEJ1dHRvbkNvZGUpKSk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0IGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkNvbG9yIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNoYW5naW5nIHRleHQgY29sb3IgaW4gYSBkb2N1bWVudC5cbiAqXG4gKlxuICogQGNsYXNzIEJ1dHRvbkNvbG9yXG4gKi9cbmNsYXNzIEJ1dHRvbkNvbG9yIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRzdGF0aWMga2V5ID0gJ2NvbG9yJztcblxuXHRzdGF0aWMgcHJvcFR5cGVzID0ge1xuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdHlsZXMgbGlzdCBpcyBleHBhbmRlZCBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IGV4cGFuZGVkXG5cdFx0ICovXG5cdFx0ZXhwYW5kZWQ6IFByb3BUeXBlcy5ib29sLFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxhYmVsIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZXMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gbGFiZWxcblx0XHQgKi9cblx0XHRsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSByZW1vdmUgc3R5bGVzIGl0ZW0gc2hvdWxkIGFwcGVhciBpbiB0aGUgc3R5bGVzIGxpc3QuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNob3dSZW1vdmVTdHlsZXNJdGVtXG5cdFx0ICovXG5cdFx0c2hvd1JlbW92ZVN0eWxlc0l0ZW06IFByb3BUeXBlcy5ib29sLFxuXG5cdFx0LyoqXG5cdFx0ICogTGlzdCBvZiB0aGUgc3R5bGVzIHRoZSBidXR0b24gaXMgYWJsZSB0byBoYW5kbGUuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge0FycmF5fSBzdHlsZXNcblx0XHQgKi9cblx0XHRzdHlsZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vYmplY3QpLFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRhYkluZGV4IG9mIHRoZSBidXR0b24gaW4gaXRzIHRvb2xiYXIgY3VycmVudCBzdGF0ZS4gQSB2YWx1ZSBvdGhlciB0aGFuIC0xXG5cdFx0ICogbWVhbnMgdGhhdCB0aGUgYnV0dG9uIGhhcyBmb2N1cyBhbmQgaXMgdGhlIGFjdGl2ZSBlbGVtZW50LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbG9yXG5cdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IHRhYkluZGV4XG5cdFx0ICovXG5cdFx0dGFiSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG5cblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayBwcm92aWRlZCBieSB0aGUgYnV0dG9uIGhvc3QgdG8gbm90aWZ5IHdoZW4gdGhlIHN0eWxlcyBsaXN0IGhhcyBiZWVuIGV4cGFuZGVkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbG9yXG5cdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdG9nZ2xlRHJvcGRvd25cblx0XHQgKi9cblx0XHR0b2dnbGVEcm9wZG93bjogUHJvcFR5cGVzLmZ1bmMsXG5cdH07XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IGFjdGl2ZUNvbG9yID0gQWxsb3lFZGl0b3IuU3RyaW5ncy5ub3JtYWw7XG5cblx0XHRjb25zdCBjb2xvcnMgPSB0aGlzLl9nZXRDb2xvcnMoKTtcblxuXHRcdGNvbG9ycy5zb21lKGl0ZW0gPT4ge1xuXHRcdFx0aWYgKHRoaXMuX2NoZWNrQWN0aXZlKGl0ZW0uc3R5bGUpKSB7XG5cdFx0XHRcdGFjdGl2ZUNvbG9yID0gaXRlbS5uYW1lO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Y29uc3Qge2V4cGFuZGVkLCB0YWJJbmRleCwgdG9nZ2xlRHJvcGRvd259ID0gdGhpcy5wcm9wcztcblxuXHRcdGNvbnN0IGJ1dHRvblN0eWxlc1Byb3BzID0ge1xuXHRcdFx0YWN0aXZlU3R5bGU6IGFjdGl2ZUNvbG9yLFxuXHRcdFx0b25EaXNtaXNzOiB0b2dnbGVEcm9wZG93bixcblx0XHRcdHNob3dSZW1vdmVTdHlsZXNJdGVtOiBmYWxzZSxcblx0XHRcdHN0eWxlczogY29sb3JzLFxuXHRcdH07XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXIgYWUtaGFzLWRyb3Bkb3duXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXtleHBhbmRlZH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdHJvbGU9XCJjb21ib2JveFwiXG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RhYkluZGV4fT5cblx0XHRcdFx0XHQ8c3Bhbj5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNvbG9yLXBpY2tlclwiIC8+XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0e2V4cGFuZGVkICYmIDxCdXR0b25TdHlsZXNMaXN0IHsuLi5idXR0b25TdHlsZXNQcm9wc30gLz59XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0X2FwcGx5U3R5bGUoY2xhc3NOYW1lKSB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0Y29uc3Qgc3R5bGVDb25maWcgPSB7XG5cdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdGNsYXNzOiBjbGFzc05hbWUsXG5cdFx0XHR9LFxuXHRcdH07XG5cblx0XHRjb25zdCBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZShzdHlsZUNvbmZpZyk7XG5cblx0XHRlZGl0b3IuZ2V0U2VsZWN0aW9uKCkubG9jaygpO1xuXG5cdFx0dGhpcy5fZ2V0Q29sb3JzKCkuZm9yRWFjaChpdGVtID0+IHtcblx0XHRcdGlmICh0aGlzLl9jaGVja0FjdGl2ZShpdGVtLnN0eWxlKSkge1xuXHRcdFx0XHRlZGl0b3IucmVtb3ZlU3R5bGUobmV3IENLRURJVE9SLnN0eWxlKGl0ZW0uc3R5bGUpKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGVkaXRvci5hcHBseVN0eWxlKHN0eWxlKTtcblxuXHRcdGVkaXRvci5nZXRTZWxlY3Rpb24oKS51bmxvY2soKTtcblxuXHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGNvbG9yIGRlZmluaXRpb24gaXMgYXBwbGllZCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gaW4gdGhlIGVkaXRvci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db2xvclxuXHQgKiBAbWV0aG9kIF9jaGVja0FjdGl2ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVDb25maWcgQ29sb3IgZGVmaW5pdGlvbiBhcyBwZXIgaHR0cDovL2RvY3MuY2tlZGl0b3IuY29tLyMhL2FwaS9DS0VESVRPUi5zdHlsZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbG9yIGlzIGFwcGxpZWQgdG8gdGhlIHNlbGVjdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cblx0X2NoZWNrQWN0aXZlKHN0eWxlQ29uZmlnKSB7XG5cdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0Ly8gU3R5bGVzIHdpdGggd2lsZGNhcmQgZWxlbWVudCAoKikgd29uJ3QgYmUgY29uc2lkZXJlZCBhY3RpdmUgYnkgQ0tFZGl0b3IuIERlZmF1bHRpbmdcblx0XHQvLyB0byBhICdzcGFuJyBlbGVtZW50IHdvcmtzIGZvciBtb3N0IG9mIHRob3NlIGNhc2VzIHdpdGggbm8gZGVmaW5lZCBlbGVtZW50LlxuXG5cdFx0c3R5bGVDb25maWcgPSBDS0VESVRPUi50b29scy5tZXJnZSh7ZWxlbWVudDogJ3NwYW4nfSwgc3R5bGVDb25maWcpO1xuXG5cdFx0Y29uc3Qgc3R5bGUgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoc3R5bGVDb25maWcpO1xuXG5cdFx0cmV0dXJuIHN0eWxlLmNoZWNrQWN0aXZlKG5hdGl2ZUVkaXRvci5lbGVtZW50UGF0aCgpLCBuYXRpdmVFZGl0b3IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgY29sb3JzLiBFYWNoIGNvbG9yIGNvbnNpc3RzIG9mIHR3byBwcm9wZXJ0aWVzOlxuXHQgKiAtIG5hbWUgLSBUaGUgc3R5bGUgbmFtZSwgZm9yIGV4YW1wbGUgXCJkZWZhdWx0XCIuXG5cdCAqIC0gc3R5bGUgLSBBbiBvYmplY3Qgd2l0aCBvbmUgcHJvcGVydHksIGNhbGxlZCBgZWxlbWVudGAgd2hpY2ggdmFsdWVcblx0ICogICAgICAgICAgcmVwcmVzZW50cyB0aGUgc3R5bGUgd2hpY2ggaGF2ZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50LlxuXHQgKiAtIHN0eWxlRm4gLSBUaGUgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIHRvIGFwcGx5IHRoZSBzdHlsZSB0byB0aGUgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db2xvclxuXHQgKiBAbWV0aG9kIF9nZXRDb2xvclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0FycmF5PG9iamVjdD59IEFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgY29sb3JzLlxuXHQgKi9cblx0X2dldENvbG9ycygpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5wcm9wcy5zdHlsZXMgfHwgW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5wcmltYXJ5LFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC1wcmltYXJ5Jyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtcHJpbWFyeScpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5zdWNjZXNzLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC1zdWNjZXNzJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtc3VjY2VzcycpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5kYW5nZXIsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRcdFx0Y2xhc3M6ICd0ZXh0LWRhbmdlcicsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICd0ZXh0LWRhbmdlcicpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy53YXJuaW5nLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC13YXJuaW5nJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtd2FybmluZycpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5pbmZvLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC1pbmZvJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtaW5mbycpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5kYXJrLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC1kYXJrJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtZGFyaycpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5kYXJrR3JheSxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtZ3JheS1kYXJrJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtZ3JheS1kYXJrJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLnNlY29uZGFyeSxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtc2Vjb25kYXJ5Jyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtc2Vjb25kYXJ5JyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmxpZ2h0LFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC1kYXJrJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtbGlnaHQnKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MubGlnaHRlcixcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtZGFyaycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICd0ZXh0LWxpZ2h0ZXInKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3Mud2hpdGUsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRcdFx0Y2xhc3M6ICd0ZXh0LWRhcmsnLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAndGV4dC13aGl0ZScpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29sb3I7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Db21tYW5kTGlzdEl0ZW0gY2xhc3MgaXMgYSBVSSBjbGFzcyB0aGF0IHJlbmRlcnMgYSBCdXR0b25Db21tYW5kIHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlXG4gKiBhIGxpc3QgYXMgYW4gaXRlbSwgd2l0aCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdHMgYmVoYXZpb3VyLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db21tYW5kTGlzdEl0ZW1cbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuY2xhc3MgQnV0dG9uQ29tbWFuZExpc3RJdGVtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBidXR0b25Db21tYW5kTGlzdEl0ZW1cblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnYnV0dG9uQ29tbWFuZExpc3RJdGVtJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXt0aGlzLnByb3BzLmRlc2NyaXB0aW9ufVxuXHRcdFx0XHRjbGFzc05hbWU9e3RoaXMuX2dldENsYXNzTmFtZSgpfVxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0+XG5cdFx0XHRcdHt0aGlzLnByb3BzLmRlc2NyaXB0aW9ufVxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjbGFzcyBuYW1lIG9mIFdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kTGlzdEl0ZW1cblx0ICogQG1ldGhvZCBfZ2V0Q2xhc3NOYW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgY2xhc3MgbmFtZSBvZiB0aGUgV2lkZ2V0LlxuXHQgKi9cblx0X2dldENsYXNzTmFtZSgpIHtcblx0XHRjb25zdCBjbGFzc05hbWUgPSAnYWUtY29udGFpbmVyIGFlLXRvb2xiYXItZWxlbWVudCc7XG5cblx0XHRyZXR1cm4gY2xhc3NOYW1lO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoQnV0dG9uQ29tbWFuZExpc3RJdGVtKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyJztcbmltcG9ydCBCdXR0b25Db21tYW5kTGlzdEl0ZW0gZnJvbSAnLi9idXR0b24tY29tbWFuZC1saXN0LWl0ZW0uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uQ29tbWFuZHNMaXN0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHNob3dpbmcgYSBsaXN0IG9mIGNvbW1hbmRzIHRoYXQgY2FuIGJlXG4gKiBleGVjdXRlZCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db21tYW5kc0xpc3RcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBCdXR0b25Db21tYW5kc0xpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZHNMaXN0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y2lyY3VsYXI6IGZhbHNlLFxuXHRcdGRlc2NlbmRhbnRzOiAnLmFlLXRvb2xiYXItZWxlbWVudCcsXG5cdFx0a2V5czoge1xuXHRcdFx0ZGlzbWlzczogWzI3XSxcblx0XHRcdGRpc21pc3NOZXh0OiBbMzldLFxuXHRcdFx0ZGlzbWlzc1ByZXY6IFszN10sXG5cdFx0XHRuZXh0OiBbNDBdLFxuXHRcdFx0cHJldjogWzM4XSxcblx0XHR9LFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgYnV0dG9uQ29tbWFuZHNMaXN0XG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kc0xpc3Rcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2J1dHRvbkNvbW1hbmRzTGlzdCc7XG5cblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cdFx0dGhpcy5fcmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogRm9jdXNlcyBvbiB0aGUgbGlzdCBub2RlIHRvIGFsbG93IGtleWJvYXJkIGludGVyYWN0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRzTGlzdFxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLl9yZWYuY3VycmVudC5mb2N1cygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGxpc3QuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZHNMaXN0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2XG5cdFx0XHRcdGNsYXNzTmFtZT1cImFlLWFycm93LWJveCBhZS1hcnJvdy1ib3gtdG9wLWxlZnQgYWUtZHJvcGRvd25cIlxuXHRcdFx0XHRvbkZvY3VzPXt0aGlzLmZvY3VzfVxuXHRcdFx0XHRvbktleURvd249e3RoaXMuaGFuZGxlS2V5fVxuXHRcdFx0XHRyZWY9e3RoaXMuX3JlZn1cblx0XHRcdFx0dGFiSW5kZXg9XCIwXCI+XG5cdFx0XHRcdDx1bFxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWxpc3Rib3hcIlxuXHRcdFx0XHRcdGlkPXt0aGlzLnByb3BzLmxpc3RJZH1cblx0XHRcdFx0XHRyb2xlPVwibGlzdGJveFwiPlxuXHRcdFx0XHRcdHt0aGlzLl9yZW5kZXJBY3Rpb25zKHRoaXMucHJvcHMuY29tbWFuZHMpfVxuXHRcdFx0XHQ8L3VsPlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIGluc3RhbmNlcyBvZiBCdXR0b25Db21tYW5kTGlzdEl0ZW0gd2l0aCB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIHJvdyBhY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRzTGlzdFxuXHQgKiBAbWV0aG9kIF9yZW5kZXJBY3Rpb25zXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7QXJyYXl9IFJlbmRlcmVkIGluc3RhbmNlcyBvZiBCdXR0b25Db21tYW5kTGlzdEl0ZW0gY2xhc3Ncblx0ICovXG5cdF9yZW5kZXJBY3Rpb25zKGNvbW1hbmRzKSB7XG5cdFx0bGV0IGl0ZW1zO1xuXG5cdFx0aWYgKGNvbW1hbmRzICYmIGNvbW1hbmRzLmxlbmd0aCkge1xuXHRcdFx0aXRlbXMgPSBjb21tYW5kcy5tYXAoaXRlbSA9PiB7XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0PGxpIGtleT17aXRlbS5jb21tYW5kfSByb2xlPVwib3B0aW9uXCI+XG5cdFx0XHRcdFx0XHQ8QnV0dG9uQ29tbWFuZExpc3RJdGVtXG5cdFx0XHRcdFx0XHRcdGNvbW1hbmQ9e2l0ZW0uY29tbWFuZH1cblx0XHRcdFx0XHRcdFx0ZGVzY3JpcHRpb249e1xuXHRcdFx0XHRcdFx0XHRcdHR5cGVvZiBpdGVtLmxhYmVsID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0XHRcdFx0PyBpdGVtLmxhYmVsXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IGl0ZW0ubGFiZWwoKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGljb249e2l0ZW0uaWNvbn1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtcztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRGb2N1c01hbmFnZXIoQnV0dG9uQ29tbWFuZHNMaXN0KTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyJztcblxuLyoqXG4gKiBUaGUgQnV0dG9uRHJvcGRvd24gY2xhc3MgcHJvdmlkZXMgbWFya3VwIGFuZCBrZXlib2FyZCBuYXZpZ2F0aW9uIGJlaGF2aW91ciB0byBhIGRyb3Bkb3duXG4gKiBvcGVuZWQgZnJvbSBhIGJ1dHRvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uRHJvcGRvd25cbiAqL1xuY2xhc3MgQnV0dG9uRHJvcGRvd24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRHJvcGRvd25cblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y2lyY3VsYXI6IGZhbHNlLFxuXHRcdGRlc2NlbmRhbnRzOiAnLmFlLXRvb2xiYXItZWxlbWVudCcsXG5cdFx0a2V5czoge1xuXHRcdFx0ZGlzbWlzczogWzI3XSxcblx0XHRcdGRpc21pc3NOZXh0OiBbMzldLFxuXHRcdFx0ZGlzbWlzc1ByZXY6IFszN10sXG5cdFx0XHRuZXh0OiBbNDBdLFxuXHRcdFx0cHJldjogWzM4XSxcblx0XHR9LFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGRyb3Bkb3duIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBkcm9wZG93blxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRHJvcGRvd25cblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2Ryb3Bkb3duJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkRyb3Bkb3duXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2XG5cdFx0XHRcdGNsYXNzTmFtZT1cImFlLWFycm93LWJveCBhZS1hcnJvdy1ib3gtdG9wLWxlZnQgYWUtZHJvcGRvd25cIlxuXHRcdFx0XHRvbkZvY3VzPXt0aGlzLmZvY3VzfVxuXHRcdFx0XHRvbktleURvd249e3RoaXMuaGFuZGxlS2V5fVxuXHRcdFx0XHR0YWJJbmRleD1cIjBcIj5cblx0XHRcdFx0PHVsIGNsYXNzTmFtZT1cImFlLWxpc3Rib3hcIiByb2xlPVwibGlzdGJveFwiPlxuXHRcdFx0XHRcdHt0aGlzLnByb3BzLmNoaWxkcmVufVxuXHRcdFx0XHQ8L3VsPlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRGb2N1c01hbmFnZXIoQnV0dG9uRHJvcGRvd24pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuY29uc3QgS0VZX0VOVEVSID0gMTM7XG5jb25zdCBLRVlfRVNDID0gMjc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkVtYmVkRWRpdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhbiBlbWJlZCBsaW5rIGluIGEgZG9jdW1lbnQuXG4gKiBQcm92aWRlcyBVSSBmb3IgY3JlYXRpbmcgYW5kIGVkaXRpbmcgYW4gZW1iZWQgbGluay5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uRW1iZWRFZGl0XG4gKi9cbmNsYXNzIEJ1dHRvbkVtYmVkRWRpdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBlbWJlZEVkaXRcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnZW1iZWRFZGl0JztcblxuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdHRoaXMubGlua0lucHV0ID0gUmVhY3QuY3JlYXRlUmVmKCk7XG5cdFx0dGhpcy5zdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogRm9jdXNlcyBvbiB0aGUgbGluayBpbnB1dCB0byBpbW1lZGlhdGVseSBhbGxvdyBlZGl0aW5nLiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGUgY29tcG9uZW50XG5cdCAqIGlzIHJlbmRlcmVkIGluIGV4Y2x1c2l2ZSBtb2RlIHRvIHByZXZlbnQgYWdncmVzc2l2ZSBmb2N1cyBzdGVhbGluZy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcblx0ICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0aWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlIHx8IHRoaXMucHJvcHMubWFudWFsU2VsZWN0aW9uKSB7XG5cdFx0XHQvLyBXZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZSBiZWZvcmUgZm9jdXNpbmcgdG8gYXZvaWQgdW5kZXNpcmVkXG5cdFx0XHQvLyBzY3JvbGxzIG9uIHRoZSBwYWdlXG5cblx0XHRcdGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fZm9jdXNMaW5rSW5wdXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2V0VGltZW91dCh0aGlzLl9mb2N1c0xpbmtJbnB1dCwgMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlY2VpdmluZyBuZXcgcHJvcHMuXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcblx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG5cdCAqL1xuXHRjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkge1xuXHRcdHRoaXMuc2V0U3RhdGUodGhpcy5nZXRJbml0aWFsU3RhdGUoKSk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cblx0ICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhpcy5zdGF0ZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcblx0ICogQG1ldGhvZCBnZXRJbml0aWFsU3RhdGVcblx0ICovXG5cdGdldEluaXRpYWxTdGF0ZSgpIHtcblx0XHQvLyBDYW4ndCBhY2Nlc3MgY29udGV4dCBmcm9tIGNvbnN0cnVjdG9yLCBzbyBnZXQgZWRpdG9yIGZyb20gcHJvcHMuXG5cblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLnByb3BzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0bGV0IGVtYmVkO1xuXG5cdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0aWYgKHNlbGVjdGlvbikge1xuXHRcdFx0Y29uc3Qgc2VsZWN0ZWRFbGVtZW50ID0gc2VsZWN0aW9uLmdldFNlbGVjdGVkRWxlbWVudCgpO1xuXG5cdFx0XHRpZiAoc2VsZWN0ZWRFbGVtZW50KSB7XG5cdFx0XHRcdGVtYmVkID0gc2VsZWN0ZWRFbGVtZW50LmZpbmRPbmUoJ1tkYXRhLXdpZGdldD1cImFlX2VtYmVkXCJdJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgaHJlZiA9IGVtYmVkID8gZW1iZWQuZ2V0QXR0cmlidXRlKCdkYXRhLWFlLWVtYmVkLXVybCcpIDogJyc7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZWxlbWVudDogZW1iZWQsXG5cdFx0XHRpbml0aWFsTGluazoge1xuXHRcdFx0XHRocmVmLFxuXHRcdFx0fSxcblx0XHRcdGxpbmtIcmVmOiBocmVmLFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjbGVhckxpbmtTdHlsZSA9IHtcblx0XHRcdG9wYWNpdHk6IHRoaXMuc3RhdGUubGlua0hyZWYgPyAxIDogMCxcblx0XHR9O1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWVkaXQtbGlua1wiPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5kZWxldGVFbWJlZH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1lbWJlZC1yZW1vdmVcIlxuXHRcdFx0XHRcdGRpc2FibGVkPXshdGhpcy5zdGF0ZS5lbGVtZW50fVxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX3JlbW92ZUVtYmVkfVxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmRlbGV0ZUVtYmVkfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBjbGFzc05hbWU9XCJhZS1pY29uLXN2Zy10cmFzaFwiIHN5bWJvbD1cInRyYXNoXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0IHh4bFwiPlxuXHRcdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtaW5wdXRcIlxuXHRcdFx0XHRcdFx0b25DaGFuZ2U9e3RoaXMuX2hhbmRsZUxpbmtIcmVmQ2hhbmdlfVxuXHRcdFx0XHRcdFx0b25LZXlEb3duPXt0aGlzLl9oYW5kbGVLZXlEb3dufVxuXHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9e0FsbG95RWRpdG9yLlN0cmluZ3MuZWRpdExpbmt9XG5cdFx0XHRcdFx0XHRyZWY9e3RoaXMubGlua0lucHV0fVxuXHRcdFx0XHRcdFx0dHlwZT1cInRleHRcIlxuXHRcdFx0XHRcdFx0dmFsdWU9e3RoaXMuc3RhdGUubGlua0hyZWZ9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNsZWFySW5wdXR9XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b24gYWUtYnV0dG9uLWNsZWFyXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX2NsZWFyTGlua31cblx0XHRcdFx0XHRcdHN0eWxlPXtjbGVhckxpbmtTdHlsZX1cblx0XHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNsZWFyfT5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInRpbWVzLWNsZWFyXCIgLz5cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbmZpcm19XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRkaXNhYmxlZD17IXRoaXMuX2lzVmFsaWRTdGF0ZSgpfVxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX2VtYmVkTGlua31cblx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5jb25maXJtfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBjbGFzc05hbWU9XCJhZS1pY29uLXN2Zy1jaGVja1wiIHN5bWJvbD1cImNoZWNrXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyB0aGUgbGluayBpbnB1dC4gVGhpcyBvbmx5IGNoYW5nZXMgdGhlIGNvbXBvbmVudCBpbnRlcm5hbCBzdGF0ZSwgYnV0IGRvZXMgbm90XG5cdCAqIGFmZmVjdCB0aGUgbGluayBlbGVtZW50IG9mIHRoZSBlZGl0b3IuIE9ubHkgdGhlIF9yZW1vdmVMaW5rIGFuZCBfdXBkYXRlTGluayBtZXRob2RzXG5cdCAqIGFyZSB0cmFuc2xhdGVkIHRvIHRoZSBlZGl0b3IgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcblx0ICogQG1ldGhvZCBfY2xlYXJMaW5rXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9jbGVhckxpbmsgPSAoKSA9PiB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRsaW5rSHJlZjogJycsXG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJzIHRoZSBlbWJlZFVybCBjb21tYW5kIHRvIHRyYW5zZm9ybSB0aGUgbGluayBpbnRvIGFuIGVtYmVkIG1lZGlhIG9iamVjdFxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuXHQgKiBAbWV0aG9kIF9lbWJlZExpbmtcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2VtYmVkTGluayA9ICgpID0+IHtcblx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRuYXRpdmVFZGl0b3IuZXhlY0NvbW1hbmQoJ2VtYmVkVXJsJywge1xuXHRcdFx0dXJsOiB0aGlzLnN0YXRlLmxpbmtIcmVmLFxuXHRcdH0pO1xuXG5cdFx0Ly8gV2UgbmVlZCB0byBjYW5jZWxFeGNsdXNpdmUgd2l0aCB0aGUgYm91bmQgcGFyYW1ldGVycyBpbiBjYXNlIHRoZSBidXR0b24gaXMgdXNlZFxuXHRcdC8vIGluc2lkZSBhbm90aGVyIGluIGV4Y2x1c2l2ZSBtb2RlIChzdWNoIGlzIHRoZSBjYXNlIG9mIHRoZSBsaW5rIGJ1dHRvbilcblxuXHRcdHRoaXMucHJvcHMuY2FuY2VsRXhjbHVzaXZlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEZvY3VzZXMgdGhlIHVzZXIgY3Vyc29yIG9uIHRoZSB3aWRnZXQncyBpbnB1dC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcblx0ICogQG1ldGhvZCBfZm9jdXNMaW5rSW5wdXRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2ZvY3VzTGlua0lucHV0ID0gKCkgPT4ge1xuXHRcdHRoaXMubGlua0lucHV0LmN1cnJlbnQuZm9jdXMoKTtcblx0fTtcblxuXHQvKipcblx0ICogTW9uaXRvcnMga2V5IGludGVyYWN0aW9uIGluc2lkZSB0aGUgaW5wdXQgZWxlbWVudCB0byByZXNwb25kIHRvIHRoZSBrZXlzOlxuXHQgKiAtIEVudGVyOiBDcmVhdGVzL3VwZGF0ZXMgdGhlIGxpbmsuXG5cdCAqIC0gRXNjYXBlOiBEaXNjYXJkcyB0aGUgY2hhbmdlcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcblx0ICogQG1ldGhvZCBfaGFuZGxlS2V5RG93blxuXHQgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUga2V5Ym9hcmQgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9oYW5kbGVLZXlEb3duID0gZXZlbnQgPT4ge1xuXHRcdGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRU5URVIgfHwgZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VTQykge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VOVEVSKSB7XG5cdFx0XHR0aGlzLl9lbWJlZExpbmsoKTtcblx0XHR9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FU0MpIHtcblx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0Ly8gV2UgbmVlZCB0byBjYW5jZWxFeGNsdXNpdmUgd2l0aCB0aGUgYm91bmQgcGFyYW1ldGVycyBpbiBjYXNlIHRoZSBidXR0b24gaXMgdXNlZFxuXHRcdFx0Ly8gaW5zaWRlIGFub3RoZXIgaW4gZXhjbHVzaXZlIG1vZGUgKHN1Y2ggaXMgdGhlIGNhc2Ugb2YgdGhlIGxpbmsgYnV0dG9uKVxuXG5cdFx0XHR0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXG5cdFx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQgc3RhdGUgd2hlbiB0aGUgbGluayBpbnB1dCBjaGFuZ2VzIG9uIHVzZXIgaW50ZXJhY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG5cdCAqIEBtZXRob2QgX2hhbmRsZUxpbmtIcmVmQ2hhbmdlXG5cdCAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBjaGFuZ2UgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9oYW5kbGVMaW5rSHJlZkNoYW5nZSA9IGV2ZW50ID0+IHtcblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdGxpbmtIcmVmOiBldmVudC50YXJnZXQudmFsdWUsXG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFZlcmlmaWVzIHRoYXQgdGhlIGN1cnJlbnQgbGluayBzdGF0ZSBpcyB2YWxpZCBzbyB0aGUgdXNlciBjYW4gc2F2ZSB0aGUgbGluay4gQSB2YWxpZCBzdGF0ZVxuXHQgKiBtZWFucyB0aGF0IHdlIGhhdmUgYSBub24tZW1wdHkgaHJlZiB0aGF0J3MgZGlmZmVyZW50IGZyb20gdGhlIG9yaWdpbmFsIG9uZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcblx0ICogQG1ldGhvZCBfaXNWYWxpZFN0YXRlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3RhdGUgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0X2lzVmFsaWRTdGF0ZSgpIHtcblx0XHRjb25zdCB2YWxpZFN0YXRlID1cblx0XHRcdHRoaXMuc3RhdGUubGlua0hyZWYgJiZcblx0XHRcdHRoaXMuc3RhdGUubGlua0hyZWYgIT09IHRoaXMuc3RhdGUuaW5pdGlhbExpbmsuaHJlZjtcblxuXHRcdHJldHVybiB2YWxpZFN0YXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGVtYmVkIGluIHRoZSBlZGl0b3IgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcblx0ICogQG1ldGhvZCBfcmVtb3ZlRW1iZWRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3JlbW92ZUVtYmVkID0gKCkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGNvbnN0IGVtYmVkV3JhcHBlciA9IHRoaXMuc3RhdGUuZWxlbWVudC5nZXRBc2NlbmRhbnQoZWxlbWVudCA9PiB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudC5oYXNDbGFzcygnY2tlX3dpZGdldF93cmFwcGVyJyk7XG5cdFx0fSk7XG5cblx0XHRlbWJlZFdyYXBwZXIucmVtb3ZlKCk7XG5cblx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVkaXRvckNvbnRleHQudG9Qcm9wcyhCdXR0b25FbWJlZEVkaXQpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG5jb25zdCBLRVlfRU5URVIgPSAxMztcbmNvbnN0IEtFWV9FU0MgPSAyNztcblxuLyoqXG4gKiBUaGUgQnV0dG9uRW1iZWRWaWRlb0VkaXQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2hhbmdpbmcgdGV4dCBjb2xvciBpbiBhIGRvY3VtZW50LlxuICpcbiAqIEB1c2VzIEJ1dHRvbkljb25cbiAqXG4gKiBAY2xhc3MgQnV0dG9uRW1iZWRWaWRlb0VkaXRcbiAqL1xuY2xhc3MgQnV0dG9uRW1iZWRWaWRlb0VkaXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdHN0YXRpYyBrZXkgPSAnZW1iZWRWaWRlb0VkaXQnO1xuXG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXG5cdFx0dGhpcy5zdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogRm9jdXNlcyBvbiB0aGUgbGluayBpbnB1dCB0byBpbW1lZGlhdGVseSBhbGxvdyBlZGl0aW5nLiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGUgY29tcG9uZW50XG5cdCAqIGlzIHJlbmRlcmVkIGluIGV4Y2x1c2l2ZSBtb2RlIHRvIHByZXZlbnQgYWdncmVzc2l2ZSBmb2N1cyBzdGVhbGluZy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFZpZGVvRWRpdFxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUgfHwgdGhpcy5wcm9wcy5tYW51YWxTZWxlY3Rpb24pIHtcblx0XHRcdC8vIFdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgcmVuZGVyaW5nIGN5Y2xlIGJlZm9yZSBmb2N1c2luZyB0byBhdm9pZCB1bmRlc2lyZWRcblx0XHRcdC8vIHNjcm9sbHMgb24gdGhlIHBhZ2VcblxuXHRcdFx0aWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcblx0XHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9mb2N1c1ZpZGVvVXJsSW5wdXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2V0VGltZW91dCh0aGlzLl9mb2N1c1ZpZGVvVXJsSW5wdXQsIDApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZWNlaXZpbmcgbmV3IHByb3BzLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRWaWRlb0VkaXRcblx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG5cdCAqL1xuXHRjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkge1xuXHRcdGNvbnN0IG5ld1N0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUoKTtcblxuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0YWxsOiB1bmRlZmluZWQsXG5cdFx0XHRrZXlzOiB1bmRlZmluZWQsXG5cdFx0XHRuZXc6IG5ld1N0YXRlLFxuXHRcdFx0b2xkOiB1bmRlZmluZWQsXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cblx0ICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhpcy5zdGF0ZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFZpZGVvRWRpdFxuXHQgKiBAbWV0aG9kIGdldEluaXRpYWxTdGF0ZVxuXHQgKi9cblx0Z2V0SW5pdGlhbFN0YXRlKCkge1xuXHRcdC8vIENhbid0IGFjY2VzcyBjb250ZXh0IGZyb20gY29uc3RydWN0b3IsIHNvIGdldCBlZGl0b3IgZnJvbSBwcm9wcy5cblxuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMucHJvcHMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRsZXQgZWxlbWVudDtcblxuXHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdGlmIChzZWxlY3Rpb24pIHtcblx0XHRcdGNvbnN0IHNlbGVjdGVkRWxlbWVudCA9IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuXHRcdFx0aWYgKHNlbGVjdGVkRWxlbWVudCkge1xuXHRcdFx0XHRlbGVtZW50ID0gc2VsZWN0ZWRFbGVtZW50LmZpbmRPbmUoJ1tkYXRhLXdpZGdldD1cInZpZGVvZW1iZWRcIl0nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCB2aWRlb1VSTCA9IGVsZW1lbnRcblx0XHRcdD8gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZW1iZWQtdmlkZW8tdXJsJylcblx0XHRcdDogJyc7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZWxlbWVudCxcblx0XHRcdGluaXRpYWxFbWJlZDoge1xuXHRcdFx0XHR2aWRlb1VSTCxcblx0XHRcdH0sXG5cdFx0XHR2aWRlb1VSTCxcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFZpZGVvRWRpdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBpbnB1dFBsYWNlaG9sZGVyID0gQWxsb3lFZGl0b3IuU3RyaW5ncy5wYXN0ZVZpZGVvTGluaztcblxuXHRcdGNvbnN0IGNsZWFyVmlkZW9VUkxTdHlsZSA9IHtcblx0XHRcdG9wYWNpdHk6IHRoaXMuc3RhdGUudmlkZW9VUkwgPyAxIDogMCxcblx0XHR9O1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWVtYmVkLXZpZGVvLWVkaXRcIj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItaW5wdXQgeHhsXCI+XG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1pbnB1dFwiXG5cdFx0XHRcdFx0XHRvbkNoYW5nZT17dGhpcy5faGFuZGxlVmlkZW9VUkxDaGFuZ2V9XG5cdFx0XHRcdFx0XHRvbktleURvd249e3RoaXMuX2hhbmRsZUtleURvd259XG5cdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj17aW5wdXRQbGFjZWhvbGRlcn1cblx0XHRcdFx0XHRcdHJlZj1cImxpbmtJbnB1dFwiXG5cdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHR2YWx1ZT17dGhpcy5zdGF0ZS52aWRlb1VSTH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY2xlYXJJbnB1dH1cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvbiBhZS1pY29uLXJlbW92ZVwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9jbGVhckxpbmt9XG5cdFx0XHRcdFx0XHRzdHlsZT17Y2xlYXJWaWRlb1VSTFN0eWxlfVxuXHRcdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY2xlYXJ9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbmZpcm19XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRkaXNhYmxlZD17IXRoaXMuX2lzVmFsaWRTdGF0ZSgpfVxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX2VtYmVkVmlkZW9VUkx9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29uZmlybX0+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiY2hlY2tcIiAvPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIHRoZSBsaW5rIGlucHV0LiBUaGlzIG9ubHkgY2hhbmdlcyB0aGUgY29tcG9uZW50IGludGVybmFsIHN0YXRlLCBidXQgZG9lcyBub3Rcblx0ICogYWZmZWN0IHRoZSBsaW5rIGVsZW1lbnQgb2YgdGhlIGVkaXRvci4gT25seSB0aGUgX3JlbW92ZUxpbmsgYW5kIF91cGRhdGVMaW5rIG1ldGhvZHNcblx0ICogYXJlIHRyYW5zbGF0ZWQgdG8gdGhlIGVkaXRvciBlbGVtZW50LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkVmlkZW9FZGl0XG5cdCAqIEBtZXRob2QgX2NsZWFyTGlua1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfY2xlYXJMaW5rKCkge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0dmlkZW9VUkw6ICcnLFxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJzIHRoZSBlbWJlZFZpZGVvVXJsIGNvbW1hbmQgdG8gdHJhbnNmb3JtIHRoZSBsaW5rIGludG8gYW4gZW1iZWQgbWVkaWEgb2JqZWN0XG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgRW1iZWRWaWRlb0VkaXRcblx0ICogQG1ldGhvZCBfZW1iZWRWaWRlb1VSTFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfZW1iZWRWaWRlb1VSTCA9ICgpID0+IHtcblx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRuYXRpdmVFZGl0b3IuZXhlY0NvbW1hbmQoJ2VtYmVkVXJsJywge1xuXHRcdFx0dHlwZTogJ3ZpZGVvJyxcblx0XHRcdHVybDogdGhpcy5zdGF0ZS52aWRlb1VSTCxcblx0XHR9KTtcblxuXHRcdC8vIFdlIG5lZWQgdG8gY2FuY2VsRXhjbHVzaXZlIHdpdGggdGhlIGJvdW5kIHBhcmFtZXRlcnMgaW4gY2FzZSB0aGUgYnV0dG9uIGlzIHVzZWRcblx0XHQvLyBpbnNpZGUgYW5vdGhlciBpbiBleGNsdXNpdmUgbW9kZSAoc3VjaCBpcyB0aGUgY2FzZSBvZiB0aGUgbGluayBidXR0b24pXG5cblx0XHR0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb2N1c2VzIHRoZSB1c2VyIGN1cnNvciBvbiB0aGUgd2lkZ2V0J3MgaW5wdXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRWaWRlb0VkaXRcblx0ICogQG1ldGhvZCBfZm9jdXNWaWRlb1VybElucHV0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9mb2N1c1ZpZGVvVXJsSW5wdXQgPSAoKSA9PiB7XG5cdFx0UmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZzLmxpbmtJbnB1dCkuZm9jdXMoKTtcblx0fTtcblxuXHQvKipcblx0ICogTW9uaXRvcnMga2V5IGludGVyYWN0aW9uIGluc2lkZSB0aGUgaW5wdXQgZWxlbWVudCB0byByZXNwb25kIHRvIHRoZSBrZXlzOlxuXHQgKiAtIEVudGVyOiBDcmVhdGVzL3VwZGF0ZXMgdGhlIGxpbmsuXG5cdCAqIC0gRXNjYXBlOiBEaXNjYXJkcyB0aGUgY2hhbmdlcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFZpZGVvRWRpdFxuXHQgKiBAbWV0aG9kIF9oYW5kbGVLZXlEb3duXG5cdCAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBrZXlib2FyZCBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2hhbmRsZUtleURvd24gPSBldmVudCA9PiB7XG5cdFx0aWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FTlRFUiB8fCBldmVudC5rZXlDb2RlID09PSBLRVlfRVNDKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRU5URVIpIHtcblx0XHRcdHRoaXMuX2VtYmVkVmlkZW9VUkwoKTtcblx0XHR9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FU0MpIHtcblx0XHRcdHRoaXMucHJvcHMuY2FuY2VsRXhjbHVzaXZlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQgc3RhdGUgd2hlbiB0aGUgbGluayBpbnB1dCBjaGFuZ2VzIG9uIHVzZXIgaW50ZXJhY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRWaWRlb0VkaXRcblx0ICogQG1ldGhvZCBfaGFuZGxlVmlkZW9VUkxDaGFuZ2Vcblx0ICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIGNoYW5nZSBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2hhbmRsZVZpZGVvVVJMQ2hhbmdlID0gZXZlbnQgPT4ge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0dmlkZW9VUkw6IGV2ZW50LnRhcmdldC52YWx1ZSxcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogVmVyaWZpZXMgdGhhdCB0aGUgY3VycmVudCBsaW5rIHN0YXRlIGlzIHZhbGlkIHNvIHRoZSB1c2VyIGNhbiBzYXZlIHRoZSBsaW5rLiBBIHZhbGlkIHN0YXRlXG5cdCAqIG1lYW5zIHRoYXQgd2UgaGF2ZSBhIG5vbi1lbXB0eSB2aWRlb1VSTCB0aGF0J3MgZGlmZmVyZW50IGZyb20gdGhlIG9yaWdpbmFsIG9uZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBFbWJlZFZpZGVvRWRpdFxuXHQgKiBAbWV0aG9kIF9pc1ZhbGlkU3RhdGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBzdGF0ZSBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRfaXNWYWxpZFN0YXRlKCkge1xuXHRcdGNvbnN0IHZhbGlkU3RhdGUgPVxuXHRcdFx0dGhpcy5zdGF0ZS52aWRlb1VSTCAmJlxuXHRcdFx0dGhpcy5zdGF0ZS52aWRlb1VSTCAhPT0gdGhpcy5zdGF0ZS5pbml0aWFsRW1iZWQudmlkZW9VUkw7XG5cblx0XHRyZXR1cm4gdmFsaWRTdGF0ZTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBFZGl0b3JDb250ZXh0LnRvUHJvcHMoQnV0dG9uRW1iZWRWaWRlb0VkaXQpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkVtYmVkVmlkZW9FZGl0IGZyb20gJy4vYnV0dG9uLWVtYmVkLXZpZGVvLWVkaXQuanN4JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uRW1iZWRWaWRlbyBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjaGFuZ2luZyB0ZXh0IGNvbG9yIGluIGEgZG9jdW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkVtYmVkVmlkZW9cbiAqL1xuY2xhc3MgQnV0dG9uRW1iZWRWaWRlbyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBrZXkgPSAnZW1iZWRWaWRlbyc7XG5cblx0c3RhdGljIHByb3BUeXBlcyA9IHtcblx0XHQvKipcblx0XHQgKiBUaGUgbGFiZWwgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgYWNjZXNzaWJpbGl0eSBwdXJwb3Nlcy5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFZpZGVvXG5cdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGxhYmVsXG5cdFx0ICovXG5cdFx0bGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGFiSW5kZXggb2YgdGhlIGJ1dHRvbiBpbiBpdHMgdG9vbGJhciBjdXJyZW50IHN0YXRlLiBBIHZhbHVlIG90aGVyIHRoYW4gLTFcblx0XHQgKiBtZWFucyB0aGF0IHRoZSBidXR0b24gaGFzIGZvY3VzIGFuZCBpcyB0aGUgYWN0aXZlIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRWaWRlb1xuXHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0YWJJbmRleFxuXHRcdCAqL1xuXHRcdHRhYkluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0cmV0dXJuIDxCdXR0b25FbWJlZFZpZGVvRWRpdCB7Li4udGhpcy5wcm9wc30gLz47XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnZpZGVvfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWVtYmVkLXZpZGVvXCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmV9XG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MudmlkZW99PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInZpZGVvXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25FbWJlZFZpZGVvO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uS2V5c3Ryb2tlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWtleXN0cm9rZSc7XG5pbXBvcnQgQnV0dG9uRW1iZWRFZGl0IGZyb20gJy4vYnV0dG9uLWVtYmVkLWVkaXQuanN4JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uRW1iZWQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgYW5kIGVkaXRpbmcgYW4gZW1iZWQgbGluayBpbiBhIGRvY3VtZW50LlxuICogQnV0dG9uRW1iZWQgcmVuZGVycyBpbiB0d28gZGlmZmVyZW50IG1vZGVzOlxuICpcbiAqIC0gTm9ybWFsOiBKdXN0IGEgYnV0dG9uIHRoYXQgYWxsb3dzIHRvIHN3aXRjaCB0byB0aGUgZWRpdGlvbiBtb2RlXG4gKiAtIEV4Y2x1c2l2ZTogVGhlIEJ1dHRvbkVtYmVkRWRpdCBVSSB3aXRoIGFsbCB0aGUgbGluayBlZGl0aW9uIGNvbnRyb2xzLlxuICpcbiAqIEBjbGFzcyBCdXR0b25FbWJlZFxuICogQHVzZXMgQnV0dG9uS2V5c3Ryb2tlXG4gKi9cbmNsYXNzIEJ1dHRvbkVtYmVkIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkXG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0a2V5c3Ryb2tlOiB7XG5cdFx0XHRmbjogJ19yZXF1ZXN0RXhjbHVzaXZlJyxcblx0XHRcdGtleXM6IENLRURJVE9SLkNUUkwgKyBDS0VESVRPUi5TSElGVCArIDc2IC8qIEwqLyxcblx0XHRcdG5hbWU6ICdlbWJlZCcsXG5cdFx0fSxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IGVtYmVkXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnZW1iZWQnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0aWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlKSB7XG5cdFx0XHRyZXR1cm4gPEJ1dHRvbkVtYmVkRWRpdCB7Li4udGhpcy5wcm9wc30gLz47XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmxpbmt9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tZW1iZWRcIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX3JlcXVlc3RFeGNsdXNpdmV9XG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MubGlua30+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwicGx1c1wiIC8+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVxdWVzdHMgdGhlIGxpbmsgYnV0dG9uIHRvIGJlIHJlbmRlcmVkIGluIGV4Y2x1c2l2ZSBtb2RlIHRvIGFsbG93IHRoZSBlbWJlZGRpbmcgb2YgYSBsaW5rLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkXG5cdCAqIEBtZXRob2QgX3JlcXVlc3RFeGNsdXNpdmVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3JlcXVlc3RFeGNsdXNpdmUgPSAoKSA9PiB7XG5cdFx0dGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlKEJ1dHRvbkVtYmVkLmtleSk7XG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbktleXN0cm9rZShCdXR0b25FbWJlZCk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25BY3Rpb25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1hY3Rpb24tc3R5bGUnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkgxIGNsYXNzIHByb3ZpZGVzIHdyYXBzIGEgc2VsZWN0aW9uIGluIGBoMWAgZWxlbWVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSDFcbiAqIEB1c2VzIEJ1dHRvbkFjdGlvblN0eWxlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvbkgxIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkgxXG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0c3R5bGU6IHtcblx0XHRcdGVsZW1lbnQ6ICdoMScsXG5cdFx0fSxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IGgxXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25IMVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnaDEnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSDFcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5oMX1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24taDFcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmFwcGx5U3R5bGV9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5oMX0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImgxXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQWN0aW9uU3R5bGUoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblN0eWxlKEJ1dHRvbkgxKSkpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQWN0aW9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tYWN0aW9uLXN0eWxlJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25IMiBjbGFzcyBwcm92aWRlcyB3cmFwcyBhIHNlbGVjdGlvbiBpbiBgaDJgIGVsZW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkgyXG4gKiBAdXNlcyBCdXR0b25BY3Rpb25TdHlsZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25IMiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25IMlxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdHN0eWxlOiB7XG5cdFx0XHRlbGVtZW50OiAnaDInLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBoMlxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSDJcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2gyJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkgyXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuaDJ9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWgyXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5hcHBseVN0eWxlfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuaDJ9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJoMlwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkFjdGlvblN0eWxlKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25TdHlsZShCdXR0b25IMikpKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkhsaW5lIGNsYXNzIHByb3ZpZGVzIGluc2VydHMgaG9yaXpvbnRhbCBsaW5lLlxuICpcbiAqIEBjbGFzcyBCdXR0b25IbGluZVxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICovXG5jbGFzcyBCdXR0b25IbGluZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25IbGluZVxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdob3Jpem9udGFscnVsZScsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBobGluZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSGxpbmVcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2hsaW5lJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkhsaW5lXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuaG9yaXpvbnRhbHJ1bGV9XG5cdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1obGluZVwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5ob3Jpem9udGFscnVsZX0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImhyXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChCdXR0b25IbGluZSk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCdXR0b25JY29uKHtjbGFzc05hbWUgPSAnJywgc3ltYm9sfSkge1xuXHRyZXR1cm4gKFxuXHRcdDxFZGl0b3JDb250ZXh0LkNvbnN1bWVyPlxuXHRcdFx0eyh7ZWRpdG9yfSkgPT4ge1xuXHRcdFx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSBlZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRcdFx0Y29uc3Qgc3ByaXRlbWFwID0gbmF0aXZlRWRpdG9yLmNvbmZpZy5zcHJpdGVtYXAgfHwgJyc7XG5cdFx0XHRcdGNvbnN0IHBhdGggPSBgJHtzcHJpdGVtYXB9IyR7c3ltYm9sfWA7XG5cdFx0XHRcdGNvbnN0IGNsYXNzTmFtZVByZWZpeCA9IGNsYXNzTmFtZSA/IGAgJHtjbGFzc05hbWV9YCA6ICcnO1xuXHRcdFx0XHRjb25zdCBjb21iaW5lZENsYXNzTmFtZSA9IGBhZS1zdmctaWNvbiR7Y2xhc3NOYW1lUHJlZml4fWA7XG5cblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHQ8c3ZnIGNsYXNzTmFtZT17Y29tYmluZWRDbGFzc05hbWV9IGhlaWdodD1cIjE4XCIgd2lkdGg9XCIxOFwiPlxuXHRcdFx0XHRcdFx0PHVzZSBocmVmPXtwYXRofSAvPlxuXHRcdFx0XHRcdDwvc3ZnPlxuXHRcdFx0XHQpO1xuXHRcdFx0fX1cblx0XHQ8L0VkaXRvckNvbnRleHQuQ29uc3VtZXI+XG5cdCk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRBY3RpdmUgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlciBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhbGlnbmluZyBhbiBpbWFnZSBpbiB0aGUgY2VudGVyLlxuICpcbiAqIEBjbGFzcyBCdXR0b25JbWFnZUFsaWduQ2VudGVyXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZUFsaWduQ2VudGVyXG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ2p1c3RpZnljZW50ZXInLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgaW1hZ2VDZW50ZXJcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25DZW50ZXJcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2ltYWdlQ2VudGVyJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25DZW50ZXJcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkNlbnRlcn1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24taW1hZ2UtYWxpZ24tY2VudGVyXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduQ2VudGVyfT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiYWxpZ24taW1hZ2UtY2VudGVyXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcblx0QnV0dG9uQ29tbWFuZEFjdGl2ZShCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uSW1hZ2VBbGlnbkNlbnRlcikpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkltYWdlQWxpZ25MZWZ0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGFsaWduaW5nIGFuIGltYWdlIG9uIGxlZnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkltYWdlQWxpZ25MZWZ0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uSW1hZ2VBbGlnbkxlZnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnbkxlZnRcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnanVzdGlmeWxlZnQnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgaW1hZ2VMZWZ0XG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZUFsaWduTGVmdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnaW1hZ2VMZWZ0JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25MZWZ0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25MZWZ0fVxuXHRcdFx0XHRhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9XG5cdFx0XHRcdGNsYXNzTmFtZT17Y3NzQ2xhc3N9XG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1pbWFnZS1hbGlnbi1sZWZ0XCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduTGVmdH0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImFsaWduLWltYWdlLWxlZnRcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuXHRCdXR0b25Db21tYW5kQWN0aXZlKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25JbWFnZUFsaWduTGVmdCkpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkltYWdlQWxpZ25SaWdodCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhbGlnbmluZyBhbiBpbWFnZSBvbiByaWdodC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25SaWdodFxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdqdXN0aWZ5cmlnaHQnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgaW1hZ2VSaWdodFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdpbWFnZVJpZ2h0JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25SaWdodFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduUmlnaHR9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWltYWdlLWFsaWduLXJpZ2h0XCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduUmlnaHR9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJhbGlnbi1pbWFnZS1yaWdodFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbkNvbW1hbmRBY3RpdmUoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvbkltYWdlQWxpZ25SaWdodCkpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uSW1hZ2UgY2xhc3MgaW5zZXJ0cyBhbiBpbWFnZSB0byB0aGUgY29udGVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSW1hZ2VcbiAqL1xuY2xhc3MgQnV0dG9uSW1hZ2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgaW1hZ2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdpbWFnZUZyb21GaWxlJztcblxuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblx0XHR0aGlzLmZpbGVJbnB1dCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBpbnB1dFN5bGUgPSB7ZGlzcGxheTogJ25vbmUnfTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2PlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5pbWFnZX1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1pbWFnZVwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5oYW5kbGVDbGlja31cblx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5pbWFnZX0+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiZG9jdW1lbnQtaW1hZ2VcIiAvPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblxuXHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRhY2NlcHQ9XCJpbWFnZS8qXCJcblx0XHRcdFx0XHRvbkNoYW5nZT17dGhpcy5fb25JbnB1dENoYW5nZX1cblx0XHRcdFx0XHRyZWY9e3RoaXMuZmlsZUlucHV0fVxuXHRcdFx0XHRcdHN0eWxlPXtpbnB1dFN5bGV9XG5cdFx0XHRcdFx0dHlwZT1cImZpbGVcIlxuXHRcdFx0XHQvPlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTaW11bGF0ZXMgY2xpY2sgb24gdGhlIGlucHV0IGVsZW1lbnQuIFRoaXMgd2lsbCBvcGVuIGJyb3dzZXIncyBuYXRpdmUgZmlsZSBvcGVuIGRpYWxvZy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZVxuXHQgKiBAbWV0aG9kIGhhbmRsZUNsaWNrXG5cdCAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSByZWNlaXZlZCBjbGljayBldmVudCBvbiB0aGUgYnV0dG9uLlxuXHQgKi9cblx0aGFuZGxlQ2xpY2sgPSAoKSA9PiB7XG5cdFx0dGhpcy5maWxlSW5wdXQuY3VycmVudC5jbGljaygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBPbiBpbnB1dCBjaGFuZ2UsIHJlYWRzIHRoZSBjaG9zZW4gZmlsZSBhbmQgZmlyZXMgYW4gZXZlbnQgYGJlZm9yZUltYWdlQWRkYCB3aXRoIHRoZSBpbWFnZSB3aGljaCB3aWxsIGJlIGFkZGVkXG5cdCAqIHRvIHRoZSBjb250ZW50LiBUaGUgaW1hZ2UgZmlsZSB3aWxsIGJlIHBhc3NlZCBpbiB0aGUgYGltYWdlRmlsZXNgIHByb3BlcnR5LlxuXHQgKiBJZiBhbnkgb2YgdGhlIGxpc3RlbmVycyByZXR1cm5zIGBmYWxzZWAgb3IgY2FuY2VscyB0aGUgZXZlbnQsIHRoZSBpbWFnZSB3b24ndCBiZSBhZGRlZCB0byB0aGUgY29udGVudC5cblx0ICogT3RoZXJ3aXNlLCBhbiBldmVudCBgaW1hZ2VBZGRgIHdpbGwgYmUgZmlyZWQgd2l0aCB0aGUgaW5zZXJ0ZWQgZWxlbWVudCBpbnRvIHRoZSBlZGl0YWJsZSBhcmVhLlxuXHQgKiBUaGUgcGFzc2VkIHBhcmFtcyB3aWxsIGJlOlxuXHQgKiAtIGBlbGAgLSB0aGUgY3JlYXRlZCBpbWcgZWxlbWVudFxuXHQgKiAtIGBmaWxlYCAtIHRoZSBvcmlnaW5hbCBpbWFnZSBmaWxlIGZyb20gdGhlIGlucHV0IGVsZW1lbnRcblx0ICpcblx0ICogQGZpcmVzIEJ1dHRvbkltYWdlI2JlZm9yZUltYWdlQWRkXG5cdCAqIEBmaXJlcyBCdXR0b25JbWFnZSNpbWFnZUFkZFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlXG5cdCAqIEBtZXRob2QgX29uSW5wdXRDaGFuZ2Vcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X29uSW5wdXRDaGFuZ2UgPSAoKSA9PiB7XG5cdFx0Y29uc3QgaW5wdXRFbCA9IHRoaXMuZmlsZUlucHV0LmN1cnJlbnQ7XG5cblx0XHQvLyBPbiBJRTExIHRoZSBmdW5jdGlvbiBtaWdodCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhcnJheSBvZlxuXHRcdC8vIGZpbGVzLiBJbiBzdWNoIGEgY2FzZSwgbm8gYWN0aW9ucyB3aWxsIGJlIHRha2VuLlxuXG5cdFx0aWYgKCFpbnB1dEVsLmZpbGVzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0Y29uc3QgZmlsZSA9IGlucHV0RWwuZmlsZXNbMF07XG5cblx0XHRyZWFkZXIub25sb2FkID0gZXZlbnQgPT4ge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRjb25zdCByZXN1bHQgPSBlZGl0b3IuZmlyZSgnYmVmb3JlSW1hZ2VBZGQnLCB7XG5cdFx0XHRcdGltYWdlRmlsZXM6IGZpbGUsXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHRjb25zdCBlbCA9IENLRURJVE9SLmRvbS5lbGVtZW50LmNyZWF0ZUZyb21IdG1sKFxuXHRcdFx0XHRcdGA8aW1nIHNyYz1cIiR7ZXZlbnQudGFyZ2V0LnJlc3VsdH1cIj5gXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0ZWRpdG9yLmluc2VydEVsZW1lbnQoZWwpO1xuXG5cdFx0XHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblxuXHRcdFx0XHRjb25zdCBpbWFnZURhdGEgPSB7XG5cdFx0XHRcdFx0ZWwsXG5cdFx0XHRcdFx0ZmlsZSxcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRlZGl0b3IuZmlyZSgnaW1hZ2VBZGQnLCBpbWFnZURhdGEpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRyZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcblxuXHRcdGlucHV0RWwudmFsdWUgPSAnJztcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uSW1hZ2U7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRBY3RpdmUgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uSW5kZW50QmxvY2sgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgaW5kZW50aW5nIHRoZSBzZWxlY3RlZCBibG9ja3MuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkluZGVudEJsb2NrXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uSW5kZW50QmxvY2sgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSW5kZW50QmxvY2tcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnaW5kZW50Jyxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IGluZGVudEJsb2NrXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbmRlbnRCbG9ja1xuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnaW5kZW50QmxvY2snO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSW5kZW50QmxvY2tcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5pbmRlbnR9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWluZGVudC1ibG9ja1wiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5pbmRlbnR9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJpbmRlbnQtbW9yZVwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbkNvbW1hbmRBY3RpdmUoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvbkluZGVudEJsb2NrKSlcbik7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbktleXN0cm9rZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1rZXlzdHJva2UnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkl0YWxpYyBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBzdHlsaW5nIGFuIHNlbGVjdGlvbiB3aXRoIGl0YWxpYyAoZW0pIHN0eWxlLlxuICpcbiAqIEBjbGFzcyBCdXR0b25JdGFsaWNcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbktleXN0cm9rZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25JdGFsaWMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSXRhbGljXG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ2l0YWxpYycsXG5cdFx0a2V5c3Ryb2tlOiB7XG5cdFx0XHRmbjogJ2V4ZWNDb21tYW5kJyxcblx0XHRcdGtleXM6IENLRURJVE9SLkNUUkwgKyA3MyAvKiBJKi8sXG5cdFx0XHRuYW1lOiAnaXRhbGljJyxcblx0XHR9LFxuXHRcdHN0eWxlOiAnY29yZVN0eWxlc19pdGFsaWMnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgaXRhbGljXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JdGFsaWNcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2l0YWxpYyc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JdGFsaWNcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5pdGFsaWN9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWl0YWxpY1wiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5pdGFsaWN9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJpdGFsaWNcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuXHRCdXR0b25LZXlzdHJva2UoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblN0eWxlKEJ1dHRvbkl0YWxpYykpKVxuKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogQGNsYXNzIEJ1dHRvbkl0ZW1TZWxlY3RvckF1ZGlvXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKi9cbmNsYXNzIEJ1dHRvbkl0ZW1TZWxlY3RvckF1ZGlvIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnYXVkaW9zZWxlY3RvcicsXG5cdH07XG5cblx0c3RhdGljIGtleSA9ICdhdWRpbyc7XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYXVkaW99XG5cdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1hdWRpb1wiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX2hhbmRsZUNsaWNrfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYXVkaW99PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJhdWRpb1wiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG5cblx0X2hhbmRsZUNsaWNrID0gKCkgPT4ge1xuXHRcdHRoaXMuZXhlY0NvbW1hbmQobnVsbCk7XG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoQnV0dG9uSXRlbVNlbGVjdG9yQXVkaW8pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBAY2xhc3MgQnV0dG9uSXRlbVNlbGVjdG9ySW1hZ2VcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuY2xhc3MgQnV0dG9uSXRlbVNlbGVjdG9ySW1hZ2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdpbWFnZXNlbGVjdG9yJyxcblx0fTtcblxuXHRzdGF0aWMga2V5ID0gJ2ltYWdlJztcblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5pbWFnZX1cblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWltYWdlXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5faGFuZGxlQ2xpY2t9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5pbWFnZX0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInBpY3R1cmVcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxuXG5cdF9oYW5kbGVDbGljayA9ICgpID0+IHtcblx0XHR0aGlzLmV4ZWNDb21tYW5kKG51bGwpO1xuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKEJ1dHRvbkl0ZW1TZWxlY3RvckltYWdlKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogQGNsYXNzIEJ1dHRvbkl0ZW1TZWxlY3RvclZpZGVvXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKi9cbmNsYXNzIEJ1dHRvbkl0ZW1TZWxlY3RvclZpZGVvIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAndmlkZW9zZWxlY3RvcicsXG5cdH07XG5cblx0c3RhdGljIGtleSA9ICd2aWRlbyc7XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MudmlkZW99XG5cdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi12aWRlb1wiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX2hhbmRsZUNsaWNrfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MudmlkZW99PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJkb2N1bWVudC1tdWx0aW1lZGlhXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cblxuXHRfaGFuZGxlQ2xpY2sgPSAoKSA9PiB7XG5cdFx0dGhpcy5leGVjQ29tbWFuZChudWxsKTtcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChCdXR0b25JdGVtU2VsZWN0b3JWaWRlbyk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBXaWRnZXRGb2N1c01hbmFnZXIgZnJvbSAnLi4vYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlcic7XG5pbXBvcnQgQnV0dG9uRHJvcGRvd24gZnJvbSAnLi9idXR0b24tZHJvcGRvd24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3Igc2hvd2luZyBhIGxpc3Qgb2ZcbiAqIGl0ZW1zIHRoYXQgY2FuIGJlIHNlbGVjdGVkIGZvciB0aGUgbGluay5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3RcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNpcmN1bGFyOiBmYWxzZSxcblx0XHRkYXRhOiBbXSxcblx0XHRkZWxheTogMTAwLFxuXHRcdGRlc2NlbmRhbnRzOiAnLmFlLXRvb2xiYXItZWxlbWVudCcsXG5cdFx0a2V5czoge1xuXHRcdFx0ZGlzbWlzczogWzI3XSxcblx0XHRcdGRpc21pc3NOZXh0OiBbMzldLFxuXHRcdFx0ZGlzbWlzc1ByZXY6IFszN10sXG5cdFx0XHRuZXh0OiBbNDBdLFxuXHRcdFx0cHJldjogWzM4XSxcblx0XHR9LFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgYnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Rcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdidXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdCc7XG5cblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHR0aGlzLnN0YXRlID0ge1xuXHRcdFx0aXRlbXM6IFtdLFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVjZWl2aW5nIG5ldyBwcm9wcy5cblx0ICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG5cdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1xuXHQgKi9cblx0Y29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcblx0XHRpZiAoIW5leHRQcm9wcy50ZXJtIHx8IG5leHRQcm9wcy50ZXJtICE9PSB0aGlzLnByb3BzLnRlcm0pIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcblxuXHRcdFx0aWYgKG5leHRQcm9wcy50ZXJtKSB7XG5cdFx0XHRcdHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX3VwZGF0ZUl0ZW1zLCB0aGlzLnByb3BzLmRlbGF5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRcdGl0ZW1zOiBbXSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG5leHRQcm9wcy5hdXRvY29tcGxldGVTZWxlY3RlZCkge1xuXHRcdFx0c2V0VGltZW91dCh0aGlzLmZvY3VzLCAwKTtcblx0XHRcdHRoaXMucHJvcHMuc2V0QXV0b2NvbXBsZXRlU3RhdGUoe1xuXHRcdFx0XHRzZWxlY3RlZDogZmFsc2UsXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZnJvbSB0aGUgRE9NLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG5cdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcblx0ICovXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBsaXN0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICghdGhpcy5wcm9wcy5leHBhbmRlZCB8fCAhdGhpcy5zdGF0ZS5pdGVtcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8QnV0dG9uRHJvcGRvd24+XG5cdFx0XHRcdHt0aGlzLl9yZW5kZXJBdXRvY29tcGxldGVJdGVtcyh0aGlzLnN0YXRlLml0ZW1zKX1cblx0XHRcdDwvQnV0dG9uRHJvcGRvd24+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgYmVmb3JlIHJlbmRlcmluZyB3aGVuIG5ldyBwcm9wcyBvciBzdGF0ZSBhcmUgYmVpbmcgcmVjZWl2ZWQuXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlciBvciB3aGVuIGZvcmNlVXBkYXRlIGlzIHVzZWQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Rcblx0ICogQG1ldGhvZCAgc2hvdWxkQ29tcG9uZW50VXBkYXRlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgZmFsc2Ugd2hlbiB0aGUgdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzIGFuZCBzdGF0ZSB3aWxsIG5vdFxuXHQgKiByZXF1aXJlIGEgY29tcG9uZW50IHVwZGF0ZS5cblx0ICovXG5cdHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuXHRcdHJldHVybiAoXG5cdFx0XHRuZXh0UHJvcHMuZXhwYW5kZWQgIT09IHRoaXMucHJvcHMuZXhwYW5kZWQgfHxcblx0XHRcdG5leHRQcm9wcy50ZXJtICE9PSB0aGlzLnByb3BzLnRlcm0gfHxcblx0XHRcdG5leHRTdGF0ZS5pdGVtcyAhPT0gdGhpcy5zdGF0ZS5pdGVtc1xuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVycyBhIHNldCBvZiBsaXN0IGl0ZW1zIGZvciB0aGUgcHJvdmlkZWQgaXRlbXNcblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuXHQgKiBAbWV0aG9kIF9yZW5kZXJBdXRvY29tcGxldGVJdGVtc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBpdGVtcyBMaXN0IG9mIGF1dG9jb21wbGV0ZSBpdGVtcyB0byByZW5kZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBcnJheX0gUmVuZGVyZWQgbGlzdCBpdGVtIGluc3RhbmNlc1xuXHQgKi9cblx0X3JlbmRlckF1dG9jb21wbGV0ZUl0ZW1zKGl0ZW1zKSB7XG5cdFx0aXRlbXMgPSBpdGVtcyB8fCBbXTtcblxuXHRcdGNvbnN0IGhhbmRsZUxpbmtBdXRvY29tcGxldGVDbGljayA9IHRoaXMucHJvcHNcblx0XHRcdC5oYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2s7XG5cblx0XHRyZXR1cm4gaXRlbXMubWFwKGl0ZW0gPT4ge1xuXHRcdFx0Y29uc3QgY2xhc3NOYW1lID1cblx0XHRcdFx0dGhpcy5wcm9wcy50ZXJtID09PSBpdGVtLnVybFxuXHRcdFx0XHRcdD8gJ2FlLXRvb2xiYXItZWxlbWVudCBhY3RpdmUnXG5cdFx0XHRcdFx0OiAnYWUtdG9vbGJhci1lbGVtZW50JztcblxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PGxpIGtleT17aXRlbS51cmx9IHJvbGU9XCJvcHRpb25cIj5cblx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzTmFtZX1cblx0XHRcdFx0XHRcdGRhdGEtdmFsdWU9e2l0ZW0udXJsfVxuXHRcdFx0XHRcdFx0b25DbGljaz17aGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrfT5cblx0XHRcdFx0XHRcdHtpdGVtLnRpdGxlfVxuXHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0KTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIGRhdGEgYWNjb3JkaW5nIHRvIHt0aGlzLnByb3BzLnRlcm19IGFuZCBjYWxscyBzZXRTdGF0ZSgpIHdpdGggdGhlIHJldHVybmVkIGRhdGFcblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuXHQgKiBAbWV0aG9kIF91cGRhdGVJdGVtc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfdXBkYXRlSXRlbXMoKSB7XG5cdFx0aWYgKCF0aGlzLnByb3BzLnRlcm0pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHRoaXMucHJvcHMuZGF0YSh0aGlzLnByb3BzLnRlcm0pKTtcblxuXHRcdHByb21pc2UudGhlbihpdGVtcyA9PiB7XG5cdFx0XHRpZiAoaXRlbXMubGVuZ3RoICYmICF0aGlzLnByb3BzLmV4cGFuZGVkKSB7XG5cdFx0XHRcdHRoaXMucHJvcHMudG9nZ2xlRHJvcGRvd24oKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRcdGl0ZW1zLFxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0Rm9jdXNNYW5hZ2VyKEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0KTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25LZXlzdHJva2UgZnJvbSAnLi4vYmFzZS9idXR0b24ta2V5c3Ryb2tlJztcbmltcG9ydCBCdXR0b25Qcm9wcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1wcm9wcyc7XG5pbXBvcnQgQnV0dG9uTGlua0VkaXRCcm93c2UgZnJvbSAnLi9idXR0b24tbGluay1lZGl0LWJyb3dzZS5qc3gnO1xuaW1wb3J0IEJ1dHRvbkxpbmsgZnJvbSAnLi9idXR0b24tbGluay5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25MaW5rQnJvd3NlIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNoYW5naW5nIHRleHQgY29sb3IgaW4gYSBkb2N1bWVudC5cbiAqXG4gKiBAdXNlcyBCdXR0b25LZXlzdHJva2VcbiAqIEB1c2VzIEJ1dHRvblByb3BzXG4gKlxuICogQGNsYXNzIEJ1dHRvbkxpbmtCcm93c2VcbiAqL1xuY2xhc3MgQnV0dG9uTGlua0Jyb3dzZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0a2V5c3Ryb2tlOiB7XG5cdFx0XHRmbjogJ19yZXF1ZXN0RXhjbHVzaXZlJyxcblx0XHRcdGtleXM6IENLRURJVE9SLkNUUkwgKyA3NiAvKiBMKi8sXG5cdFx0XHRuYW1lOiAnbGlua0Jyb3dzZScsXG5cdFx0fSxcblx0fTtcblxuXHRzdGF0aWMga2V5ID0gJ2xpbmtCcm93c2UnO1xuXG5cdHN0YXRpYyBwcm9wVHlwZXMgPSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIGxhYmVsIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZXMuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gbGFiZWxcblx0XHQgKi9cblx0XHRsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0YWJJbmRleCBvZiB0aGUgYnV0dG9uIGluIGl0cyB0b29sYmFyIGN1cnJlbnQgc3RhdGUuIEEgdmFsdWUgb3RoZXIgdGhhbiAtMVxuXHRcdCAqIG1lYW5zIHRoYXQgdGhlIGJ1dHRvbiBoYXMgZm9jdXMgYW5kIGlzIHRoZSBhY3RpdmUgZWxlbWVudC5cblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0YWJJbmRleFxuXHRcdCAqL1xuXHRcdHRhYkluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0dGhpcy5wcm9wcyA9IHRoaXMubWVyZ2VCdXR0b25DZmdQcm9wcygpO1xuXG5cdFx0XHRyZXR1cm4gPEJ1dHRvbkxpbmtFZGl0QnJvd3NlIHsuLi50aGlzLnByb3BzfSAvPjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIDxCdXR0b25MaW5rIHsuLi50aGlzLnByb3BzfSAvPjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVxdWVzdHMgdGhlIGxpbmsgYnV0dG9uIHRvIGJlIHJlbmRlcmVkIGluIGV4Y2x1c2l2ZSBtb2RlIHRvIGFsbG93IHRoZSBjcmVhdGlvbiBvZiBhIGxpbmsuXG5cdCAqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfcmVxdWVzdEV4Y2x1c2l2ZVxuXHQgKi9cblx0X3JlcXVlc3RFeGNsdXNpdmUoKSB7XG5cdFx0dGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlKEJ1dHRvbkxpbmtCcm93c2Uua2V5KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Qcm9wcyhCdXR0b25LZXlzdHJva2UoQnV0dG9uTGlua0Jyb3dzZSkpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25MaW5rRWRpdCBmcm9tICcuL2J1dHRvbi1saW5rLWVkaXQuanN4JztcblxuLyoqXG4gKiBUaGUgTGlua0VkaXRCcm93c2UgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgYW5kIGVkaXRpbmcgYSBsaW5rIGluIGEgZG9jdW1lbnQsXG4gKiBhbmQgYWxzbyBhbGxvd3MgdG8gbGluayB0byBhbiBleGlzdGluZyBmaWxlIGluIERNLlxuICogUHJvdmlkZXMgVUkgZm9yIGNyZWF0aW5nLCBlZGl0aW5nIGFuZCByZW1vdmluZyBhIGxpbmsuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkxpbmtFZGl0QnJvd3NlXG4gKi9cbmNsYXNzIEJ1dHRvbkxpbmtFZGl0QnJvd3NlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRzdGF0aWMga2V5ID0gJ2xpbmtFZGl0QnJvd3NlJztcblxuXHQvKipcblx0ICpcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXG5cdFx0Y29uc3QgbGluayA9IG5ldyBDS0VESVRPUi5MaW5rKFxuXHRcdFx0Ly8gQ2FuJ3QgYWNjZXNzIGNvbnRleHQgZnJvbSBjb25zdHJ1Y3Rvciwgc28gZ2V0IGVkaXRvciBmcm9tIHByb3BzLlxuXG5cdFx0XHR0aGlzLnByb3BzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJylcblx0XHQpLmdldEZyb21TZWxlY3Rpb24oKTtcblxuXHRcdGNvbnN0IGhyZWYgPSBsaW5rID8gbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSA6ICcnO1xuXG5cdFx0dGhpcy5saW5rRWRpdEJ1dHRvblJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXG5cdFx0dGhpcy5zdGF0ZSA9IHtcblx0XHRcdGVsZW1lbnQ6IGxpbmssXG5cdFx0XHRsaW5rSHJlZjogaHJlZixcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWxpbmstZWRpdC1icm93c2VcIj5cblx0XHRcdFx0PEJ1dHRvbkxpbmtFZGl0IHJlZj17dGhpcy5saW5rRWRpdEJ1dHRvblJlZn0gey4uLnRoaXMucHJvcHN9IC8+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPVwiQnJvd3NlXCJcblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX2Jyb3dzZUNsaWNrfVxuXHRcdFx0XHRcdHRpdGxlPVwiYnJvd3NlXCI+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiZm9sZGVyXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE9wZW5zIGFuIGl0ZW0gc2VsZWN0b3IgZGlhbG9nLlxuXHQgKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX2Jyb3dzZUNsaWNrXG5cdCAqL1xuXHRfYnJvd3NlQ2xpY2sgPSAoKSA9PiB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdGNvbnN0IHVybCA9IGVkaXRvci5jb25maWcuZG9jdW1lbnRCcm93c2VMaW5rVXJsO1xuXHRcdGNvbnN0IGJyb3dzZUxpbmtDYWxsYmFjayA9IGVkaXRvci5jb25maWcuZG9jdW1lbnRCcm93c2VMaW5rQ2FsbGJhY2s7XG5cdFx0Y29uc3QgbGlua1RhcmdldCA9IHRoaXMubGlua0VkaXRCdXR0b25SZWYuY3VycmVudFxuXHRcdFx0PyB0aGlzLmxpbmtFZGl0QnV0dG9uUmVmLmN1cnJlbnQuc3RhdGUubGlua1RhcmdldFxuXHRcdFx0OiAnJztcblxuXHRcdGNvbnN0IGNoYW5nZUxpbmtDYWxsYmFjayA9IHNlbGVjdGVkSXRlbSA9PiB7XG5cdFx0XHR0aGlzLl91cGRhdGVMaW5rKFxuXHRcdFx0XHRzZWxlY3RlZEl0ZW0udmFsdWUsXG5cdFx0XHRcdGxpbmtUYXJnZXQsXG5cdFx0XHRcdHNlbGVjdGVkSXRlbS50aXRsZVxuXHRcdFx0KTtcblx0XHR9O1xuXG5cdFx0aWYgKExhbmcuaXNGdW5jdGlvbihicm93c2VMaW5rQ2FsbGJhY2spKSB7XG5cdFx0XHRicm93c2VMaW5rQ2FsbGJhY2suYXBwbHkobnVsbCwgW2VkaXRvciwgdXJsLCBjaGFuZ2VMaW5rQ2FsbGJhY2tdKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGxpbmsgaW4gdGhlIGVkaXRvciBlbGVtZW50LiBJZiB0aGUgZWxlbWVudCBkaWRuJ3QgZXhpc3QgcHJldmlvdXNseSwgaXQgd2lsbFxuXHQgKiBjcmVhdGUgYSBuZXcgPGE+IGVsZW1lbnQgd2l0aCB0aGUgaHJlZiBzcGVjaWZpZWQgaW4gdGhlIGxpbmsgaW5wdXQuXG5cdCAqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfdXBkYXRlTGlua1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gbGlua0hyZWYgaHJlZiB2YWx1ZSBmb3IgdGhlIGxpbmtcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxpbmtUYXJnZXQgdGFyZ2V0IHZhbHVlIGZvciB0aGUgbGlua1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gbGlua1RpdGxlIGlmIHRoZSBsaW5rIGlzIGEgdGl0bGUgdGhhdCBwb2ludHMgdG8gYSB3aWtpIHBhZ2UgKG9ubHkgd29ya3MgZm9yIGNyZW9sZSlcblx0ICovXG5cdF91cGRhdGVMaW5rID0gKGxpbmtIcmVmLCBsaW5rVGFyZ2V0LCBsaW5rVGl0bGUpID0+IHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0Y29uc3QgbGlua1V0aWxzID0gbmV3IENLRURJVE9SLkxpbmsoZWRpdG9yLCB7YXBwZW5kUHJvdG9jb2w6IGZhbHNlfSk7XG5cdFx0Y29uc3QgbGlua0F0dHJzID0ge1xuXHRcdFx0dGFyZ2V0OiBsaW5rVGFyZ2V0LFxuXHRcdH07XG5cdFx0Y29uc3QgbW9kaWZ5U2VsZWN0aW9uID0ge2FkdmFuY2U6IHRydWV9O1xuXG5cdFx0aWYgKGxpbmtIcmVmKSB7XG5cdFx0XHRpZiAoZWRpdG9yLnBsdWdpbnMgJiYgZWRpdG9yLnBsdWdpbnMuY3Jlb2xlICYmICFsaW5rVGl0bGUpIHtcblx0XHRcdFx0bGlua0hyZWYgPSBsb2NhdGlvbi5vcmlnaW4gKyBsaW5rSHJlZjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuc3RhdGUuZWxlbWVudCkge1xuXHRcdFx0XHRsaW5rQXR0cnMuaHJlZiA9IGxpbmtIcmVmO1xuXG5cdFx0XHRcdGxpbmtVdGlscy51cGRhdGUoXG5cdFx0XHRcdFx0bGlua0F0dHJzLFxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuZWxlbWVudCxcblx0XHRcdFx0XHRtb2RpZnlTZWxlY3Rpb25cblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxpbmtVdGlscy5jcmVhdGUobGlua0hyZWYsIGxpbmtBdHRycywgbW9kaWZ5U2VsZWN0aW9uKTtcblx0XHRcdH1cblxuXHRcdFx0ZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXHRcdH1cblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRWRpdG9yQ29udGV4dC50b1Byb3BzKEJ1dHRvbkxpbmtFZGl0QnJvd3NlKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5pbXBvcnQgV2lkZ2V0RHJvcGRvd24gZnJvbSAnLi4vYmFzZS93aWRnZXQtZHJvcGRvd24nO1xuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdCBmcm9tICcuL2J1dHRvbi1saW5rLWF1dG9jb21wbGV0ZS1saXN0LmpzeCc7XG5pbXBvcnQgQnV0dG9uTGlua1RhcmdldEVkaXQgZnJvbSAnLi9idXR0b24tbGluay10YXJnZXQtZWRpdC5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25MaW5rRWRpdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhIGxpbmsgaW4gYSBkb2N1bWVudC5cbiAqIFByb3ZpZGVzIFVJIGZvciBjcmVhdGluZywgZWRpdGluZyBhbmQgcmVtb3ZpbmcgYSBsaW5rLlxuICpcbiAqIEBjbGFzcyBCdXR0b25MaW5rRWRpdFxuICogQHVzZXMgV2lkZ2V0RHJvcGRvd25cbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBCdXR0b25MaW5rRWRpdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0YXBwZW5kUHJvdG9jb2w6IHRydWUsXG5cdFx0YXV0b2NvbXBsZXRlVXJsOiAnJyxcblx0XHRjaXJjdWxhcjogdHJ1ZSxcblx0XHRjdXN0b21JbmRleFN0YXJ0OiB0cnVlLFxuXHRcdGRlZmF1bHRMaW5rVGFyZ2V0OiAnJyxcblx0XHRkZXNjZW5kYW50czogJy5hZS10b29sYmFyLWVsZW1lbnQnLFxuXHRcdGtleXM6IHtcblx0XHRcdGRpc21pc3M6IFsyN10sXG5cdFx0XHRkaXNtaXNzTmV4dDogWzM5XSxcblx0XHRcdGRpc21pc3NQcmV2OiBbMzddLFxuXHRcdFx0bmV4dDogWzQwXSxcblx0XHRcdHByZXY6IFszOF0sXG5cdFx0fSxcblx0XHRzaG93VGFyZ2V0U2VsZWN0b3I6IHRydWUsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBsaW5rRWRpdFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2xpbmtFZGl0JztcblxuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdHRoaXMubGlua0lucHV0ID0gUmVhY3QuY3JlYXRlUmVmKCk7XG5cdFx0dGhpcy5zdGF0ZSA9IHRoaXMuX2dldEluaXRpYWxTdGF0ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdCAqXG5cdCAqIEZvY3VzZXMgb24gdGhlIGxpbmsgaW5wdXQgdG8gaW1tZWRpYXRlbHkgYWxsb3cgZWRpdGluZy4gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlIGNvbXBvbmVudFxuXHQgKiBpcyByZW5kZXJlZCBpbiBleGNsdXNpdmUgbW9kZSB0byBwcmV2ZW50IGFnZ3Jlc3NpdmUgZm9jdXMgc3RlYWxpbmcuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0aWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlIHx8IHRoaXMucHJvcHMubWFudWFsU2VsZWN0aW9uKSB7XG5cdFx0XHQvLyBXZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZSBiZWZvcmUgZm9jdXNpbmcgdG8gYXZvaWQgdW5kZXNpcmVkXG5cdFx0XHQvLyBzY3JvbGxzIG9uIHRoZSBwYWdlXG5cblx0XHRcdHRoaXMuX2ZvY3VzTGlua0lucHV0KCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlY2VpdmluZyBuZXcgcHJvcHMuXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcblx0ICovXG5cdGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKSB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh0aGlzLl9nZXRJbml0aWFsU3RhdGUoKSk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGxldCB0YXJnZXRTZWxlY3RvciA9IHtcblx0XHRcdGFsbG93ZWRUYXJnZXRzOiB0aGlzLnByb3BzLmFsbG93ZWRUYXJnZXRzLFxuXHRcdFx0ZWRpdG9yOiB0aGlzLmNvbnRleHQuZWRpdG9yLFxuXHRcdFx0aGFuZGxlTGlua1RhcmdldENoYW5nZTogdGhpcy5faGFuZGxlTGlua1RhcmdldENoYW5nZSxcblx0XHRcdHNlbGVjdGVkVGFyZ2V0OlxuXHRcdFx0XHR0aGlzLnN0YXRlLmxpbmtUYXJnZXQgfHwgQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0RGVmYXVsdCxcblx0XHR9O1xuXG5cdFx0dGFyZ2V0U2VsZWN0b3IgPSB0aGlzLm1lcmdlRHJvcGRvd25Qcm9wcyhcblx0XHRcdHRhcmdldFNlbGVjdG9yLFxuXHRcdFx0QnV0dG9uTGlua1RhcmdldEVkaXQua2V5XG5cdFx0KTtcblxuXHRcdGxldCBhdXRvY29tcGxldGVEcm9wZG93bjtcblxuXHRcdGlmICh0aGlzLnByb3BzLmRhdGEpIHtcblx0XHRcdGxldCBkYXRhRm4gPSB0aGlzLnByb3BzLmRhdGE7XG5cblx0XHRcdGlmICghTGFuZy5pc0Z1bmN0aW9uKGRhdGFGbikpIHtcblx0XHRcdFx0Y29uc3QgaXRlbXMgPSB0aGlzLnByb3BzLmRhdGE7XG5cblx0XHRcdFx0ZGF0YUZuID0gKCkgPT4gaXRlbXM7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBhdXRvY29tcGxldGVEcm9wZG93blByb3BzID0ge1xuXHRcdFx0XHRhdXRvY29tcGxldGVTZWxlY3RlZDogdGhpcy5zdGF0ZS5hdXRvY29tcGxldGVTZWxlY3RlZCxcblx0XHRcdFx0ZGF0YTogZGF0YUZuLFxuXHRcdFx0XHRlZGl0b3I6IHRoaXMuY29udGV4dC5lZGl0b3IsXG5cdFx0XHRcdGhhbmRsZUxpbmtBdXRvY29tcGxldGVDbGljazogdGhpcy5faGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrLFxuXHRcdFx0XHRvbkRpc21pc3M6IHRoaXMucHJvcHMudG9nZ2xlRHJvcGRvd24sXG5cdFx0XHRcdHNldEF1dG9jb21wbGV0ZVN0YXRlOiB0aGlzLl9zZXRBdXRvY29tcGxldGVTdGF0ZSxcblx0XHRcdFx0dGVybTogdGhpcy5zdGF0ZS5saW5rSHJlZixcblx0XHRcdH07XG5cblx0XHRcdGF1dG9jb21wbGV0ZURyb3Bkb3duUHJvcHMgPSB0aGlzLm1lcmdlRHJvcGRvd25Qcm9wcyhcblx0XHRcdFx0YXV0b2NvbXBsZXRlRHJvcGRvd25Qcm9wcyxcblx0XHRcdFx0QnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Qua2V5XG5cdFx0XHQpO1xuXG5cdFx0XHRhdXRvY29tcGxldGVEcm9wZG93biA9IChcblx0XHRcdFx0PEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0IHsuLi5hdXRvY29tcGxldGVEcm9wZG93blByb3BzfSAvPlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRsZXQgYnV0dG9uQ2xlYXJMaW5rO1xuXG5cdFx0aWYgKHRoaXMuc3RhdGUubGlua0hyZWYpIHtcblx0XHRcdGJ1dHRvbkNsZWFyTGluayA9IChcblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY2xlYXJJbnB1dH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b24gYWUtYnV0dG9uLWNsZWFyXCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9jbGVhckxpbmt9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY2xlYXJ9PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInRpbWVzLWNpcmNsZVwiIC8+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRjb25zdCBwbGFjZWhvbGRlclByb3AgPSB7fTtcblxuXHRcdGlmICghQ0tFRElUT1IuZW52LmllICYmIEFsbG95RWRpdG9yLlN0cmluZ3MpIHtcblx0XHRcdHBsYWNlaG9sZGVyUHJvcC5wbGFjZWhvbGRlciA9IEFsbG95RWRpdG9yLlN0cmluZ3MuZWRpdExpbms7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWVkaXQtbGlua1wiPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5yZW1vdmVMaW5rfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0ZGlzYWJsZWQ9eyF0aGlzLnN0YXRlLmVsZW1lbnR9XG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5fcmVtb3ZlTGlua31cblx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5yZW1vdmV9PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNoYWluLWJyb2tlblwiIC8+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1pbnB1dCB4eGxcIj5cblx0XHRcdFx0XHR7dGhpcy5wcm9wcy5zaG93VGFyZ2V0U2VsZWN0b3IgJiYgKFxuXHRcdFx0XHRcdFx0PEJ1dHRvbkxpbmtUYXJnZXRFZGl0IHsuLi50YXJnZXRTZWxlY3Rvcn0gLz5cblx0XHRcdFx0XHQpfVxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0XCI+XG5cdFx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtaW5wdXRcIlxuXHRcdFx0XHRcdFx0XHRvbkNoYW5nZT17dGhpcy5faGFuZGxlTGlua0hyZWZDaGFuZ2V9XG5cdFx0XHRcdFx0XHRcdG9uS2V5RG93bj17dGhpcy5faGFuZGxlS2V5RG93bn1cblx0XHRcdFx0XHRcdFx0ey4uLnBsYWNlaG9sZGVyUHJvcH1cblx0XHRcdFx0XHRcdFx0cmVmPXt0aGlzLmxpbmtJbnB1dH1cblx0XHRcdFx0XHRcdFx0dHlwZT1cInRleHRcIlxuXHRcdFx0XHRcdFx0XHR2YWx1ZT17dGhpcy5zdGF0ZS5saW5rSHJlZn1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHR7YXV0b2NvbXBsZXRlRHJvcGRvd259XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0e2J1dHRvbkNsZWFyTGlua31cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbmZpcm19XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRkaXNhYmxlZD17IXRoaXMuX2lzVmFsaWRTdGF0ZSgpfVxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX3VwZGF0ZUxpbmt9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29uZmlybX0+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb24gY2xhc3NOYW1lPVwiYWUtaWNvbi1zdmctY2hlY2tcIiBzeW1ib2w9XCJjaGVja1wiIC8+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGlzLnN0YXRlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG5cdCAqIEBtZXRob2QgX2dldEluaXRpYWxTdGF0ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICovXG5cdF9nZXRJbml0aWFsU3RhdGUoKSB7XG5cdFx0Ly8gQ2FuJ3QgYWNjZXNzIGNvbnRleHQgZnJvbSBjb250cnVjdG9yLCBzbyBnZXQgZWRpdG9yIGZyb20gcHJvcHMuXG5cblx0XHRjb25zdCB7ZWRpdG9yfSA9IHRoaXMucHJvcHMuY29udGV4dDtcblx0XHRjb25zdCB7ZGVmYXVsdExpbmtUYXJnZXR9ID0gdGhpcy5wcm9wcztcblxuXHRcdGNvbnN0IGxpbmsgPSBuZXcgQ0tFRElUT1IuTGluayhcblx0XHRcdGVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpXG5cdFx0KS5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cdFx0Y29uc3QgaHJlZiA9IChsaW5rICYmIGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJykpIHx8ICcnO1xuXHRcdGNvbnN0IHRhcmdldCA9XG5cdFx0XHQobGluayAmJiBsaW5rLmdldEF0dHJpYnV0ZSgndGFyZ2V0JykpIHx8IGRlZmF1bHRMaW5rVGFyZ2V0O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGF1dG9jb21wbGV0ZVNlbGVjdGVkOiBmYWxzZSxcblx0XHRcdGVsZW1lbnQ6IGxpbmssXG5cdFx0XHRpbml0aWFsTGluazoge1xuXHRcdFx0XHRocmVmLFxuXHRcdFx0XHR0YXJnZXQsXG5cdFx0XHR9LFxuXHRcdFx0bGlua0hyZWY6IGhyZWYsXG5cdFx0XHRsaW5rVGFyZ2V0OiB0YXJnZXQsXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIGxpbmsgaW5wdXQuIFRoaXMgb25seSBjaGFuZ2VzIHRoZSBjb21wb25lbnQgaW50ZXJuYWwgc3RhdGUsIGJ1dCBkb2VzIG5vdFxuXHQgKiBhZmZlY3QgdGhlIGxpbmsgZWxlbWVudCBvZiB0aGUgZWRpdG9yLiBPbmx5IHRoZSBfcmVtb3ZlTGluayBhbmQgX3VwZGF0ZUxpbmsgbWV0aG9kc1xuXHQgKiBhcmUgdHJhbnNsYXRlZCB0byB0aGUgZWRpdG9yIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfY2xlYXJMaW5rXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9jbGVhckxpbmsgPSAoKSA9PiB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRsaW5rSHJlZjogJycsXG5cdFx0fSk7XG5cblx0XHR0aGlzLl9mb2N1c0xpbmtJbnB1dCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb2N1c2VzIHRoZSB1c2VyIGN1cnNvciBvbiB0aGUgd2lkZ2V0J3MgaW5wdXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfZm9jdXNMaW5rSW5wdXRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2ZvY3VzTGlua0lucHV0KCkge1xuXHRcdGNvbnN0IGluc3RhbmNlID0gdGhpcztcblxuXHRcdGNvbnN0IGZvY3VzTGlua0VsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpbnN0YW5jZS5saW5rSW5wdXQuY3VycmVudC5mb2N1cygpO1xuXHRcdH07XG5cblx0XHRpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmb2N1c0xpbmtFbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNldFRpbWVvdXQoZm9jdXNMaW5rRWwsIDApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBNb25pdG9ycyBrZXkgaW50ZXJhY3Rpb24gaW5zaWRlIHRoZSBpbnB1dCBlbGVtZW50IHRvIHJlc3BvbmQgdG8gdGhlIGtleXM6XG5cdCAqIC0gRW50ZXI6IENyZWF0ZXMvdXBkYXRlcyB0aGUgbGluay5cblx0ICogLSBFc2NhcGU6IERpc2NhcmRzIHRoZSBjaGFuZ2VzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG5cdCAqIEBtZXRob2QgX2hhbmRsZUtleURvd25cblx0ICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIGtleWJvYXJkIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfaGFuZGxlS2V5RG93biA9IGV2ZW50ID0+IHtcblx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMgfHwgZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LmtleUNvZGUgPT09IDEzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVMaW5rKCk7XG5cdFx0fSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSA0MCkge1xuXHRcdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRcdGF1dG9jb21wbGV0ZVNlbGVjdGVkOiB0cnVlLFxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRuZXcgQ0tFRElUT1IuTGluayhlZGl0b3IpLmFkdmFuY2VTZWxlY3Rpb24oKTtcblxuXHRcdFx0dGhpcy5jb250ZXh0LmVkaXRvclxuXHRcdFx0XHQuZ2V0KCduYXRpdmVFZGl0b3InKVxuXHRcdFx0XHQuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQgc3RhdGUgd2hlbiB0aGUgbGluayBpbnB1dCBjaGFuZ2VzIG9uIHVzZXIgaW50ZXJhY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfaGFuZGxlTGlua0hyZWZDaGFuZ2Vcblx0ICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIGNoYW5nZSBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2hhbmRsZUxpbmtIcmVmQ2hhbmdlID0gZXZlbnQgPT4ge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0bGlua0hyZWY6IGV2ZW50LnRhcmdldC52YWx1ZSxcblx0XHR9KTtcblxuXHRcdHRoaXMuX2ZvY3VzTGlua0lucHV0KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCBzdGF0ZSB3aGVuIHRoZSBsaW5rIHRhcmdldCBjaGFuZ2VzIG9uIHVzZXIgaW50ZXJhY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfaGFuZGxlTGlua1RhcmdldENoYW5nZVxuXHQgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgY2xpY2sgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9oYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlID0gZXZlbnQgPT4ge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0aXRlbURyb3Bkb3duOiBudWxsLFxuXHRcdFx0bGlua1RhcmdldDogZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpLFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fZm9jdXNMaW5rSW5wdXQoKTtcblx0fTtcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgY29tcG9uZW50IHN0YXRlIHdoZW4gYW4gYXV0b2NvbXBsZXRlIGxpbmsgcmVzdWx0IGlzIHNlbGVjdGVkIGJ5IHVzZXIgaW50ZXJhY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfaGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrXG5cdCAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBjbGljayBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2hhbmRsZUxpbmtBdXRvY29tcGxldGVDbGljayhldmVudCkge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0aXRlbURyb3Bkb3duOiBudWxsLFxuXHRcdFx0bGlua0hyZWY6IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSxcblx0XHR9KTtcblxuXHRcdHRoaXMuX2ZvY3VzTGlua0lucHV0KCk7XG5cdH1cblxuXHQvKipcblx0ICogVmVyaWZpZXMgdGhhdCB0aGUgY3VycmVudCBsaW5rIHN0YXRlIGlzIHZhbGlkIHNvIHRoZSB1c2VyIGNhbiBzYXZlIHRoZSBsaW5rLiBBIHZhbGlkIHN0YXRlXG5cdCAqIG1lYW5zIHRoYXQgd2UgaGF2ZSBhIG5vbi1lbXB0eSBocmVmIGFuZCB0aGF0IGVpdGhlciB0aGF0IG9yIHRoZSBsaW5rIHRhcmdldCBhcmUgZGlmZmVyZW50XG5cdCAqIGZyb20gdGhlIG9yaWdpbmFsIGxpbmsuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfaXNWYWxpZFN0YXRlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gW2Rlc2NyaXB0aW9uXVxuXHQgKi9cblx0X2lzVmFsaWRTdGF0ZSgpIHtcblx0XHRjb25zdCB2YWxpZFN0YXRlID1cblx0XHRcdHRoaXMuc3RhdGUubGlua0hyZWYgJiZcblx0XHRcdCh0aGlzLnN0YXRlLmxpbmtIcmVmICE9PSB0aGlzLnN0YXRlLmluaXRpYWxMaW5rLmhyZWYgfHxcblx0XHRcdFx0dGhpcy5zdGF0ZS5saW5rVGFyZ2V0ICE9PSB0aGlzLnN0YXRlLmluaXRpYWxMaW5rLnRhcmdldCk7XG5cblx0XHRyZXR1cm4gdmFsaWRTdGF0ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBsaW5rIGluIHRoZSBlZGl0b3IgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuXHQgKiBAbWV0aG9kIF9yZW1vdmVMaW5rXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9yZW1vdmVMaW5rID0gKCkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRjb25zdCBsaW5rVXRpbHMgPSBuZXcgQ0tFRElUT1IuTGluayhlZGl0b3IpO1xuXHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRjb25zdCBib29rbWFya3MgPSBzZWxlY3Rpb24uY3JlYXRlQm9va21hcmtzKCk7XG5cblx0XHRsaW5rVXRpbHMucmVtb3ZlKHRoaXMuc3RhdGUuZWxlbWVudCwge2FkdmFuY2U6IGZhbHNlfSk7XG5cblx0XHRzZWxlY3Rpb24uc2VsZWN0Qm9va21hcmtzKGJvb2ttYXJrcyk7XG5cblx0XHQvLyBXZSBuZWVkIHRvIGNhbmNlbEV4Y2x1c2l2ZSB3aXRoIHRoZSBib3VuZCBwYXJhbWV0ZXJzIGluIGNhc2UgdGhlIGJ1dHRvbiBpcyB1c2VkXG5cdFx0Ly8gaW5zaWRlIGFub3RoZXIgaW4gZXhjbHVzaXZlIG1vZGUgKHN1Y2ggaXMgdGhlIGNhc2Ugb2YgdGhlIGxpbmsgYnV0dG9uKVxuXG5cdFx0dGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcblxuXHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogVXBkYXRlIGF1dG9jb21wbGV0ZVNlbGVjdGVkIHN0YXRlIHRvIGZvY3VzIGFuZCBzZWxlY3QgYXV0b2NvbXBsZXRlwrRzIGRyb3Bkb3duXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfc2V0QXV0b2NvbXBsZXRlU3RhdGVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3NldEF1dG9jb21wbGV0ZVN0YXRlKHN0YXRlKSB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRhdXRvY29tcGxldGVTZWxlY3RlZDogc3RhdGUuc2VsZWN0ZWQsXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgbGluayBpbiB0aGUgZWRpdG9yIGVsZW1lbnQuIElmIHRoZSBlbGVtZW50IGRpZG4ndCBleGlzdCBwcmV2aW91c2x5LCBpdCB3aWxsXG5cdCAqIGNyZWF0ZSBhIG5ldyA8YT4gZWxlbWVudCB3aXRoIHRoZSBocmVmIHNwZWNpZmllZCBpbiB0aGUgbGluayBpbnB1dC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuXHQgKiBAbWV0aG9kIF91cGRhdGVMaW5rXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF91cGRhdGVMaW5rID0gKCkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRjb25zdCBsaW5rVXRpbHMgPSBuZXcgQ0tFRElUT1IuTGluayhlZGl0b3IsIHtcblx0XHRcdGFwcGVuZFByb3RvY29sOiB0aGlzLnByb3BzLmFwcGVuZFByb3RvY29sLFxuXHRcdH0pO1xuXHRcdGxldCBsaW5rQXR0cnMgPSB7XG5cdFx0XHR0YXJnZXQ6IHRoaXMuc3RhdGUubGlua1RhcmdldCB8fCBudWxsLFxuXHRcdH07XG5cdFx0Y29uc3QgbW9kaWZ5U2VsZWN0aW9uID0ge2FkdmFuY2U6IGZhbHNlfTtcblxuXHRcdGlmICh0aGlzLnN0YXRlLmxpbmtIcmVmKSB7XG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5lbGVtZW50KSB7XG5cdFx0XHRcdGxpbmtBdHRycy5ocmVmID0gdGhpcy5zdGF0ZS5saW5rSHJlZjtcblxuXHRcdFx0XHRsaW5rVXRpbHMudXBkYXRlKFxuXHRcdFx0XHRcdGxpbmtBdHRycyxcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmVsZW1lbnQsXG5cdFx0XHRcdFx0bW9kaWZ5U2VsZWN0aW9uXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIXRoaXMuc3RhdGUubGlua1RhcmdldCkge1xuXHRcdFx0XHRcdGxpbmtBdHRycyA9IHt9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGlua1V0aWxzLmNyZWF0ZShcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmxpbmtIcmVmLFxuXHRcdFx0XHRcdGxpbmtBdHRycyxcblx0XHRcdFx0XHRtb2RpZnlTZWxlY3Rpb25cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0ZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXHRcdH1cblxuXHRcdC8vIFdlIG5lZWQgdG8gY2FuY2VsRXhjbHVzaXZlIHdpdGggdGhlIGJvdW5kIHBhcmFtZXRlcnMgaW4gY2FzZSB0aGUgYnV0dG9uIGlzIHVzZWRcblx0XHQvLyBpbnNpZGUgYW5vdGhlciBpbiBleGNsdXNpdmUgbW9kZSAoc3VjaCBpcyB0aGUgY2FzZSBvZiB0aGUgbGluayBidXR0b24pXG5cblx0XHR0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBFZGl0b3JDb250ZXh0LnRvUHJvcHMoXG5cdFdpZGdldERyb3Bkb3duKFdpZGdldEZvY3VzTWFuYWdlcihCdXR0b25MaW5rRWRpdCkpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFyZ2V0TGlzdCBmcm9tICcuL2J1dHRvbi10YXJnZXQtbGlzdC5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25MaW5rVGFyZ2V0RWRpdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjaGFuZ2luZyB0aGUgdGFyZ2V0IG9mIGEgbGlua1xuICogaW4gdGhlIGRvY3VtZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25MaW5rVGFyZ2V0RWRpdFxuICovXG5jbGFzcyBCdXR0b25MaW5rVGFyZ2V0RWRpdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgbGlua1RhcmdldEVkaXRcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtUYXJnZXRFZGl0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdsaW5rVGFyZ2V0RWRpdCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rVGFyZ2V0RWRpdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBoYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlID0gdGhpcy5wcm9wcy5oYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlO1xuXHRcdGNvbnN0IGFsbG93ZWRMaW5rVGFyZ2V0cyA9IHRoaXMucHJvcHMuYWxsb3dlZFRhcmdldHM7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdlxuXHRcdFx0XHRjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24gYWUtY29udGFpbmVyLWRyb3Bkb3duLW1lZGl1bSBhZS1jb250YWluZXItZWRpdC1saW5rLXRhcmdldCBhZS1oYXMtZHJvcGRvd25cIlxuXHRcdFx0XHR0YWJJbmRleD1cIjBcIj5cblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9XG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17dGhpcy5wcm9wcy5zZWxlY3RlZFRhcmdldH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdFx0cm9sZT1cImNvbWJvYm94XCJcblx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHR0aXRsZT17dGhpcy5wcm9wcy5zZWxlY3RlZFRhcmdldH0+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXJcIj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1kcm9wZG93bi1zZWxlY3RlZC1pdGVtXCI+XG5cdFx0XHRcdFx0XHRcdHt0aGlzLnByb3BzLnNlbGVjdGVkVGFyZ2V0fVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiY2FyZXQtYm90dG9tXCIgLz5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdHt0aGlzLnByb3BzLmV4cGFuZGVkICYmIChcblx0XHRcdFx0XHQ8QnV0dG9uVGFyZ2V0TGlzdFxuXHRcdFx0XHRcdFx0YWxsb3dlZExpbmtUYXJnZXRzPXthbGxvd2VkTGlua1RhcmdldHN9XG5cdFx0XHRcdFx0XHRoYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlPXtoYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlfVxuXHRcdFx0XHRcdFx0b25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdFx0c2VsZWN0ZWRUYXJnZXQ9e3RoaXMucHJvcHMuc2VsZWN0ZWRUYXJnZXR9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0KX1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIGJlZm9yZSByZW5kZXJpbmcgd2hlbiBuZXcgcHJvcHMgb3Igc3RhdGUgYXJlIGJlaW5nIHJlY2VpdmVkLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIgb3Igd2hlbiBmb3JjZVVwZGF0ZSBpcyB1c2VkLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtUYXJnZXRFZGl0XG5cdCAqIEBtZXRob2QgIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGZhbHNlIHdoZW4gdGhlIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcyBhbmQgc3RhdGUgd2lsbCBub3Rcblx0ICogcmVxdWlyZSBhIGNvbXBvbmVudCB1cGRhdGUuXG5cdCAqL1xuXHRzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdG5leHRQcm9wcy5leHBhbmRlZCAhPT0gdGhpcy5wcm9wcy5leHBhbmRlZCB8fFxuXHRcdFx0bmV4dFByb3BzLnNlbGVjdGVkVGFyZ2V0ICE9PSB0aGlzLnByb3BzLnNlbGVjdGVkVGFyZ2V0XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25MaW5rVGFyZ2V0RWRpdDtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgQnV0dG9uS2V5c3Ryb2tlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWtleXN0cm9rZSc7XG5pbXBvcnQgQnV0dG9uUHJvcHMgZnJvbSAnLi4vYmFzZS9idXR0b24tcHJvcHMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25MaW5rRWRpdCBmcm9tICcuL2J1dHRvbi1saW5rLWVkaXQuanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uTGluayBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhIGxpbmsgaW4gYSBkb2N1bWVudC4gQnV0dG9uTGlua1xuICogcmVuZGVycyBpbiB0d28gZGlmZmVyZW50IG1vZGVzOlxuICpcbiAqIC0gTm9ybWFsOiBKdXN0IGEgYnV0dG9uIHRoYXQgYWxsb3dzIHRvIHN3aXRjaCB0byB0aGUgZWRpdGlvbiBtb2RlXG4gKiAtIEV4Y2x1c2l2ZTogVGhlIEJ1dHRvbkxpbmtFZGl0IFVJIHdpdGggYWxsIHRoZSBsaW5rIGVkaXRpb24gY29udHJvbHMuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkxpbmtcbiAqIEB1c2VzIEJ1dHRvblByb3BzXG4gKiBAdXNlcyBCdXR0b25LZXlzdHJva2VcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25MaW5rIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua1xuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGtleXN0cm9rZToge1xuXHRcdFx0Zm46ICdfcmVxdWVzdEV4Y2x1c2l2ZScsXG5cdFx0XHRrZXlzOiBDS0VESVRPUi5DVFJMICsgNzYgLyogTCovLFxuXHRcdFx0bmFtZTogJ2xpbmsnLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBsaW5rXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdsaW5rJztcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBjb250YWluZWQgd2l0aGluIGEgbGluay5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rXG5cdCAqIEBtZXRob2QgaXNBY3RpdmVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIGlzIGluc2lkZSBhIGxpbmssIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG5cdGlzQWN0aXZlKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHRuZXcgQ0tFRElUT1IuTGluayhcblx0XHRcdFx0dGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpXG5cdFx0XHQpLmdldEZyb21TZWxlY3Rpb24oKSAhPT0gbnVsbFxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlKSB7XG5cdFx0XHRjb25zdCBwcm9wcyA9IHRoaXMubWVyZ2VCdXR0b25DZmdQcm9wcygpO1xuXG5cdFx0XHRyZXR1cm4gPEJ1dHRvbkxpbmtFZGl0IHsuLi5wcm9wc30gLz47XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmxpbmt9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tbGlua1wiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5fcmVxdWVzdEV4Y2x1c2l2ZX1cblx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJsaW5rXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0cyB0aGUgbGluayBidXR0b24gdG8gYmUgcmVuZGVyZWQgaW4gZXhjbHVzaXZlIG1vZGUgdG8gYWxsb3cgdGhlIGNyZWF0aW9uIG9mIGEgbGluay5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rXG5cdCAqIEBtZXRob2QgX3JlcXVlc3RFeGNsdXNpdmVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3JlcXVlc3RFeGNsdXNpdmUgPSAoKSA9PiB7XG5cdFx0dGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlKEJ1dHRvbkxpbmsua2V5KTtcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uUHJvcHMoQnV0dG9uS2V5c3Ryb2tlKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25MaW5rKSkpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25PcmRlcmVkTGlzdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBvcmRlcmVkIGxpc3RzIGluIGFuIGVkaXRvci5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uT3JkZXJlZExpc3RcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uT3JkZXJlZExpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uT3JkZXJlZExpc3Rcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnbnVtYmVyZWRsaXN0Jyxcblx0XHRzdHlsZToge1xuXHRcdFx0ZWxlbWVudDogJ29sJyxcblx0XHR9LFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgb2xcblx0ICogQG1lbWJlcm9mIEJ1dHRvbk9yZGVyZWRMaXN0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdvbCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25PcmRlcmVkTGlzdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLm51bWJlcmVkbGlzdH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tb2xcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MubnVtYmVyZWRsaXN0fT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwibGlzdC1vbFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25TdHlsZShCdXR0b25PcmRlcmVkTGlzdCkpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbk91dGRlbnRCbG9jayBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBvdXRkZW50aW5nIGJsb2Nrcy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uT3V0ZGVudEJsb2NrXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uT3V0ZGVudEJsb2NrIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbk91dGRlbnRCbG9ja1xuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdvdXRkZW50Jyxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IG91dGRlbnRCbG9ja1xuXHQgKiBAbWVtYmVyb2YgQnV0dG9uT3V0ZGVudEJsb2NrXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdvdXRkZW50QmxvY2snO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uT3V0ZGVudEJsb2NrXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Mub3V0ZGVudH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tb3V0ZGVudC1ibG9ja1wiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5vdXRkZW50fT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiaW5kZW50LWxlc3NcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuXHRCdXR0b25Db21tYW5kQWN0aXZlKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25PdXRkZW50QmxvY2spKVxuKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZSc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYWxpZ25pbmcgYSBwYXJhZ3JhcGggb24gbGVmdC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0XG4gKlxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnRcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnanVzdGlmeWxlZnQnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgcGFyYWdyYXBoTGVmdFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdwYXJhZ3JhcGhMZWZ0JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduTGVmdH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tcGFyYWdyYXBoLWFsaWduLWxlZnRcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25MZWZ0fT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiYWxpZ24tbGVmdFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbkNvbW1hbmRBY3RpdmUoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdCkpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYWxpZ25pbmcgYSBwYXJhZ3JhcGggb24gcmlnaHQuXG4gKlxuICogQGNsYXNzIEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHRcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnanVzdGlmeXJpZ2h0Jyxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHBhcmFncmFwaFJpZ2h0XG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdwYXJhZ3JhcGhSaWdodCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25SaWdodH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tcGFyYWdyYXBoLWFsaWduLXJpZ2h0XCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduUmlnaHR9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJhbGlnbi1yaWdodFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbkNvbW1hbmRBY3RpdmUoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHQpKVxuKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZHNMaXN0IGZyb20gJy4vYnV0dG9uLWNvbW1hbmRzLWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uUGFyYWdyYXBoQWxpZ24gY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byB3b3JrIHdpdGggdGFibGUgcm93cy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUGFyYWdyYXBoQWxpZ25cbiAqL1xuY2xhc3MgQnV0dG9uUGFyYWdyYXBoQWxpZ24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdHN0YXRpYyBrZXkgPSAncGFyYWdyYXBoQWxpZ24nO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25cblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IGJ1dHRvbkNvbW1hbmRzTGlzdDtcblx0XHRsZXQgYnV0dG9uQ29tbWFuZHNMaXN0SWQ7XG5cdFx0Y29uc3QgZ2V0Q29tbWFuZHMgPSB0aGlzLl9nZXRDb21tYW5kcygpO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMuZXhwYW5kZWQpIHtcblx0XHRcdGJ1dHRvbkNvbW1hbmRzTGlzdElkID0gQnV0dG9uUGFyYWdyYXBoQWxpZ24ua2V5ICsgJ0xpc3QnO1xuXHRcdFx0YnV0dG9uQ29tbWFuZHNMaXN0ID0gKFxuXHRcdFx0XHQ8QnV0dG9uQ29tbWFuZHNMaXN0XG5cdFx0XHRcdFx0Y29tbWFuZHM9e2dldENvbW1hbmRzfVxuXHRcdFx0XHRcdGlubGluZUljb25zPXtmYWxzZX1cblx0XHRcdFx0XHRsaXN0SWQ9e2J1dHRvbkNvbW1hbmRzTGlzdElkfVxuXHRcdFx0XHRcdG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0Lz5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0bGV0IGFjdGl2ZUNvbW1hbmQgPSBnZXRDb21tYW5kc1xuXHRcdFx0LmZpbHRlcihhbGlnbm1lbnQgPT4ge1xuXHRcdFx0XHRjb25zdCBjb21tYW5kID0gZWRpdG9yLmdldENvbW1hbmQoYWxpZ25tZW50LmNvbW1hbmQpO1xuXG5cdFx0XHRcdHJldHVybiBjb21tYW5kID8gY29tbWFuZC5zdGF0ZSA9PT0gQ0tFRElUT1IuVFJJU1RBVEVfT04gOiBmYWxzZTtcblx0XHRcdH0pXG5cdFx0XHQucG9wKCk7XG5cblx0XHRhY3RpdmVDb21tYW5kID0gYWN0aXZlQ29tbWFuZCA/IGFjdGl2ZUNvbW1hbmQgOiBnZXRDb21tYW5kc1swXTtcblxuXHRcdGNvbnN0IGljb25DbGFzc05hbWUgPSBhY3RpdmVDb21tYW5kLmljb247XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24gYWUtY29udGFpbmVyLWRyb3Bkb3duLXhzbWFsbCBhZS1oYXMtZHJvcGRvd25cIj5cblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9XG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17YWN0aXZlQ29tbWFuZC5sYWJlbH1cblx0XHRcdFx0XHRhcmlhLW93bnM9e2J1dHRvbkNvbW1hbmRzTGlzdElkfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLXRvb2xiYXItZWxlbWVudFwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0XHRyb2xlPVwiY29tYm9ib3hcIlxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnJvd30+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXJcIj5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD17aWNvbkNsYXNzTmFtZX0gLz5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNhcmV0LWJvdHRvbVwiIC8+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHR7YnV0dG9uQ29tbWFuZHNMaXN0fVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbGlzdCBvZiBjb21tYW5kcy4gSWYgYSBsaXN0IG9mIGNvbW1hbmRzIHdhcyBwYXNzZWRcblx0ICogYXMgcHJvcGVydHkgYGNvbW1hbmRzYCwgaXQgd2lsbCB0YWtlIGEgcHJlY2VkZW5jZSBvdmVyIHRoZSBkZWZhdWx0IG9uZXMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25cblx0ICogQG1ldGhvZCBfZ2V0Q29tbWFuZHNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGNvbW1hbmRzLlxuXHQgKi9cblx0X2dldENvbW1hbmRzKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLmNvbW1hbmRzIHx8IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdqdXN0aWZ5bGVmdCcsXG5cdFx0XHRcdFx0aWNvbjogJ2FsaWduLWxlZnQnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduTGVmdCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdqdXN0aWZ5Y2VudGVyJyxcblx0XHRcdFx0XHRpY29uOiAnYWxpZ24tY2VudGVyJyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkNlbnRlcixcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdqdXN0aWZ5cmlnaHQnLFxuXHRcdFx0XHRcdGljb246ICdhbGlnbi1yaWdodCcsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25SaWdodCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdqdXN0aWZ5YmxvY2snLFxuXHRcdFx0XHRcdGljb246ICdhbGlnbi1qdXN0aWZ5Jyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkp1c3RpZnksXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25QYXJhZ3JhcGhBbGlnbjtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZSc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25QYXJhZ3JhcGhDZW50ZXIgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2VudGVyaW5nIGEgcGFyYWdyYXBoLlxuICpcbiAqIEBjbGFzcyBCdXR0b25QYXJhZ3JhcGhDZW50ZXJcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25QYXJhZ3JhcGhDZW50ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQ2VudGVyXG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ2p1c3RpZnljZW50ZXInLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgcGFyYWdyYXBoQ2VudGVyXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhDZW50ZXJcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3BhcmFncmFwaENlbnRlcic7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhDZW50ZXJcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkNlbnRlcn1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tcGFyYWdyYXBoLWNlbnRlclwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkNlbnRlcn0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImFsaWduLWNlbnRlclwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbkNvbW1hbmRBY3RpdmUoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblBhcmFncmFwaENlbnRlcikpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblBhcmFncmFwaEp1c3RpZnkgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IganVzdGZ5aW5nIGEgcGFyYWdyYXBoLlxuICpcbiAqIEBjbGFzcyBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ2p1c3RpZnlibG9jaycsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBwYXJhZ3JhcGhKdXN0aWZ5XG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdwYXJhZ3JhcGhKdXN0aWZ5JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEp1c3RpZnlcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkp1c3RpZnl9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXBhcmFncmFwaC1qdXN0aWZ5XCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduSnVzdGlmeX0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImFsaWduLWp1c3RpZnlcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuXHRCdXR0b25Db21tYW5kQWN0aXZlKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5KSlcbik7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblF1b3RlIGNsYXNzIHdyYXBzIGEgc2VsZWN0aW9uIGluIGBibG9ja3F1b3RlYCBlbGVtZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25RdW90ZVxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25RdW90ZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25RdW90ZVxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdibG9ja3F1b3RlJyxcblx0XHRzdHlsZToge1xuXHRcdFx0ZWxlbWVudDogJ2Jsb2NrcXVvdGUnLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBxdW90ZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUXVvdGVcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3F1b3RlJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblF1b3RlXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MucXVvdGV9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXF1b3RlXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnF1b3RlfT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwicXVvdGUtcmlnaHRcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25TdHlsZShCdXR0b25RdW90ZSkpKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblJlbW92ZUZvcm1hdCBjbGFzcyByZW1vdmVzIHN0eWxlIGZvcm1hdHRpbmcuXG4gKlxuICogQGNsYXNzIEJ1dHRvblJlbW92ZUZvcm1hdFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICovXG5jbGFzcyBCdXR0b25SZW1vdmVGb3JtYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUmVtb3ZlRm9ybWF0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ3JlbW92ZUZvcm1hdCcsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCByZW1vdmVGb3JtYXRcblx0ICogQG1lbWJlcm9mIEJ1dHRvblJlbW92ZUZvcm1hdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAncmVtb3ZlRm9ybWF0JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblJlbW92ZUZvcm1hdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnJlbW92ZWZvcm1hdH1cblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXJlbW92ZWZvcm1hdFwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5yZW1vdmVmb3JtYXR9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJyZW1vdmUtc3R5bGVcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKEJ1dHRvblJlbW92ZUZvcm1hdCk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25SZW1vdmVJbWFnZSBjbGFzcyByZW1vdmVzIGFuIGltYWdlIHVzaW5nIGEgQ0tFRElUT1IuY29tbWFuZC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUmVtb3ZlSW1hZ2VcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuY2xhc3MgQnV0dG9uUmVtb3ZlSW1hZ2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdyZW1vdmVJbWFnZScsXG5cdH07XG5cblx0c3RhdGljIGtleSA9ICdyZW1vdmVJbWFnZSc7XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5yZW1vdmVJbWFnZX1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtmYWxzZX1cblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MucmVtb3ZlSW1hZ2V9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJ0aW1lcy1jaXJjbGVcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKEJ1dHRvblJlbW92ZUltYWdlKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU2VwYXJhdG9yIGZ1bmN0aW9uIHJlbmRlcnMgYSBzaW1wbGUgc2VwYXJhdG9yLlxuICovXG5mdW5jdGlvbiBCdXR0b25TZXBhcmF0b3IoX3Byb3BzKSB7XG5cdHJldHVybiA8c3BhbiBjbGFzc05hbWU9XCJhZS1zZXBhcmF0b3JcIiAvPjtcbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBzZXBhcmF0b3JcbiAqIEBtZW1iZXJvZiBCdXR0b25TZXBhcmF0b3JcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9uU2VwYXJhdG9yLmtleSA9ICdzZXBhcmF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25TZXBhcmF0b3I7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0IGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblNwYWNpbmcgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2hhbmdpbmcgdGV4dCBzcGFjaW5nIGluIGEgZG9jdW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvblNwYWNpbmdcbiAqL1xuY2xhc3MgQnV0dG9uU3BhY2luZyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0c3RhdGljIGtleSA9ICdzcGFjaW5nJztcblxuXHRzdGF0aWMgcHJvcFR5cGVzID0ge1xuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdHlsZXMgbGlzdCBpcyBleHBhbmRlZCBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU3BhY2luZ1xuXHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZXhwYW5kZWRcblx0XHQgKi9cblx0XHRleHBhbmRlZDogUHJvcFR5cGVzLmJvb2wsXG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGFiZWwgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgYWNjZXNzaWJpbGl0eSBwdXJwb3Nlcy5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBTcGFjaW5nXG5cdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGxhYmVsXG5cdFx0ICovXG5cdFx0bGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVtb3ZlIHN0eWxlcyBpdGVtIHNob3VsZCBhcHBlYXIgaW4gdGhlIHN0eWxlcyBsaXN0LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFNwYWNpbmdcblx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNob3dSZW1vdmVTdHlsZXNJdGVtXG5cdFx0ICovXG5cdFx0c2hvd1JlbW92ZVN0eWxlc0l0ZW06IFByb3BUeXBlcy5ib29sLFxuXG5cdFx0LyoqXG5cdFx0ICogTGlzdCBvZiB0aGUgc3R5bGVzIHRoZSBidXR0b24gaXMgYWJsZSB0byBoYW5kbGUuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU3BhY2luZ1xuXHRcdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IHN0eWxlc1xuXHRcdCAqL1xuXHRcdHN0eWxlczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9iamVjdCksXG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGFiSW5kZXggb2YgdGhlIGJ1dHRvbiBpbiBpdHMgdG9vbGJhciBjdXJyZW50IHN0YXRlLiBBIHZhbHVlIG90aGVyIHRoYW4gLTFcblx0XHQgKiBtZWFucyB0aGF0IHRoZSBidXR0b24gaGFzIGZvY3VzIGFuZCBpcyB0aGUgYWN0aXZlIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU3BhY2luZ1xuXHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0YWJJbmRleFxuXHRcdCAqL1xuXHRcdHRhYkluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuXG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgcHJvdmlkZWQgYnkgdGhlIGJ1dHRvbiBob3N0IHRvIG5vdGlmeSB3aGVuIHRoZSBzdHlsZXMgbGlzdCBoYXMgYmVlbiBleHBhbmRlZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBTcGFjaW5nXG5cdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdG9nZ2xlRHJvcGRvd25cblx0XHQgKi9cblx0XHR0b2dnbGVEcm9wZG93bjogUHJvcFR5cGVzLmZ1bmMsXG5cdH07XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IGFjdGl2ZVNwYWNpbmcgPSAnMS4weCc7XG5cblx0XHRjb25zdCBzcGFjaW5ncyA9IHRoaXMuX2dldFNwYWNpbmdzKCk7XG5cblx0XHRzcGFjaW5ncy5mb3JFYWNoKGl0ZW0gPT4ge1xuXHRcdFx0aWYgKHRoaXMuX2NoZWNrQWN0aXZlKGl0ZW0uc3R5bGUpKSB7XG5cdFx0XHRcdGFjdGl2ZVNwYWNpbmcgPSBpdGVtLm5hbWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRjb25zdCB7ZWRpdG9yLCBleHBhbmRlZCwgdGFiSW5kZXgsIHRvZ2dsZURyb3Bkb3dufSA9IHRoaXMucHJvcHM7XG5cblx0XHRjb25zdCBidXR0b25TdHlsZXNQcm9wcyA9IHtcblx0XHRcdGFjdGl2ZVN0eWxlOiBhY3RpdmVTcGFjaW5nLFxuXHRcdFx0ZWRpdG9yLFxuXHRcdFx0b25EaXNtaXNzOiB0b2dnbGVEcm9wZG93bixcblx0XHRcdHNob3dSZW1vdmVTdHlsZXNJdGVtOiBmYWxzZSxcblx0XHRcdHN0eWxlczogc3BhY2luZ3MsXG5cdFx0fTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lciBhZS1jb250YWluZXItZHJvcGRvd24tc21hbGwgYWUtaGFzLWRyb3Bkb3duXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXtleHBhbmRlZH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdHJvbGU9XCJjb21ib2JveFwiXG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RhYkluZGV4fT5cblx0XHRcdFx0XHQ8c3Bhbj5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInNlcGFyYXRvclwiIC8+XG5cdFx0XHRcdFx0XHQmbmJzcDtcblx0XHRcdFx0XHRcdHthY3RpdmVTcGFjaW5nfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdHtleHBhbmRlZCAmJiA8QnV0dG9uU3R5bGVzTGlzdCB7Li4uYnV0dG9uU3R5bGVzUHJvcHN9IC8+fVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdF9hcHBseVN0eWxlKGNsYXNzTmFtZSkge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGNvbnN0IHN0eWxlQ29uZmlnID0ge1xuXHRcdFx0ZWxlbWVudDogJ2RpdicsXG5cdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdGNsYXNzOiBjbGFzc05hbWUsXG5cdFx0XHR9LFxuXHRcdH07XG5cblx0XHRjb25zdCBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZShzdHlsZUNvbmZpZyk7XG5cblx0XHRlZGl0b3IuZ2V0U2VsZWN0aW9uKCkubG9jaygpO1xuXG5cdFx0dGhpcy5fZ2V0U3BhY2luZ3MoKS5mb3JFYWNoKGl0ZW0gPT4ge1xuXHRcdFx0aWYgKHRoaXMuX2NoZWNrQWN0aXZlKGl0ZW0uc3R5bGUpKSB7XG5cdFx0XHRcdGVkaXRvci5yZW1vdmVTdHlsZShuZXcgQ0tFRElUT1Iuc3R5bGUoaXRlbS5zdHlsZSkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0ZWRpdG9yLmFwcGx5U3R5bGUoc3R5bGUpO1xuXG5cdFx0ZWRpdG9yLmdldFNlbGVjdGlvbigpLnVubG9jaygpO1xuXG5cdFx0ZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3BhY2luZyBkZWZpbml0aW9uIGlzIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgU3BhY2luZ1xuXHQgKiBAbWV0aG9kIF9jaGVja0FjdGl2ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVDb25maWcgU3BhY2luZyBkZWZpbml0aW9uIGFzIHBlciBodHRwOi8vZG9jcy5ja2VkaXRvci5jb20vIyEvYXBpL0NLRURJVE9SLnN0eWxlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BhY2luZyBpcyBhcHBsaWVkIHRvIHRoZSBzZWxlY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG5cdF9jaGVja0FjdGl2ZShzdHlsZUNvbmZpZykge1xuXHRcdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGxldCBhY3RpdmUgPSB0cnVlO1xuXG5cdFx0Y29uc3QgZWxlbWVudFBhdGggPSBuYXRpdmVFZGl0b3IuZWxlbWVudFBhdGgoKTtcblxuXHRcdGlmIChlbGVtZW50UGF0aCAmJiBlbGVtZW50UGF0aC5sYXN0RWxlbWVudCkge1xuXHRcdFx0c3R5bGVDb25maWcuYXR0cmlidXRlcy5jbGFzcy5zcGxpdCgnICcpLmZvckVhY2goY2xhc3NOYW1lID0+IHtcblx0XHRcdFx0YWN0aXZlID0gYWN0aXZlICYmIGVsZW1lbnRQYXRoLmxhc3RFbGVtZW50Lmhhc0NsYXNzKGNsYXNzTmFtZSk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YWN0aXZlID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjdGl2ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHNwYWNpbmdzLiBFYWNoIHNwYWNpbmcgY29uc2lzdHMgZnJvbSB0aHJlZSBwcm9wZXJ0aWVzOlxuXHQgKiAtIG5hbWUgLSB0aGUgc3R5bGUgbmFtZSwgZm9yIGV4YW1wbGUgXCJkZWZhdWx0XCJcblx0ICogLSBzdHlsZSAtIGFuIG9iamVjdCB3aXRoIG9uZSBwcm9wZXJ0eSwgY2FsbGVkIGBlbGVtZW50YCB3aGljaCB2YWx1ZVxuXHQgKiByZXByZXNlbnRzIHRoZSBzdHlsZSB3aGljaCBoYXZlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQuXG5cdCAqIC0gc3R5bGVGbiAtIGEgZnVuY3Rpb24gd2hpY2ggYXBwbGllcyBzZWxlY3RlZCBzdHlsZSB0byB0aGUgZWRpdG9yIHNlbGVjdGlvblxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFNwYWNpbmdcblx0ICogQG1ldGhvZCBfZ2V0U3BhY2luZ3Ncblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBcnJheTxvYmplY3Q+fSBBbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHNwYWNpbmdzLlxuXHQgKi9cblx0X2dldFNwYWNpbmdzKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLnN0eWxlcyB8fCBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnMS4weCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnMS41eCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ210LTEgbWItMScsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnbXQtMSBtYi0xJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnMi4weCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ210LTIgbWItMicsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnbXQtMiBtYi0yJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnMy4weCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ210LTMgbWItMycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnbXQtMyBtYi0zJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnNC4weCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ210LTQgbWItNCcsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnbXQtNCBtYi00JyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnNS4weCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ210LTUgbWItNScsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnbXQtNSBtYi01JyksXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25TcGFjaW5nO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdHJpa2UgY2xhc3Mgc3R5bGVzIGEgc2VsZWN0aW9uIHdpdGggc3RyaWtlIHN0eWxlLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdHJpa2VcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uU3RyaWtlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0cmlrZVxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdzdHJpa2UnLFxuXHRcdHN0eWxlOiAnY29yZVN0eWxlc19zdHJpa2UnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgc3RyaWtlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHJpa2Vcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3N0cmlrZSc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHJpa2Vcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5zdHJpa2V9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXN0cmlrZVwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5zdHJpa2V9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJzdHJpa2V0aHJvdWdoXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3R5bGUoQnV0dG9uU3RyaWtlKSkpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25zU3R5bGVzTGlzdEhlYWRlciBjbGFzcyBwcm92aWRlcyB0aGUgaGVhZGVyIG9mIGFuIGxpc3Qgb2Ygc3R5bGUgaXRlbXMuXG4gKlxuICogQGNsYXNzIEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyXG4gKi9cbmNsYXNzIEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGtleSA9ICdidXR0b25TdHlsZXNMaXN0SGVhZGVyJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnN0eWxlcyAmJiB0aGlzLnByb3BzLnN0eWxlcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiA8c3BhbiBjbGFzc05hbWU9XCJhZS1saXN0LWhlYWRlclwiPnt0aGlzLnByb3BzLm5hbWV9PC9zcGFuPjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgcHJldmlld2luZyBhIHN0eWxlIGRlZmluaXRpb25cbiAqIGluc2lkZSBhIGxpc3QgYW5kIGFwcGx5aW5nIGl0IHRvIHRoZSBjdXJyZW50IGVkaXRvciBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlXG4gKi9cbmNsYXNzIEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmVcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRyZW1vdmVCbG9ja3M6IFsnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAncHJlJ10sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBidXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmVcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2J1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8bGkgcm9sZT1cIm9wdGlvblwiPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtdG9vbGJhci1lbGVtZW50XCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9yZW1vdmVTdHlsZXN9XG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9PlxuXHRcdFx0XHRcdHtBbGxveUVkaXRvci5TdHJpbmdzLm5vcm1hbH1cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQ8L2xpPlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgaW5saW5lIHN0eWxlcyBhbmQgY29uZmlndXJlZCBibG9jayBlbGVtZW50cyBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZVxuXHQgKiBAbWV0aG9kIF9yZW1vdmVTdHlsZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3JlbW92ZVN0eWxlcyA9ICgpID0+IHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRlZGl0b3IuZXhlY0NvbW1hbmQoJ3JlbW92ZUZvcm1hdCcpO1xuXG5cdFx0dGhpcy5wcm9wcy5yZW1vdmVCbG9ja3MuZm9yRWFjaChibG9ja0l0ZW0gPT4ge1xuXHRcdFx0Y29uc3QgYmxvY2tTdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZSh7ZWxlbWVudDogYmxvY2tJdGVtfSk7XG5cblx0XHRcdGVkaXRvci5yZW1vdmVTdHlsZShibG9ja1N0eWxlKTtcblx0XHR9KTtcblxuXHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmU7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IEJ1dHRvbkFjdGlvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWFjdGlvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdHlsZXNMaXN0SXRlbSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBwcmV2aWV3aW5nIGEgc3R5bGUgZGVmaW5pdGlvblxuICogaW5zaWRlIGEgbGlzdCBhbmQgYXBwbHlpbmcgaXQgdG8gdGhlIGN1cnJlbnQgZWRpdG9yIHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3R5bGVzTGlzdEl0ZW1cbiAqIEB1c2VzIEJ1dHRvbkFjdGlvblN0eWxlXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25TdHlsZXNMaXN0SXRlbSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBidXR0b25TdHlsZXNMaXN0SXRlbVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1cblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2J1dHRvblN0eWxlc0xpc3RJdGVtJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIGJvdGggb24gdGhlIGNsaWVudCBhbmQgc2VydmVyLCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50V2lsbE1vdW50KCkge1xuXHRcdC8vIFN0eWxlcyB3aXRoIHdpbGRjYXJkIGVsZW1lbnQgKCopIGdlbmVyYXRlIGFuIGVtcHR5IHRhZyBpbiB0aGVpciBwcmV2aWV3IDwgY2xhc3M9XCJjdXN0b20tY2xhc3NcIiAvPi5cblx0XHQvLyBXZSBkZWZhdWx0IHRvIGVsZW1lbnQgc3BhbiBhbmQgcmVtb3ZlIHRoZSBtYXJnaW5zIHRvIG9idGFpbiBhIG1vcmUgY29uc2lzdGVudCBzZXQgb2YgcHJldmlld3MuXG5cblx0XHRsZXQgc3R5bGVDZmcgPSB7XG5cdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRzdHlsZXM6IHtcblx0XHRcdFx0bWFyZ2luOiAwLFxuXHRcdFx0fSxcblx0XHR9O1xuXG5cdFx0c3R5bGVDZmcgPSBDS0VESVRPUi50b29scy5tZXJnZShzdHlsZUNmZywgdGhpcy5wcm9wcy5zdHlsZSk7XG5cblx0XHR0aGlzLl9wcmV2aWV3ID0gbmV3IENLRURJVE9SLnN0eWxlKHN0eWxlQ2ZnKS5idWlsZFByZXZpZXcoXG5cdFx0XHR0aGlzLnByb3BzLm5hbWVcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHQvLyBXZSBuZWVkIHRvIHVzZSBkYW5nZXJvdXNlbHlTZXRJbm50ZXJIVE1MIHNpbmNlIHdlJ3JlIG5vdCBpbiBjb250cm9sIG9mIHRoZSBzdHlsZVxuXHRcdC8vIHByZXZpZXcgdGhhdCBpcyBnZW5lcmF0ZWQgYnkgQ0tFZGl0b3IuXG5cblx0XHRjb25zdCBjbGFzc05hbWUgPVxuXHRcdFx0dGhpcy5wcm9wcy5uYW1lID09PSB0aGlzLnByb3BzLmFjdGl2ZVN0eWxlXG5cdFx0XHRcdD8gJ2FlLXRvb2xiYXItZWxlbWVudCBhY3RpdmUnXG5cdFx0XHRcdDogJ2FlLXRvb2xiYXItZWxlbWVudCc7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzTmFtZX1cblx0XHRcdFx0ZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3tfX2h0bWw6IHRoaXMuX3ByZXZpZXd9fVxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9vbkNsaWNrfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdC8+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoZSBpdGVtIHN0eWxlIHRvIHRoZSBlZGl0b3Igc2VsZWN0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtXG5cdCAqIEBtZXRob2QgX29uQ2xpY2tcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X29uQ2xpY2sgPSAoKSA9PiB7XG5cdFx0aWYgKHRoaXMucHJvcHMuc3R5bGVGbikge1xuXHRcdFx0dGhpcy5wcm9wcy5zdHlsZUZuKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFR5cGljYWxseSwgd2Ugd2FudCB0aGUgc3R5bGUgdG8gYmUgdGhlIG9ubHkgb25lIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLCBzb1xuXHRcdFx0Ly8gd2UgZXhlY3V0ZSB0aGUgJ3JlbW92ZUZvcm1hdCcgY29tbWFuZCBmaXJzdC4gTm90ZSB0aGF0IGJsb2NrIHN0eWxlcyB3b24ndCBiZSBjbGVhbmVkLlxuXHRcdFx0Ly8gSG93ZXZlciwgdGhpcyBpcyBjb25zaXN0ZW50IHdpdGggb3RoZXIgZWRpdG9ycyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBmZWF0dXJlLlxuXG5cdFx0XHR0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJykuZXhlY0NvbW1hbmQoJ3JlbW92ZUZvcm1hdCcpO1xuXG5cdFx0XHR0aGlzLmFwcGx5U3R5bGUoKTtcblx0XHR9XG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkFjdGlvblN0eWxlKEJ1dHRvblN0eWxlKEJ1dHRvblN0eWxlc0xpc3RJdGVtKSk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyJztcbmltcG9ydCBCdXR0b25Ecm9wZG93biBmcm9tICcuL2J1dHRvbi1kcm9wZG93bi5qc3gnO1xuaW1wb3J0IEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyIGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LWhlYWRlci5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlIGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0tcmVtb3ZlLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3R5bGVzTGlzdEl0ZW0gZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QtaXRlbS5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdHlsZXNMaXN0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHNob3dpbmcgYSBsaXN0IG9mIHN0eWxlcyB0aGF0IGNhbiBiZVxuICogYXBwbGllZCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdHlsZXNMaXN0XG4gKiBAdXNlcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqL1xuY2xhc3MgQnV0dG9uU3R5bGVzTGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y2lyY3VsYXI6IGZhbHNlLFxuXHRcdGRlc2NlbmRhbnRzOiAnLmFlLXRvb2xiYXItZWxlbWVudCcsXG5cdFx0a2V5czoge1xuXHRcdFx0ZGlzbWlzczogWzI3XSxcblx0XHRcdGRpc21pc3NOZXh0OiBbMzldLFxuXHRcdFx0ZGlzbWlzc1ByZXY6IFszN10sXG5cdFx0XHRuZXh0OiBbNDBdLFxuXHRcdFx0cHJldjogWzM4XSxcblx0XHR9LFxuXHRcdHNob3dSZW1vdmVTdHlsZXNJdGVtOiB0cnVlLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3Rcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBkZWZhdWx0IGJ1dHRvblN0eWxlc0xpc3Rcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnYnV0dG9uU3R5bGVzTGlzdCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdCAqXG5cdCAqIEZvY3VzZXMgb24gdGhlIGxpc3Qgbm9kZSB0byBhbGxvdyBrZXlib2FyZCBpbnRlcmFjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcblx0ICovXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpLmZvY3VzKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIGJvdGggb24gdGhlIGNsaWVudCBhbmQgc2VydmVyLCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG5cdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnRXaWxsTW91bnQoKSB7XG5cdFx0Y29uc3QgYmxvY2tTdHlsZXMgPSBbXTtcblx0XHRjb25zdCBpbmxpbmVTdHlsZXMgPSBbXTtcblx0XHRjb25zdCBvYmplY3RTdHlsZXMgPSBbXTtcblxuXHRcdHRoaXMucHJvcHMuc3R5bGVzLmZvckVhY2goaXRlbSA9PiB7XG5cdFx0XHRjb25zdCBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZShpdGVtLnN0eWxlKTtcblxuXHRcdFx0aWYgKHN0eWxlLnR5cGUgPT09IENLRURJVE9SLlNUWUxFX0JMT0NLKSB7XG5cdFx0XHRcdGJsb2NrU3R5bGVzLnB1c2goaXRlbSk7XG5cdFx0XHR9IGVsc2UgaWYgKHN0eWxlLnR5cGUgPT09IENLRURJVE9SLlNUWUxFX0lOTElORSkge1xuXHRcdFx0XHRpbmxpbmVTdHlsZXMucHVzaChpdGVtKTtcblx0XHRcdH0gZWxzZSBpZiAoc3R5bGUudHlwZSA9PT0gQ0tFRElUT1IuU1RZTEVfT0JKRUNUKSB7XG5cdFx0XHRcdG9iamVjdFN0eWxlcy5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fYmxvY2tTdHlsZXMgPSBibG9ja1N0eWxlcztcblx0XHR0aGlzLl9pbmxpbmVTdHlsZXMgPSBpbmxpbmVTdHlsZXM7XG5cdFx0dGhpcy5fb2JqZWN0U3R5bGVzID0gb2JqZWN0U3R5bGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGxpc3QuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRsZXQgcmVtb3ZlU3R5bGVzSXRlbTtcblxuXHRcdGlmICh0aGlzLnByb3BzLnNob3dSZW1vdmVTdHlsZXNJdGVtKSB7XG5cdFx0XHRyZW1vdmVTdHlsZXNJdGVtID0gKFxuXHRcdFx0XHQ8QnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmVcblx0XHRcdFx0XHRvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdC8+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8QnV0dG9uRHJvcGRvd24gey4uLnRoaXMucHJvcHN9PlxuXHRcdFx0XHR7cmVtb3ZlU3R5bGVzSXRlbX1cblxuXHRcdFx0XHQ8QnV0dG9uc1N0eWxlc0xpc3RIZWFkZXJcblx0XHRcdFx0XHRuYW1lPXtBbGxveUVkaXRvci5TdHJpbmdzLmJsb2NrU3R5bGVzfVxuXHRcdFx0XHRcdHN0eWxlcz17dGhpcy5fYmxvY2tTdHlsZXN9XG5cdFx0XHRcdC8+XG5cdFx0XHRcdHt0aGlzLl9yZW5kZXJTdHlsZXNJdGVtcyh0aGlzLl9ibG9ja1N0eWxlcyl9XG5cblx0XHRcdFx0PEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyXG5cdFx0XHRcdFx0bmFtZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5pbmxpbmVTdHlsZXN9XG5cdFx0XHRcdFx0c3R5bGVzPXt0aGlzLl9pbmxpbmVTdHlsZXN9XG5cdFx0XHRcdC8+XG5cdFx0XHRcdHt0aGlzLl9yZW5kZXJTdHlsZXNJdGVtcyh0aGlzLl9pbmxpbmVTdHlsZXMpfVxuXG5cdFx0XHRcdDxCdXR0b25zU3R5bGVzTGlzdEhlYWRlclxuXHRcdFx0XHRcdG5hbWU9e0FsbG95RWRpdG9yLlN0cmluZ3Mub2JqZWN0U3R5bGVzfVxuXHRcdFx0XHRcdHN0eWxlcz17dGhpcy5fb2JqZWN0U3R5bGVzfVxuXHRcdFx0XHQvPlxuXHRcdFx0XHR7dGhpcy5fcmVuZGVyU3R5bGVzSXRlbXModGhpcy5fb2JqZWN0U3R5bGVzKX1cblx0XHRcdDwvQnV0dG9uRHJvcGRvd24+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIGluc3RhbmNlcyBvZiBCdXR0b25TdHlsZXNMaXN0SXRlbSB3aXRoIHRoZSBwcmV2aWV3IG9mIHRoZSBjb3JyZXNwb25kZW50IGJsb2NrLCBpbmxpbmUgb3Igb2JqZWN0IHN0eWxlcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG5cdCAqIEBtZXRob2QgX3JlbmRlclN0eWxlc0l0ZW1zXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHN0eWxlcyBMaXN0IG9mIHN0eWxlcyBmb3Igd2hpY2ggcHJldmlldyBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7QXJyYXl9IFJlbmRlcmVkIGluc3RhbmNlcyBvZiBCdXR0b25TdHlsZXNMaXN0SXRlbSBjbGFzc1xuXHQgKi9cblx0X3JlbmRlclN0eWxlc0l0ZW1zKHN0eWxlcykge1xuXHRcdGxldCBpdGVtcztcblxuXHRcdGlmIChzdHlsZXMgJiYgc3R5bGVzLmxlbmd0aCkge1xuXHRcdFx0aXRlbXMgPSBzdHlsZXMubWFwKGl0ZW0gPT4ge1xuXHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdDxsaSBrZXk9e2l0ZW0ubmFtZX0gcm9sZT1cIm9wdGlvblwiPlxuXHRcdFx0XHRcdFx0PEJ1dHRvblN0eWxlc0xpc3RJdGVtXG5cdFx0XHRcdFx0XHRcdGFjdGl2ZVN0eWxlPXt0aGlzLnByb3BzLmFjdGl2ZVN0eWxlfVxuXHRcdFx0XHRcdFx0XHRuYW1lPXtpdGVtLm5hbWV9XG5cdFx0XHRcdFx0XHRcdHN0eWxlPXtpdGVtLnN0eWxlfVxuXHRcdFx0XHRcdFx0XHRzdHlsZUZuPXtpdGVtLnN0eWxlRm59XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0Rm9jdXNNYW5hZ2VyKEJ1dHRvblN0eWxlc0xpc3QpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0IGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblN0eWxlcyBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBzdHlsaW5nIGEgc2VsZWN0aW9uIHdpdGggYSBsaXN0IG9mXG4gKiBjb25maWd1cmFibGUgYW5kIGN1c3RvbWl6YWJsZSBzdHlsZXMuIFRoZSBhbGxvd2VkIHN0eWxlcyBmb2xsb3cgQ0tFRElUT1IuU3R5bGUgY29uZmlndXJhdGlvblxuICogKGh0dHA6Ly9kb2NzLmNrZWRpdG9yLmNvbS8jIS9hcGkvQ0tFRElUT1Iuc3R5bGUpXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0eWxlc1xuICovXG5jbGFzcyBCdXR0b25TdHlsZXMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgc3R5bGVzXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3N0eWxlcyc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IGFjdGl2ZVN0eWxlID0gQWxsb3lFZGl0b3IuU3RyaW5ncy5ub3JtYWw7XG5cblx0XHRjb25zdCBzdHlsZXMgPSB0aGlzLl9nZXRTdHlsZXMoKTtcblxuXHRcdHN0eWxlcy5mb3JFYWNoKGl0ZW0gPT4ge1xuXHRcdFx0aWYgKHRoaXMuX2NoZWNrQWN0aXZlKGl0ZW0uc3R5bGUpKSB7XG5cdFx0XHRcdGFjdGl2ZVN0eWxlID0gaXRlbS5uYW1lO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0bGV0IGJ1dHRvblN0eWxlc0xpc3Q7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuXHRcdFx0YnV0dG9uU3R5bGVzTGlzdCA9IChcblx0XHRcdFx0PEJ1dHRvblN0eWxlc0xpc3Rcblx0XHRcdFx0XHRhY3RpdmVTdHlsZT17YWN0aXZlU3R5bGV9XG5cdFx0XHRcdFx0b25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdHNob3dSZW1vdmVTdHlsZXNJdGVtPXt0aGlzLnByb3BzLnNob3dSZW1vdmVTdHlsZXNJdGVtfVxuXHRcdFx0XHRcdHN0eWxlcz17c3R5bGVzfVxuXHRcdFx0XHQvPlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24gYWUtaGFzLWRyb3Bkb3duXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfVxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3R5bGVzICsgJyAnICsgYWN0aXZlU3R5bGV9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtdG9vbGJhci1lbGVtZW50XCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdHJvbGU9XCJjb21ib2JveFwiXG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3R5bGVzICsgJyAnICsgYWN0aXZlU3R5bGV9PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyXCI+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24tc2VsZWN0ZWQtaXRlbVwiPlxuXHRcdFx0XHRcdFx0XHR7YWN0aXZlU3R5bGV9XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJjYXJldC1ib3R0b21cIiAvPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0e2J1dHRvblN0eWxlc0xpc3R9XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3R5bGUgZGVmaW5pdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc1xuXHQgKiBAbWV0aG9kIF9jaGVja0FjdGl2ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVDb25maWcgU3R5bGUgZGVmaW5pdGlvbiBhcyBwZXIgaHR0cDovL2RvY3MuY2tlZGl0b3IuY29tLyMhL2FwaS9DS0VESVRPUi5zdHlsZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHN0eWxlIGlzIGFwcGxpZWQgdG8gdGhlIHNlbGVjdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cblx0X2NoZWNrQWN0aXZlKHN0eWxlQ29uZmlnKSB7XG5cdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0Ly8gU3R5bGVzIHdpdGggd2lsZGNhcmQgZWxlbWVudCAoKikgd29uJ3QgYmUgY29uc2lkZXJlZCBhY3RpdmUgYnkgQ0tFZGl0b3IuIERlZmF1bHRpbmdcblx0XHQvLyB0byBhICdzcGFuJyBlbGVtZW50IHdvcmtzIGZvciBtb3N0IG9mIHRob3NlIGNhc2VzIHdpdGggbm8gZGVmaW5lZCBlbGVtZW50LlxuXG5cdFx0c3R5bGVDb25maWcgPSBDS0VESVRPUi50b29scy5tZXJnZSh7ZWxlbWVudDogJ3NwYW4nfSwgc3R5bGVDb25maWcpO1xuXG5cdFx0Y29uc3Qgc3R5bGUgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoc3R5bGVDb25maWcpO1xuXG5cdFx0cmV0dXJuIHN0eWxlLmNoZWNrQWN0aXZlKG5hdGl2ZUVkaXRvci5lbGVtZW50UGF0aCgpLCBuYXRpdmVFZGl0b3IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2Ygc3R5bGVzLiBFYWNoIHN0eWxlIGNvbnNpc3RzIGZyb20gdHdvIHByb3BlcnRpZXM6XG5cdCAqIC0gbmFtZSAtIHRoZSBzdHlsZSBuYW1lLCBmb3IgZXhhbXBsZSBcImgxXCJcblx0ICogLSBzdHlsZSAtIGFuIG9iamVjdCB3aXRoIG9uZSBwcm9wZXJ0eSwgY2FsbGVkIGBlbGVtZW50YCB3aGljaCB2YWx1ZVxuXHQgKiByZXByZXNlbnRzIHRoZSBzdHlsZSB3aGljaCBoYXZlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzXG5cdCAqIEBtZXRob2QgX2dldFN0eWxlc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0FycmF5PG9iamVjdD59IEFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgc3R5bGVzLlxuXHQgKi9cblx0X2dldFN0eWxlcygpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5wcm9wcy5zdHlsZXMgfHwgW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5oMSxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ2gxJyxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5oMixcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ2gyJyxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5mb3JtYXR0ZWQsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdwcmUnLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmNpdGUsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdjaXRlJyxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5jb2RlLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnY29kZScsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblN0eWxlcztcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU3Vic2NyaXB0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGFwcGx5aW5nIHN1YnNjcmlwdCBzdHlsZSB0byBhIHRleHQgc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdWJzY3JpcHRcbiAqXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblN1YnNjcmlwdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdWJzY3JpcHRcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnc3Vic2NyaXB0Jyxcblx0XHRzdHlsZTogJ2NvcmVTdHlsZXNfc3Vic2NyaXB0Jyxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHN1YnNjcmlwdFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3Vic2NyaXB0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdzdWJzY3JpcHQnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3Vic2NyaXB0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3Vic2NyaXB0fVxuXHRcdFx0XHRhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9XG5cdFx0XHRcdGNsYXNzTmFtZT17Y3NzQ2xhc3N9XG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1zdWJzY3JpcHRcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3Vic2NyaXB0fT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwic3Vic2NyaXB0XCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3R5bGUoQnV0dG9uU3Vic2NyaXB0KSkpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tc3R5bGUnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdXBlcnNjcmlwdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhcHBseWluZyBzdXBlcnNjcmlwdCBzdHlsZSB0byBhIHRleHQgc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdXBlcnNjcmlwdFxuICpcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uU3VwZXJzY3JpcHQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3VwZXJzY3JpcHRcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnc3VwZXJzY3JpcHQnLFxuXHRcdHN0eWxlOiAnY29yZVN0eWxlc19zdXBlcnNjcmlwdCcsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBzdXBlcnNjcmlwdFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3VwZXJzY3JpcHRcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3N1cGVyc2NyaXB0JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN1cGVyc2NyaXB0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3VwZXJzY3JpcHR9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXN1cGVyc2NyaXB0XCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnN1cGVyc2NyaXB0fT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwic3VwZXJzY3JpcHRcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuXHRCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3R5bGUoQnV0dG9uU3VwZXJzY3JpcHQpKVxuKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmRzTGlzdCBmcm9tICcuL2J1dHRvbi1jb21tYW5kcy1saXN0LmpzeCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblRhYmxlQ2VsbCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IHRvIHdvcmsgd2l0aCB0YWJsZSBjZWxscy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVGFibGVDZWxsXG4gKi9cbmNsYXNzIEJ1dHRvblRhYmxlQ2VsbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgdGFibGVDZWxsXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUNlbGxcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3RhYmxlQ2VsbCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUNlbGxcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IGJ1dHRvbkNvbW1hbmRzTGlzdDtcblx0XHRsZXQgYnV0dG9uQ29tbWFuZHNMaXN0SWQ7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuXHRcdFx0YnV0dG9uQ29tbWFuZHNMaXN0SWQgPSBCdXR0b25UYWJsZUNlbGwua2V5ICsgJ0xpc3QnO1xuXHRcdFx0YnV0dG9uQ29tbWFuZHNMaXN0ID0gKFxuXHRcdFx0XHQ8QnV0dG9uQ29tbWFuZHNMaXN0XG5cdFx0XHRcdFx0Y29tbWFuZHM9e3RoaXMuX2dldENvbW1hbmRzKCl9XG5cdFx0XHRcdFx0bGlzdElkPXtidXR0b25Db21tYW5kc0xpc3RJZH1cblx0XHRcdFx0XHRvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdC8+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lciBhZS1oYXMtZHJvcGRvd25cIj5cblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9XG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsfVxuXHRcdFx0XHRcdGFyaWEtb3ducz17YnV0dG9uQ29tbWFuZHNMaXN0SWR9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNlbGx9PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImFkZC1jZWxsXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdHtidXR0b25Db21tYW5kc0xpc3R9XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBsaXN0IG9mIGNvbW1hbmRzLiBJZiBhIGxpc3Qgb2YgY29tbWFuZHMgd2FzIHBhc3NlZFxuXHQgKiBhcyBwcm9wZXJ0eSBgY29tbWFuZHNgLCBpdCB3aWxsIHRha2UgYSBwcmVjZWRlbmNlIG92ZXIgdGhlIGRlZmF1bHQgb25lcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUNlbGxcblx0ICogQG1ldGhvZCBfZ2V0Q29tbWFuZHNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGNvbW1hbmRzLlxuXHQgKi9cblx0X2dldENvbW1hbmRzKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLmNvbW1hbmRzIHx8IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdjZWxsSW5zZXJ0QmVmb3JlJyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsSW5zZXJ0QmVmb3JlLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ2NlbGxJbnNlcnRBZnRlcicsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbEluc2VydEFmdGVyLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ2NlbGxEZWxldGUnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxEZWxldGUsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAnY2VsbE1lcmdlJyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsTWVyZ2UsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAnY2VsbE1lcmdlRG93bicsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbE1lcmdlRG93bixcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdjZWxsTWVyZ2VSaWdodCcsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbE1lcmdlUmlnaHQsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAnY2VsbEhvcml6b250YWxTcGxpdCcsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbFNwbGl0SG9yaXpvbnRhbCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdjZWxsVmVydGljYWxTcGxpdCcsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbFNwbGl0VmVydGljYWwsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25UYWJsZUNlbGw7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kc0xpc3QgZnJvbSAnLi9idXR0b24tY29tbWFuZHMtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYWJsZUNvbHVtbiBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IHRvIHdvcmsgd2l0aCB0YWJsZSBjb2x1bW5zLlxuICpcbiAqIEBjbGFzcyBCdXR0b25UYWJsZUNvbHVtblxuICovXG5jbGFzcyBCdXR0b25UYWJsZUNvbHVtbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgdGFibGVDb2x1bW5cblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlQ29sdW1uXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICd0YWJsZUNvbHVtbic7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUNvbHVtblxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRsZXQgYnV0dG9uQ29tbWFuZHNMaXN0O1xuXHRcdGxldCBidXR0b25Db21tYW5kc0xpc3RJZDtcblxuXHRcdGlmICh0aGlzLnByb3BzLmV4cGFuZGVkKSB7XG5cdFx0XHRidXR0b25Db21tYW5kc0xpc3RJZCA9IEJ1dHRvblRhYmxlQ29sdW1uLmtleSArICdMaXN0Jztcblx0XHRcdGJ1dHRvbkNvbW1hbmRzTGlzdCA9IChcblx0XHRcdFx0PEJ1dHRvbkNvbW1hbmRzTGlzdFxuXHRcdFx0XHRcdGNvbW1hbmRzPXt0aGlzLl9nZXRDb21tYW5kcygpfVxuXHRcdFx0XHRcdGxpc3RJZD17YnV0dG9uQ29tbWFuZHNMaXN0SWR9XG5cdFx0XHRcdFx0b25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHQvPlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXIgYWUtaGFzLWRyb3Bkb3duXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfVxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29sdW1ufVxuXHRcdFx0XHRcdGFyaWEtb3ducz17YnV0dG9uQ29tbWFuZHNMaXN0SWR9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdHJvbGU9XCJsaXN0Ym94XCJcblx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5jb2x1bW59PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImFkZC1jb2x1bW5cIiAvPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0e2J1dHRvbkNvbW1hbmRzTGlzdH1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGxpc3Qgb2YgY29tbWFuZHMuIElmIGEgbGlzdCBvZiBjb21tYW5kcyB3YXMgcGFzc2VkXG5cdCAqIGFzIHByb3BlcnR5IGBjb21tYW5kc2AsIGl0IHdpbGwgdGFrZSBhIHByZWNlZGVuY2Ugb3ZlciB0aGUgZGVmYXVsdCBvbmVzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlQ29sdW1uXG5cdCAqIEBtZXRob2QgX2dldENvbW1hbmRzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIGF2YWlsYWJsZSBjb21tYW5kcy5cblx0ICovXG5cdF9nZXRDb21tYW5kcygpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5wcm9wcy5jb21tYW5kcyB8fCBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAnY29sdW1uSW5zZXJ0QmVmb3JlJyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jb2x1bW5JbnNlcnRCZWZvcmUsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAnY29sdW1uSW5zZXJ0QWZ0ZXInLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNvbHVtbkluc2VydEFmdGVyLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ2NvbHVtbkRlbGV0ZScsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY29sdW1uRGVsZXRlLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uVGFibGVDb2x1bW47XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG5jb25zdCBLRVlfRU5URVIgPSAxMztcbmNvbnN0IEtFWV9FU0MgPSAyNztcblxuY29uc3QgSU5QVVRfTkFNRVMgPSB7XG5cdENPTFM6ICdjb2xzJyxcblx0Uk9XUzogJ3Jvd3MnLFxufTtcblxuY29uc3QgTUlOSU1VTV9HUklEX1ZBTFVFID0gMTtcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGVFZGl0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIGFuZCBlZGl0aW5nIGEgdGFibGUgaW4gYSBkb2N1bWVudC5cbiAqIFByb3ZpZGVzIFVJIGZvciBjcmVhdGluZyBhIHRhYmxlLlxuICpcbiAqIEBjbGFzcyBCdXR0b25UYWJsZUVkaXRcbiAqL1xuY2xhc3MgQnV0dG9uVGFibGVFZGl0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVFZGl0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdHRhYmxlQXR0cmlidXRlczoge1xuXHRcdFx0Ym9yZGVyOiAxLFxuXHRcdFx0Y2VsbFBhZGRpbmc6IDAsXG5cdFx0XHRjZWxsU3BhY2luZzogMCxcblx0XHRcdHN0eWxlOiAndGFibGUtbGF5b3V0OiBmaXhlZDsgd2lkdGg6IDEwMCU7Jyxcblx0XHR9LFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgdGFibGVFZGl0XG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUVkaXRcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3RhYmxlRWRpdCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVFZGl0XG5cdCAqIEBtZXRob2QgZ2V0SW5pdGlhbFN0YXRlXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdHRoaXMucm93c1JlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXHRcdHRoaXMuY29sc1JlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXHRcdHRoaXMuc3RhdGUgPSB7XG5cdFx0XHRjb2xzOiAzLFxuXHRcdFx0cm93czogMyxcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQgKG5vdCBvbiB0aGUgc2VydmVyKSxcblx0ICogaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogRm9jdXNlcyBvbiB0aGUgbGluayBpbnB1dCB0byBpbW1lZGlhdGVseSBhbGxvdyBlZGl0aW5nLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLnJvd3NSZWYuY3VycmVudC5mb2N1cygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSB0YWJsZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUVkaXRcblx0ICogQG1ldGhvZCBfY3JlYXRlVGFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2NyZWF0ZVRhYmxlID0gKCkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRjb25zdCB0YWJsZVV0aWxzID0gbmV3IENLRURJVE9SLlRhYmxlKGVkaXRvcik7XG5cdFx0Y29uc3Qge2NvbHMsIHJvd3N9ID0gdGhpcy5zdGF0ZTtcblxuXHRcdHRhYmxlVXRpbHMuY3JlYXRlKHtcblx0XHRcdGF0dHJzOiB0aGlzLnByb3BzLnRhYmxlQXR0cmlidXRlcyxcblx0XHRcdGNvbHM6IE1hdGgubWF4KE1JTklNVU1fR1JJRF9WQUxVRSwgY29scyksXG5cdFx0XHRyb3dzOiBNYXRoLm1heChNSU5JTVVNX0dSSURfVkFMVUUsIHJvd3MpLFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcblxuXHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlcyBhIGNoYW5nZSBpbiBpbnB1dCB2YWx1ZS4gU2V0cyB0aGUgcHJvdmlkZWQgdmFsdWUgZnJvbSB0aGUgdXNlciBiYWNrIHRvIHRoZSBpbnB1dC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUVkaXRcblx0ICogQG1ldGhvZCBfaGFuZGxlQ2hhbmdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGlucHV0IHdoaWNoIHZhbHVlIHNob3VsZCBiZSB1cGRhdGVkLlxuXHQgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgcHJvdmlkZWQgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9oYW5kbGVDaGFuZ2UgPSAoaW5wdXROYW1lLCBldmVudCkgPT4ge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0W2lucHV0TmFtZV06IGV2ZW50LnRhcmdldC52YWx1ZSxcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogTW9uaXRvcnMga2V5IGludGVyYWN0aW9uIGluc2lkZSB0aGUgaW5wdXQgZWxlbWVudCB0byByZXNwb25kIHRvIHRoZSBrZXlzOlxuXHQgKiAtIEVudGVyOiBDcmVhdGVzIHRoZSB0YWJsZS5cblx0ICogLSBFc2NhcGU6IERpc2NhcmRzIHRoZSBjaGFuZ2VzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuXHQgKiBAbWV0aG9kIF9oYW5kbGVLZXlEb3duXG5cdCAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBrZXlib2FyZCBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2hhbmRsZUtleURvd24gPSBldmVudCA9PiB7XG5cdFx0aWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FTlRFUiB8fCBldmVudC5rZXlDb2RlID09PSBLRVlfRVNDKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRU5URVIpIHtcblx0XHRcdHRoaXMuX2NyZWF0ZVRhYmxlKCk7XG5cdFx0fSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRVNDKSB7XG5cdFx0XHR0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCB0aW1lID0gRGF0ZS5ub3coKTtcblx0XHRjb25zdCByb3dzSWQgPSB0aW1lICsgSU5QVVRfTkFNRVMuUk9XUztcblx0XHRjb25zdCBjb2xzSWQgPSB0aW1lICsgSU5QVVRfTkFNRVMuQ09MUztcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1lZGl0LXRhYmxlXCI+XG5cdFx0XHRcdDxsYWJlbCBodG1sRm9yPXtyb3dzSWR9PntBbGxveUVkaXRvci5TdHJpbmdzLnJvd3N9PC9sYWJlbD5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItaW5wdXQgc21hbGxcIj5cblx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWlucHV0XCJcblx0XHRcdFx0XHRcdGlkPXtyb3dzSWR9XG5cdFx0XHRcdFx0XHRtaW49e01JTklNVU1fR1JJRF9WQUxVRX1cblx0XHRcdFx0XHRcdG9uQ2hhbmdlPXt0aGlzLl9oYW5kbGVDaGFuZ2UuYmluZChcblx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0SU5QVVRfTkFNRVMuUk9XU1xuXHRcdFx0XHRcdFx0KX1cblx0XHRcdFx0XHRcdG9uS2V5RG93bj17dGhpcy5faGFuZGxlS2V5RG93bn1cblx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPVwiUm93c1wiXG5cdFx0XHRcdFx0XHRyZWY9e3RoaXMucm93c1JlZn1cblx0XHRcdFx0XHRcdHR5cGU9XCJudW1iZXJcIlxuXHRcdFx0XHRcdFx0dmFsdWU9e3RoaXMuc3RhdGUucm93c31cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8bGFiZWwgaHRtbEZvcj17Y29sc0lkfT57QWxsb3lFZGl0b3IuU3RyaW5ncy5jb2x1bW5zfTwvbGFiZWw+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0IHNtYWxsXCI+XG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1pbnB1dFwiXG5cdFx0XHRcdFx0XHRpZD17Y29sc0lkfVxuXHRcdFx0XHRcdFx0bWluPXtNSU5JTVVNX0dSSURfVkFMVUV9XG5cdFx0XHRcdFx0XHRvbkNoYW5nZT17dGhpcy5faGFuZGxlQ2hhbmdlLmJpbmQoXG5cdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdElOUFVUX05BTUVTLkNPTFNcblx0XHRcdFx0XHRcdCl9XG5cdFx0XHRcdFx0XHRvbktleURvd249e3RoaXMuX2hhbmRsZUtleURvd259XG5cdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj1cIkNvbHVtc1wiXG5cdFx0XHRcdFx0XHRyZWY9e3RoaXMuY29sc1JlZn1cblx0XHRcdFx0XHRcdHR5cGU9XCJudW1iZXJcIlxuXHRcdFx0XHRcdFx0dmFsdWU9e3RoaXMuc3RhdGUuY29sc31cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1sYWJlbD1cIkNvbmZpcm1cIlxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5fY3JlYXRlVGFibGV9PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNoZWNrXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlRWRpdDtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZHNMaXN0IGZyb20gJy4vYnV0dG9uLWNvbW1hbmRzLWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGVIZWFkaW5nIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gd29yayB3aXRoIHRhYmxlIGhlYWRpbmcuXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhYmxlSGVhZGluZ1xuICovXG5jbGFzcyBCdXR0b25UYWJsZUhlYWRpbmcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgdGFibGVSb3dcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlSGVhZGluZ1xuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndGFibGVIZWFkaW5nJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlSGVhZGluZ1xuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRsZXQgYnV0dG9uQ29tbWFuZHNMaXN0O1xuXHRcdGxldCBidXR0b25Db21tYW5kc0xpc3RJZDtcblxuXHRcdGlmICh0aGlzLnByb3BzLmV4cGFuZGVkKSB7XG5cdFx0XHRidXR0b25Db21tYW5kc0xpc3RJZCA9IEJ1dHRvblRhYmxlSGVhZGluZy5rZXkgKyAnTGlzdCc7XG5cdFx0XHRidXR0b25Db21tYW5kc0xpc3QgPSAoXG5cdFx0XHRcdDxCdXR0b25Db21tYW5kc0xpc3Rcblx0XHRcdFx0XHRjb21tYW5kcz17dGhpcy5fZ2V0Q29tbWFuZHMoKX1cblx0XHRcdFx0XHRsaXN0SWQ9e2J1dHRvbkNvbW1hbmRzTGlzdElkfVxuXHRcdFx0XHRcdG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0Lz5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgYWN0aXZlSGVhZGluZyA9IG5ldyBDS0VESVRPUi5UYWJsZShcblx0XHRcdHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKVxuXHRcdCkuZ2V0SGVhZGluZygpO1xuXHRcdGNvbnN0IGFjdGl2ZUhlYWRpbmdJbnRybyA9IEFsbG95RWRpdG9yLlN0cmluZ3MuaGVhZGVycyArICc6Jztcblx0XHRjb25zdCBhY3RpdmVIZWFkaW5nTGFiZWwgPVxuXHRcdFx0QWxsb3lFZGl0b3IuU3RyaW5nc1snaGVhZGVycycgKyBhY3RpdmVIZWFkaW5nXTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1kcm9wZG93bi14bCBhZS1oYXMtZHJvcGRvd25cIj5cblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9XG5cdFx0XHRcdFx0YXJpYS1sYWJlbD1cIlwiXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtdG9vbGJhci1lbGVtZW50XCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdHJvbGU9XCJjb21ib2JveFwiXG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0dGl0bGU9XCJcIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lclwiPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWRyb3Bkb3duLXNlbGVjdGVkLWl0ZW1cIj5cblx0XHRcdFx0XHRcdFx0e2FjdGl2ZUhlYWRpbmdJbnRyb317JyAnfVxuXHRcdFx0XHRcdFx0XHQ8c3Ryb25nPnthY3RpdmVIZWFkaW5nTGFiZWx9PC9zdHJvbmc+XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJjYXJldC1ib3R0b21cIiAvPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0e2J1dHRvbkNvbW1hbmRzTGlzdH1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGxpc3Qgb2YgY29tbWFuZHMuIElmIGEgbGlzdCBvZiBjb21tYW5kcyB3YXMgcGFzc2VkXG5cdCAqIGFzIHByb3BlcnR5IGBjb21tYW5kc2AsIGl0IHdpbGwgdGFrZSBhIHByZWNlZGVuY2Ugb3ZlciB0aGUgZGVmYXVsdCBvbmVzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlSGVhZGluZ1xuXHQgKiBAbWV0aG9kIF9nZXRDb21tYW5kc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBhdmFpbGFibGUgY29tbWFuZHMuXG5cdCAqL1xuXHRfZ2V0Q29tbWFuZHMoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMucHJvcHMuY29tbWFuZHMgfHwgW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ3RhYmxlSGVhZGluZ05vbmUnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmhlYWRlcnNOb25lLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ3RhYmxlSGVhZGluZ1JvdycsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuaGVhZGVyc1Jvdyxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICd0YWJsZUhlYWRpbmdDb2x1bW4nLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmhlYWRlcnNDb2x1bW4sXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAndGFibGVIZWFkaW5nQm90aCcsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuaGVhZGVyc0JvdGgsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25UYWJsZUhlYWRpbmc7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYWJsZVJlbW92ZSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciByZW1vdmluZyBhIHRhYmxlXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhYmxlUmVtb3ZlXG4gKi9cbmNsYXNzIEJ1dHRvblRhYmxlUmVtb3ZlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHRhYmxlUmVtb3ZlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJlbW92ZVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndGFibGVSZW1vdmUnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVSZW1vdmVcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5kZWxldGVUYWJsZX1cblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXRhYmxlLXJlbW92ZVwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX3JlbW92ZVRhYmxlfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuZGVsZXRlVGFibGV9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJ0cmFzaFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHRhYmxlIGluIHRoZSBlZGl0b3IgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJlbW92ZVxuXHQgKiBAbWV0aG9kIF9yZW1vdmVUYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfcmVtb3ZlVGFibGUgPSAoKSA9PiB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdGNvbnN0IHRhYmxlVXRpbHMgPSBuZXcgQ0tFRElUT1IuVGFibGUoZWRpdG9yKTtcblxuXHRcdHRhYmxlVXRpbHMucmVtb3ZlKCk7XG5cblx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlUmVtb3ZlO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgQnV0dG9uQ29tbWFuZHNMaXN0IGZyb20gJy4vYnV0dG9uLWNvbW1hbmRzLWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGVSb3cgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byB3b3JrIHdpdGggdGFibGUgcm93cy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVGFibGVSb3dcbiAqL1xuY2xhc3MgQnV0dG9uVGFibGVSb3cgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHRhYmxlUm93XG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJvd1xuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndGFibGVSb3cnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVSb3dcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IGJ1dHRvbkNvbW1hbmRzTGlzdDtcblx0XHRsZXQgYnV0dG9uQ29tbWFuZHNMaXN0SWQ7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuXHRcdFx0YnV0dG9uQ29tbWFuZHNMaXN0SWQgPSBCdXR0b25UYWJsZVJvdy5rZXkgKyAnTGlzdCc7XG5cdFx0XHRidXR0b25Db21tYW5kc0xpc3QgPSAoXG5cdFx0XHRcdDxCdXR0b25Db21tYW5kc0xpc3Rcblx0XHRcdFx0XHRjb21tYW5kcz17dGhpcy5fZ2V0Q29tbWFuZHMoKX1cblx0XHRcdFx0XHRsaXN0SWQ9e2J1dHRvbkNvbW1hbmRzTGlzdElkfVxuXHRcdFx0XHRcdG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0Lz5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyIGFlLWhhcy1kcm9wZG93blwiPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1leHBhbmRlZD17dGhpcy5wcm9wcy5leHBhbmRlZH1cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnJvd31cblx0XHRcdFx0XHRhcmlhLW93bnM9e2J1dHRvbkNvbW1hbmRzTGlzdElkfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0XHRyb2xlPVwiY29tYm9ib3hcIlxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnJvd30+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiYWRkLXJvd1wiIC8+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHR7YnV0dG9uQ29tbWFuZHNMaXN0fVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbGlzdCBvZiBjb21tYW5kcy4gSWYgYSBsaXN0IG9mIGNvbW1hbmRzIHdhcyBwYXNzZWRcblx0ICogYXMgcHJvcGVydHkgYGNvbW1hbmRzYCwgaXQgd2lsbCB0YWtlIGEgcHJlY2VkZW5jZSBvdmVyIHRoZSBkZWZhdWx0IG9uZXMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVSb3dcblx0ICogQG1ldGhvZCBfZ2V0Q29tbWFuZHNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGNvbW1hbmRzLlxuXHQgKi9cblx0X2dldENvbW1hbmRzKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLmNvbW1hbmRzIHx8IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdyb3dJbnNlcnRCZWZvcmUnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLnJvd0luc2VydEJlZm9yZSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdyb3dJbnNlcnRBZnRlcicsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3Mucm93SW5zZXJ0QWZ0ZXIsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAncm93RGVsZXRlJyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5yb3dEZWxldGUsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25UYWJsZVJvdztcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlRWRpdCBmcm9tICcuL2J1dHRvbi10YWJsZS1lZGl0LmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblRhYmxlIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIGFuZCBlZGl0aW5nIGEgdGFibGUgaW4gYSBkb2N1bWVudC4gQnV0dG9uVGFibGVcbiAqIHJlbmRlcnMgaW4gdHdvIGRpZmZlcmVudCBtb2RlczpcbiAqXG4gKiAtIE5vcm1hbDogSnVzdCBhIGJ1dHRvbiB0aGF0IGFsbG93cyB0byBzd2l0Y2ggdG8gdGhlIGVkaXRpb24gbW9kZVxuICogLSBFeGNsdXNpdmU6IFRoZSBCdXR0b25UYWJsZUVkaXQgVUkgd2l0aCBhbGwgdGhlIHRhYmxlIGVkaXRpb24gY29udHJvbHMuXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhYmxlXG4gKi9cbmNsYXNzIEJ1dHRvblRhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCB0YWJsZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3RhYmxlJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0cmV0dXJuIDxCdXR0b25UYWJsZUVkaXQgey4uLnRoaXMucHJvcHN9IC8+O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy50YWJsZX1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi10YWJsZVwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlfVxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnRhYmxlfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJ0YWJsZVwiIC8+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0KTtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uVGFibGU7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyJztcbmltcG9ydCBCdXR0b25Ecm9wZG93biBmcm9tICcuL2J1dHRvbi1kcm9wZG93bi5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYXJnZXRMaXN0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNoYW5naW5nIHRoZSB0YXJnZXQgb2YgYSBsaW5rXG4gKiBpbiB0aGUgZG9jdW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhcmdldExpc3RcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBCdXR0b25UYXJnZXRMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhcmdldExpc3Rcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y2lyY3VsYXI6IHRydWUsXG5cdFx0ZGVzY2VuZGFudHM6ICcuYWUtdG9vbGJhci1lbGVtZW50Jyxcblx0XHRrZXlzOiB7XG5cdFx0XHRkaXNtaXNzOiBbMjddLFxuXHRcdFx0ZGlzbWlzc05leHQ6IFszOV0sXG5cdFx0XHRkaXNtaXNzUHJldjogWzM3XSxcblx0XHRcdG5leHQ6IFs0MF0sXG5cdFx0XHRwcmV2OiBbMzhdLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBsaW5rVGFyZ2V0RWRpdFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFyZ2V0TGlzdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndGFyZ2V0TGlzdCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFyZ2V0TGlzdFxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5mb2N1cygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYXJnZXRMaXN0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGxpc3RUYXJnZXRzID0gdGhpcy5fcmVuZGVyTGlzdFRhcmdldHMoKTtcblxuXHRcdHJldHVybiA8QnV0dG9uRHJvcGRvd24gey4uLnRoaXMucHJvcHN9PntsaXN0VGFyZ2V0c308L0J1dHRvbkRyb3Bkb3duPjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0aGUgYWxsb3dlZCBsaW5rIHRhcmdldCBpdGVtcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYXJnZXRMaXN0XG5cdCAqIEBtZXRob2QgX2dldEFsbG93ZWRUYXJnZXRJdGVtc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0FycmF5fSBUaGUgYWxsb3dlZCB0YXJnZXQgaXRlbXMuXG5cdCAqL1xuXHRfZ2V0QWxsb3dlZFRhcmdldEl0ZW1zKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLmFsbG93ZWRMaW5rVGFyZ2V0cyB8fCBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0RGVmYXVsdCxcblx0XHRcdFx0XHR2YWx1ZTogJycsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0U2VsZixcblx0XHRcdFx0XHR2YWx1ZTogJ19zZWxmJyxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmxpbmtUYXJnZXRCbGFuayxcblx0XHRcdFx0XHR2YWx1ZTogJ19ibGFuaycsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0UGFyZW50LFxuXHRcdFx0XHRcdHZhbHVlOiAnX3BhcmVudCcsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0VG9wLFxuXHRcdFx0XHRcdHZhbHVlOiAnX3RvcCcsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIHRoZSBhbGxvd2VkIGxpbmsgdGFyZ2V0IGl0ZW1zLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhcmdldExpc3Rcblx0ICogQG1ldGhvZCBfcmVuZGVyTGlzdFRhcmdldHNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIHJlbmRlcmVkIGxpbmsgaXRlbXNcblx0ICovXG5cdF9yZW5kZXJMaXN0VGFyZ2V0cygpIHtcblx0XHRsZXQgdGFyZ2V0cyA9IHRoaXMuX2dldEFsbG93ZWRUYXJnZXRJdGVtcygpO1xuXG5cdFx0Y29uc3QgaGFuZGxlTGlua1RhcmdldENoYW5nZSA9IHRoaXMucHJvcHMuaGFuZGxlTGlua1RhcmdldENoYW5nZTtcblxuXHRcdHRhcmdldHMgPSB0YXJnZXRzLm1hcCh0YXJnZXQgPT4ge1xuXHRcdFx0Y29uc3QgY2xhc3NOYW1lID1cblx0XHRcdFx0dGhpcy5wcm9wcy5zZWxlY3RlZFRhcmdldCA9PT0gdGFyZ2V0LnZhbHVlXG5cdFx0XHRcdFx0PyAnYWUtdG9vbGJhci1lbGVtZW50IGFjdGl2ZSdcblx0XHRcdFx0XHQ6ICdhZS10b29sYmFyLWVsZW1lbnQnO1xuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8bGkga2V5PXt0YXJnZXQudmFsdWV9IHJvbGU9XCJvcHRpb25cIj5cblx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzTmFtZX1cblx0XHRcdFx0XHRcdGRhdGEtdmFsdWU9e3RhcmdldC52YWx1ZX1cblx0XHRcdFx0XHRcdG9uQ2xpY2s9e2hhbmRsZUxpbmtUYXJnZXRDaGFuZ2V9PlxuXHRcdFx0XHRcdFx0e3RhcmdldC5sYWJlbH1cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PC9saT5cblx0XHRcdCk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0cztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRGb2N1c01hbmFnZXIoQnV0dG9uVGFyZ2V0TGlzdCk7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuY29uc3QgTUFYX1RXRUVUX0xFTkdUSCA9IDI4MDtcblxuLyoqXG4gKiBUaGUgQnV0dG9uVHdpdHRlciBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhIGxpbmsgd2hpY2hcbiAqIGFsbG93cyBwZW9wbGUgdG8gdHdlZXQgcGFydCBvZiB0aGUgY29udGVudCBpbiB0aGUgZWRpdG9yLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Ud2l0dGVyXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uVHdpdHRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCB0d2l0dGVyXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Ud2l0dGVyXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICd0d2l0dGVyJztcblxuXHQvKipcblx0ICogQ3JlYXRlcyBvciByZW1vdmVzIHRoZSB0d2l0dGVyIGxpbmsgb24gdGhlIHNlbGVjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Ud2l0dGVyXG5cdCAqIEBtZXRob2QgaGFuZGxlQ2xpY2tcblx0ICovXG5cdGhhbmRsZUNsaWNrID0gKCkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGNvbnN0IGxpbmtVdGlscyA9IG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvcik7XG5cblx0XHRpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG5cdFx0XHRsaW5rVXRpbHMucmVtb3ZlKGxpbmtVdGlscy5nZXRGcm9tU2VsZWN0aW9uKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsaW5rVXRpbHMuY3JlYXRlKHRoaXMuX2dldEhyZWYoKSwge1xuXHRcdFx0XHRjbGFzczogJ2FlLXR3aXR0ZXItbGluaycsXG5cdFx0XHRcdHRhcmdldDogJ19ibGFuaycsXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgY29udGFpbmVkIHdpdGhpbiBhIGxpbmsgdGhhdCBwb2ludHMgdG8gdHdpdHRlci5jb20vaW50ZW50L3R3ZWV0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblR3aXR0ZXJcblx0ICogQG1ldGhvZCBpc0FjdGl2ZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBzZWxlY3Rpb24gaXMgaW5zaWRlIGEgdHdpdHRlciBsaW5rLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuXHRpc0FjdGl2ZSgpIHtcblx0XHRjb25zdCBsaW5rID0gbmV3IENLRURJVE9SLkxpbmsoXG5cdFx0XHR0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJylcblx0XHQpLmdldEZyb21TZWxlY3Rpb24oKTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHRsaW5rICYmXG5cdFx0XHRsaW5rLmdldEF0dHJpYnV0ZSgnaHJlZicpLmluZGV4T2YoJ3R3aXR0ZXIuY29tL2ludGVudC90d2VldCcpICE9PSAtMVxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblR3aXR0ZXJcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy50d2l0dGVyfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tdHdpdHRlclwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy50d2l0dGVyfT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwidHdpdHRlclwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyB0aGUgYXBwcm9wcmlhdGUgdHdpdHRlciB1cmwgYmFzZWQgb24gdGhlIHNlbGVjdGVkIHRleHQgYW5kIHRoZSBjb25maWd1cmF0aW9uXG5cdCAqIG9wdGlvbnMgcmVjZWl2ZWQgdmlhIHByb3BzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblR3aXR0ZXJcblx0ICogQG1ldGhvZCBfZ2V0SHJlZlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gQSB2YWxpZCB0d2l0dGVyIHVybCB3aXRoIHRoZSBzZWxlY3RlZCB0ZXh0IGFuZCBnaXZlbiBjb25maWd1cmF0aW9uLlxuXHQgKi9cblx0X2dldEhyZWYoKSB7XG5cdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdGNvbnN0IHNlbGVjdGVkVGV4dCA9IG5hdGl2ZUVkaXRvclxuXHRcdFx0LmdldFNlbGVjdGlvbigpXG5cdFx0XHQuZ2V0U2VsZWN0ZWRUZXh0KClcblx0XHRcdC5zdWJzdHJpbmcoMCwgTUFYX1RXRUVUX0xFTkdUSCk7XG5cdFx0Y29uc3QgdXJsID0gdGhpcy5wcm9wcy51cmw7XG5cdFx0Y29uc3QgdmlhID0gdGhpcy5wcm9wcy52aWE7XG5cdFx0bGV0IHR3aXR0ZXJIcmVmID1cblx0XHRcdCdodHRwczovL3R3aXR0ZXIuY29tL2ludGVudC90d2VldD90ZXh0PScgKyBzZWxlY3RlZFRleHQ7XG5cblx0XHRpZiAodXJsKSB7XG5cdFx0XHR0d2l0dGVySHJlZiArPSAnJnVybD0nICsgdXJsO1xuXHRcdH1cblxuXHRcdGlmICh2aWEpIHtcblx0XHRcdHR3aXR0ZXJIcmVmICs9ICcmdmlhPScgKyB2aWE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHR3aXR0ZXJIcmVmO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25Ud2l0dGVyKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVW5vcmRlcmVkbGlzdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyB1bm9yZGVyZWQgbGlzdHMgaW4gYW4gZWRpdG9yLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Vbm9yZGVyZWRsaXN0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblVub3JkZXJlZGxpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVW5vcmRlcmVkbGlzdFxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdidWxsZXRlZGxpc3QnLFxuXHRcdHN0eWxlOiB7XG5cdFx0XHRlbGVtZW50OiAndWwnLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCB1bFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVW5vcmRlcmVkbGlzdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndWwnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVW5vcmRlcmVkbGlzdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmJ1bGxldGVkbGlzdH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tdWxcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYnVsbGV0ZWRsaXN0fT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwibGlzdC11bFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25TdHlsZShCdXR0b25Vbm9yZGVyZWRsaXN0KSlcbik7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbktleXN0cm9rZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1rZXlzdHJva2UnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblVuZGVybGluZSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciB1bmRlcmx5aW5nIGEgdGV4dCBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvblVuZGVybGluZVxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uS2V5c3Ryb2tlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblVuZGVybGluZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25VbmRlcmxpbmVcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAndW5kZXJsaW5lJyxcblx0XHRrZXlzdHJva2U6IHtcblx0XHRcdGZuOiAnZXhlY0NvbW1hbmQnLFxuXHRcdFx0a2V5czogQ0tFRElUT1IuQ1RSTCArIDg1IC8qIFUqLyxcblx0XHRcdG5hbWU6ICd1bmRlcmxpbmUnLFxuXHRcdH0sXG5cdFx0c3R5bGU6ICdjb3JlU3R5bGVzX3VuZGVybGluZScsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCB1bmRlcmxpbmVcblx0ICogQG1lbWJlcm9mIEJ1dHRvblVuZGVybGluZVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndW5kZXJsaW5lJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblVuZGVybGluZVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnVuZGVybGluZX1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tdW5kZXJsaW5lXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnVuZGVybGluZX0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInVuZGVybGluZVwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbktleXN0cm9rZShCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3R5bGUoQnV0dG9uVW5kZXJsaW5lKSkpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgQnV0dG9uQWNjZXNzaWJpbGl0eUltYWdlQWx0IGZyb20gJy4vYnV0dG9uLWFjY2Vzc2liaWxpdHktaW1hZ2UtYWx0LmpzeCc7XG5pbXBvcnQgQnV0dG9uQmFja2dyb3VuZENvbG9yIGZyb20gJy4vYnV0dG9uLWJhY2tncm91bmQtY29sb3IuanN4JztcbmltcG9ydCBCdXR0b25Cb2xkIGZyb20gJy4vYnV0dG9uLWJvbGQuanN4JztcbmltcG9ydCBCdXR0b25DYW1lcmFJbWFnZSBmcm9tICcuL2J1dHRvbi1jYW1lcmEtaW1hZ2UuanN4JztcbmltcG9ydCBCdXR0b25DYW1lcmEgZnJvbSAnLi9idXR0b24tY2FtZXJhLmpzeCc7XG5pbXBvcnQgQnV0dG9uQ29kZSBmcm9tICcuL2J1dHRvbi1jb2RlLmpzeCc7XG5pbXBvcnQgQnV0dG9uQ29sb3IgZnJvbSAnLi9idXR0b24tY29sb3IuanN4JztcbmltcG9ydCBCdXR0b25Db21tYW5kTGlzdEl0ZW0gZnJvbSAnLi9idXR0b24tY29tbWFuZC1saXN0LWl0ZW0uanN4JztcbmltcG9ydCBCdXR0b25Db21tYW5kc0xpc3QgZnJvbSAnLi9idXR0b24tY29tbWFuZHMtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJy4vYnV0dG9uLWRyb3Bkb3duLmpzeCc7XG5pbXBvcnQgQnV0dG9uRW1iZWRFZGl0IGZyb20gJy4vYnV0dG9uLWVtYmVkLWVkaXQuanN4JztcbmltcG9ydCBCdXR0b25FbWJlZFZpZGVvRWRpdCBmcm9tICcuL2J1dHRvbi1lbWJlZC12aWRlby1lZGl0LmpzeCc7XG5pbXBvcnQgQnV0dG9uRW1iZWRWaWRlbyBmcm9tICcuL2J1dHRvbi1lbWJlZC12aWRlby5qc3gnO1xuaW1wb3J0IEJ1dHRvbkVtYmVkIGZyb20gJy4vYnV0dG9uLWVtYmVkLmpzeCc7XG5pbXBvcnQgQnV0dG9uSDEgZnJvbSAnLi9idXR0b24taDEuanN4JztcbmltcG9ydCBCdXR0b25IMiBmcm9tICcuL2J1dHRvbi1oMi5qc3gnO1xuaW1wb3J0IEJ1dHRvbkhsaW5lIGZyb20gJy4vYnV0dG9uLWhsaW5lLmpzeCc7XG5pbXBvcnQgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlciBmcm9tICcuL2J1dHRvbi1pbWFnZS1hbGlnbi1jZW50ZXIuanN4JztcbmltcG9ydCBCdXR0b25JbWFnZUFsaWduTGVmdCBmcm9tICcuL2J1dHRvbi1pbWFnZS1hbGlnbi1sZWZ0LmpzeCc7XG5pbXBvcnQgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0IGZyb20gJy4vYnV0dG9uLWltYWdlLWFsaWduLXJpZ2h0LmpzeCc7XG5pbXBvcnQgQnV0dG9uSW1hZ2UgZnJvbSAnLi9idXR0b24taW1hZ2UuanN4JztcbmltcG9ydCBCdXR0b25JbmRlbnRCbG9jayBmcm9tICcuL2J1dHRvbi1pbmRlbnQtYmxvY2suanN4JztcbmltcG9ydCBCdXR0b25JdGFsaWMgZnJvbSAnLi9idXR0b24taXRhbGljLmpzeCc7XG5pbXBvcnQgQnV0dG9uSXRlbVNlbGVjdG9yQXVkaW8gZnJvbSAnLi9idXR0b24taXRlbS1zZWxlY3Rvci1hdWRpby5qc3gnO1xuaW1wb3J0IEJ1dHRvbkl0ZW1TZWxlY3RvckltYWdlIGZyb20gJy4vYnV0dG9uLWl0ZW0tc2VsZWN0b3ItaW1hZ2UuanN4JztcbmltcG9ydCBCdXR0b25JdGVtU2VsZWN0b3JWaWRlbyBmcm9tICcuL2J1dHRvbi1pdGVtLXNlbGVjdG9yLXZpZGVvLmpzeCc7XG5pbXBvcnQgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QgZnJvbSAnLi9idXR0b24tbGluay1hdXRvY29tcGxldGUtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkxpbmtCcm93c2UgZnJvbSAnLi9idXR0b24tbGluay1icm93c2UuanN4JztcbmltcG9ydCBCdXR0b25MaW5rRWRpdEJyb3dzZSBmcm9tICcuL2J1dHRvbi1saW5rLWVkaXQtYnJvd3NlLmpzeCc7XG5pbXBvcnQgQnV0dG9uTGlua0VkaXQgZnJvbSAnLi9idXR0b24tbGluay1lZGl0LmpzeCc7XG5pbXBvcnQgQnV0dG9uTGlua1RhcmdldEVkaXQgZnJvbSAnLi9idXR0b24tbGluay10YXJnZXQtZWRpdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkxpbmsgZnJvbSAnLi9idXR0b24tbGluay5qc3gnO1xuaW1wb3J0IEJ1dHRvbk9sIGZyb20gJy4vYnV0dG9uLW9sLmpzeCc7XG5pbXBvcnQgQnV0dG9uT3V0ZGVudEJsb2NrIGZyb20gJy4vYnV0dG9uLW91dGRlbnQtYmxvY2suanN4JztcbmltcG9ydCBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQgZnJvbSAnLi9idXR0b24tcGFyYWdyYXBoLWFsaWduLWxlZnQuanN4JztcbmltcG9ydCBCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0IGZyb20gJy4vYnV0dG9uLXBhcmFncmFwaC1hbGlnbi1yaWdodC5qc3gnO1xuaW1wb3J0IEJ1dHRvblBhcmFncmFwaEFsaWduIGZyb20gJy4vYnV0dG9uLXBhcmFncmFwaC1hbGlnbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblBhcmFncmFwaENlbnRlciBmcm9tICcuL2J1dHRvbi1wYXJhZ3JhcGgtY2VudGVyLmpzeCc7XG5pbXBvcnQgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeSBmcm9tICcuL2J1dHRvbi1wYXJhZ3JhcGgtanVzdGlmeS5qc3gnO1xuaW1wb3J0IEJ1dHRvblF1b3RlIGZyb20gJy4vYnV0dG9uLXF1b3RlLmpzeCc7XG5pbXBvcnQgQnV0dG9uUmVtb3ZlRm9ybWF0IGZyb20gJy4vYnV0dG9uLXJlbW92ZS1mb3JtYXQuanN4JztcbmltcG9ydCBCdXR0b25SZW1vdmVJbWFnZSBmcm9tICcuL2J1dHRvbi1yZW1vdmUtaW1hZ2UuanN4JztcbmltcG9ydCBCdXR0b25TZXBhcmF0b3IgZnJvbSAnLi9idXR0b24tc2VwYXJhdG9yLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3BhY2luZyBmcm9tICcuL2J1dHRvbi1zcGFjaW5nLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3RyaWtlIGZyb20gJy4vYnV0dG9uLXN0cmlrZS5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3RIZWFkZXIgZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QtaGVhZGVyLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUgZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QtaXRlbS1yZW1vdmUuanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0SXRlbSBmcm9tICcuL2J1dHRvbi1zdHlsZXMtbGlzdC1pdGVtLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3R5bGVzTGlzdCBmcm9tICcuL2J1dHRvbi1zdHlsZXMtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlcyBmcm9tICcuL2J1dHRvbi1zdHlsZXMuanN4JztcbmltcG9ydCBCdXR0b25TdWJzY3JpcHQgZnJvbSAnLi9idXR0b24tc3Vic2NyaXB0LmpzeCc7XG5pbXBvcnQgQnV0dG9uU3VwZXJzY3JpcHQgZnJvbSAnLi9idXR0b24tc3VwZXJzY3JpcHQuanN4JztcbmltcG9ydCBCdXR0b25UYWJsZUNlbGwgZnJvbSAnLi9idXR0b24tdGFibGUtY2VsbC5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlQ29sdW1uIGZyb20gJy4vYnV0dG9uLXRhYmxlLWNvbHVtbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlRWRpdCBmcm9tICcuL2J1dHRvbi10YWJsZS1lZGl0LmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFibGVIZWFkaW5nIGZyb20gJy4vYnV0dG9uLXRhYmxlLWhlYWRpbmcuanN4JztcbmltcG9ydCBCdXR0b25UYWJsZVJlbW92ZSBmcm9tICcuL2J1dHRvbi10YWJsZS1yZW1vdmUuanN4JztcbmltcG9ydCBCdXR0b25UYWJsZVJvdyBmcm9tICcuL2J1dHRvbi10YWJsZS1yb3cuanN4JztcbmltcG9ydCBCdXR0b25UYWJsZSBmcm9tICcuL2J1dHRvbi10YWJsZS5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhcmdldExpc3QgZnJvbSAnLi9idXR0b24tdGFyZ2V0LWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25Ud2l0dGVyIGZyb20gJy4vYnV0dG9uLXR3aXR0ZXIuanN4JztcbmltcG9ydCBCdXR0b25VbCBmcm9tICcuL2J1dHRvbi11bC5qc3gnO1xuaW1wb3J0IEJ1dHRvblVuZGVybGluZSBmcm9tICcuL2J1dHRvbi11bmRlcmxpbmUuanN4JztcblxuZXhwb3J0IGRlZmF1bHQge1xuXHRbQnV0dG9uQWNjZXNzaWJpbGl0eUltYWdlQWx0LmtleV06IEJ1dHRvbkFjY2Vzc2liaWxpdHlJbWFnZUFsdCxcblx0W0J1dHRvbkJhY2tncm91bmRDb2xvci5rZXldOiBCdXR0b25CYWNrZ3JvdW5kQ29sb3IsXG5cdFtCdXR0b25Cb2xkLmtleV06IEJ1dHRvbkJvbGQsXG5cdFtCdXR0b25DYW1lcmFJbWFnZS5rZXldOiBCdXR0b25DYW1lcmFJbWFnZSxcblx0W0J1dHRvbkNhbWVyYS5rZXldOiBCdXR0b25DYW1lcmEsXG5cdFtCdXR0b25Db2RlLmtleV06IEJ1dHRvbkNvZGUsXG5cdFtCdXR0b25Db2xvci5rZXldOiBCdXR0b25Db2xvcixcblx0W0J1dHRvbkNvbW1hbmRMaXN0SXRlbS5rZXldOiBCdXR0b25Db21tYW5kTGlzdEl0ZW0sXG5cdFtCdXR0b25Db21tYW5kc0xpc3Qua2V5XTogQnV0dG9uQ29tbWFuZHNMaXN0LFxuXHRbQnV0dG9uRHJvcGRvd24ua2V5XTogQnV0dG9uRHJvcGRvd24sXG5cdFtCdXR0b25FbWJlZEVkaXQua2V5XTogQnV0dG9uRW1iZWRFZGl0LFxuXHRbQnV0dG9uRW1iZWQua2V5XTogQnV0dG9uRW1iZWQsXG5cdFtCdXR0b25FbWJlZFZpZGVvRWRpdC5rZXldOiBCdXR0b25FbWJlZFZpZGVvRWRpdCxcblx0W0J1dHRvbkVtYmVkVmlkZW8ua2V5XTogQnV0dG9uRW1iZWRWaWRlbyxcblx0W0J1dHRvbkgxLmtleV06IEJ1dHRvbkgxLFxuXHRbQnV0dG9uSDIua2V5XTogQnV0dG9uSDIsXG5cdFtCdXR0b25IbGluZS5rZXldOiBCdXR0b25IbGluZSxcblx0W0J1dHRvbkltYWdlQWxpZ25DZW50ZXIua2V5XTogQnV0dG9uSW1hZ2VBbGlnbkNlbnRlcixcblx0W0J1dHRvbkltYWdlQWxpZ25MZWZ0LmtleV06IEJ1dHRvbkltYWdlQWxpZ25MZWZ0LFxuXHRbQnV0dG9uSW1hZ2VBbGlnblJpZ2h0LmtleV06IEJ1dHRvbkltYWdlQWxpZ25SaWdodCxcblx0W0J1dHRvbkltYWdlLmtleV06IEJ1dHRvbkltYWdlLFxuXHRbQnV0dG9uSW5kZW50QmxvY2sua2V5XTogQnV0dG9uSW5kZW50QmxvY2ssXG5cdFtCdXR0b25JdGFsaWMua2V5XTogQnV0dG9uSXRhbGljLFxuXHRbQnV0dG9uSXRlbVNlbGVjdG9yQXVkaW8ua2V5XTogQnV0dG9uSXRlbVNlbGVjdG9yQXVkaW8sXG5cdFtCdXR0b25JdGVtU2VsZWN0b3JJbWFnZS5rZXldOiBCdXR0b25JdGVtU2VsZWN0b3JJbWFnZSxcblx0W0J1dHRvbkl0ZW1TZWxlY3RvclZpZGVvLmtleV06IEJ1dHRvbkl0ZW1TZWxlY3RvclZpZGVvLFxuXHRbQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Qua2V5XTogQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QsXG5cdFtCdXR0b25MaW5rQnJvd3NlLmtleV06IEJ1dHRvbkxpbmtCcm93c2UsXG5cdFtCdXR0b25MaW5rRWRpdEJyb3dzZS5rZXldOiBCdXR0b25MaW5rRWRpdEJyb3dzZSxcblx0W0J1dHRvbkxpbmtFZGl0LmtleV06IEJ1dHRvbkxpbmtFZGl0LFxuXHRbQnV0dG9uTGlua1RhcmdldEVkaXQua2V5XTogQnV0dG9uTGlua1RhcmdldEVkaXQsXG5cdFtCdXR0b25MaW5rLmtleV06IEJ1dHRvbkxpbmssXG5cdFtCdXR0b25PbC5rZXldOiBCdXR0b25PbCxcblx0W0J1dHRvbk91dGRlbnRCbG9jay5rZXldOiBCdXR0b25PdXRkZW50QmxvY2ssXG5cdFtCdXR0b25QYXJhZ3JhcGhBbGlnbi5rZXldOiBCdXR0b25QYXJhZ3JhcGhBbGlnbixcblx0W0J1dHRvblBhcmFncmFwaEFsaWduTGVmdC5rZXldOiBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQsXG5cdFtCdXR0b25QYXJhZ3JhcGhBbGlnblJpZ2h0LmtleV06IEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHQsXG5cdFtCdXR0b25QYXJhZ3JhcGhDZW50ZXIua2V5XTogQnV0dG9uUGFyYWdyYXBoQ2VudGVyLFxuXHRbQnV0dG9uUGFyYWdyYXBoSnVzdGlmeS5rZXldOiBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5LFxuXHRbQnV0dG9uUXVvdGUua2V5XTogQnV0dG9uUXVvdGUsXG5cdFtCdXR0b25SZW1vdmVGb3JtYXQua2V5XTogQnV0dG9uUmVtb3ZlRm9ybWF0LFxuXHRbQnV0dG9uUmVtb3ZlSW1hZ2Uua2V5XTogQnV0dG9uUmVtb3ZlSW1hZ2UsXG5cdFtCdXR0b25TZXBhcmF0b3Iua2V5XTogQnV0dG9uU2VwYXJhdG9yLFxuXHRbQnV0dG9uU3BhY2luZy5rZXldOiBCdXR0b25TcGFjaW5nLFxuXHRbQnV0dG9uU3RyaWtlLmtleV06IEJ1dHRvblN0cmlrZSxcblx0W0J1dHRvblN0eWxlc0xpc3RIZWFkZXIua2V5XTogQnV0dG9uU3R5bGVzTGlzdEhlYWRlcixcblx0W0J1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlLmtleV06IEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlLFxuXHRbQnV0dG9uU3R5bGVzTGlzdEl0ZW0ua2V5XTogQnV0dG9uU3R5bGVzTGlzdEl0ZW0sXG5cdFtCdXR0b25TdHlsZXNMaXN0LmtleV06IEJ1dHRvblN0eWxlc0xpc3QsXG5cdFtCdXR0b25TdHlsZXMua2V5XTogQnV0dG9uU3R5bGVzLFxuXHRbQnV0dG9uU3Vic2NyaXB0LmtleV06IEJ1dHRvblN1YnNjcmlwdCxcblx0W0J1dHRvblN1cGVyc2NyaXB0LmtleV06IEJ1dHRvblN1cGVyc2NyaXB0LFxuXHRbQnV0dG9uVGFibGVDZWxsLmtleV06IEJ1dHRvblRhYmxlQ2VsbCxcblx0W0J1dHRvblRhYmxlQ29sdW1uLmtleV06IEJ1dHRvblRhYmxlQ29sdW1uLFxuXHRbQnV0dG9uVGFibGVFZGl0LmtleV06IEJ1dHRvblRhYmxlRWRpdCxcblx0W0J1dHRvblRhYmxlSGVhZGluZy5rZXldOiBCdXR0b25UYWJsZUhlYWRpbmcsXG5cdFtCdXR0b25UYWJsZVJlbW92ZS5rZXldOiBCdXR0b25UYWJsZVJlbW92ZSxcblx0W0J1dHRvblRhYmxlUm93LmtleV06IEJ1dHRvblRhYmxlUm93LFxuXHRbQnV0dG9uVGFibGUua2V5XTogQnV0dG9uVGFibGUsXG5cdFtCdXR0b25UYXJnZXRMaXN0LmtleV06IEJ1dHRvblRhcmdldExpc3QsXG5cdFtCdXR0b25Ud2l0dGVyLmtleV06IEJ1dHRvblR3aXR0ZXIsXG5cdFtCdXR0b25VbC5rZXldOiBCdXR0b25VbCxcblx0W0J1dHRvblVuZGVybGluZS5rZXldOiBCdXR0b25VbmRlcmxpbmUsXG59O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5cbi8qKlxuICogQnV0dG9uQWN0aW9uU3R5bGUgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGFwcGx5aW5nIHN0eWxlXG4gKiBpbXBsZW1lbnRhdGlvbiBmb3IgYSBidXR0b24gYmFzZWQgb24gdGhlIGBhcHBseVN0eWxlYCBhbmRcbiAqIGByZW1vdmVTdHlsZWAgQVBJIG9mIENLRURJVE9SLlxuICpcbiAqIFRvIGV4ZWN1dGUgcHJvcGVybHksIHRoZSBjb21wb25lbnQgaGFzIHRvIGV4cG9zZSB0aGUgZm9sbG93aW5nXG4gKiBtZXRob2RzIHdoaWNoIGNhbiBiZSBvYnRhaW5lZCBvdXQgb2YgdGhlIGJveCB1c2luZyB0aGUge3sjY3Jvc3NMaW5rXG4gKiBcIkJ1dHRvblN0eWxlXCJ9fXt7L2Nyb3NzTGlua319IG1peGluOlxuICogLSBgRnVuY3Rpb25gIHt7I2Nyb3NzTGluayBcIkJ1dHRvblN0eWxlL2lzQWN0aXZlXCJ9fXt7L2Nyb3NzTGlua319IHRvXG4gKiAgICBjaGVjayB0aGUgYWN0aXZlIHN0YXRlXG4gKiAtIGBGdW5jdGlvbmAge3sjY3Jvc3NMaW5rIFwiQnV0dG9uU3R5bGUvZ2V0U3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gdG9cbiAqICAgIHJldHVybiB0aGUgc3R5bGUgdGhhdCBzaG91bGQgYmUgYXBwbGllZFxuICpcbiAqIEBjbGFzcyBCdXR0b25BY3Rpb25TdHlsZVxuICovXG5jb25zdCBCdXR0b25BY3Rpb25TdHlsZSA9IHtcblx0LyoqXG5cdCAqIFJlbW92ZXMgb3IgYXBwbGllcyB0aGUgY29tcG9uZW50IHN0eWxlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25BY3Rpb25TdHlsZVxuXHQgKiBAbWV0aG9kIGFwcGx5U3R5bGVcblx0ICovXG5cdGFwcGx5U3R5bGUoKSB7XG5cdFx0aWYgKExhbmcuaXNGdW5jdGlvbih0aGlzLmlzQWN0aXZlKSAmJiBMYW5nLmlzRnVuY3Rpb24odGhpcy5nZXRTdHlsZSkpIHtcblx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdGVkaXRvci5nZXRTZWxlY3Rpb24oKS5sb2NrKCk7XG5cblx0XHRcdGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcblx0XHRcdFx0ZWRpdG9yLnJlbW92ZVN0eWxlKHRoaXMuZ2V0U3R5bGUoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlZGl0b3IuYXBwbHlTdHlsZSh0aGlzLmdldFN0eWxlKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRlZGl0b3IuZ2V0U2VsZWN0aW9uKCkudW5sb2NrKCk7XG5cblx0XHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0XHR9XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25BY3Rpb25TdHlsZTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuLyoqXG4gKiBCdXR0b25Db21tYW5kQWN0aXZlIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBhbiBgaXNBY3RpdmVgIG1ldGhvZCB0b1xuICogZGV0ZXJtaW5lIGlmIGEgY29udGV4dC1hd2FyZSBjb21tYW5kIGlzIGN1cnJlbnRseSBpbiBhbiBhY3RpdmUgc3RhdGUuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqL1xuY29uc3QgQnV0dG9uQ29tbWFuZEFjdGl2ZSA9IHtcblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgY29tbWFuZCBpcyBhY3RpdmUgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRBY3RpdmVcblx0ICogQG1ldGhvZCBpc0FjdGl2ZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBjb21tYW5kIGlzIGFjdGl2ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cblx0aXNBY3RpdmUoKSB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGNvbnN0IGNvbW1hbmQgPSBlZGl0b3IuZ2V0Q29tbWFuZCh0aGlzLnByb3BzLmNvbW1hbmQpO1xuXG5cdFx0cmV0dXJuIGNvbW1hbmQgPyBjb21tYW5kLnN0YXRlID09PSBDS0VESVRPUi5UUklTVEFURV9PTiA6IGZhbHNlO1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZEFjdGl2ZTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyoqXG4gKiBCdXR0b25Db21tYW5kIGlzIGEgbWl4aW4gdGhhdCBleGVjdXRlcyBhIGNvbW1hbmQgdmlhIENLRURJVE9SJ3MgQVBJLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db21tYW5kXG4gKi9cbmNvbnN0IEJ1dHRvbkNvbW1hbmQgPSB7XG5cdC8vIEFsbG93cyB2YWxpZGF0aW5nIHByb3BzIGJlaW5nIHBhc3NlZCB0byB0aGUgY29tcG9uZW50LlxuXG5cdHByb3BUeXBlczoge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb21tYW5kIHRoYXQgc2hvdWxkIGJlIGV4ZWN1dGVkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRcblx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gY29tbWFuZFxuXHRcdCAqL1xuXHRcdGNvbW1hbmQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGF0IHRoZSBjb21tYW5kIG1heSBjYXVzZSB0aGUgZWRpdG9yIHRvIGhhdmUgYSBkaWZmZXJlbnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZFxuXHRcdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbW9kaWZpZXNTZWxlY3Rpb25cblx0XHQgKi9cblx0XHRtb2RpZmllc1NlbGVjdGlvbjogUHJvcFR5cGVzLmJvb2wsXG5cdH0sXG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVzIGEgQ0tFZGl0b3IgY29tbWFuZCBhbmQgZmlyZXMgYGFjdGlvblBlcmZvcm1lZGAgZXZlbnQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZFxuXHQgKiBAcGFyYW0ge09iamVjdD19IGRhdGEgT3B0aW9uYWwgZGF0YSB0byBiZSBwYXNzZWQgdG8gQ0tFRElUT1IncyBgZXhlY0NvbW1hbmRgIG1ldGhvZC5cblx0ICogQG1ldGhvZCBleGVjQ29tbWFuZFxuXHQgKi9cblx0ZXhlY0NvbW1hbmQoZGF0YSkge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRlZGl0b3IuZXhlY0NvbW1hbmQodGhpcy5wcm9wcy5jb21tYW5kLCBkYXRhKTtcblxuXHRcdGlmICh0aGlzLnByb3BzLm1vZGlmaWVzU2VsZWN0aW9uKSB7XG5cdFx0XHRlZGl0b3Iuc2VsZWN0aW9uQ2hhbmdlKHRydWUpO1xuXHRcdH1cblxuXHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQ7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nJztcblxuLyoqXG4gKiBCdXR0b25LZXlzdHJva2UgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGEgYGtleXN0cm9rZWAgcHJvcCB0aGF0IGFsbG93cyBjb25maWd1cmluZ1xuICogYSBmdW5jdGlvbiBvZiB0aGUgaW5zdGFuY2UgdG8gYmUgaW52b2tlZCB1cG9uIHRoZSBrZXlzdHJva2UgYWN0aXZhdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uS2V5c3Ryb2tlXG4gKi9cbmNvbnN0IEJ1dHRvbktleXN0cm9rZSA9IHtcblx0Ly8gQWxsb3dzIHZhbGlkYXRpbmcgcHJvcHMgYmVpbmcgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQuXG5cblx0cHJvcFR5cGVzOiB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIGtleXN0cm9rZSBkZWZpbml0aW9uLiBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cdFx0ICogLSBmbjogVGhlIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkXG5cdFx0ICogLSBrZXlzOiBUaGUga2V5c3Ryb2tlIGRlZmluaXRpb24sIGFzIGV4cGVjdGVkIGJ5IGh0dHA6Ly9kb2NzLmNrZWRpdG9yLmNvbS8jIS9hcGkvQ0tFRElUT1IuZWRpdG9yLW1ldGhvZC1zZXRLZXlzdHJva2Vcblx0XHQgKiAtIG5hbWU6IFRoZSBuYW1lIGZvciB0aGUgQ0tFZGl0b3IgY29tbWFuZCB0aGF0IHdpbGwgYmUgY3JlYXRlZC4gSWYgZW1wdHksXG5cdFx0ICogYSByYW5kb20gbmFtZSB3aWxsIGJlIGNyZWF0ZWQgb24gdGhlIGZseVxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbktleXN0cm9rZVxuXHRcdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBrZXlzdHJva2Vcblx0XHQgKi9cblx0XHRrZXlzdHJva2U6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblx0fSxcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIGJvdGggb24gdGhlIGNsaWVudCBhbmQgc2VydmVyLCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25LZXlzdHJva2Vcblx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsTW91bnRcblx0ICovXG5cdGNvbXBvbmVudFdpbGxNb3VudCgpIHtcblx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdGNvbnN0IGtleXN0cm9rZSA9IHRoaXMucHJvcHMua2V5c3Ryb2tlO1xuXG5cdFx0Y29uc3QgY29tbWFuZE5hbWUgPVxuXHRcdFx0a2V5c3Ryb2tlLm5hbWUgfHwgKChNYXRoLnJhbmRvbSgpICogMWU5KSA+Pj4gMCkudG9TdHJpbmcoKTtcblxuXHRcdGxldCBjb21tYW5kID0gbmF0aXZlRWRpdG9yLmdldENvbW1hbmQoY29tbWFuZE5hbWUpO1xuXG5cdFx0aWYgKCFjb21tYW5kKSB7XG5cdFx0XHRjb21tYW5kID0gbmV3IENLRURJVE9SLmNvbW1hbmQobmF0aXZlRWRpdG9yLCB7XG5cdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdFx0XHRcdGNvbnN0IGtleXN0cm9rZUZuID0ga2V5c3Ryb2tlLmZuO1xuXG5cdFx0XHRcdFx0aWYgKExhbmcuaXNTdHJpbmcoa2V5c3Ryb2tlRm4pKSB7XG5cdFx0XHRcdFx0XHR0aGlzW2tleXN0cm9rZUZuXS5jYWxsKHRoaXMsIGVkaXRvcik7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChMYW5nLmlzRnVuY3Rpb24oa2V5c3Ryb2tlRm4pKSB7XG5cdFx0XHRcdFx0XHRrZXlzdHJva2VGbi5jYWxsKHRoaXMsIGVkaXRvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LmJpbmQodGhpcyksXG5cdFx0XHR9KTtcblxuXHRcdFx0bmF0aXZlRWRpdG9yLmFkZENvbW1hbmQoY29tbWFuZE5hbWUsIGNvbW1hbmQpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RlZmF1bHRLZXlzdHJva2VDb21tYW5kID1cblx0XHRcdG5hdGl2ZUVkaXRvci5rZXlzdHJva2VIYW5kbGVyLmtleXN0cm9rZXNba2V5c3Ryb2tlLmtleXNdO1xuXG5cdFx0bmF0aXZlRWRpdG9yLnNldEtleXN0cm9rZShrZXlzdHJva2Uua2V5cywgY29tbWFuZE5hbWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgaW1tZWRpYXRlbHkgYmVmb3JlIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBmcm9tIHRoZSBET00uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uS2V5c3Ryb2tlXG5cdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcblx0ICovXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdHRoaXMucHJvcHMuZWRpdG9yXG5cdFx0XHQuZ2V0KCduYXRpdmVFZGl0b3InKVxuXHRcdFx0LnNldEtleXN0cm9rZShcblx0XHRcdFx0dGhpcy5wcm9wcy5rZXlzdHJva2Uua2V5cyxcblx0XHRcdFx0dGhpcy5fZGVmYXVsdEtleXN0cm9rZUNvbW1hbmRcblx0XHRcdCk7XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25LZXlzdHJva2U7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmltcG9ydCBCdXR0b25MaW5rRWRpdCBmcm9tICcuLi9idXR0b25zL2J1dHRvbi1saW5rLWVkaXQuanN4JztcblxuLyoqXG4gKiBCdXR0b25Qcm9wcyBpcyBhIG1peGluIHRoYXQgcHJvdmlkZXMgYSBzdHlsZSBwcm9wIGFuZCBzb21lIG1ldGhvZHMgdG8gYXBwbHkgdGhlIHJlc3VsdGluZ1xuICogc3R5bGUgYW5kIGNoZWNraW5nIGlmIGl0IGlzIHByZXNlbnQgaW4gYSBnaXZlbiBwYXRoIG9yIHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUHJvcHNcbiAqL1xuY29uc3QgQnV0dG9uUHJvcHMgPSB7XG5cdC8vIEFsbG93cyB2YWxpZGF0aW5nIHByb3BzIGJlaW5nIHBhc3NlZCB0byB0aGUgY29tcG9uZW50LlxuXG5cdHByb3BUeXBlczoge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBlZGl0b3IgaW5zdGFuY2Ugd2hlcmUgdGhlIGNvbXBvbmVudCBpcyBiZWluZyB1c2VkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvblByb3BzXG5cdFx0ICogQHByb3BlcnR5IHtPYmplY3R9IGVkaXRvclxuXHRcdCAqL1xuXHRcdGVkaXRvcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBNZXJnZXMgdGhlIHByb3BlcnRpZXMsIHBhc3NlZCB0byB0aGUgY3VycmVudCBjb21wb25lbnQgd2l0aCB1c2VyJ3MgY29uZmlndXJhdGlvblxuXHQgKiB2aWEgYGJ1dHRvbkNmZ2AgcHJvcGVydHkuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUHJvcHNcblx0ICogQG1ldGhvZCBtZXJnZUJ1dHRvbkNmZ1Byb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBUaGUgcHJvcGVydGllcyB0byBiZSBtZXJnZWQgd2l0aCB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvbiBmb3IgdGhpc1xuXHQgKiBidXR0b24uIElmIG5vdCBwYXNzZWQsIHRoZSB1c2VyIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBtZXJnZWQgd2l0aCBgdGhpcy5wcm9wc2Bcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgbWVyZ2VkIHByb3BlcnRpZXNcblx0ICovXG5cdG1lcmdlQnV0dG9uQ2ZnUHJvcHMocHJvcHMpIHtcblx0XHRwcm9wcyA9IHByb3BzIHx8IHRoaXMucHJvcHM7XG5cblx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdGNvbnN0IGJ1dHRvbkNmZyA9IG5hdGl2ZUVkaXRvci5jb25maWcuYnV0dG9uQ2ZnIHx8IHt9O1xuXHRcdGNvbnN0IHJlc3VsdCA9IENLRURJVE9SLnRvb2xzLm1lcmdlKFxuXHRcdFx0cHJvcHMsXG5cdFx0XHRidXR0b25DZmdbQnV0dG9uTGlua0VkaXQua2V5XVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uUHJvcHM7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nJztcblxuLyoqXG4gKiBCdXR0b25TdGF0ZUNsYXNzZXMgaXMgYSBtaXhpbiB0aGF0IGRlY29yYXRlcyB0aGUgZG9tRWxlbWVudCBvZiBhIGNvbXBvbmVudFxuICogd2l0aCBkaWZmZXJlbnQgQ1NTIGNsYXNzZXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogVG8gY2hlY2sgZm9yIHN0YXRlLCB0aGUgY29tcG9uZW50IGNhbiBleHBvc2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICogLSBgRnVuY3Rpb25gICoqaXNBY3RpdmUqKiB0byBjaGVjayB0aGUgYWN0aXZlIHN0YXRlXG4gKiAtIGBGdW5jdGlvbmAgKippc0Rpc2FibGVkKiogdG8gY2hlY2sgdGhlIGRpc2FibGVkIHN0YXRlXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jb25zdCBCdXR0b25TdGF0ZUNsYXNzZXMgPSB7XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHN0YXRlIGNsYXNzZXMgYXNzb2NpYXRlZCB0byB0aGUgY3VycmVudCBlbGVtZW50J3Mgc3RhdGUsIGFjY29yZGluZ1xuXHQgKiB0byB0aGUgcmVzdWx0cyBvZiB0aGUgaXNBY3RpdmUgYW5kIGlzRGlzYWJsZWQgbWV0aG9kcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdGF0ZUNsYXNzZXNcblx0ICogQG1ldGhvZCBnZXRTdGF0ZUNsYXNzZXNcblx0ICogQHJldHVybiB7U3RyaW5nfSBBIHN0cmluZyB3aXRoIHRoZSBzdGF0ZSBDU1MgY2xhc3Nlcy5cblx0ICovXG5cdGdldFN0YXRlQ2xhc3NlcygpIHtcblx0XHRsZXQgc3RhdGVDbGFzc2VzID0gJyc7XG5cblx0XHQvLyBDaGVjayBmb3IgYWN0aXZlIHN0YXRlXG5cblx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKHRoaXMuaXNBY3RpdmUpICYmIHRoaXMuaXNBY3RpdmUoKSkge1xuXHRcdFx0c3RhdGVDbGFzc2VzICs9ICdhZS1idXR0b24tcHJlc3NlZCc7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIGRpc2FibGVkIHN0YXRlXG5cblx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKHRoaXMuaXNEaXNhYmxlZCkgJiYgdGhpcy5pc0Rpc2FibGVkKCkpIHtcblx0XHRcdHN0YXRlQ2xhc3NlcyArPSAnIGFlLWJ1dHRvbi1kaXNhYmxlZCc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0YXRlQ2xhc3Nlcztcblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblN0YXRlQ2xhc3NlcztcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuXG4vKipcbiAqIEJ1dHRvblN0eWxlIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBhIHN0eWxlIHByb3AgYW5kIHNvbWUgbWV0aG9kcyB0b1xuICogYXBwbHkgdGhlIHJlc3VsdGluZyBzdHlsZSBhbmQgY2hlY2tpbmcgaWYgaXQgaXMgcHJlc2VudCBpbiBhIGdpdmVuXG4gKiBwYXRoIG9yIHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3R5bGVcbiAqL1xuY29uc3QgQnV0dG9uU3R5bGUgPSB7XG5cdC8vIEFsbG93cyB2YWxpZGF0aW5nIHByb3BzIGJlaW5nIHBhc3NlZCB0byB0aGUgY29tcG9uZW50LlxuXG5cdHByb3BUeXBlczoge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBzdHlsZSB0aGUgYnV0dG9uIHNob3VsZCBoYW5kbGUuIEFsbG93ZWQgdmFsdWVzIGFyZTpcblx0XHQgKiAtIE9iamVjdCBhcyBkZXNjcmliZWQgYnlcblx0XHQgKiAgIGh0dHA6Ly9kb2NzLmNrZWRpdG9yLmNvbS8jIS9hcGkvQ0tFRElUT1Iuc3R5bGUuXG5cdFx0ICogLSBTdHJpbmcgcG9pbnRpbmcgdG8gYW4gb2JqZWN0IGluc2lkZSB0aGUgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICogICBjb25maWd1cmF0aW9uLiBGb3IgZXhhbXBsZSwgYHN0eWxlID0gJ2NvcmVTdHlsZXNfYm9sZCdgIHdpbGxcblx0XHQgKiAgIHRyeSB0byByZXRyaWV2ZSB0aGUgc3R5bGUgb2JqZWN0IGZyb21cblx0XHQgKiAgIGBlZGl0b3IuY29uZmlnLmNvcmVTdHlsZXNfYm9sZGAuIE5lc3RlZCBwcm9wZXJ0aWVzIHN1Y2ggYXNcblx0XHQgKiAgIGBzdHlsZSA9ICdteXBsdWdpbi5teUNvbmZpZy5teVN0eWxlJ2AgYXJlIGFsc28gc3VwcG9ydGVkXG5cdFx0ICogICBhbmQgd2lsbCB0cnkgdG8gcmV0cmlldmUgdGhlIHN0eWxlIG9iamVjdCBmcm9tIHRoZSBlZGl0b3Jcblx0XHQgKiAgIGNvbmZpZ3VyYXRpb24gYXMgd2VsbC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuXHRcdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fFN0cmluZ30gc3R5bGVcblx0XHQgKi9cblx0XHRzdHlsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHN0eWxlIGZ1bmN0aW9uIHRoZSBidXR0b24gc2hvdWxkIGhhbmRsZS5cblx0XHQgKiBJZiBzcGVjaWZpZWQsIHN0eWxlIGZ1bmN0aW9uIGhhcyBoaWdoZXIgcHJpb3JpdHkgdGhhbiBzdHlsZSBwcm9wZXJ0eS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuXHRcdCAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHN0eWxlRm5cblx0XHQgKi9cblx0XHRzdHlsZUZuOiBQcm9wVHlwZXMuZnVuYyxcblx0fSxcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIGJvdGggb24gdGhlIGNsaWVudCBhbmQgc2VydmVyLFxuXHQgKiBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50V2lsbE1vdW50KCkge1xuXHRcdGxldCBzdHlsZSA9IHRoaXMucHJvcHMuc3R5bGU7XG5cblx0XHRpZiAoTGFuZy5pc1N0cmluZyhzdHlsZSkpIHtcblx0XHRcdGNvbnN0IHBhcnRzID0gc3R5bGUuc3BsaXQoJy4nKTtcblx0XHRcdGxldCBjdXJyZW50TWVtYmVyID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKS5jb25maWc7XG5cdFx0XHRsZXQgcHJvcGVydHkgPSBwYXJ0cy5zaGlmdCgpO1xuXG5cdFx0XHR3aGlsZSAoXG5cdFx0XHRcdHByb3BlcnR5ICYmXG5cdFx0XHRcdExhbmcuaXNPYmplY3QoY3VycmVudE1lbWJlcikgJiZcblx0XHRcdFx0TGFuZy5pc09iamVjdChjdXJyZW50TWVtYmVyW3Byb3BlcnR5XSlcblx0XHRcdCkge1xuXHRcdFx0XHRjdXJyZW50TWVtYmVyID0gY3VycmVudE1lbWJlcltwcm9wZXJ0eV07XG5cdFx0XHRcdHByb3BlcnR5ID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKExhbmcuaXNPYmplY3QoY3VycmVudE1lbWJlcikpIHtcblx0XHRcdFx0c3R5bGUgPSBjdXJyZW50TWVtYmVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3N0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKHN0eWxlKTtcblx0fSxcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWRcblx0ICogZnJvbSB0aGUgRE9NLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlXG5cdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcblx0ICovXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdHRoaXMuX3N0eWxlID0gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBpbnN0YW5jZSBvZiBDS0VESVRPUi5zdHlsZSB3aGljaCByZXByZXNlbnRzIHRoZSBjdXJyZW50XG5cdCAqIGJ1dHRvbiBzdHlsZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuXHQgKiBAbWV0aG9kIGdldFN0eWxlXG5cdCAqIEByZXR1cm4ge0NLRURJVE9SLnN0eWxlfSBUaGUgY3VycmVudCBzdHlsZSByZXByZXNlbnRhdGlvbi5cblx0ICovXG5cdGdldFN0eWxlKCkge1xuXHRcdHJldHVybiB0aGlzLl9zdHlsZTtcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHN0eWxlIGlzIGFjdGl2ZSBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVcblx0ICogQG1ldGhvZCBpc0FjdGl2ZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHN0eWxlIGlzIGFjdGl2ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cblx0aXNBY3RpdmUoKSB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGNvbnN0IGVsZW1lbnRQYXRoID0gZWRpdG9yLmVsZW1lbnRQYXRoKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmNoZWNrQWN0aXZlKGVsZW1lbnRQYXRoLCBlZGl0b3IpO1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uU3R5bGU7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBCdXR0b25BY3Rpb25TdHlsZX0gZnJvbSAnLi9idXR0b24tYWN0aW9uLXN0eWxlJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBCdXR0b25Db21tYW5kQWN0aXZlfSBmcm9tICcuL2J1dHRvbi1jb21tYW5kLWFjdGl2ZSc7XG5leHBvcnQge2RlZmF1bHQgYXMgQnV0dG9uQ29tbWFuZH0gZnJvbSAnLi9idXR0b24tY29tbWFuZCc7XG5leHBvcnQge2RlZmF1bHQgYXMgQnV0dG9uS2V5c3Ryb2tlfSBmcm9tICcuL2J1dHRvbi1rZXlzdHJva2UnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEJ1dHRvblByb3BzfSBmcm9tICcuL2J1dHRvbi1wcm9wcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgQnV0dG9uU3RhdGVDbGFzc2VzfSBmcm9tICcuL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBCdXR0b25TdHlsZX0gZnJvbSAnLi9idXR0b24tc3R5bGUnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFRvb2xiYXJCdXR0b25zfSBmcm9tICcuL3Rvb2xiYXItYnV0dG9ucyc7XG5leHBvcnQge2RlZmF1bHQgYXMgV2lkZ2V0QXJyb3dCb3h9IGZyb20gJy4vd2lkZ2V0LWFycm93LWJveCc7XG5leHBvcnQge2RlZmF1bHQgYXMgV2lkZ2V0RHJvcGRvd259IGZyb20gJy4vd2lkZ2V0LWRyb3Bkb3duJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBXaWRnZXRFeGNsdXNpdmV9IGZyb20gJy4vd2lkZ2V0LWV4Y2x1c2l2ZSc7XG5leHBvcnQge2RlZmF1bHQgYXMgV2lkZ2V0Rm9jdXNNYW5hZ2VyfSBmcm9tICcuL3dpZGdldC1mb2N1cy1tYW5hZ2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBXaWRnZXRJbnRlcmFjdGlvblBvaW50fSBmcm9tICcuL3dpZGdldC1pbnRlcmFjdGlvbi1wb2ludCc7XG5leHBvcnQge2RlZmF1bHQgYXMgV2lkZ2V0UG9zaXRpb259IGZyb20gJy4vd2lkZ2V0LXBvc2l0aW9uJztcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuXG4vKipcbiAqIFRvb2xiYXJCdXR0b25zIGlzIGEgbWl4aW4gd2hpY2ggcHJvdmlkZXMgYSBsaXN0IG9mIGJ1dHRvbnMgd2hpY2ggaGF2ZVxuICogdG8gYmUgZGlzcGxheWVkIG9uIHRoZSBjdXJyZW50IHRvb2xiYXIgZGVwZW5kaW5nIG9uIHVzZXIgcHJlZmVyZW5jZXNcbiAqIGFuZCBnaXZlbiBzdGF0ZS5cbiAqXG4gKiBAY2xhc3MgVG9vbGJhckJ1dHRvbnNcbiAqL1xuY29uc3QgVG9vbGJhckJ1dHRvbnMgPSB7XG5cdC8qKlxuXHQgKiBBbmFseXNlcyB0aGUgY3VycmVudCBzZWxlY3Rpb24gYW5kIHJldHVybnMgdGhlIGJ1dHRvbnMgb3IgYnV0dG9uXG5cdCAqIGdyb3VwcyB0byBiZSByZW5kZXJlZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZXRob2QgZ2V0VG9vbGJhckJ1dHRvbkdyb3Vwc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBidXR0b25zIFRoZSBidXR0b25zIGNvdWxkIGJlIHNob3duLCBwcmlvciB0byB0aGUgc3RhdGUgZmlsdGVyaW5nLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYWRkaXRpb25hbFByb3BzIEFkZGl0aW9uYWwgcHJvcHMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIGRvd24gdG8gdGhlIGJ1dHRvbnMuXG5cdCAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSB3aGljaCBjb250YWlucyB0aGUgYnV0dG9ucyBvciBidXR0b24gZ3JvdXBzIHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0Z2V0VG9vbGJhckJ1dHRvbkdyb3VwcyhidXR0b25zLCBhZGRpdGlvbmFsUHJvcHMpIHtcblx0XHRjb25zdCBpbnN0YW5jZSA9IHRoaXM7XG5cblx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKGJ1dHRvbnMpKSB7XG5cdFx0XHRidXR0b25zID0gYnV0dG9ucy5jYWxsKHRoaXMpIHx8IFtdO1xuXHRcdH1cblxuXHRcdHJldHVybiBidXR0b25zLnJlZHVjZSgobGlzdCwgYnV0dG9uKSA9PiB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShidXR0b24pKSB7XG5cdFx0XHRcdGxpc3QucHVzaChpbnN0YW5jZS5nZXRUb29sYmFyQnV0dG9ucyhidXR0b24sIGFkZGl0aW9uYWxQcm9wcykpO1xuXG5cdFx0XHRcdHJldHVybiBsaXN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGluc3RhbmNlLmdldFRvb2xiYXJCdXR0b25zKGJ1dHRvbnMsIGFkZGl0aW9uYWxQcm9wcyk7XG5cdFx0XHR9XG5cdFx0fSwgW10pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBbmFseXplcyB0aGUgY3VycmVudCBzZWxlY3Rpb24gYW5kIHRoZSBidXR0b25zIGV4Y2x1c2l2ZSBtb2RlIHZhbHVlIHRvIGZpZ3VyZSBvdXQgd2hpY2hcblx0ICogYnV0dG9ucyBzaG91bGQgYmUgcHJlc2VudCBpbiBhIGdpdmVuIHN0YXRlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFRvb2xiYXJCdXR0b25zXG5cdCAqIEBtZXRob2QgZ2V0VG9vbGJhckJ1dHRvbnNcblx0ICogQHBhcmFtIHtBcnJheX0gYnV0dG9ucyBUaGUgYnV0dG9ucyBjb3VsZCBiZSBzaG93biwgcHJpb3IgdG8gdGhlIHN0YXRlIGZpbHRlcmluZy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGFkZGl0aW9uYWxQcm9wcyBBZGRpdGlvbmFsIHByb3BzIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCBkb3duIHRvIHRoZSBidXR0b25zLlxuXHQgKiBAcmV0dXJuIHtBcnJheX0gQW4gQXJyYXkgd2hpY2ggY29udGFpbnMgdGhlIGJ1dHRvbnMgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRnZXRUb29sYmFyQnV0dG9ucyhidXR0b25zLCBhZGRpdGlvbmFsUHJvcHMpIHtcblx0XHRjb25zdCBidXR0b25Qcm9wcyA9IHt9O1xuXG5cdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRjb25zdCBidXR0b25DZmcgPSBuYXRpdmVFZGl0b3IuY29uZmlnLmJ1dHRvbkNmZyB8fCB7fTtcblxuXHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oYnV0dG9ucykpIHtcblx0XHRcdGJ1dHRvbnMgPSBidXR0b25zLmNhbGwodGhpcykgfHwgW107XG5cdFx0fVxuXG5cdFx0Y29uc3QgdG9vbGJhckJ1dHRvbnMgPSB0aGlzLmZpbHRlckV4Y2x1c2l2ZShcblx0XHRcdGJ1dHRvbnNcblx0XHRcdFx0LmZpbHRlcihidXR0b24gPT4ge1xuXHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRidXR0b24gJiZcblx0XHRcdFx0XHRcdChBbGxveUVkaXRvci5CdXR0b25zW2J1dHRvbl0gfHxcblx0XHRcdFx0XHRcdFx0QWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b24ubmFtZV0pXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSlcblx0XHRcdFx0Lm1hcChidXR0b24gPT4ge1xuXHRcdFx0XHRcdGlmIChMYW5nLmlzU3RyaW5nKGJ1dHRvbikpIHtcblx0XHRcdFx0XHRcdGJ1dHRvblByb3BzW2J1dHRvbl0gPSBidXR0b25DZmdbYnV0dG9uXTtcblx0XHRcdFx0XHRcdGJ1dHRvbiA9IEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKExhbmcuaXNTdHJpbmcoYnV0dG9uLm5hbWUpKSB7XG5cdFx0XHRcdFx0XHRidXR0b25Qcm9wc1tcblx0XHRcdFx0XHRcdFx0QWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b24ubmFtZV0ua2V5XG5cdFx0XHRcdFx0XHRdID0gQ0tFRElUT1IudG9vbHMubWVyZ2UoYnV0dG9uQ2ZnW2J1dHRvbl0sIGJ1dHRvbi5jZmcpO1xuXHRcdFx0XHRcdFx0YnV0dG9uID0gQWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b24ubmFtZV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGJ1dHRvbjtcblx0XHRcdFx0fSlcblx0XHQpLm1hcChmdW5jdGlvbihidXR0b24sIGluZGV4KSB7XG5cdFx0XHRsZXQgcHJvcHMgPSB0aGlzLm1lcmdlRXhjbHVzaXZlUHJvcHMoXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlZGl0b3I6IHRoaXMucHJvcHMuZWRpdG9yLFxuXHRcdFx0XHRcdGtleTpcblx0XHRcdFx0XHRcdGJ1dHRvbi5rZXkgIT09ICdzZXBhcmF0b3InXG5cdFx0XHRcdFx0XHRcdD8gYnV0dG9uLmtleVxuXHRcdFx0XHRcdFx0XHQ6IGAke2J1dHRvbi5rZXl9LSR7aW5kZXh9YCxcblx0XHRcdFx0XHR0YWJLZXk6IGJ1dHRvbi5rZXksXG5cdFx0XHRcdFx0dGFiSW5kZXg6XG5cdFx0XHRcdFx0XHR0aGlzLnByb3BzLnRyaWdnZXIgJiZcblx0XHRcdFx0XHRcdHRoaXMucHJvcHMudHJpZ2dlci5wcm9wcy50YWJLZXkgPT09IGJ1dHRvbi5rZXlcblx0XHRcdFx0XHRcdFx0PyAwXG5cdFx0XHRcdFx0XHRcdDogLTEsXG5cdFx0XHRcdFx0dHJpZ2dlcjogdGhpcy5wcm9wcy50cmlnZ2VyLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRidXR0b24ua2V5XG5cdFx0XHQpO1xuXG5cdFx0XHRwcm9wcyA9IHRoaXMubWVyZ2VEcm9wZG93blByb3BzKHByb3BzLCBidXR0b24ua2V5KTtcblxuXHRcdFx0aWYgKGFkZGl0aW9uYWxQcm9wcykge1xuXHRcdFx0XHRwcm9wcyA9IENLRURJVE9SLnRvb2xzLm1lcmdlKHByb3BzLCBhZGRpdGlvbmFsUHJvcHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRwcm9wcyA9IENLRURJVE9SLnRvb2xzLm1lcmdlKHByb3BzLCBidXR0b25Qcm9wc1tidXR0b24ua2V5XSk7XG5cblx0XHRcdHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KGJ1dHRvbiwgcHJvcHMpO1xuXHRcdH0sIHRoaXMpO1xuXG5cdFx0cmV0dXJuIHRvb2xiYXJCdXR0b25zO1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgVG9vbGJhckJ1dHRvbnM7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nJztcblxuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBkaXNwbGF5aW5nIFdpZGdldCBBcnJvdyBib3ggb24gdG9wIG9yIG9uIGJvdHRvbSBvZiB0aGUgd2lkZ2V0XG4gKiBkZXBlbmRpbmcgb24gdGhlIHBvaW50IG9mIHVzZXIgaW50ZXJhY3Rpb24gd2l0aCB0aGUgZWRpdG9yLlxuICpcbiAqIEBjbGFzcyBXaWRnZXRBcnJvd0JveFxuICovXG5jb25zdCBXaWRnZXRBcnJvd0JveCA9IHtcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYXJyb3cgYm94IGNsYXNzZXMgYXNzb2NpYXRlZCB0byB0aGUgY3VycmVudCBlbGVtZW50J3Mgc3RhdGUuIEl0IHJlbGllc1xuXHQgKiBvbiB0aGUgZ2V0SW50ZXJhY3Rpb25Qb2ludCBtZXRob2QgdG8gY2FsY3VsYXRlIHRoZSBzZWxlY3Rpb24gZGlyZWN0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldEFycm93Qm94XG5cdCAqIEBtZXRob2QgZ2V0QXJyb3dCb3hDbGFzc2VzXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgd2l0aCB0aGUgYXJyb3cgYm94IENTUyBjbGFzc2VzLlxuXHQgKi9cblx0Z2V0QXJyb3dCb3hDbGFzc2VzKCkge1xuXHRcdGxldCBhcnJvd0JveENsYXNzZXMgPSAnYWUtYXJyb3ctYm94JztcblxuXHRcdGlmIChcblx0XHRcdExhbmcuaXNGdW5jdGlvbih0aGlzLmdldEludGVyYWN0aW9uUG9pbnQpICYmXG5cdFx0XHR0aGlzLmdldEludGVyYWN0aW9uUG9pbnQoKVxuXHRcdCkge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHR0aGlzLmdldEludGVyYWN0aW9uUG9pbnQoKS5kaXJlY3Rpb24gPT09XG5cdFx0XHRcdENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NXG5cdFx0XHQpIHtcblx0XHRcdFx0YXJyb3dCb3hDbGFzc2VzICs9ICcgYWUtYXJyb3ctYm94LXRvcCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhcnJvd0JveENsYXNzZXMgKz0gJyBhZS1hcnJvdy1ib3gtYm90dG9tJztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyb3dCb3hDbGFzc2VzO1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0QXJyb3dCb3g7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIFByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIG1hbmFnaW5nIGRpZmZlcmVudCBkcm9wZG93bnMgaW5zaWRlIGEgd2lkZ2V0LlxuICpcbiAqIEBjbGFzcyBXaWRnZXREcm9wZG93blxuICovXG5jb25zdCBXaWRnZXREcm9wZG93biA9IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlY2VpdmluZyBuZXcgcHJvcHMuXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXREcm9wZG93blxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcblx0ICovXG5cdGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoX25leHRQcm9wcykge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0ZHJvcGRvd25UcmlnZ2VyOiBudWxsLFxuXHRcdFx0aXRlbURyb3Bkb3duOiBudWxsLFxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG5cdCAqIEBtZXRob2QgZ2V0SW5pdGlhbFN0YXRlXG5cdCAqL1xuXHRnZXRJbml0aWFsU3RhdGUoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGRyb3Bkb3duVHJpZ2dlcjogbnVsbCxcblx0XHRcdGl0ZW1Ecm9wZG93bjogbnVsbCxcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBNZXJnZXMgdGhlIHByb3ZpZGVkIG9iamVjdCB3aXRoIHR3byBtb3JlIHByb3BlcnRpZXM6XG5cdCAqIC0gZXhwYW5kZWQgLSBib29sZWFuIGZsYWcgd2hpY2ggaW5kaWNhdGVzIGlmIGFuIHdpZGdldCBzaG91bGQgYmVcblx0ICogICByZW5kZXJlZCBleGNsdXNpdmVseS5cblx0ICogLSB0b2dnbGVEcm9wZG93biAtIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgdXNlZCBieSBhbiB3aWRnZXQgaW5cblx0ICogICBvcmRlciB0byBvYnRhaW4gZXhjbHVzaXZlIHN0YXRlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG5cdCAqIEBtZXRob2QgbWVyZ2VEcm9wZG93blByb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIHByb3BlcnRpZXMgY29udGFpbmVyIHdoaWNoIHNob3VsZCBiZSBtZXJnZWQgd2l0aCB0aGUgcHJvcGVydGllcywgcmVsYXRlZFxuXHQgKiAgICB0byBkcm9wZG93biBzdGF0ZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1LZXkgVGhleSBrZXkgb2YgYW4gUmVhY3QgV2lkZ2V0IHdoaWNoIGNvbnRhaW5zIHRoZSBkcm9wZG93bi5cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgbWVyZ2VkIG9iamVjdC5cblx0ICovXG5cdG1lcmdlRHJvcGRvd25Qcm9wcyhvYmosIGl0ZW1LZXkpIHtcblx0XHRyZXR1cm4gQ0tFRElUT1IudG9vbHMubWVyZ2Uob2JqLCB7XG5cdFx0XHRleHBhbmRlZDogdGhpcy5zdGF0ZS5pdGVtRHJvcGRvd24gPT09IGl0ZW1LZXkgPyB0cnVlIDogZmFsc2UsXG5cdFx0XHR0YWJJbmRleDogdGhpcy5zdGF0ZS5kcm9wZG93blRyaWdnZXIgPT09IGl0ZW1LZXkgPyAwIDogLTEsXG5cdFx0XHR0b2dnbGVEcm9wZG93bjogdGhpcy50b2dnbGVEcm9wZG93bi5iaW5kKHRoaXMsIGl0ZW1LZXkpLFxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBhY3RpdmUgZHJvcGRvd24gb2YgdGhlIHdpZGdldCBvciBkaXNjYXJkcyB0aGUgdG9nZ2xlZFxuXHQgKiBpdGVtIGZyb20gdGhlIHN0YXRlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG5cdCAqIEBtZXRob2QgdG9nZ2xlRHJvcGRvd25cblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1Ecm9wZG93biBUaGUgd2lkZ2V0IHdoaWNoIHJlcXVlc3RzIHRvIHRvZ2dsZSBpdHMgZHJvcGRvd24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0b2dnbGVEaXJlY3Rpb24gVXNlciBtb3ZlbWVudCBkaXJlY3Rpb24gd2hlbiB0b2dnbGVkIHZpYSBrZXlib2FyZC5cblx0ICovXG5cdHRvZ2dsZURyb3Bkb3duKGl0ZW1Ecm9wZG93biwgdG9nZ2xlRGlyZWN0aW9uKSB7XG5cdFx0dGhpcy5zZXRTdGF0ZShcblx0XHRcdHtcblx0XHRcdFx0ZHJvcGRvd25UcmlnZ2VyOiBpdGVtRHJvcGRvd24sXG5cdFx0XHRcdGl0ZW1Ecm9wZG93bjpcblx0XHRcdFx0XHRpdGVtRHJvcGRvd24gIT09IHRoaXMuc3RhdGUuaXRlbURyb3Bkb3duXG5cdFx0XHRcdFx0XHQ/IGl0ZW1Ecm9wZG93blxuXHRcdFx0XHRcdFx0OiBudWxsLFxuXHRcdFx0fSxcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuc3RhdGUuaXRlbURyb3Bkb3duKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMubW92ZUZvY3VzKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1vdmVGb2N1cyh0b2dnbGVEaXJlY3Rpb24pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5mb2N1cygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCk7XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXREcm9wZG93bjtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBtYW5hZ2luZyBleGNsdXNpdmUgc3RhdGUgb2YgYW4gd2lkZ2V0LlxuICogVGhlIGV4Y2x1c2l2ZSBzdGF0ZSBtZWFucyB0aGF0IGEgYnV0dG9uIG1heSByZXF1ZXN0IHRvIGJlIHRoZSBvbmx5IHJlbmRlcmVkXG4gKiB3aWRnZXQgaW4gaXRzIHBhcmVudCBjb250YWluZXIuIFdpZGdldEV4Y2x1c2l2ZSB3aWxsIG1hbmFnZSB0aGlzIHN0YXRlIGJ5XG4gKiBmaWx0ZXJpbmcgYW5kIHN1cHByZXNzaW5nIHRoZSBvdGhlciBzaWJsaW5nIHdpZGdldHMgZnJvbSBkaXNwbGF5aW5nLlxuICpcbiAqIEBjbGFzcyBXaWRnZXRFeGNsdXNpdmVcbiAqL1xuY29uc3QgV2lkZ2V0RXhjbHVzaXZlID0ge1xuXHQvKipcblx0ICogQ2FuY2VscyB0aGUgZXhjbHVzaXZlIHN0YXRlIG9mIGFuIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcblx0ICogQG1ldGhvZCBjYW5jZWxFeGNsdXNpdmVcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1FeGNsdXNpdmUgVGhlIHdpZGdldCB3aGljaCBleGNsdXNpdmUgc3RhdGUgc2hvdWxkIGJlIGNhbmNlbGVkLlxuXHQgKi9cblx0Y2FuY2VsRXhjbHVzaXZlKGl0ZW1FeGNsdXNpdmUpIHtcblx0XHRpZiAodGhpcy5zdGF0ZS5pdGVtRXhjbHVzaXZlID09PSBpdGVtRXhjbHVzaXZlKSB7XG5cdFx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0aXRlbUV4Y2x1c2l2ZTogbnVsbCxcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVjZWl2aW5nIG5ldyBwcm9wcy5cblx0ICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuXHQgKiBDYWxsaW5nIHRoaXMuc2V0U3RhdGUoKSB3aXRoaW4gdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCB0cmlnZ2VyIGFuXG5cdCAqIGFkZGl0aW9uYWwgcmVuZGVyLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldEV4Y2x1c2l2ZVxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcblx0ICogQHBhcmFtIHtPYmplY3R9IG5leHRQcm9wcyBPYmplY3QgY29udGFpbmluZyB0aGUgY3VycmVudCBzZXQgb2YgcHJvcGVydGllcy5cblx0ICovXG5cdGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoX25leHRQcm9wcykge1xuXHRcdC8vIFJlY2VpdmluZyBwcm9wZXJ0aWVzIG1lYW5zIHRoYXQgdGhlIGNvbXBvbmVudCBpcyBiZWluZ1xuXHRcdC8vIHJlLXJlbmRlcmVkLiAgUmUtcmVuZGVyaW5nIGlzIHRyaWdnZXJlZCBieSBlZGl0b3JJbnRlcmFjdGlvbixcblx0XHQvLyBzbyB3ZSBoYXZlIHRvIHJlc2V0IHRoZSBleGNsdXNpdmUgc3RhdGUgYW5kIHJlbmRlciB0aGUgVUlcblx0XHQvLyBhY2NvcmRpbmcgdG8gdGhlIG5ldyBzZWxlY3Rpb24uXG5cblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdGl0ZW1FeGNsdXNpdmU6IG51bGwsXG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEZpbHRlcnMgdGhlIGl0ZW1zIGFuZCByZXR1cm5zIG9ubHkgdGhvc2Ugd2l0aCBleGNsdXNpdmUgc3RhdGUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0RXhjbHVzaXZlXG5cdCAqIEBtZXRob2QgZmlsdGVyRXhjbHVzaXZlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIFRoZSB3aWRnZXRzIHRvIGJlIGZpbHRlcmVkLlxuXHQgKiBAcmV0dXJuIHtBcnJheXxPYmplY3R9IFRoZSBpdGVtIHdpdGggZXhlY3V0aXZlIHN0YXRlLlxuXHQgKi9cblx0ZmlsdGVyRXhjbHVzaXZlKGl0ZW1zKSB7XG5cdFx0cmV0dXJuIGl0ZW1zLmZpbHRlcihpdGVtID0+IHtcblx0XHRcdGlmICh0aGlzLnN0YXRlLml0ZW1FeGNsdXNpdmUpIHtcblx0XHRcdFx0aWYgKHRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSA9PT0gaXRlbS5rZXkpIHtcblx0XHRcdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIE1lcmdlcyB0aGUgcHJvdmlkZWQgb2JqZWN0IHdpdGggdGhyZWUgbW9yZSBwcm9wZXJ0aWVzOlxuXHQgKiAtIGNhbmNlbEV4Y2x1c2l2ZSAtIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgdXNlZCBieSBhIHdpZGdldCBpblxuXHQgKiAgIG9yZGVyIHRvIGNhbmNlbCBleGVjdXRpdmUgc3RhdGUuXG5cdCAqIC0gcmVuZGVyRXhjbHVzaXZlIC0gYm9vbGVhbiBmbGFnIHdoaWNoIGluZGljYXRlcyBpZiBhbiB3aWRnZXRcblx0ICogICBzaG91bGQgYmUgcmVuZGVyZWQgZXhjbHVzaXZlbHkuXG5cdCAqIC0gcmVxdWVzdEV4Y2x1c2l2ZSAtIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgdXNlZCBieSBhIHdpZGdldCBpblxuXHQgKiAgIG9yZGVyIHRvIG9idGFpbiBleGNsdXNpdmUgc3RhdGUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0RXhjbHVzaXZlXG5cdCAqIEBtZXRob2QgbWVyZ2VFeGNsdXNpdmVQcm9wc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBwcm9wZXJ0aWVzIGNvbnRhaW5lciB3aGljaCBzaG91bGQgYmUgbWVyZ2VkIHdpdGggdGhlIHByb3BlcnRpZXMsIHJlbGF0ZWRcblx0ICogICAgdG8gZXhjbHVzaXZlIHN0YXRlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbUtleSBUaGV5IGtleSBvZiBhbiBSZWFjdCBXaWRnZXQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkIGV4Y2x1c2l2ZWx5LlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtZXJnZWQgb2JqZWN0LlxuXHQgKi9cblx0bWVyZ2VFeGNsdXNpdmVQcm9wcyhvYmosIGl0ZW1LZXkpIHtcblx0XHRyZXR1cm4gQ0tFRElUT1IudG9vbHMubWVyZ2Uob2JqLCB7XG5cdFx0XHRjYW5jZWxFeGNsdXNpdmU6IHRoaXMuY2FuY2VsRXhjbHVzaXZlLmJpbmQodGhpcywgaXRlbUtleSksXG5cdFx0XHRyZW5kZXJFeGNsdXNpdmU6IHRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSA9PT0gaXRlbUtleSxcblx0XHRcdHJlcXVlc3RFeGNsdXNpdmU6IHRoaXMucmVxdWVzdEV4Y2x1c2l2ZS5iaW5kKHRoaXMsIGl0ZW1LZXkpLFxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0cyBhbmQgc2V0cyBleGNsdXNpdmUgc3RhdGUgb2YgYW4gd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldEV4Y2x1c2l2ZVxuXHQgKiBAbWV0aG9kIHJlcXVlc3RFeGNsdXNpdmVcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1FeGNsdXNpdmUgVGhlIHdpZGdldCB3aGljaCByZXF1ZXN0cyBleGNsdXNpdmUgc3RhdGUuXG5cdCAqL1xuXHRyZXF1ZXN0RXhjbHVzaXZlKGl0ZW1FeGNsdXNpdmUpIHtcblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdGl0ZW1FeGNsdXNpdmUsXG5cdFx0fSk7XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRFeGNsdXNpdmU7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuXG5jb25zdCBESVJFQ1RJT05fTk9ORSA9IDA7XG5jb25zdCBESVJFQ1RJT05fTkVYVCA9IDE7XG5jb25zdCBESVJFQ1RJT05fUFJFViA9IC0xO1xuXG5jb25zdCBBQ1RJT05fTk9ORSA9IDA7XG5jb25zdCBBQ1RJT05fTU9WRV9GT0NVUyA9IDE7XG5jb25zdCBBQ1RJT05fRElTTUlTU19GT0NVUyA9IDI7XG5cbi8qKlxuICogV2lkZ2V0Rm9jdXNNYW5hZ2VyIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBrZXlib2FyZCBuYXZpZ2F0aW9uIGluc2lkZSBhIHdpZGdldC4gVG8gZG8gdGhpcyxcbiAqIGl0IGV4cG9zZXMgdGhlIGZvbGxvd2luZyBwcm9wcyBhbmQgbWV0aG9kczpcbiAqXG4gKiBAY2xhc3MgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gKi9cbmNvbnN0IFdpZGdldEZvY3VzTWFuYWdlciA9IHtcblx0Ly8gQWxsb3dzIHZhbGlkYXRpbmcgcHJvcHMgYmVpbmcgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQuXG5cblx0cHJvcFR5cGVzOiB7XG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgbWV0aG9kIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgZm9jdXMgbWFuYWdlciBpcyB0byBiZSBkaXNtaXNzZWQuIFRoaXMgaGFwcGVuc1xuXHRcdCAqIGluIHRoZSBmb2xsb3dpbmcgc2NlbmFyaW9zIGlmIGEgZGlzbWlzcyBjYWxsYmFjayBoYXMgYmVlbiBzcGVjaWZpZWQ6XG5cdFx0ICogLSBBIGRpc21pc3Mga2V5IGhhcyBiZWVuIHByZXNzZWRcblx0XHQgKiAtIEluIGEgbm9uLWNpcmN1bGFyIGZvY3VzIG1hbmFnZXIsIHdoZW46XG5cdFx0ICogICAgIC0gVGhlIGFjdGl2ZSBkZXNjZW5kYW50IGlzIHRoZSBmaXJzdCBvbmUgYW5kIGEgcHJldiBrZXkgaGFzIGJlZW4gcHJlc3NlZC5cblx0XHQgKiAgICAgLSBUaGUgYWN0aXZlIGRlc2NlbmRhbnQgaXMgdGhlIGxhc3Qgb25lIGFuZCBhIG5leHQga2V5IGhhcyBiZWVuIHByZXNzZWQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb25EaXNtaXNzXG5cdFx0ICovXG5cdFx0b25EaXNtaXNzOiBQcm9wVHlwZXMuZnVuYyxcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiBmb2N1cyBzaG91bGQgYmUgc2V0IHRvIHRoZSBmaXJzdC9sYXN0IGRlc2NlbmRhbnQgd2hlbiB0aGUgbGltaXRzIGFyZSByZWFjaGVkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2lyY3VsYXJcblx0XHQgKi9cblx0XHRjaXJjdWxhcjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlIGlmIHNob3VsZCBmb2N1cyB0aGUgZmlyc3QgY2hpbGQgb2YgYSBjb250YWluZXJcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBmb2N1c0ZpcnN0Q2hpbGRcblx0XHQgKi9cblx0XHRmb2N1c0ZpcnN0Q2hpbGQ6IFByb3BUeXBlcy5ib29sLFxuXG5cdFx0LyoqXG5cdFx0ICogU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgQ1NTIHNlbGVjdG9yIHVzZWQgdG8gZGVmaW5lIHRoZSBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBoYW5kbGVkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZXNjZW5kYW50c1xuXHRcdCAqL1xuXHRcdGRlc2NlbmRhbnRzOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG5cblx0XHQvKipcblx0XHQgKiBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBrZXlzIHVzZWQgdG8gbmF2aWdhdGUgYmV0d2VlbiBkZXNjZW5kYW50cy4gVGhlIGZvcm1hdCBmb3IgdGhlIHByb3AgaXM6XG5cdFx0ICogYHtkaXNtaXNzOiB2YWx1ZSwgZGlzbWlzc05leHQ6IHZhbHVlLCBkaXNtaXNzUHJldjogdmFsdWUsIG5leHQ6IHZhbHVlLCBwcmV2OiB2YWx1ZX1gIHdoZXJlXG5cdFx0ICogdmFsdWUgY2FuIGJlIGJvdGggYSBudW1iZXIgb3IgYW4gYXJyYXkgb2YgbnVtYmVycyB3aXRoIHRoZSBhbGxvd2VkIGtleUNvZGVzLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBrZXlzXG5cdFx0ICovXG5cdFx0a2V5czogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50LCBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50J3MgdXBkYXRlcyBhcmUgZmx1c2hlZCB0byB0aGUgRE9NLlxuXHQgKiBSZWZyZXNoZXMgdGhlIGRlc2NlbmRhbnRzIGxpc3QuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkVXBkYXRlXG5cdCAqL1xuXHRjb21wb25lbnREaWRVcGRhdGUoKSB7XG5cdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBGb2N1c2VzIHRoZSBjdXJyZW50IGFjdGl2ZSBkZXNjZW5kYW50LlxuXHQgKlxuXHQgKiBTZXZlcmFsIFdpZGdldHMgY2FuIGJlIG5lc3RlZCBpbiBhIGNvbXBvbmVudCBoaWVyYXJjaHkgYnkgYXR0YWNoaW5nIHRoaXMgZm9jdXMgbWV0aG9kIHRvXG5cdCAqIHRoZSB3aWRnZXQgRE9NIG5vZGUsIHRyYW5zZmVycmluZyB0aGUgRE9NIGZvY3VzIGNvbnRyb2wgdG8gdGhlIGlubmVyIEZvY3VzTWFuYWdlci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0ICogQG1ldGhvZCBmb2N1c1xuXHQgKi9cblx0Zm9jdXMoZXZlbnQpIHtcblx0XHRpZiAoIWV2ZW50IHx8IHRoaXMuX2lzVmFsaWRUYXJnZXQoZXZlbnQudGFyZ2V0KSkge1xuXHRcdFx0aWYgKHRoaXMuX2Rlc2NlbmRhbnRzICYmIHRoaXMuX2Rlc2NlbmRhbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRjb25zdCBhY3RpdmVEZXNjZW5kYW50RWwgPSB0aGlzLl9kZXNjZW5kYW50c1tcblx0XHRcdFx0XHR0aGlzLl9hY3RpdmVEZXNjZW5kYW50XG5cdFx0XHRcdF07XG5cblx0XHRcdFx0Ly8gV2hlbiB1c2VyIGNsaWNrcyB3aXRoIHRoZSBtb3VzZSwgdGhlIGFjdGl2ZUVsZW1lbnQgaXMgYWxyZWFkeSBzZXQgYW5kIHRoZXJlXG5cdFx0XHRcdC8vIGlzIG5vIG5lZWQgdG8gZm9jdXMgaXQuIEZvY3VzaW5nIG9mIHRoZSBhY3RpdmUgZGVzY2VuZGFudCAodXN1YWxseSBzb21lIGJ1dHRvbikgaXMgcmVxdWlyZWRcblx0XHRcdFx0Ly8gaW4gY2FzZSBvZiBrZXlib2FyZCBuYXZpZ2F0aW9uLCBiZWNhdXNlIHRoZSBmb2N1c2VkIGVsZW1lbnQgbWlnaHQgYmUgbm90IHRoZSBmaXJzdCBidXR0b24sXG5cdFx0XHRcdC8vIGJ1dCB0aGUgZGl2IGVsZW1lbnQsIHdoaWNoIGNvbnRhaW5zIHRoZSBidXR0b24uXG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGFjdGl2ZURlc2NlbmRhbnRFbCAmJlxuXHRcdFx0XHRcdCF0aGlzLnByb3BzLmZvY3VzRmlyc3RDaGlsZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHR0aGlzLl9kZXNjZW5kYW50cy5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpID09PSAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0YWN0aXZlRGVzY2VuZGFudEVsLmZvY3VzKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGV2ZW50KSB7XG5cdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlcyB0aGUga2V5IGV2ZW50cyBvbiBhIERPTSBub2RlIHRvIGV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIG5hdmlnYXRpb24gd2hlbiBuZWVkZWQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgS2V5Ym9hcmQgZXZlbnQgdGhhdCB3YXMgZGV0ZWN0ZWQgb24gdGhlIHdpZGdldCBET00gbm9kZS5cblx0ICogQG1ldGhvZCBoYW5kbGVLZXlcblx0ICovXG5cdGhhbmRsZUtleShldmVudCkge1xuXHRcdGlmICh0aGlzLl9pc1ZhbGlkVGFyZ2V0KGV2ZW50LnRhcmdldCkgJiYgdGhpcy5fZGVzY2VuZGFudHMpIHtcblx0XHRcdGNvbnN0IGFjdGlvbiA9IHRoaXMuX2dldEZvY3VzQWN0aW9uKGV2ZW50KTtcblxuXHRcdFx0aWYgKGFjdGlvbi50eXBlKSB7XG5cdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdGlmIChhY3Rpb24udHlwZSA9PT0gQUNUSU9OX01PVkVfRk9DVVMpIHtcblx0XHRcdFx0XHR0aGlzLl9tb3ZlRm9jdXMoYWN0aW9uLmRpcmVjdGlvbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYWN0aW9uLnR5cGUgPT09IEFDVElPTl9ESVNNSVNTX0ZPQ1VTKSB7XG5cdFx0XHRcdFx0dGhpcy5wcm9wcy5vbkRpc21pc3MoYWN0aW9uLmRpcmVjdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIE1vdmVzIHRoZSBmb2N1cyBhbW9uZyBkZXNjZW5kYW50cyBpbiB0aGUgZXNwZWNpZmllZCBkaXJlY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdCAqIEBtZXRob2QgbW92ZUZvY3VzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiAoMSBvciAtMSkgb2YgdGhlIGZvY3VzIG1vdmVtZW50IGFtb25nIGRlc2NlbmRhbnRzLlxuXHQgKi9cblx0bW92ZUZvY3VzKGRpcmVjdGlvbikge1xuXHRcdGRpcmVjdGlvbiA9IExhbmcuaXNOdW1iZXIoZGlyZWN0aW9uKSA/IGRpcmVjdGlvbiA6IDA7XG5cblx0XHR0aGlzLl9tb3ZlRm9jdXMoZGlyZWN0aW9uKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYWN0aW9uLCBpZiBhbnksIHRoYXQgYSBrZXlib2FyZCBldmVudCBpbiB0aGUgY3VycmVudCBmb2N1cyBtYW5hZ2VyIHN0YXRlXG5cdCAqIHNob3VsZCBwcm9kdWNlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHQgKiBAbWV0aG9kIF9nZXRGb2N1c0FjdGlvblxuXHQgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIEtleWJvYXJkIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQW4gYWN0aW9uIG9iamVjdCB3aXRoIHR5cGUgYW5kIGRpcmVjdGlvbiBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0X2dldEZvY3VzQWN0aW9uKGV2ZW50KSB7XG5cdFx0Y29uc3QgYWN0aW9uID0ge1xuXHRcdFx0dHlwZTogQUNUSU9OX05PTkUsXG5cdFx0fTtcblxuXHRcdGlmICh0aGlzLnByb3BzLmtleXMpIHtcblx0XHRcdGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuX2dldEZvY3VzTW92ZURpcmVjdGlvbihldmVudCk7XG5cblx0XHRcdGlmIChkaXJlY3Rpb24pIHtcblx0XHRcdFx0YWN0aW9uLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcblx0XHRcdFx0YWN0aW9uLnR5cGUgPSBBQ1RJT05fTU9WRV9GT0NVUztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZGlzbWlzc0FjdGlvbiA9IHRoaXMuX2dldEZvY3VzRGlzbWlzc0FjdGlvbihldmVudCwgZGlyZWN0aW9uKTtcblxuXHRcdFx0aWYgKGRpc21pc3NBY3Rpb24uZGlzbWlzcykge1xuXHRcdFx0XHRhY3Rpb24uZGlyZWN0aW9uID0gZGlzbWlzc0FjdGlvbi5kaXJlY3Rpb247XG5cdFx0XHRcdGFjdGlvbi50eXBlID0gQUNUSU9OX0RJU01JU1NfRk9DVVM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjdGlvbjtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZGlzbWlzcyBhY3Rpb24sIGlmIGFueSwgdGhlIGZvY3VzIG1hbmFnZXIgc2hvdWxkIGV4ZWN1dGUgdG8geWllbGQgdGhlIGZvY3VzLiBUaGlzXG5cdCAqIHdpbGwgaGFwcGVuIGluIGFueSBvZiB0aGVzZSBzY2VuYXJpb3MgaWYgYSBkaXNtaXNzIGNhbGxiYWNrIGhhcyBiZWVuIHNwZWNpZmllZDpcblx0ICogLSBBIGRpc21pc3Mga2V5IGhhcyBiZWVuIHByZXNzZWRcblx0ICogLSBJbiBhIG5vbi1jaXJjdWxhciBmb2N1cyBtYW5hZ2VyLCB3aGVuOlxuXHQgKiAgICAgLSBUaGUgYWN0aXZlIGRlc2NlbmRhbnQgaXMgdGhlIGZpcnN0IG9uZSBhbmQgYSBwcmV2IGtleSBoYXMgYmVlbiBwcmVzc2VkLlxuXHQgKiAgICAgLSBUaGUgYWN0aXZlIGRlc2NlbmRhbnQgaXMgdGhlIGxhc3Qgb25lIGFuZCBhIG5leHQga2V5IGhhcyBiZWVuIHByZXNzZWQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdCAqIEBtZXRob2QgX2dldEZvY3VzRGlzbWlzc0FjdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gZm9jdXNNb3ZlRGlyZWN0aW9uIFRoZSBmb2N1cyBtb3ZlbWVudCBkaXJlY3Rpb24gKGlmIGFueSkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgS2V5Ym9hcmQgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7T2JqZWN0fSBBIGRpc21pc3MgYWN0aW9uIHdpdGggZGlzbWlzcyBhbmQgZGlyZWN0aW9uIHByb3BlcnRpZXMuXG5cdCAqL1xuXHRfZ2V0Rm9jdXNEaXNtaXNzQWN0aW9uKGV2ZW50LCBmb2N1c01vdmVEaXJlY3Rpb24pIHtcblx0XHRjb25zdCBkaXNtaXNzQWN0aW9uID0ge1xuXHRcdFx0ZGlyZWN0aW9uOiBmb2N1c01vdmVEaXJlY3Rpb24sXG5cdFx0XHRkaXNtaXNzOiBmYWxzZSxcblx0XHR9O1xuXG5cdFx0aWYgKHRoaXMucHJvcHMub25EaXNtaXNzKSB7XG5cdFx0XHRpZiAodGhpcy5faXNWYWxpZEtleShldmVudC5rZXlDb2RlLCB0aGlzLnByb3BzLmtleXMuZGlzbWlzcykpIHtcblx0XHRcdFx0ZGlzbWlzc0FjdGlvbi5kaXNtaXNzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9pc1ZhbGlkS2V5KGV2ZW50LmtleUNvZGUsIHRoaXMucHJvcHMua2V5cy5kaXNtaXNzTmV4dCkpIHtcblx0XHRcdFx0ZGlzbWlzc0FjdGlvbi5kaXNtaXNzID0gdHJ1ZTtcblx0XHRcdFx0ZGlzbWlzc0FjdGlvbi5kaXJlY3Rpb24gPSBESVJFQ1RJT05fTkVYVDtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9pc1ZhbGlkS2V5KGV2ZW50LmtleUNvZGUsIHRoaXMucHJvcHMua2V5cy5kaXNtaXNzUHJldikpIHtcblx0XHRcdFx0ZGlzbWlzc0FjdGlvbi5kaXNtaXNzID0gdHJ1ZTtcblx0XHRcdFx0ZGlzbWlzc0FjdGlvbi5kaXJlY3Rpb24gPSBESVJFQ1RJT05fUFJFVjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKFxuXHRcdFx0XHQhZGlzbWlzc0FjdGlvbi5kaXNtaXNzICYmXG5cdFx0XHRcdCF0aGlzLnByb3BzLmNpcmN1bGFyICYmXG5cdFx0XHRcdGZvY3VzTW92ZURpcmVjdGlvblxuXHRcdFx0KSB7XG5cdFx0XHRcdGRpc21pc3NBY3Rpb24uZGlzbWlzcyA9XG5cdFx0XHRcdFx0KGZvY3VzTW92ZURpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1BSRVYgJiZcblx0XHRcdFx0XHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgPT09IDApIHx8XG5cdFx0XHRcdFx0KGZvY3VzTW92ZURpcmVjdGlvbiA9PT0gRElSRUNUSU9OX05FWFQgJiZcblx0XHRcdFx0XHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgPT09XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2Rlc2NlbmRhbnRzLmxlbmd0aCAtIDEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBkaXNtaXNzQWN0aW9uO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkaXJlY3Rpb24sIGlmIGFueSwgaW4gd2hpY2ggdGhlIGZvY3VzIHNob3VsZCBiZSBtb3ZlZC4gSW4gcHJlc2VuY2Ugb2YgdGhlXG5cdCAqIHNoaWZ0IGtleSBtb2RpZmllciwgdGhlIGRpcmVjdGlvbiBvZiB0aGUgbW92ZW1lbnQgaXMgaW52ZXJ0ZWQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdCAqIEBtZXRob2QgX2dldEZvY3VzTW92ZURpcmVjdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIEtleWJvYXJkIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNvbXB1dGVkIGRpcmVjdGlvbiBvZiB0aGUgZXhwZWN0ZWQgZm9jdXMgbW92ZW1lbnQuXG5cdCAqL1xuXHRfZ2V0Rm9jdXNNb3ZlRGlyZWN0aW9uKGV2ZW50KSB7XG5cdFx0bGV0IGRpcmVjdGlvbiA9IERJUkVDVElPTl9OT05FO1xuXG5cdFx0aWYgKHRoaXMuX2lzVmFsaWRLZXkoZXZlbnQua2V5Q29kZSwgdGhpcy5wcm9wcy5rZXlzLm5leHQpKSB7XG5cdFx0XHRkaXJlY3Rpb24gPSBESVJFQ1RJT05fTkVYVDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX2lzVmFsaWRLZXkoZXZlbnQua2V5Q29kZSwgdGhpcy5wcm9wcy5rZXlzLnByZXYpKSB7XG5cdFx0XHRkaXJlY3Rpb24gPSBESVJFQ1RJT05fUFJFVjtcblx0XHR9XG5cblx0XHRpZiAoZXZlbnQuc2hpZktleSkge1xuXHRcdFx0ZGlyZWN0aW9uICo9IC0xO1xuXHRcdH1cblxuXHRcdHJldHVybiBkaXJlY3Rpb247XG5cdH0sXG5cblx0LyoqXG5cdCAqIEluZGljYXRlcyBpZiBhIGdpdmVuIGtleUNvZGUgaXMgdmFsaWQgZm9yIHRoZSBnaXZlbiBzZXQgb2Yga2V5cy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0ICogQG1ldGhvZCBfaXNWYWxpZEtleVxuXHQgKiBAcGFyYW0ge0FycmF5fE51bWJlcn0ga2V5cyBBIGtleSBzZXQuIENhbiBiZSBhIG51bWJlciBhbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgYWxsb3dlZCBrZXlDb2Rlcy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGtleUNvZGUgQW4gZXZlbnQga2V5Q29kZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyBpZiB0aGUga2V5IGlzIHZhbGlkLlxuXHQgKi9cblx0X2lzVmFsaWRLZXkoa2V5Q29kZSwga2V5cykge1xuXHRcdHJldHVybiBMYW5nLmlzQXJyYXkoa2V5cylcblx0XHRcdD8ga2V5cy5pbmRleE9mKGtleUNvZGUpICE9PSAtMVxuXHRcdFx0OiBrZXlDb2RlID09PSBrZXlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgaWYgYSBnaXZlbiBlbGVtZW50IGlzIHZhbGlkIGZvciBmb2N1cyBtYW5hZ2VtZW50LiBVc2VyIGlucHV0IGVsZW1lbnRzIHN1Y2ggYXNcblx0ICogaW5wdXQsIHNlbGVjdCBvciB0ZXh0YXJlYSBhcmUgZXhjbHVkZWQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdCAqIEBtZXRob2QgX2lzVmFsaWRLZXlcblx0ICogQHBhcmFtIHtET01Ob2RlfSBlbGVtZW50IEEgRE9NIGVsZW1lbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgaWYgdGhlIGVsZW1lbnQgaXMgdmFsaWQuXG5cdCAqL1xuXHRfaXNWYWxpZFRhcmdldChlbGVtZW50KSB7XG5cdFx0Y29uc3QgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdHRhZ05hbWUgIT09ICdpbnB1dCcgJiZcblx0XHRcdHRhZ05hbWUgIT09ICdzZWxlY3QnICYmXG5cdFx0XHR0YWdOYW1lICE9PSAndGV4dGFyZWEnXG5cdFx0KTtcblx0fSxcblxuXHQvKipcblx0ICogTW92ZXMgdGhlIGZvY3VzIGFtb25nIGRlc2NlbmRhbnRzIGluIHRoZSBlc3BlY2lmaWVkIGRpcmVjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0ICogQG1ldGhvZCBfbW92ZUZvY3VzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiAoMSBvciAtMSkgb2YgdGhlIGZvY3VzIG1vdmVtZW50IGFtb25nIGRlc2NlbmRhbnRzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfbW92ZUZvY3VzKGRpcmVjdGlvbikge1xuXHRcdGNvbnN0IG51bURlc2NlbmRhbnRzID0gdGhpcy5fZGVzY2VuZGFudHMubGVuZ3RoO1xuXG5cdFx0bGV0IGRlc2NlbmRhbnQgPSB0aGlzLl9kZXNjZW5kYW50c1t0aGlzLl9hY3RpdmVEZXNjZW5kYW50XTtcblxuXHRcdGRlc2NlbmRhbnQuc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIC0xKTtcblxuXHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgKz0gZGlyZWN0aW9uO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMuY2lyY3VsYXIpIHtcblx0XHRcdC8vIENhbGN1bGF0ZSBwcm9wZXIgbW9kdWxvIHJlc3VsdCBzaW5jZSByZW1haW5kZXIgb3BlcmF0b3IgZG9lc24ndCBiZWhhdmUgaW4gdGhlXG5cdFx0XHQvLyBzYW1lIHdheSBmb3IgbmVnYXRpdmUgbnVtYmVyc1xuXG5cdFx0XHR0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID1cblx0XHRcdFx0KCh0aGlzLl9hY3RpdmVEZXNjZW5kYW50ICUgbnVtRGVzY2VuZGFudHMpICsgbnVtRGVzY2VuZGFudHMpICVcblx0XHRcdFx0bnVtRGVzY2VuZGFudHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgPSBNYXRoLm1heChcblx0XHRcdFx0TWF0aC5taW4odGhpcy5fYWN0aXZlRGVzY2VuZGFudCwgbnVtRGVzY2VuZGFudHMgLSAxKSxcblx0XHRcdFx0MFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRkZXNjZW5kYW50ID0gdGhpcy5fZGVzY2VuZGFudHNbdGhpcy5fYWN0aXZlRGVzY2VuZGFudF07XG5cblx0XHRkZXNjZW5kYW50LnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAwKTtcblx0XHRkZXNjZW5kYW50LmZvY3VzKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZnJlc2hlcyB0aGUgZGVzY2VuZGFudHMgbGlzdCBieSBleGVjdXRpbmcgdGhlIENTUyBzZWxlY3RvciBhZ2FpbiBhbmQgcmVzZXRzIHRoZSBkZXNjZW5kYW50cyB0YWJJbmRleC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0ICogQG1ldGhvZCBfcmVmcmVzaFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfcmVmcmVzaCgpIHtcblx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cblx0XHRpZiAoZG9tTm9kZSkge1xuXHRcdFx0Y29uc3QgZGVzY2VuZGFudHMgPSBkb21Ob2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXG5cdFx0XHRcdHRoaXMucHJvcHMuZGVzY2VuZGFudHNcblx0XHRcdCk7XG5cblx0XHRcdGxldCBwcmlvcml0eURlc2NlbmRhbnRzID0gW107XG5cblx0XHRcdHRoaXMuX2Rlc2NlbmRhbnRzID0gW107XG5cblx0XHRcdEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRlc2NlbmRhbnRzKS5mb3JFYWNoKGl0ZW0gPT4ge1xuXHRcdFx0XHRjb25zdCBkYXRhVGFiSW5kZXggPSBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS10YWJpbmRleCcpO1xuXG5cdFx0XHRcdGlmIChkYXRhVGFiSW5kZXgpIHtcblx0XHRcdFx0XHRwcmlvcml0eURlc2NlbmRhbnRzLnB1c2goaXRlbSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fZGVzY2VuZGFudHMucHVzaChpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHByaW9yaXR5RGVzY2VuZGFudHMgPSBwcmlvcml0eURlc2NlbmRhbnRzLnNvcnQoKGEsIGIpID0+IHtcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRMYW5nLnRvSW50KGEuZ2V0QXR0cmlidXRlKCdkYXRhLXRhYmluZGV4JykpID5cblx0XHRcdFx0XHRMYW5nLnRvSW50KGIuZ2V0QXR0cmlidXRlKCdkYXRhLXRhYmluZGV4JykpXG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fZGVzY2VuZGFudHMgPSBwcmlvcml0eURlc2NlbmRhbnRzLmNvbmNhdCh0aGlzLl9kZXNjZW5kYW50cyk7XG5cblx0XHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgPSAwO1xuXG5cdFx0XHR0aGlzLl9kZXNjZW5kYW50cy5zb21lKChpdGVtLCBpbmRleCkgPT4ge1xuXHRcdFx0XHRpZiAoaXRlbS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgPT09ICcwJykge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZURlc2NlbmRhbnQgPSBpbmRleDtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0Rm9jdXNNYW5hZ2VyO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNhbGN1bGF0aW5nIHRoZSBwb2ludCBvZiBpbnRlcmFjdGlvbiBvZiB0aGUgdXNlciB3aXRoIHRoZSBFZGl0b3IuXG4gKlxuICogQGNsYXNzIFdpZGdldEludGVyYWN0aW9uUG9pbnRcbiAqL1xuY29uc3QgV2lkZ2V0SW50ZXJhY3Rpb25Qb2ludCA9IHtcblx0Ly8gQWxsb3dzIHZhbGlkYXRpbmcgcHJvcHMgYmVpbmcgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQuXG5cblx0cHJvcFR5cGVzOiB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIHByb3ZpZGVkIGVkaXRvciBldmVudC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRJbnRlcmFjdGlvblBvaW50XG5cdFx0ICogQHByb3BlcnR5IHtTeW50aGV0aWNFdmVudH0gZWRpdG9yRXZlbnRcblx0XHQgKi9cblx0XHRlZGl0b3JFdmVudDogUHJvcFR5cGVzLm9iamVjdCxcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24sIGluIHBhZ2UgY29vcmRpbmF0ZXMsIGFjY29yZGluZyB0byB3aGljaCBhIHdpZGdldCBzaG91bGQgYXBwZWFyLlxuXHQgKiBEZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2VsZWN0aW9uLCB0aGUgd2RpZ2V0IG1heSBhcHBlYXIgYWJvdmUgb2Ygb3Igb24gYm90dG9tIG9mIHRoZSBzZWxlY3Rpb24uXG5cdCAqXG5cdCAqIEl0IGRlcGVuZHMgb24gdGhlIHByb3BzIGVkaXRvckV2ZW50IHRvIGFuYWx5emUgdGhlIGZvbGxvd2luZyB1c2VyLWludGVyYWN0aW9uIHBhcmFtZXRlcnM6XG5cdCAqIC0ge09iamVjdH0gc2VsZWN0aW9uRGF0YSBUaGUgZGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgYXMgcmV0dXJuZWQgZnJvbVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRTZWxlY3Rpb25EYXRhOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiAtIHtOdW1iZXJ9IHBvcyBDb250YWlucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvc2l0aW9uLCBjb25zaWRlcmVkIGFzIG1vc3QgYXBwcm9wcmlhdGUuXG5cdCAqIFRoaXMgbWF5IGJlIHRoZSBwb2ludCB3aGVyZSB0aGUgdXNlciByZWxlYXNlZCB0aGUgbW91c2UsIG9yIGp1c3QgdGhlIGJlZ2lubmluZyBvciB0aGUgZW5kIG9mXG5cdCAqIHRoZSBzZWxlY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0SW50ZXJhY3Rpb25Qb2ludFxuXHQgKiBAbWV0aG9kIGdldEludGVyYWN0aW9uUG9pbnRcblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBPYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXHQgKiBkaXJlY3Rpb24sIHgsIHksIHdoZXJlIHggYW5kIHkgYXJlIGluIHBhZ2UgY29vcmRpbmF0ZXMgYW5kIGRpcmVjdGlvbiBjYW4gYmUgb25lIG9mIHRoZXNlOlxuXHQgKiBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCBvciBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTVxuXHQgKi9cblx0Z2V0SW50ZXJhY3Rpb25Qb2ludCgpIHtcblx0XHRjb25zdCBldmVudFBheWxvYWQgPSB0aGlzLnByb3BzLmVkaXRvckV2ZW50XG5cdFx0XHQ/IHRoaXMucHJvcHMuZWRpdG9yRXZlbnQuZGF0YVxuXHRcdFx0OiBudWxsO1xuXG5cdFx0aWYgKCFldmVudFBheWxvYWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBzZWxlY3Rpb25EYXRhID0gZXZlbnRQYXlsb2FkLnNlbGVjdGlvbkRhdGE7XG5cblx0XHRjb25zdCBuYXRpdmVFdmVudCA9IGV2ZW50UGF5bG9hZC5uYXRpdmVFdmVudDtcblxuXHRcdGNvbnN0IHBvcyA9IHtcblx0XHRcdHg6IGV2ZW50UGF5bG9hZC5uYXRpdmVFdmVudC5wYWdlWCxcblx0XHRcdHk6IHNlbGVjdGlvbkRhdGEucmVnaW9uLnRvcCxcblx0XHR9O1xuXG5cdFx0bGV0IGRpcmVjdGlvbiA9IHNlbGVjdGlvbkRhdGEucmVnaW9uLmRpcmVjdGlvbjtcblxuXHRcdGNvbnN0IGVuZFJlY3QgPSBzZWxlY3Rpb25EYXRhLnJlZ2lvbi5lbmRSZWN0O1xuXG5cdFx0Y29uc3Qgc3RhcnRSZWN0ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uc3RhcnRSZWN0O1xuXG5cdFx0aWYgKGVuZFJlY3QgJiYgc3RhcnRSZWN0ICYmIHN0YXJ0UmVjdC50b3AgPT09IGVuZFJlY3QudG9wKSB7XG5cdFx0XHRkaXJlY3Rpb24gPSBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUDtcblx0XHR9XG5cblx0XHRsZXQgeDtcblx0XHRsZXQgeTtcblxuXHRcdC8vIElmIHdlIGhhdmUgdGhlIHBvaW50IHdoZXJlIHVzZXIgcmVsZWFzZWQgdGhlIG1vdXNlLCBzaG93IFRvb2xiYXIgYXQgdGhpcyBwb2ludFxuXHRcdC8vIG90aGVyd2lzZSBzaG93IGl0IG9uIHRoZSBtaWRkbGUgb2YgdGhlIHNlbGVjdGlvbi5cblxuXHRcdGlmIChwb3MueCAmJiBwb3MueSkge1xuXHRcdFx0eCA9IHRoaXMuX2dldFhQb2ludChzZWxlY3Rpb25EYXRhLCBwb3MueCk7XG5cblx0XHRcdGlmIChkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QKSB7XG5cdFx0XHRcdHkgPSBNYXRoLm1pbihwb3MueSwgc2VsZWN0aW9uRGF0YS5yZWdpb24udG9wKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHkgPSBNYXRoLm1heChcblx0XHRcdFx0XHRwb3MueSxcblx0XHRcdFx0XHR0aGlzLl9nZXRZUG9pbnQoc2VsZWN0aW9uRGF0YSwgbmF0aXZlRXZlbnQpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHggPSBzZWxlY3Rpb25EYXRhLnJlZ2lvbi5sZWZ0ICsgc2VsZWN0aW9uRGF0YS5yZWdpb24ud2lkdGggLyAyO1xuXG5cdFx0XHRpZiAoZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTSkge1xuXHRcdFx0XHR5ID0gdGhpcy5fZ2V0WVBvaW50KHNlbGVjdGlvbkRhdGEsIG5hdGl2ZUV2ZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHkgPSBzZWxlY3Rpb25EYXRhLnJlZ2lvbi50b3A7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGRpcmVjdGlvbixcblx0XHRcdHgsXG5cdFx0XHR5LFxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBXaWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0SW50ZXJhY3Rpb25Qb2ludFxuXHQgKiBAbWV0aG9kIF9nZXRYUG9pbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50WCBUaGUgWCBjb29yZGluYXRlIHJlY2VpdmVkIGZyb20gdGhlIG5hdGl2ZSBldmVudCAobW91c2V1cCkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzZWxlY3Rpb25EYXRhIFRoZSBkYXRhIGFib3V0IHRoZSBzZWxlY3Rpb24gaW4gdGhlIGVkaXRvciBhcyByZXR1cm5lZCBmcm9tIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfc2VsZWN0aW9ucmVnaW9uL2dldFNlbGVjdGlvbkRhdGE6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgY2FsY3VsYXRlZCBYIHBvaW50IGluIHBhZ2UgY29vcmRpbmF0ZXMuXG5cdCAqL1xuXHRfZ2V0WFBvaW50KHNlbGVjdGlvbkRhdGEsIGV2ZW50WCkge1xuXHRcdGNvbnN0IHJlZ2lvbiA9IHNlbGVjdGlvbkRhdGEucmVnaW9uO1xuXG5cdFx0Y29uc3QgbGVmdCA9IHJlZ2lvbi5zdGFydFJlY3QgPyByZWdpb24uc3RhcnRSZWN0LmxlZnQgOiByZWdpb24ubGVmdDtcblx0XHRjb25zdCByaWdodCA9IHJlZ2lvbi5lbmRSZWN0ID8gcmVnaW9uLmVuZFJlY3QucmlnaHQgOiByZWdpb24ucmlnaHQ7XG5cblx0XHRsZXQgeDtcblxuXHRcdGlmIChsZWZ0IDwgZXZlbnRYICYmIHJpZ2h0ID4gZXZlbnRYKSB7XG5cdFx0XHR4ID0gZXZlbnRYO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBsZWZ0RGlzdCA9IE1hdGguYWJzKGxlZnQgLSBldmVudFgpO1xuXHRcdFx0Y29uc3QgcmlnaHREaXN0ID0gTWF0aC5hYnMocmlnaHQgLSBldmVudFgpO1xuXG5cdFx0XHRpZiAobGVmdERpc3QgPCByaWdodERpc3QpIHtcblx0XHRcdFx0Ly8gdXNlciByYWlzZWQgdGhlIG1vdXNlIG9uIGxlZnQgb24gdGhlIHNlbGVjdGlvblxuXG5cdFx0XHRcdHggPSBsZWZ0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eCA9IHJpZ2h0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB4O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgV2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldEludGVyYWN0aW9uUG9pbnRcblx0ICogQG1ldGhvZCBfZ2V0WVBvaW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBuYXRpdmVFdmVudCBUaGUgZGF0YSBhYm91dCBldmVudCBpcyBmaXJlZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0aW9uRGF0YSBUaGUgZGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgYXMgcmV0dXJuZWQgZnJvbSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRTZWxlY3Rpb25EYXRhOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNhbGN1bGF0ZWQgWSBwb2ludCBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuXHQgKi9cblx0X2dldFlQb2ludChzZWxlY3Rpb25EYXRhLCBuYXRpdmVFdmVudCkge1xuXHRcdGxldCB5ID0gMDtcblxuXHRcdGlmIChzZWxlY3Rpb25EYXRhICYmIG5hdGl2ZUV2ZW50KSB7XG5cdFx0XHRjb25zdCBlbGVtZW50VGFyZ2V0ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KG5hdGl2ZUV2ZW50LnRhcmdldCk7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0ZWxlbWVudFRhcmdldC4kICYmXG5cdFx0XHRcdGVsZW1lbnRUYXJnZXQuZ2V0U3R5bGUoJ292ZXJmbG93JykgPT09ICdhdXRvJ1xuXHRcdFx0KSB7XG5cdFx0XHRcdHkgPVxuXHRcdFx0XHRcdG5hdGl2ZUV2ZW50LnRhcmdldC5vZmZzZXRUb3AgK1xuXHRcdFx0XHRcdG5hdGl2ZUV2ZW50LnRhcmdldC5vZmZzZXRIZWlnaHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR5ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uYm90dG9tO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB5O1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0SW50ZXJhY3Rpb25Qb2ludDtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5pbXBvcnQgV2lkZ2V0SW50ZXJhY3Rpb25Qb2ludCBmcm9tICcuL3dpZGdldC1pbnRlcmFjdGlvbi1wb2ludCc7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgcG9zaXRpb24gd2hlcmUgYW4gV2lkZ2V0IHNob3VsZCBiZSBkaXNwbGF5ZWQgYmFzZWQgb25cbiAqIHRoZSBwb2ludCB3aGVyZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGUgZWRpdG9yLlxuICpcbiAqIEBjbGFzcyBXaWRnZXRQb3NpdGlvblxuICogQHVzZXMgV2lkZ2V0SW50ZXJhY3Rpb25Qb2ludFxuICovXG5jb25zdCBXaWRnZXRQb3NpdGlvbiA9IHtcblx0bWl4aW5zOiBbV2lkZ2V0SW50ZXJhY3Rpb25Qb2ludF0sXG5cblx0Ly8gQWxsb3dzIHZhbGlkYXRpbmcgcHJvcHMgYmVpbmcgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQuXG5cblx0cHJvcFR5cGVzOiB7XG5cdFx0LyoqXG5cdFx0ICogU2hvdWxkIHRoZSB3aWRnZXQgdG8gYmUgcmVzdHJpY3RlZCB0byB0aGUgdmlld3BvcnQsIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY29uc3RyYWluVG9WaWV3cG9ydFxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHRjb25zdHJhaW5Ub1ZpZXdwb3J0OiBQcm9wVHlwZXMuYm9vbCxcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBndXR0ZXIgKHZlcnRpY2FsIGFuZCBob3Jpem9udGFsKSBiZXR3ZWVuIHRoZSBpbnRlcmFjdGlvblxuXHRcdCAqIHBvaW50IGFuZCB3aGVyZSB0aGUgd2lkZ2V0IHNob3VsZCBiZSByZW5kZXJlZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHRcdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBndXR0ZXJcblx0XHQgKiBAZGVmYXVsdCB7XG5cdFx0ICogICAgIGxlZnQ6IDAsXG5cdFx0ICogICAgIHRvcDogMTBcblx0XHQgKiB9XG5cdFx0ICovXG5cdFx0Z3V0dGVyOiBQcm9wVHlwZXMub2JqZWN0LFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW5cblx0ICogdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKi9cblx0Z2V0RGVmYXVsdFByb3BzKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRndXR0ZXI6IHtcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0dG9wOiAxMCxcblx0XHRcdH0sXG5cdFx0XHRjb25zdHJhaW5Ub1ZpZXdwb3J0OiB0cnVlLFxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhbmNlbHMgYW4gc2NoZWR1bGVkIGFuaW1hdGlvbiBmcmFtZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHQgKiBAbWV0aG9kIGNhbmNlbEFuaW1hdGlvblxuXHQgKi9cblx0Y2FuY2VsQW5pbWF0aW9uKCkge1xuXHRcdGlmICh3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcblx0XHRcdHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRpb25GcmFtZUlkKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCBpblxuXHQgKiBwYWdlIGNvb3JkaW5hdGVzLCByZXN0cmljdGVkIHRvIGZpdCB0byBnaXZlbiB2aWV3cG9ydC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHQgKiBAbWV0aG9kIGdldENvbnN0cmFpbmVkUG9zaXRpb25cblx0ICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcywgcHJvdmlkZWQgYXMgbnVtYmVyczpcblx0ICogLSBoZWlnaHRcblx0ICogLSBsZWZ0XG5cdCAqIC0gdG9wXG5cdCAqIC0gd2lkdGhcblx0ICogQHBhcmFtIHtPYmplY3R9IHZpZXdQYW5lU2l6ZSBPcHRpb25hbC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgY3VycmVudCB2aWV3cG9ydCB3aWxsIGJlIHVzZWQuIFNob3VsZCBjb250YWluIGF0IGxlYXN0IHRoZXNlIHByb3BlcnRpZXM6XG5cdCAqIC0gd2lkdGhcblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzLCB3aGljaCByZXByZXNlbnQgdGhlIGNvbnN0cmFpbmVkIHBvc2l0aW9uIG9mIHRoZVxuXHQgKiBlbGVtZW50LlxuXHQgKi9cblx0Z2V0Q29uc3RyYWluZWRQb3NpdGlvbihhdHRycywgdmlld1BhbmVTaXplKSB7XG5cdFx0dmlld1BhbmVTaXplID1cblx0XHRcdHZpZXdQYW5lU2l6ZSB8fCBuZXcgQ0tFRElUT1IuZG9tLndpbmRvdyh3aW5kb3cpLmdldFZpZXdQYW5lU2l6ZSgpO1xuXG5cdFx0bGV0IHggPSBhdHRycy5sZWZ0O1xuXHRcdGxldCB5ID0gYXR0cnMudG9wO1xuXG5cdFx0aWYgKGF0dHJzLmxlZnQgKyBhdHRycy53aWR0aCA+IHZpZXdQYW5lU2l6ZS53aWR0aCkge1xuXHRcdFx0eCAtPSBhdHRycy5sZWZ0ICsgYXR0cnMud2lkdGggLSB2aWV3UGFuZVNpemUud2lkdGg7XG5cdFx0fVxuXG5cdFx0aWYgKHkgPCAwKSB7XG5cdFx0XHR5ID0gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eCxcblx0XHRcdHksXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIFdpZGdldCB0YWtpbmcgaW4gY29uc2lkZXJhdGlvbiB0aGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiV2lkZ2V0UG9zaXRpb24vZ3V0dGVyOmF0dHJpYnV0ZVwifX17ey9jcm9zc0xpbmt9fSBhdHRyaWJ1dGUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0UG9zaXRpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kICBnZXRXaWRnZXRYWVBvaW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IFRoZSBsZWZ0IG9mZnNldCBpbiBwYWdlIGNvb3JkaW5hdGVzIHdoZXJlIFRvb2xiYXIgc2hvdWxkIGJlIHNob3duLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdG9wIFRoZSB0b3Agb2Zmc2V0IGluIHBhZ2UgY29vcmRpbmF0ZXMgd2hlcmUgVG9vbGJhciBzaG91bGQgYmUgc2hvd24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiBvZiB0aGUgc2VsZWN0aW9uLiBNYXkgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG5cdCAqIENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QIG9yIENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NXG5cdCAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSB3aXRoIGxlZnQgYW5kIHRvcCBvZmZzZXRzIGluIHBhZ2UgY29vcmRpbmF0ZXMuXG5cdCAqL1xuXHRnZXRXaWRnZXRYWVBvaW50KGxlZnQsIHRvcCwgZGlyZWN0aW9uKSB7XG5cdFx0Y29uc3QgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG5cdFx0Y29uc3QgZ3V0dGVyID0gdGhpcy5wcm9wcy5ndXR0ZXI7XG5cdFx0Y29uc3Qgb2Zmc2V0V2lkdGggPSBkb21Ob2RlLm9mZnNldFdpZHRoO1xuXHRcdGNvbnN0IGhhbGZXaWR0aCA9IG9mZnNldFdpZHRoIC8gMjtcblxuXHRcdGlmIChcblx0XHRcdGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT00gfHxcblx0XHRcdGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1Bcblx0XHQpIHtcblx0XHRcdGxlZnQgPSBsZWZ0IC0gZ3V0dGVyLmxlZnQgLSBoYWxmV2lkdGg7XG5cblx0XHRcdHRvcCA9XG5cdFx0XHRcdGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT01cblx0XHRcdFx0XHQ/IHRvcCArIGd1dHRlci50b3Bcblx0XHRcdFx0XHQ6IHRvcCAtIGRvbU5vZGUub2Zmc2V0SGVpZ2h0IC0gZ3V0dGVyLnRvcDtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0ZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fTEVGVF9UT19SSUdIVCB8fFxuXHRcdFx0ZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fUklHSFRfVE9fTEVGVFxuXHRcdCkge1xuXHRcdFx0bGVmdCA9XG5cdFx0XHRcdGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX0xFRlRfVE9fUklHSFRcblx0XHRcdFx0XHQ/IGxlZnQgKyBndXR0ZXIubGVmdCArIGRvbU5vZGUub2Zmc2V0SGVpZ2h0IC8gMlxuXHRcdFx0XHRcdDogbGVmdCAtICgzICogZG9tTm9kZS5vZmZzZXRIZWlnaHQpIC8gMiAtIGd1dHRlci5sZWZ0O1xuXG5cdFx0XHR0b3AgPSB0b3AgLSBndXR0ZXIudG9wIC0gZG9tTm9kZS5vZmZzZXRIZWlnaHQgLyAyO1xuXHRcdH1cblxuXHRcdGlmIChsZWZ0IDwgMCkge1xuXHRcdFx0bGVmdCA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKGxlZnQgPiBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoIC0gaGFsZldpZHRoKSB7XG5cdFx0XHRsZWZ0ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCAtIGhhbGZXaWR0aDtcblx0XHR9XG5cblx0XHRpZiAodG9wIDwgMCkge1xuXHRcdFx0dG9wID0gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gW2xlZnQsIHRvcF07XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgd2lkZ2V0IGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZVxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHdpZGdldCBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdGlzVmlzaWJsZSgpIHtcblx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cblx0XHRpZiAoZG9tTm9kZSkge1xuXHRcdFx0Y29uc3QgZG9tRWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChkb21Ob2RlKTtcblxuXHRcdFx0cmV0dXJuIGRvbUVsZW1lbnQuaGFzQ2xhc3MoJ2FsbG95LWVkaXRvci12aXNpYmxlJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBNb3ZlcyBhIHdpZGdldCBmcm9tIGEgc3RhcnRpbmcgcG9pbnQgdG8gYSBkZXN0aW5hdGlvbiBwb2ludC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHQgKiBAbWV0aG9kIG1vdmVUb1BvaW50XG5cdCAqIEBwYXJhbSAge09iamVjdH0gc3RhcnRQb2ludCBUaGUgc3RhcnRpbmcgcG9pbnQgZm9yIHRoZSBtb3ZlbWVudC5cblx0ICogQHBhcmFtICB7T2JqZWN0fSBlbmRQb2ludCBUaGUgZGVzdGluYXRpb24gcG9pbnQgZm9yIHRoZSBtb3ZlbWVudC5cblx0ICovXG5cdG1vdmVUb1BvaW50KHN0YXJ0UG9pbnQsIGVuZFBvaW50KSB7XG5cdFx0Y29uc3QgZG9tRWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSk7XG5cblx0XHRkb21FbGVtZW50LnNldFN0eWxlcyh7XG5cdFx0XHRsZWZ0OiBzdGFydFBvaW50WzBdICsgJ3B4Jyxcblx0XHRcdHRvcDogc3RhcnRQb2ludFsxXSArICdweCcsXG5cdFx0XHRvcGFjaXR5OiAwLFxuXHRcdFx0cG9pbnRlckV2ZW50czogJ25vbmUnLFxuXHRcdH0pO1xuXG5cdFx0ZG9tRWxlbWVudC5yZW1vdmVDbGFzcygnYWxsb3ktZWRpdG9yLWludmlzaWJsZScpO1xuXG5cdFx0dGhpcy5fYW5pbWF0ZSgoKSA9PiB7XG5cdFx0XHRkb21FbGVtZW50LmFkZENsYXNzKCdhZS10b29sYmFyLXRyYW5zaXRpb24nKTtcblx0XHRcdGRvbUVsZW1lbnQuYWRkQ2xhc3MoJ2FsbG95LWVkaXRvci12aXNpYmxlJyk7XG5cdFx0XHRkb21FbGVtZW50LnNldFN0eWxlcyh7XG5cdFx0XHRcdGxlZnQ6IGVuZFBvaW50WzBdICsgJ3B4Jyxcblx0XHRcdFx0dG9wOiBlbmRQb2ludFsxXSArICdweCcsXG5cdFx0XHRcdG9wYWNpdHk6IDEsXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gMTUwbXMgdG8gbWF0Y2ggdHJhbnNpdGlvbi1kdXJhdGlvbiBmb3IgLmFlLXRvb2xiYXItdHJhbnNpdGlvbjpcblxuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdGRvbUVsZW1lbnQuc2V0U3R5bGVzKHtcblx0XHRcdFx0XHRwb2ludGVyRXZlbnRzOiAnJyxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LCAxNTApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTaG93cyB0aGUgd2lkZ2V0IHdpdGggdGhlIGRlZmF1bHQgYW5pbWF0aW9uIHRyYW5zaXRpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0UG9zaXRpb25cblx0ICogQG1ldGhvZCBzaG93XG5cdCAqL1xuXHRzaG93KCkge1xuXHRcdGNvbnN0IGRvbU5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcblx0XHRjb25zdCB1aU5vZGUgPSB0aGlzLnByb3BzLmVkaXRvci5nZXQoJ3VpTm9kZScpO1xuXG5cdFx0Y29uc3Qgc2Nyb2xsVG9wID0gdWlOb2RlID8gdWlOb2RlLnNjcm9sbFRvcCA6IDA7XG5cblx0XHRpZiAoIXRoaXMuaXNWaXNpYmxlKCkgJiYgZG9tTm9kZSkge1xuXHRcdFx0Y29uc3QgaW50ZXJhY3Rpb25Qb2ludCA9IHRoaXMuZ2V0SW50ZXJhY3Rpb25Qb2ludCgpO1xuXG5cdFx0XHRpZiAoaW50ZXJhY3Rpb25Qb2ludCkge1xuXHRcdFx0XHRjb25zdCBkb21FbGVtZW50ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGRvbU5vZGUpO1xuXG5cdFx0XHRcdGxldCBmaW5hbFgsIGZpbmFsWSwgaW5pdGlhbFgsIGluaXRpYWxZO1xuXG5cdFx0XHRcdGZpbmFsWCA9IGluaXRpYWxYID0gcGFyc2VGbG9hdChkb21FbGVtZW50LmdldFN0eWxlKCdsZWZ0JykpO1xuXHRcdFx0XHRmaW5hbFkgPSBpbml0aWFsWSA9IHBhcnNlRmxvYXQoZG9tRWxlbWVudC5nZXRTdHlsZSgndG9wJykpO1xuXG5cdFx0XHRcdGlmICh0aGlzLnByb3BzLmNvbnN0cmFpblRvVmlld3BvcnQpIHtcblx0XHRcdFx0XHRjb25zdCByZXMgPSB0aGlzLmdldENvbnN0cmFpbmVkUG9zaXRpb24oe1xuXHRcdFx0XHRcdFx0aGVpZ2h0OiBwYXJzZUZsb2F0KGRvbU5vZGUub2Zmc2V0SGVpZ2h0KSxcblx0XHRcdFx0XHRcdGxlZnQ6IGZpbmFsWCxcblx0XHRcdFx0XHRcdHRvcDogZmluYWxZLFxuXHRcdFx0XHRcdFx0d2lkdGg6IHBhcnNlRmxvYXQoZG9tTm9kZS5vZmZzZXRXaWR0aCksXG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRmaW5hbFggPSByZXMueDtcblx0XHRcdFx0XHRmaW5hbFkgPSByZXMueTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRpbnRlcmFjdGlvblBvaW50LmRpcmVjdGlvbiA9PT1cblx0XHRcdFx0XHRDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRpbml0aWFsWSA9XG5cdFx0XHRcdFx0XHR0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGEucmVnaW9uLmJvdHRvbSArIHNjcm9sbFRvcDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpbml0aWFsWSA9IHRoaXMucHJvcHMuc2VsZWN0aW9uRGF0YS5yZWdpb24udG9wICsgc2Nyb2xsVG9wO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5tb3ZlVG9Qb2ludChbaW5pdGlhbFgsIGluaXRpYWxZXSwgW2ZpbmFsWCwgZmluYWxZXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSB3aWRnZXQgcG9zaXRpb24gYmFzZWQgb24gdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb24gcG9pbnQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0UG9zaXRpb25cblx0ICogQG1ldGhvZCB1cGRhdGVQb3NpdGlvblxuXHQgKi9cblx0dXBkYXRlUG9zaXRpb24oKSB7XG5cdFx0Y29uc3QgaW50ZXJhY3Rpb25Qb2ludCA9IHRoaXMuZ2V0SW50ZXJhY3Rpb25Qb2ludCgpO1xuXG5cdFx0Y29uc3QgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG5cdFx0aWYgKGludGVyYWN0aW9uUG9pbnQgJiYgZG9tTm9kZSkge1xuXHRcdFx0Y29uc3QgdWlOb2RlID0gdGhpcy5wcm9wcy5lZGl0b3IuZ2V0KCd1aU5vZGUnKSB8fCBkb2N1bWVudC5ib2R5O1xuXHRcdFx0Y29uc3QgdWlOb2RlU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHVpTm9kZSk7XG5cdFx0XHRjb25zdCB1aU5vZGVNYXJnaW5MZWZ0ID0gcGFyc2VJbnQoXG5cdFx0XHRcdHVpTm9kZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ21hcmdpbi1sZWZ0JyksXG5cdFx0XHRcdDEwXG5cdFx0XHQpO1xuXHRcdFx0Y29uc3QgdWlOb2RlTWFyZ2luUmlnaHQgPSBwYXJzZUludChcblx0XHRcdFx0dWlOb2RlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXJpZ2h0JyksXG5cdFx0XHRcdDEwXG5cdFx0XHQpO1xuXHRcdFx0Y29uc3QgdG90YWxXaWR0aCA9XG5cdFx0XHRcdHVpTm9kZU1hcmdpbkxlZnQgKyB1aU5vZGUuY2xpZW50V2lkdGggKyB1aU5vZGVNYXJnaW5SaWdodDtcblxuXHRcdFx0Y29uc3Qgc2Nyb2xsVG9wID0gdWlOb2RlLnRhZ05hbWUgIT09ICdCT0RZJyA/IHVpTm9kZS5zY3JvbGxUb3AgOiAwO1xuXG5cdFx0XHRjb25zdCB4eSA9IHRoaXMuZ2V0V2lkZ2V0WFlQb2ludChcblx0XHRcdFx0aW50ZXJhY3Rpb25Qb2ludC54LFxuXHRcdFx0XHRpbnRlcmFjdGlvblBvaW50LnksXG5cdFx0XHRcdGludGVyYWN0aW9uUG9pbnQuZGlyZWN0aW9uXG5cdFx0XHQpO1xuXHRcdFx0eHlbMV0gKz0gc2Nyb2xsVG9wO1xuXG5cdFx0XHRpZiAoeHlbMF0gPCAwKSB7XG5cdFx0XHRcdHh5WzBdID0gMDtcblx0XHRcdH1cblx0XHRcdGlmICh4eVswXSA+IHRvdGFsV2lkdGggLSBkb21Ob2RlLm9mZnNldFdpZHRoKSB7XG5cdFx0XHRcdHh5WzBdID0gdG90YWxXaWR0aCAtIGRvbU5vZGUub2Zmc2V0V2lkdGg7XG5cdFx0XHR9XG5cblx0XHRcdG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChkb21Ob2RlKS5zZXRTdHlsZXMoe1xuXHRcdFx0XHRsZWZ0OiB4eVswXSArICdweCcsXG5cdFx0XHRcdHRvcDogeHlbMV0gKyAncHgnLFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0cyBhbiBhbmltYXRpb24gZnJhbWUsIGlmIHBvc3NpYmxlLCB0byBzaW11bGF0ZSBhbiBhbmltYXRpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgV2lkZ2V0UG9zaXRpb25cblx0ICogQG1ldGhvZCBfYW5pbWF0ZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHNjaGVkdWxlZCBmcmFtZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2FuaW1hdGUoY2FsbGJhY2spIHtcblx0XHRpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHRcdFx0dGhpcy5fYW5pbWF0aW9uRnJhbWVJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdH1cblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFdpZGdldFBvc2l0aW9uO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBXaWRnZXRFeGNsdXNpdmUgZnJvbSAnLi9iYXNlL3dpZGdldC1leGNsdXNpdmUnO1xuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXInO1xuXG4vKipcbiAqIFRoZSBtYWluIGVkaXRvciBVSSBjbGFzcyBtYW5hZ2VzIGEgaGllcmFyY2h5IG9mIHdpZGdldHMgKHRvb2xiYXJzIGFuZCBidXR0b25zKS5cbiAqXG4gKiBAY2xhc3MgVUlcbiAqIEB1c2VzIFdpZGdldEV4Y2x1c2l2ZVxuICogQHVzZXMgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gKi9cbmNsYXNzIFVJIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVUlcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjaXJjdWxhcjogdHJ1ZSxcblx0XHRkZXNjZW5kYW50czogJ1tjbGFzc149YWUtdG9vbGJhci1dJyxcblx0XHRldmVudHNEZWxheTogMCxcblx0XHRrZXlzOiB7XG5cdFx0XHRuZXh0OiA5LFxuXHRcdH0sXG5cdH07XG5cblx0c3RhdGljIHByb3BUeXBlcyA9IHtcblx0XHQvKipcblx0XHQgKiBMb2NhbGl6ZWQgbWVzc2FnZXMgZm9yIGxpdmUgYXJpYSB1cGRhdGVzLiBTaG91bGQgaW5jbHVkZSB0aGUgZm9sbG93aW5nIG1lc3NhZ2VzOlxuXHRcdCAqIC0gbm9Ub29sYmFyOiBOb3RpZmljYXRpb24gZm9yIG5vIGF2YWlsYWJsZSB0b29sYmFyIGluIHRoZSBlZGl0b3IuXG5cdFx0ICogLSBvbmVUb29sYmFyOiBOb3RpZmljYXRpb24gZm9yIGp1c3Qgb25lIGF2YWlsYWJsZSB0b29sYmFyIGluIHRoZSBlZGl0b3IuXG5cdFx0ICogLSBtYW55VG9vbGJhcnM6IE5vdGlmaWNhdGlvbiBmb3IgbW9yZSB0aGFuIG9uZSBhdmFpbGFibGUgdG9vbGJhciBpbiB0aGUgZWRpdG9yLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFVJXG5cdFx0ICogQHByb3BlcnR5IHtPYmplY3R9IGFyaWFVcGRhdGVzXG5cdFx0ICovXG5cdFx0YXJpYVVwZGF0ZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cblx0XHQvKipcblx0XHQgKiBUaGUgZGVsYXkgKG1zKSwgYWZ0ZXIgd2hpY2gga2V5IG9yIG1vdXNlIGV2ZW50cyB3aWxsIGJlIHByb2Nlc3NlZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBVSVxuXHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBldmVudHNEZWxheVxuXHRcdCAqL1xuXHRcdGV2ZW50c0RlbGF5OiBQcm9wVHlwZXMubnVtYmVyLFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRvb2xiYXJzIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgVUlcblx0XHQgKiBAcHJvcGVydHkge09iamVjdH0gdG9vbGJhcnNcblx0XHQgKi9cblx0XHR0b29sYmFyczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXHR9O1xuXG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXG5cdFx0dGhpcy5zdGF0ZSA9IHtcblx0XHRcdGhpZGRlbjogZmFsc2UsXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50LCBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFVJXG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcblx0ICovXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGVkaXRvci5vbignZWRpdG9ySW50ZXJhY3Rpb24nLCB0aGlzLl9vbkVkaXRvckludGVyYWN0aW9uLCB0aGlzKTtcblx0XHRlZGl0b3Iub24oJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMuX29uQWN0aW9uUGVyZm9ybWVkLCB0aGlzKTtcblx0XHRlZGl0b3Iub24oJ2tleScsIHRoaXMuX29uRWRpdG9yS2V5LCB0aGlzKTtcblxuXHRcdC8vIFNldCB1cCBldmVudHMgZm9yIGhpZGluZyB0aGUgVUkgd2hlbiB1c2VyIHN0b3BzIGludGVyYWN0aW5nIHdpdGggdGhlIGVkaXRvci5cblx0XHQvLyBUaGlzIG1heSBoYXBwZW4gd2hlbiBoZSBqdXN0IGNsaWNrcyBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuIEhvd2V2ZXIsXG5cdFx0Ly8gdGhpcyBkb2VzIG5vdCBpbmNsdWRlIGEgc2l0dWF0aW9uIHdoZW4gaGUgY2xpY2tzIG9uIHNvbWUgYnV0dG9uLCBwYXJ0IG9mXG5cdFx0Ly8gZWRpdG9yJ3MgVUkuXG5cblx0XHQvLyBJdCBpcyBub3QgZWFzeSB0byBkZWJvdW5jZSBfc2V0VUlIaWRkZW4gb24gbW91c2Vkb3duLCBiZWNhdXNlIGlmIHdlXG5cdFx0Ly8gZGVib3VuY2UgaXQsIHdoZW4gdGhlIGhhbmRsZXIgaXMgYmVpbmcgaW52b2tlZCwgdGhlIHRhcmdldCBtaWdodCBiZSBubyBtb3JlIHBhcnRcblx0XHQvLyBvZiB0aGUgZWRpdG9yJ3MgVUkgLSBvbkFjdGlvblBlcmZvcm1lZCBjYXVzZXMgcmUtcmVuZGVyLlxuXG5cdFx0dGhpcy5fbW91c2Vkb3duTGlzdGVuZXIgPSBldmVudCA9PiB7XG5cdFx0XHR0aGlzLl9zZXRVSUhpZGRlbihldmVudC50YXJnZXQpO1xuXHRcdH07XG5cblx0XHR0aGlzLl9rZXlEb3duTGlzdGVuZXIgPSBDS0VESVRPUi50b29scy5kZWJvdW5jZShcblx0XHRcdF9ldmVudCA9PiB7XG5cdFx0XHRcdHRoaXMuX3NldFVJSGlkZGVuKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuXHRcdFx0fSxcblx0XHRcdHRoaXMucHJvcHMuZXZlbnRzRGVsYXksXG5cdFx0XHR0aGlzXG5cdFx0KTtcblxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX21vdXNlZG93bkxpc3RlbmVyKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fa2V5RG93bkxpc3RlbmVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXBvbmVudCdzIHVwZGF0ZXMgYXJlIGZsdXNoZWQgdG8gdGhlIERPTS5cblx0ICogRmlyZXMgYGFyaWFVcGRhdGVgIGV2ZW50IHBhc3NpbmcgQVJJQSByZWxhdGVkIG1lc3NhZ2VzLlxuXHQgKiBGaXJlcyBgZWRpdG9yVXBkYXRlYCBldmVudCBwYXNzaW5nIHRoZSBwcmV2aW91cyBhbmQgY3VycmVudCBwcm9wZXJ0aWVzIGFuZCBzdGF0ZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBVSVxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZFVwZGF0ZVxuXHQgKi9cblx0Y29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG5cdFx0Y29uc3QgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0aWYgKGRvbU5vZGUpIHtcblx0XHRcdGVkaXRvci5maXJlKCdhcmlhVXBkYXRlJywge1xuXHRcdFx0XHRtZXNzYWdlOiB0aGlzLl9nZXRBdmFpbGFibGVUb29sYmFyc01lc3NhZ2UoZG9tTm9kZSksXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRlZGl0b3IuZmlyZSgnZWRpdG9yVXBkYXRlJywge1xuXHRcdFx0cHJldlByb3BzLFxuXHRcdFx0cHJldlN0YXRlLFxuXHRcdFx0cHJvcHM6IHRoaXMucHJvcHMsXG5cdFx0XHRzdGF0ZTogdGhpcy5zdGF0ZSxcblx0XHR9KTtcblx0fVxuXG5cdF9nZXRBcmlhVXBkYXRlVGVtcGxhdGUoYXJpYVVwZGF0ZSkge1xuXHRcdGlmICghdGhpcy5fYXJpYVVwZGF0ZVRlbXBsYXRlcykge1xuXHRcdFx0dGhpcy5fYXJpYVVwZGF0ZVRlbXBsYXRlcyA9IHt9O1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fYXJpYVVwZGF0ZVRlbXBsYXRlc1thcmlhVXBkYXRlXSkge1xuXHRcdFx0dGhpcy5fYXJpYVVwZGF0ZVRlbXBsYXRlc1thcmlhVXBkYXRlXSA9IG5ldyBDS0VESVRPUi50ZW1wbGF0ZShcblx0XHRcdFx0dGhpcy5fZ2V0QXJpYVVwZGF0ZXMoKVthcmlhVXBkYXRlXVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fYXJpYVVwZGF0ZVRlbXBsYXRlc1thcmlhVXBkYXRlXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZXMgZm9yIEFSSUEgbWVzc2FnZXMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVUlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF9nZXRBcmlhVXBkYXRlc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEFSSUEgcmVsYXRlcyBtZXNzYWdlcy4gRGVmYXVsdDpcblx0ICoge1xuXHQgKiAgICAgIG5vVG9vbGJhcjogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlTm9Ub29sYmFyLFxuXHQgKiAgICAgIG9uZVRvb2xiYXI6IEFsbG95RWRpdG9yLlN0cmluZ3MuYXJpYVVwZGF0ZU9uZVRvb2xiYXIsXG5cdCAqICAgICAgbWFueVRvb2xiYXJzOiBBbGxveUVkaXRvci5TdHJpbmdzLmFyaWFVcGRhdGVNYW55VG9vbGJhcnNcblx0ICogIH1cblx0ICovXG5cdF9nZXRBcmlhVXBkYXRlcygpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5wcm9wcy5hcmlhVXBkYXRlcyB8fCB7XG5cdFx0XHRcdG5vVG9vbGJhcjogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlTm9Ub29sYmFyLFxuXHRcdFx0XHRvbmVUb29sYmFyOiBBbGxveUVkaXRvci5TdHJpbmdzLmFyaWFVcGRhdGVPbmVUb29sYmFyLFxuXHRcdFx0XHRtYW55VG9vbGJhcnM6IEFsbG95RWRpdG9yLlN0cmluZ3MuYXJpYVVwZGF0ZU1hbnlUb29sYmFycyxcblx0XHRcdH1cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gQVJJQSBtZXNzYWdlIHdoaWNoIHJlcHJlc2VudHMgdGhlIG51bWJlciBvZiBjdXJyZW50bHkgYXZhaWxhYmxlIHRvb2xiYXJzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFVJXG5cdCAqIEBtZXRob2QgX2dldEF2YWlsYWJsZVRvb2xiYXJzTWVzc2FnZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGRvbU5vZGUgVGhlIERPTSBub2RlIGZyb20gd2hpY2ggdGhlIGF2YWlsYWJsZSB0b29sYmFycyB3aWxsIGJlIHJldHJpZXZlZC5cblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgQVJJQSBtZXNzYWdlIGZvciB0aGUgbnVtYmVyIG9mIGF2YWlsYWJsZSB0b29sYmFyc1xuXHQgKi9cblx0X2dldEF2YWlsYWJsZVRvb2xiYXJzTWVzc2FnZShkb21Ob2RlKSB7XG5cdFx0Y29uc3QgdG9vbGJhcnNOb2RlTGlzdCA9IGRvbU5vZGUucXVlcnlTZWxlY3RvckFsbCgnW3JvbGU9XCJ0b29sYmFyXCJdJyk7XG5cblx0XHRpZiAoIXRvb2xiYXJzTm9kZUxpc3QubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZ2V0QXJpYVVwZGF0ZXMoKS5ub1Rvb2xiYXI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IHRvb2xiYXJOYW1lcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxuXHRcdFx0XHQuY2FsbCh0b29sYmFyc05vZGVMaXN0KVxuXHRcdFx0XHQubWFwKHRvb2xiYXIgPT4ge1xuXHRcdFx0XHRcdHJldHVybiB0b29sYmFyLmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0Y29uc3QgYXJpYVVwZGF0ZSA9XG5cdFx0XHRcdHRvb2xiYXJOYW1lcy5sZW5ndGggPT09IDEgPyAnb25lVG9vbGJhcicgOiAnbWFueVRvb2xiYXJzJztcblxuXHRcdFx0cmV0dXJuIHRoaXMuX2dldEFyaWFVcGRhdGVUZW1wbGF0ZShhcmlhVXBkYXRlKS5vdXRwdXQoe1xuXHRcdFx0XHR0b29sYmFyczogdG9vbGJhck5hbWVzXG5cdFx0XHRcdFx0LmpvaW4oJywnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC8sKFteLF0qKSQvLCAnIGFuZCAnICsgJyQxJyksXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZnJvbSB0aGUgRE9NLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFVJXG5cdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcblx0ICovXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdGlmICh0aGlzLl9tb3VzZWRvd25MaXN0ZW5lcikge1xuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fbW91c2Vkb3duTGlzdGVuZXIpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9rZXlEb3duTGlzdGVuZXIpIHtcblx0XHRcdHRoaXMuX2tleURvd25MaXN0ZW5lci5kZXRhY2goKTtcblx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlEb3duTGlzdGVuZXIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBlZGl0b3IuIFRoaXMgbWF5IGluY2x1ZGUgc2V2ZXJhbCB0b29sYmFycyBhbmQgYnV0dG9ucy5cblx0ICogVGhlIGVkaXRvcidzIFVJIGFsc28gdGFrZXMgY2FyZSBvZiByZW5kZXJpbmcgdGhlIGl0ZW1zIGluIGV4Y2x1c2l2ZSBtb2RlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFVJXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLnN0YXRlLmhpZGRlbikge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0bGV0IHRvb2xiYXJzID0gT2JqZWN0LmtleXModGhpcy5wcm9wcy50b29sYmFycykubWFwKHRvb2xiYXIgPT4ge1xuXHRcdFx0cmV0dXJuIEFsbG95RWRpdG9yLlRvb2xiYXJzW3Rvb2xiYXJdIHx8IHdpbmRvd1t0b29sYmFyXTtcblx0XHR9KTtcblxuXHRcdHRvb2xiYXJzID0gdGhpcy5maWx0ZXJFeGNsdXNpdmUodG9vbGJhcnMpLm1hcCh0b29sYmFyID0+IHtcblx0XHRcdGNvbnN0IHByb3BzID0gdGhpcy5tZXJnZUV4Y2x1c2l2ZVByb3BzKFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uZmlnOiB0aGlzLnByb3BzLnRvb2xiYXJzW3Rvb2xiYXIua2V5XSxcblx0XHRcdFx0XHRlZGl0b3I6IHRoaXMuY29udGV4dC5lZGl0b3IsXG5cdFx0XHRcdFx0ZWRpdG9yRXZlbnQ6IHRoaXMuc3RhdGUuZWRpdG9yRXZlbnQsXG5cdFx0XHRcdFx0a2V5OiB0b29sYmFyLmtleSxcblx0XHRcdFx0XHRvbkRpc21pc3M6IHRoaXMuX29uRGlzbWlzc1Rvb2xiYXJGb2N1cyxcblx0XHRcdFx0XHRzZWxlY3Rpb25EYXRhOiB0aGlzLnN0YXRlLnNlbGVjdGlvbkRhdGEsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRvb2xiYXIua2V5XG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCh0b29sYmFyLCBwcm9wcyk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS10b29sYmFyc1wiIG9uS2V5RG93bj17dGhpcy5oYW5kbGVLZXl9PlxuXHRcdFx0XHR7dG9vbGJhcnN9XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpc3RlbmVyIHRvIHRoZSBlZGl0b3IncyBgYWN0aW9uUGVyZm9ybWVkYCBldmVudC4gU2V0cyBzdGF0ZSBhbmQgcmVkcmF3cyB0aGUgVUkgb2YgdGhlIGVkaXRvci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBVSVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX29uQWN0aW9uUGVyZm9ybWVkXG5cdCAqIEBwYXJhbSB7U3ludGV0aWNFdmVudH0gZXZlbnQgVGhlIHByb3ZpZGVkIGV2ZW50XG5cdCAqL1xuXHRfb25BY3Rpb25QZXJmb3JtZWQoX2V2ZW50KSB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0ZWRpdG9yLmZvY3VzKCk7XG5cblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdGl0ZW1FeGNsdXNpdmU6IG51bGwsXG5cdFx0XHRzZWxlY3Rpb25EYXRhOiBlZGl0b3IuZ2V0U2VsZWN0aW9uRGF0YSgpLFxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVkIHdoZW4gYSBkaXNtaXNzIGtleSBpcyBwcmVzc2VkIG92ZXIgYSB0b29sYmFyIHRvIHJldHVybiB0aGUgZm9jdXMgdG8gdGhlIGVkaXRvci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBVSVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX29uRGlzbWlzc1Rvb2xiYXJGb2N1c1xuXHQgKi9cblx0X29uRGlzbWlzc1Rvb2xiYXJGb2N1cyA9ICgpID0+IHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRlZGl0b3IuZm9jdXMoKTtcblx0fTtcblxuXHQvKipcblx0ICogTGlzdGVuZXIgdG8gdGhlIGVkaXRvcidzIGB1c2VySW50ZXJhY3Rpb25gIGV2ZW50LiBSZXRyaWV2ZXMgdGhlIGRhdGEgYWJvdXQgdGhlIHVzZXIgc2VsZWN0aW9uIGFuZFxuXHQgKiBwcm92aWRlcyBpdCB2aWEgY29tcG9uZW50J3Mgc3RhdGUgcHJvcGVydHkuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVUlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF9vbkVkaXRvckludGVyYWN0aW9uXG5cdCAqIEBwYXJhbSB7U3ludGV0aWNFdmVudH0gZXZlbnQgVGhlIHByb3ZpZGVkIGV2ZW50XG5cdCAqL1xuXHRfb25FZGl0b3JJbnRlcmFjdGlvbihldmVudCkge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0ZWRpdG9yRXZlbnQ6IGV2ZW50LFxuXHRcdFx0aGlkZGVuOiBmYWxzZSxcblx0XHRcdGl0ZW1FeGNsdXNpdmU6IG51bGwsXG5cdFx0XHRzZWxlY3Rpb25EYXRhOiBldmVudC5kYXRhLnNlbGVjdGlvbkRhdGEsXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogRm9jdXNlcyBvbiB0aGUgYWN0aXZlIHRvb2xiYXIgd2hlbiB0aGUgY29tYmluYXRpb24gQUxUK0YxMCBpcyBwcmVzc2VkIGluc2lkZSB0aGUgZWRpdG9yLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFVJXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfb25FZGl0b3JLZXlcblx0ICovXG5cdF9vbkVkaXRvcktleShldmVudCkge1xuXHRcdGNvbnN0IG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS5kb21FdmVudC4kO1xuXG5cdFx0aWYgKG5hdGl2ZUV2ZW50LmFsdEtleSAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSAxMjEpIHtcblx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSB0YXJnZXQgd2l0aCB3aGljaCB0aGUgdXNlciBpbnRlcmFjdGVkIGlzIHBhcnQgb2YgZWRpdG9yJ3MgVUkgb3IgaXQgaXNcblx0ICogdGhlIGVkaXRhYmxlIGFyZWEuIElmIG5vbmUgb2YgdGhlc2UsIHNldHMgdGhlIHN0YXRlIG9mIGVkaXRvcidzIFVJIHRvIGJlIGhpZGRlbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBVSVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX3NldFVJSGlkZGVuXG5cdCAqIEBwYXJhbSB7RE9NRWxlbWVudH0gdGFyZ2V0IFRoZSBET00gZWxlbWVudCB3aXRoIHdoaWNoIHVzZXIgaW50ZXJhY3RlZCBsYXN0bHkuXG5cdCAqL1xuXHRfc2V0VUlIaWRkZW4odGFyZ2V0KSB7XG5cdFx0Y29uc3QgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG5cdFx0aWYgKGRvbU5vZGUpIHtcblx0XHRcdGNvbnN0IGVkaXRhYmxlID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpLmVkaXRhYmxlKCk7XG5cdFx0XHRjb25zdCBwYXJlbnROb2RlID0gdGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0XHRjb25zdCB0YXJnZXROb2RlID0gbmV3IENLRURJVE9SLmRvbS5ub2RlKHRhcmdldCk7XG5cblx0XHRcdGlmICghZWRpdGFibGUpIHtcblx0XHRcdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRcdFx0aGlkZGVuOiB0cnVlLFxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxldCByZXMgPVxuXHRcdFx0XHRcdGVkaXRhYmxlLiQgPT09IHRhcmdldCB8fFxuXHRcdFx0XHRcdGVkaXRhYmxlLmNvbnRhaW5zKHRhcmdldE5vZGUpIHx8XG5cdFx0XHRcdFx0bmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGRvbU5vZGUpLmNvbnRhaW5zKHRhcmdldE5vZGUpO1xuXG5cdFx0XHRcdGlmIChwYXJlbnROb2RlKSB7XG5cdFx0XHRcdFx0cmVzID0gcmVzIHx8IHBhcmVudE5vZGUuaWQgPT09ICdja2ltZ3Jzeic7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIXJlcykge1xuXHRcdFx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRcdFx0aGlkZGVuOiB0cnVlLFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogRmlyZWQgd2hlbiBjb21wb25lbnQgdXBkYXRlcyBhbmQgd2hlbiBpdCBpcyByZW5kZXJlZCBpbiB0aGUgRE9NLlxuICogVGhlIHBheWxvYWQgY29uc2lzdHMgZnJvbSBhIGBtZXNzYWdlYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZSBBUklBIG1lc3NhZ2UuXG4gKlxuICogQGV2ZW50IGFyaWFVcGRhdGVcbiAqL1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gY29tcG9uZW50IHVwZGF0ZXMuIFRoZSBwYXlsb2FkIGNvbnNpc3RzIGZyb20gYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICogcHJvcGVydGllczpcbiAqIC0gcHJldlByb3BzIC0gVGhlIHByZXZpb3VzIHByb3BlcnRpZXMgb2YgdGhlIGNvbXBvbmVudFxuICogLSBwcmV2U3RhdGUgLSBUaGUgcHJldmlvdXMgc3RhdGUgb2YgdGhlIGNvbXBvbmVudFxuICogLSBwcm9wcyAtIFRoZSBjdXJyZW50IHByb3BlcnRpZXMgb2YgdGhlIGNvbXBvbmVudFxuICogLSBzdGF0ZSAtIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBjb21wb25lbnRcbiAqXG4gKiBAZXZlbnQgYXJpYVVwZGF0ZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IFdpZGdldEV4Y2x1c2l2ZShXaWRnZXRGb2N1c01hbmFnZXIoVUkpKTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFRvb2xiYXJBZGQgZnJvbSAnLi90b29sYmFyLWFkZC5qc3gnO1xuaW1wb3J0IFRvb2xiYXJTdHlsZXMgZnJvbSAnLi90b29sYmFyLXN0eWxlcy5qc3gnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdFtUb29sYmFyQWRkLmtleV06IFRvb2xiYXJBZGQsXG5cdFtUb29sYmFyU3R5bGVzLmtleV06IFRvb2xiYXJTdHlsZXMsXG59O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IFRvb2xiYXJCdXR0b25zIGZyb20gJy4uL2Jhc2UvdG9vbGJhci1idXR0b25zJztcbmltcG9ydCBXaWRnZXREcm9wZG93biBmcm9tICcuLi9iYXNlL3dpZGdldC1kcm9wZG93bic7XG5pbXBvcnQgV2lkZ2V0RXhjbHVzaXZlIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWV4Y2x1c2l2ZSc7XG5pbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXInO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi4vYnV0dG9ucy9idXR0b24taWNvbi5qc3gnO1xuXG5jb25zdCBQT1NJVElPTl9MRUZUID0gMTtcbmNvbnN0IFBPU0lUSU9OX1JJR0hUID0gMjtcblxuLyoqXG4gKiBUaGUgVG9vbGJhckFkZCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhZGRpbmcgY29udGVudCB0byB0aGUgZWRpdG9yLlxuICpcbiAqIEBjbGFzcyBUb29sYmFyQWRkXG4gKiBAdXNlcyBUb29sYmFyQnV0dG9uc1xuICogQHVzZXMgV2lkZ2V0RHJvcGRvd25cbiAqIEB1c2VzIFdpZGdldEV4Y2x1c2l2ZVxuICogQHVzZXMgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gKi9cbmNsYXNzIFRvb2xiYXJBZGQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXG5cdFx0dGhpcy5zdGF0ZSA9IHt9O1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQgKG5vdCBvbiB0aGUgc2VydmVyKSxcblx0ICogaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcblx0ICovXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQncyB1cGRhdGVzIGFyZSBmbHVzaGVkIHRvIHRoZSBET00uXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkVXBkYXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2UHJvcHMgVGhlIHByZXZpb3VzIHN0YXRlIG9mIHRoZSBjb21wb25lbnQncyBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJldlN0YXRlIENvbXBvbmVudCdzIHByZXZpb3VzIHN0YXRlLlxuXHQgKi9cblx0Y29tcG9uZW50RGlkVXBkYXRlKF9wcmV2UHJvcHMsIF9wcmV2U3RhdGUpIHtcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXG5cdFx0Ly8gSW4gY2FzZSBvZiBleGNsdXNpdmUgcmVuZGVyaW5nLCBmb2N1cyB0aGUgZmlyc3QgZGVzY2VuZGFudCAoYnV0dG9uKVxuXHRcdC8vIHNvIHRoZSB1c2VyIHdpbGwgYmUgYWJsZSB0byBzdGFydCBpbnRlcmFjdGluZyB3aXRoIHRoZSBidXR0b25zIGltbWVkaWF0ZWx5LlxuXG5cdFx0aWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlKSB7XG5cdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgYnV0dG9ucyBmb3IgYWRkaW5nIGNvbnRlbnQgb3IgaGlkZXMgdGhlIHRvb2xiYXJcblx0ICogaWYgdXNlciBpbnRlcmFjdGVkIHdpdGggYSBub24tZWRpdGFibGUgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdHxudWxsfSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Ly8gU29tZSBvcGVyYXRpb25zIHN1Y2ggYXMgYHJlcXVlc3RFeGNsdXNpdmVgIG1heSBmb3JjZSBlZGl0b3IgdG8gYmx1ciB3aGljaCB3aWxsXG5cdFx0Ly8gaW52YWxpZGF0ZSB0aGUgYHByb3BzLmVkaXRvckV2ZW50YCBzdG9yZWQgdmFsdWUsIHdpdGhvdXQgY2F1c2luZyBhIGBwcm9wc2AgY2hhbmdlLlxuXHRcdC8vIEZvciBleGFtcGxlLCBpZiB0aGUgZWRpdG9yIGlzIGVtcHR5LCBgYWVfcGxhY2Vob2xkZXJgIHBsdWdpbiB3aWxsIHJlbW92ZVxuXHRcdC8vIHRoZSB0YXJnZXQgZnJvbSB0aGUgRE9NIGFuZCB3aWxsIHByZXZlbnQgYGFkZGAgdG9vbGJhciBmcm9tIHJlbmRlcmluZy5cblx0XHQvL1xuXHRcdC8vIEl0IHNob3VsZCBiZSBzYWZlIHRvIGFzc3VtZSB0aGF0IGlmIHlvdSBoYXZlIGJlZW4gYWJsZSB0byByZW5kZXIgdGhlIHRvb2xiYXJcblx0XHQvLyBhbmQgcmVxdWVzdCB0aGUgZXhjbHVzaXZlIG1vZGUsIHRoZW4gcmVuZGVyaW5nIG1pZ2h0IGJlIGtlcHQgdW50aWwgdGhlIGV4Y2x1c2l2ZSBtb2RlIGlzIGxlZnQuXG5cblx0XHRpZiAoXG5cdFx0XHQhdGhpcy5zdGF0ZS5pdGVtRXhjbHVzaXZlICYmXG5cdFx0XHR0aGlzLnByb3BzLmVkaXRvckV2ZW50ICYmXG5cdFx0XHR0aGlzLnByb3BzLmVkaXRvckV2ZW50LmRhdGEubmF0aXZlRXZlbnQudGFyZ2V0ICYmXG5cdFx0XHQhdGhpcy5wcm9wcy5lZGl0b3JFdmVudC5kYXRhLm5hdGl2ZUV2ZW50LnRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Y29uc3QgYnV0dG9ucyA9IHRoaXMuX2dldEJ1dHRvbnMoKTtcblx0XHRjb25zdCBjbGFzc05hbWUgPSB0aGlzLl9nZXRUb29sYmFyQ2xhc3NOYW1lKCk7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdlxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFkZH1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc05hbWV9XG5cdFx0XHRcdGRhdGEtdGFiaW5kZXg9e3RoaXMucHJvcHMuY29uZmlnLnRhYkluZGV4IHx8IDB9XG5cdFx0XHRcdG9uRm9jdXM9e3RoaXMuZm9jdXMuYmluZCh0aGlzKX1cblx0XHRcdFx0b25LZXlEb3duPXt0aGlzLmhhbmRsZUtleS5iaW5kKHRoaXMpfVxuXHRcdFx0XHRyb2xlPVwidG9vbGJhclwiXG5cdFx0XHRcdHRhYkluZGV4PVwiLTFcIj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXJcIj57YnV0dG9uc308L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGxpc3Qgb2YgYnV0dG9ucyB0aGF0IHdpbGwgZXZlbnR1YWxseSByZW5kZXIgdG8gSFRNTC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG5cdCAqIEBtZXRob2QgX2dldEJ1dHRvbnNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBidXR0b25zIHdoaWNoIGhhdmUgdG8gYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRfZ2V0QnV0dG9ucygpIHtcblx0XHRsZXQgYnV0dG9ucztcblxuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0YnV0dG9ucyA9IHRoaXMuZ2V0VG9vbGJhckJ1dHRvbnModGhpcy5wcm9wcy5jb25maWcuYnV0dG9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGEgJiYgdGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhLnJlZ2lvbikge1xuXHRcdFx0XHRidXR0b25zID0gKFxuXHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWRkfVxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uIGFlLWJ1dHRvbi1hZGRcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlLmJpbmQoXG5cdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFRvb2xiYXJBZGQua2V5XG5cdFx0XHRcdFx0XHQpfVxuXHRcdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWRkfT5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInBsdXNcIiAvPlxuXHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBidXR0b25zO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNsYXNzIG5hbWUgb2YgdGhlIHRvb2xiYXIgaW4gY2FzZSBvZiBib3RoIGV4Y2x1c2l2ZSBhbmQgbm9ybWFsIG1vZGUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuXHQgKiBAbWV0aG9kIF9nZXRUb29sYmFyQ2xhc3NOYW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgY2xhc3MgbmFtZSB3aGljaCBoYXZlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIERPTSBlbGVtZW50LlxuXHQgKi9cblx0X2dldFRvb2xiYXJDbGFzc05hbWUoKSB7XG5cdFx0bGV0IGNzc0NsYXNzID0gJ2FlLXRvb2xiYXItYWRkJztcblxuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0Y3NzQ2xhc3MgPSAnYWUtdG9vbGJhciAnICsgdGhpcy5nZXRBcnJvd0JveENsYXNzZXMoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY3NzQ2xhc3M7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyBhbmQgc2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2xiYXIgaW4gZXhjbHVzaXZlIG9yIG5vcm1hbCBtb2RlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcblx0ICogQG1ldGhvZCBfdXBkYXRlUG9zaXRpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3VwZGF0ZVBvc2l0aW9uKCkge1xuXHRcdGxldCByZWdpb247XG5cblx0XHQvLyBJZiBjb21wb25lbnQgaXMgbm90IG1vdW50ZWQsIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG9cblxuXHRcdGlmICghUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcblx0XHRcdHRoaXMudXBkYXRlUG9zaXRpb24oKTtcblx0XHRcdHRoaXMuc2hvdygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhKSB7XG5cdFx0XHRcdHJlZ2lvbiA9IHRoaXMucHJvcHMuc2VsZWN0aW9uRGF0YS5yZWdpb247XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZWdpb24pIHtcblx0XHRcdFx0Y29uc3QgZG9tTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuXG5cdFx0XHRcdGNvbnN0IGRvbUVsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZG9tTm9kZSk7XG5cblx0XHRcdFx0Y29uc3Qgc3RhcnRSZWN0ID0gcmVnaW9uLnN0YXJ0UmVjdCB8fCByZWdpb247XG5cblx0XHRcdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRcdGNvbnN0IGNsaWVudFJlY3QgPSBuYXRpdmVFZGl0b3IuZWRpdGFibGUoKS5nZXRDbGllbnRSZWN0KCk7XG5cblx0XHRcdFx0bGV0IG9mZnNldExlZnQ7XG5cblx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPVxuXHRcdFx0XHRcdHRoaXMucHJvcHMuY29uZmlnLnBvc2l0aW9uIHx8IHRoaXMucHJvcHMucG9zaXRpb247XG5cblx0XHRcdFx0aWYgKHBvc2l0aW9uID09PSBQT1NJVElPTl9MRUZUKSB7XG5cdFx0XHRcdFx0b2Zmc2V0TGVmdCA9XG5cdFx0XHRcdFx0XHRjbGllbnRSZWN0LmxlZnQgLVxuXHRcdFx0XHRcdFx0ZG9tTm9kZS5vZmZzZXRXaWR0aCAtXG5cdFx0XHRcdFx0XHR0aGlzLnByb3BzLmd1dHRlckV4Y2x1c2l2ZS5sZWZ0ICtcblx0XHRcdFx0XHRcdCdweCc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b2Zmc2V0TGVmdCA9XG5cdFx0XHRcdFx0XHRjbGllbnRSZWN0LnJpZ2h0ICtcblx0XHRcdFx0XHRcdHRoaXMucHJvcHMuZ3V0dGVyRXhjbHVzaXZlLmxlZnQgK1xuXHRcdFx0XHRcdFx0J3B4Jztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRvbU5vZGUuc3R5bGUubGVmdCA9IG9mZnNldExlZnQ7XG5cblx0XHRcdFx0ZG9tTm9kZS5zdHlsZS50b3AgPVxuXHRcdFx0XHRcdE1hdGguZmxvb3IoKHJlZ2lvbi5ib3R0b20gKyByZWdpb24udG9wKSAvIDIpICsgJ3B4JztcblxuXHRcdFx0XHRjb25zdCB1aU5vZGUgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgndWlOb2RlJyk7XG5cblx0XHRcdFx0Y29uc3Qgc2Nyb2xsVG9wID0gdWlOb2RlID8gdWlOb2RlLnNjcm9sbFRvcCA6IDA7XG5cblx0XHRcdFx0aWYgKG5hdGl2ZUVkaXRvci5lbGVtZW50LmdldFN0eWxlKCdvdmVyZmxvdycpICE9PSAnYXV0bycpIHtcblx0XHRcdFx0XHRkb21Ob2RlLnN0eWxlLnRvcCA9XG5cdFx0XHRcdFx0XHRNYXRoLmZsb29yKFxuXHRcdFx0XHRcdFx0XHRyZWdpb24udG9wIC1cblx0XHRcdFx0XHRcdFx0XHRkb21Ob2RlLm9mZnNldEhlaWdodCAvIDIgK1xuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0UmVjdC5oZWlnaHQgLyAyICtcblx0XHRcdFx0XHRcdFx0XHRzY3JvbGxUb3Bcblx0XHRcdFx0XHRcdCkgKyAncHgnO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvbU5vZGUuc3R5bGUudG9wID1cblx0XHRcdFx0XHRcdE1hdGguZmxvb3IoXG5cdFx0XHRcdFx0XHRcdG5hdGl2ZUVkaXRvci5lbGVtZW50LiQub2Zmc2V0VG9wICtcblx0XHRcdFx0XHRcdFx0XHRzdGFydFJlY3QuaGVpZ2h0IC8gMiAtXG5cdFx0XHRcdFx0XHRcdFx0ZG9tTm9kZS5vZmZzZXRIZWlnaHQgLyAyXG5cdFx0XHRcdFx0XHQpICsgJ3B4Jztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRvbU5vZGUuc3R5bGUub3BhY2l0eSA9IDE7XG5cblx0XHRcdFx0ZG9tRWxlbWVudC5yZW1vdmVDbGFzcygnYWUtYXJyb3ctYm94Jyk7XG5cblx0XHRcdFx0dGhpcy5jYW5jZWxBbmltYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBhZGRcbiAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cblRvb2xiYXJBZGQua2V5ID0gJ2FkZCc7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgY29uc3RhbnQgZm9yIHBvc2l0aW9uaW5nIHRoZSBUb29sYmFyIG9uIGxlZnQgb2YgdGhlIGVkaXRhYmxlIGFyZWEuXG4gKlxuICogQGRlZmF1bHQgMVxuICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBsZWZ0XG4gKiBAc3RhdGljXG4gKi9cblRvb2xiYXJBZGQubGVmdCA9IFBPU0lUSU9OX0xFRlQ7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgY29uc3RhbnQgZm9yIHBvc2l0aW9uaW5nIHRoZSBUb29sYmFyIG9uIHJpZ2h0IG9mIHRoZSBlZGl0YWJsZSBhcmVhLlxuICpcbiAqIEBkZWZhdWx0IDJcbiAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmlnaHRcbiAqIEBzdGF0aWNcbiAqL1xuVG9vbGJhckFkZC5yaWdodCA9IFBPU0lUSU9OX1JJR0hUO1xuXG4vKipcbiAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG4gKi9cblRvb2xiYXJBZGQuZGVmYXVsdFByb3BzID0ge1xuXHRjaXJjdWxhcjogdHJ1ZSxcblx0ZGVzY2VuZGFudHM6ICcuYWUtYnV0dG9uJyxcblx0Z3V0dGVyRXhjbHVzaXZlOiB7XG5cdFx0bGVmdDogMTAsXG5cdFx0dG9wOiAwLFxuXHR9LFxuXHRrZXlzOiB7XG5cdFx0ZGlzbWlzczogWzI3XSxcblx0XHRuZXh0OiBbMzksIDQwXSxcblx0XHRwcmV2OiBbMzcsIDM4XSxcblx0fSxcblx0cG9zaXRpb246IFBPU0lUSU9OX0xFRlQsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXREcm9wZG93bihcblx0V2lkZ2V0RXhjbHVzaXZlKFdpZGdldEZvY3VzTWFuYWdlcihUb29sYmFyQnV0dG9ucyhUb29sYmFyQWRkKSkpXG4pO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuaW1wb3J0IFRvb2xiYXJCdXR0b25zIGZyb20gJy4uL2Jhc2UvdG9vbGJhci1idXR0b25zJztcbmltcG9ydCBXaWRnZXREcm9wZG93biBmcm9tICcuLi9iYXNlL3dpZGdldC1kcm9wZG93bic7XG5pbXBvcnQgV2lkZ2V0RXhjbHVzaXZlIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWV4Y2x1c2l2ZSc7XG5pbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXInO1xuXG4vKipcbiAqIFRoZSBUb29sYmFyU3R5bGVzIGNsYXNzIGhvc3RzIHRoZSBidXR0b25zIGZvciBzdHlsaW5nIGEgdGV4dCBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIFRvb2xiYXJTdHlsZXNcbiAqIEB1c2VzIFRvb2xiYXJCdXR0b25zXG4gKiBAdXNlcyBXaWRnZXREcm9wZG93blxuICogQHVzZXMgV2lkZ2V0RXhjbHVzaXZlXG4gKiBAdXNlcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqL1xuY2xhc3MgVG9vbGJhclN0eWxlcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHR0aGlzLnN0YXRlID0ge307XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCAobm90IG9uIHRoZSBzZXJ2ZXIpLFxuXHQgKiBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFRvb2xiYXJTdHlsZXNcblx0ICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXBvbmVudCdzIHVwZGF0ZXMgYXJlIGZsdXNoZWQgdG8gdGhlIERPTS5cblx0ICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFRvb2xiYXJTdHlsZXNcblx0ICogQG1ldGhvZCBjb21wb25lbnREaWRVcGRhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHByZXZQcm9wcyBUaGUgcHJldmlvdXMgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCdzIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U3RhdGUgQ29tcG9uZW50J3MgcHJldmlvdXMgc3RhdGUuXG5cdCAqL1xuXHRjb21wb25lbnREaWRVcGRhdGUoX3ByZXZQcm9wcywgX3ByZXZTdGF0ZSkge1xuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBidXR0b25zIGZvciBhZGRpbmcgY29udGVudCBvciBoaWRlcyB0aGUgdG9vbGJhclxuXHQgKiBpZiB1c2VyIGludGVyYWN0ZWQgd2l0aCBhIG5vbi1lZGl0YWJsZSBlbGVtZW50LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFRvb2xiYXJTdHlsZXNcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fG51bGx9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gdGhpcy5fZ2V0Q3VycmVudFNlbGVjdGlvbigpO1xuXG5cdFx0aWYgKGN1cnJlbnRTZWxlY3Rpb24pIHtcblx0XHRcdGNvbnN0IGdldEFycm93Qm94Q2xhc3Nlc0ZuID0gdGhpcy5fZ2V0U2VsZWN0aW9uRnVuY3Rpb24oXG5cdFx0XHRcdGN1cnJlbnRTZWxlY3Rpb24uZ2V0QXJyb3dCb3hDbGFzc2VzXG5cdFx0XHQpO1xuXHRcdFx0bGV0IGFycm93Qm94Q2xhc3NlcztcblxuXHRcdFx0aWYgKGdldEFycm93Qm94Q2xhc3Nlc0ZuKSB7XG5cdFx0XHRcdGFycm93Qm94Q2xhc3NlcyA9IGdldEFycm93Qm94Q2xhc3Nlc0ZuKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhcnJvd0JveENsYXNzZXMgPSB0aGlzLmdldEFycm93Qm94Q2xhc3NlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjc3NDbGFzc2VzID0gJ2FlLXRvb2xiYXItc3R5bGVzICcgKyBhcnJvd0JveENsYXNzZXM7XG5cblx0XHRcdGxldCBidXR0b25zID0gY3VycmVudFNlbGVjdGlvbi5idXR0b25zO1xuXG5cdFx0XHRpZiAodHlwZW9mIGJ1dHRvbnMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGJ1dHRvbnMpKSB7XG5cdFx0XHRcdGJ1dHRvbnMgPVxuXHRcdFx0XHRcdGJ1dHRvbnNbdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ21vZGUnKV0gfHxcblx0XHRcdFx0XHRidXR0b25zWydzaW1wbGUnXTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYnV0dG9uc0dyb3VwID0gdGhpcy5nZXRUb29sYmFyQnV0dG9uR3JvdXBzKGJ1dHRvbnMsIHtcblx0XHRcdFx0bWFudWFsU2VsZWN0aW9uOiB0aGlzLnByb3BzLmVkaXRvckV2ZW50XG5cdFx0XHRcdFx0PyB0aGlzLnByb3BzLmVkaXRvckV2ZW50LmRhdGEubWFudWFsU2VsZWN0aW9uXG5cdFx0XHRcdFx0OiBudWxsLFxuXHRcdFx0XHRzZWxlY3Rpb25UeXBlOiBjdXJyZW50U2VsZWN0aW9uLm5hbWUsXG5cdFx0XHR9KTtcblxuXHRcdFx0Y29uc3QgaGFzR3JvdXBzID1cblx0XHRcdFx0YnV0dG9uc0dyb3VwLmZpbHRlcihidXR0b24gPT4ge1xuXHRcdFx0XHRcdHJldHVybiBBcnJheS5pc0FycmF5KGJ1dHRvbik7XG5cdFx0XHRcdH0pLmxlbmd0aCA+IDA7XG5cblx0XHRcdGxldCBjbGFzc05hbWUgPSAnYWUtY29udGFpbmVyJztcblxuXHRcdFx0aWYgKGhhc0dyb3Vwcykge1xuXHRcdFx0XHRjbGFzc05hbWUgKz0gJyBhZS1jb250YWluZXItY29sdW1uJztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3R5bGVzfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT17Y3NzQ2xhc3Nlc31cblx0XHRcdFx0XHRkYXRhLXRhYmluZGV4PXt0aGlzLnByb3BzLmNvbmZpZy50YWJJbmRleCB8fCAwfVxuXHRcdFx0XHRcdG9uRm9jdXM9e3RoaXMuZm9jdXMuYmluZCh0aGlzKX1cblx0XHRcdFx0XHRvbktleURvd249e3RoaXMuaGFuZGxlS2V5LmJpbmQodGhpcyl9XG5cdFx0XHRcdFx0cm9sZT1cInRvb2xiYXJcIlxuXHRcdFx0XHRcdHRhYkluZGV4PVwiLTFcIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cblx0XHRcdFx0XHRcdHtidXR0b25zR3JvdXAubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtcm93XCIga2V5PXtpbmRleH0+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHt2YWx1ZS5tYXAoYnV0dG9uID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gYnV0dG9uO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KX1cblx0XHRcdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KX1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlIGEgZnVuY3Rpb24gZnJvbSBTdHJpbmcuIEl0IGNvbnZlcnRzIGEgZnVsbHkgcXVhbGlmaWVkIHN0cmluZyBpbnRvIHRoZSBtYXBwZWQgZnVuY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVG9vbGJhclN0eWxlc1xuXHQgKiBAbWV0aG9kIF9nZXRTZWxlY3Rpb25GdW5jdGlvblxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gc2VsZWN0aW9uRm4gQSBmdW5jdGlvbiwgb3IgYSBmdWxseSBxdWFsaWZpZWQgc3RyaW5nIHBvaW50aW5nIHRvIHRoZSBkZXNpcmVkIG9uZSAoZS5nLiAnQWxsb3lFZGl0b3IuU2VsZWN0aW9uVGVzdC5pbWFnZScpLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgbWFwcGVkIGZ1bmN0aW9uLlxuXHQgKi9cblx0X2dldFNlbGVjdGlvbkZ1bmN0aW9uKHNlbGVjdGlvbkZuKSB7XG5cdFx0bGV0IHNlbGVjdGlvbkZ1bmN0aW9uO1xuXG5cdFx0aWYgKExhbmcuaXNGdW5jdGlvbihzZWxlY3Rpb25GbikpIHtcblx0XHRcdHNlbGVjdGlvbkZ1bmN0aW9uID0gc2VsZWN0aW9uRm47XG5cdFx0fSBlbHNlIGlmIChMYW5nLmlzU3RyaW5nKHNlbGVjdGlvbkZuKSkge1xuXHRcdFx0Y29uc3QgcGFydHMgPSBzZWxlY3Rpb25Gbi5zcGxpdCgnLicpO1xuXHRcdFx0bGV0IGN1cnJlbnRNZW1iZXIgPSB3aW5kb3c7XG5cdFx0XHRsZXQgcHJvcGVydHkgPSBwYXJ0cy5zaGlmdCgpO1xuXG5cdFx0XHR3aGlsZSAoXG5cdFx0XHRcdHByb3BlcnR5ICYmXG5cdFx0XHRcdExhbmcuaXNPYmplY3QoY3VycmVudE1lbWJlcikgJiZcblx0XHRcdFx0TGFuZy5pc09iamVjdChjdXJyZW50TWVtYmVyW3Byb3BlcnR5XSlcblx0XHRcdCkge1xuXHRcdFx0XHRjdXJyZW50TWVtYmVyID0gY3VycmVudE1lbWJlcltwcm9wZXJ0eV07XG5cdFx0XHRcdHByb3BlcnR5ID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKExhbmcuaXNGdW5jdGlvbihjdXJyZW50TWVtYmVyKSkge1xuXHRcdFx0XHRzZWxlY3Rpb25GdW5jdGlvbiA9IGN1cnJlbnRNZW1iZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlbGVjdGlvbkZ1bmN0aW9uO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFuYWx5emVzIHRoZSBjdXJyZW50IGVkaXRvciBzZWxlY3Rpb24gYW5kIHJldHVybnMgdGhlIHNlbGVjdGlvbiBjb25maWd1cmF0aW9uIHRoYXQgbWF0Y2hlcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG5cdCAqIEBtZXRob2QgX2dldEN1cnJlbnRTZWxlY3Rpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtYXRjaGVkIHNlbGVjdGlvbiBjb25maWd1cmF0aW9uLlxuXHQgKi9cblx0X2dldEN1cnJlbnRTZWxlY3Rpb24oKSB7XG5cdFx0Y29uc3QgZXZlbnRQYXlsb2FkID0gdGhpcy5wcm9wcy5lZGl0b3JFdmVudFxuXHRcdFx0PyB0aGlzLnByb3BzLmVkaXRvckV2ZW50LmRhdGFcblx0XHRcdDogbnVsbDtcblx0XHRsZXQgc2VsZWN0aW9uO1xuXG5cdFx0aWYgKGV2ZW50UGF5bG9hZCkge1xuXHRcdFx0dGhpcy5wcm9wcy5jb25maWcuc2VsZWN0aW9ucy5zb21lKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0Y29uc3QgdGVzdEZuID0gdGhpcy5fZ2V0U2VsZWN0aW9uRnVuY3Rpb24oaXRlbS50ZXN0KTtcblx0XHRcdFx0bGV0IHJlc3VsdDtcblxuXHRcdFx0XHRpZiAodGVzdEZuKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID1cblx0XHRcdFx0XHRcdGV2ZW50UGF5bG9hZC5tYW51YWxTZWxlY3Rpb24gPT09IGl0ZW0ubmFtZSB8fFxuXHRcdFx0XHRcdFx0dGVzdEZuKHtcblx0XHRcdFx0XHRcdFx0ZGF0YTogZXZlbnRQYXlsb2FkLFxuXHRcdFx0XHRcdFx0XHRlZGl0b3I6IHRoaXMuY29udGV4dC5lZGl0b3IsXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0XHRzZWxlY3Rpb24gPSBpdGVtO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZWxlY3Rpb247XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyBhbmQgc2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2xiYXIuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVG9vbGJhclN0eWxlc1xuXHQgKiBAbWV0aG9kIF91cGRhdGVQb3NpdGlvblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfdXBkYXRlUG9zaXRpb24oKSB7XG5cdFx0Ly8gSWYgY29tcG9uZW50IGlzIG5vdCBtb3VudGVkLCB0aGVyZSBpcyBub3RoaW5nIHRvIGRvXG5cblx0XHRpZiAoIVJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgY3VycmVudFNlbGVjdGlvbiA9IHRoaXMuX2dldEN1cnJlbnRTZWxlY3Rpb24oKTtcblx0XHRsZXQgcmVzdWx0O1xuXG5cdFx0Ly8gSWYgY3VycmVudCBzZWxlY3Rpb24gaGFzIGEgZnVuY3Rpb24gY2FsbGVkIGBzZXRQb3NpdGlvbmAsIGNhbGwgaXRcblx0XHQvLyBhbmQgY2hlY2sgdGhlIHJldHVybmVkIHZhbHVlLiBJZiBmYWxzZSwgZmFsbGJhY2sgdG8gdGhlIGRlZmF1bHQgcG9zaXRpb25pbmcgbG9naWMuXG5cblx0XHRpZiAoY3VycmVudFNlbGVjdGlvbikge1xuXHRcdFx0Y29uc3Qgc2V0UG9zaXRpb25GbiA9IHRoaXMuX2dldFNlbGVjdGlvbkZ1bmN0aW9uKFxuXHRcdFx0XHRjdXJyZW50U2VsZWN0aW9uLnNldFBvc2l0aW9uXG5cdFx0XHQpO1xuXG5cdFx0XHRpZiAoc2V0UG9zaXRpb25Gbikge1xuXHRcdFx0XHRyZXN1bHQgPSBzZXRQb3NpdGlvbkZuLmNhbGwodGhpcywge1xuXHRcdFx0XHRcdGVkaXRvcjogdGhpcy5jb250ZXh0LmVkaXRvcixcblx0XHRcdFx0XHRlZGl0b3JFdmVudDogdGhpcy5wcm9wcy5lZGl0b3JFdmVudCxcblx0XHRcdFx0XHRzZWxlY3Rpb25EYXRhOiB0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGEsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghcmVzdWx0KSB7XG5cdFx0XHR0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG5cdFx0XHR0aGlzLnNob3coKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5Ub29sYmFyU3R5bGVzLmRlZmF1bHRQcm9wcyA9IHtcblx0Y2lyY3VsYXI6IHRydWUsXG5cdGRlc2NlbmRhbnRzOiAnLmFlLWlucHV0LCAuYWUtYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgLmFlLXRvb2xiYXItZWxlbWVudCcsXG5cdGtleXM6IHtcblx0XHRkaXNtaXNzOiBbMjddLFxuXHRcdG5leHQ6IFszOSwgNDBdLFxuXHRcdHByZXY6IFszNywgMzhdLFxuXHR9LFxufTtcblxuLyoqXG4gKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZGVmYXVsdCBzdHlsZXNcbiAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG4gKiBAc3RhdGljXG4gKi9cblRvb2xiYXJTdHlsZXMua2V5ID0gJ3N0eWxlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IFdpZGdldERyb3Bkb3duKFxuXHRXaWRnZXRFeGNsdXNpdmUoV2lkZ2V0Rm9jdXNNYW5hZ2VyKFRvb2xiYXJCdXR0b25zKFRvb2xiYXJTdHlsZXMpKSlcbik7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2J1dHRvbmJyaWRnZScpKSB7XG5cdGNvbnN0IEJVVFRPTl9ERUZTID0ge307XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIEJ1dHRvbkJyaWRnZSBSZWFjdCBjbGFzcyBmb3IgYSBnaXZlbiBidXR0b24gZGVmaW5pdGlvbiBpZiBpdCBoYXMgbm90IGJlZW5cblx0ICogYWxyZWFkeSBjcmVhdGVkIGJhc2VkIG9uIHRoZSBidXR0b24gbmFtZSBhbmQgZGVmaW5pdGlvbi5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG1ldGhvZCBnZW5lcmF0ZUJ1dHRvbkJyaWRnZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYnV0dG9uTmFtZSBUaGUgYnV0dG9uJ3MgbmFtZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gYnV0dG9uRGVmaW5pdGlvbiBUaGUgYnV0dG9uJ3MgZGVmaW5pdGlvblxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBnZW5lcmF0ZWQgb3IgYWxyZWFkeSBleGlzdGluZyBSZWFjdCBCdXR0b24gQ2xhc3Ncblx0ICovXG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVCdXR0b25CcmlkZ2UoYnV0dG9uTmFtZSwgYnV0dG9uRGVmaW5pdGlvbiwgZWRpdG9yKSB7XG5cdFx0bGV0IEJ1dHRvbkJyaWRnZSA9IEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uTmFtZV07XG5cblx0XHRCVVRUT05fREVGU1tlZGl0b3IubmFtZV0gPSBCVVRUT05fREVGU1tlZGl0b3IubmFtZV0gfHwge307XG5cdFx0QlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW2J1dHRvbk5hbWVdID1cblx0XHRcdEJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVtidXR0b25OYW1lXSB8fCBidXR0b25EZWZpbml0aW9uO1xuXG5cdFx0aWYgKCFCdXR0b25CcmlkZ2UpIHtcblx0XHRcdEJ1dHRvbkJyaWRnZSA9IGNsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0XHRcdFx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRcdFx0XHRzdGF0aWMgZGlzcGxheU5hbWUgPSBidXR0b25OYW1lO1xuXG5cdFx0XHRcdHN0YXRpYyBrZXkgPSBidXR0b25OYW1lO1xuXG5cdFx0XHRcdC8vIEFQSSBub3QgeWV0IGltcGxlbWVudGVkIGluc2lkZSB0aGUgYnV0dG9uXG5cdFx0XHRcdC8vIGJyaWRnZS4gQnkgbW9ja2luZyB0aGUgdW5zdXBwb3J0ZWQgbWV0aG9kLCB3ZSBwcmV2ZW50XG5cdFx0XHRcdC8vIHBsdWdpbnMgZnJvbSBjcmFzaGluZyBpZiB0aGV5IG1ha2UgdXNlIG9mIGl0LlxuXG5cdFx0XHRcdHRvRmVhdHVyZSgpIHt9XG5cblx0XHRcdFx0cmVuZGVyKCkge1xuXHRcdFx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0XHRcdGNvbnN0IGJ1dHRvbkNsYXNzTmFtZSA9ICdhZS1idXR0b24gYWUtYnV0dG9uLWJyaWRnZSc7XG5cblx0XHRcdFx0XHRjb25zdCBidXR0b25EaXNwbGF5TmFtZSA9XG5cdFx0XHRcdFx0XHRCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bYnV0dG9uTmFtZV0ubmFtZSB8fFxuXHRcdFx0XHRcdFx0QlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW2J1dHRvbk5hbWVdLmNvbW1hbmQgfHxcblx0XHRcdFx0XHRcdGJ1dHRvbk5hbWU7XG5cblx0XHRcdFx0XHRjb25zdCBidXR0b25MYWJlbCA9XG5cdFx0XHRcdFx0XHRCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bYnV0dG9uTmFtZV0ubGFiZWw7XG5cblx0XHRcdFx0XHRjb25zdCBidXR0b25UeXBlID0gJ2J1dHRvbi0nICsgYnV0dG9uRGlzcGxheU5hbWU7XG5cblx0XHRcdFx0XHRjb25zdCBpY29uQ2xhc3NOYW1lID0gJ2FlLWljb24tJyArIGJ1dHRvbkRpc3BsYXlOYW1lO1xuXG5cdFx0XHRcdFx0Y29uc3QgaWNvblN0eWxlID0ge307XG5cblx0XHRcdFx0XHRjb25zdCBjc3NTdHlsZSA9IENLRURJVE9SLnNraW4uZ2V0SWNvblN0eWxlKFxuXHRcdFx0XHRcdFx0YnV0dG9uRGlzcGxheU5hbWVcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKGNzc1N0eWxlKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjc3NTdHlsZVBhcnRzID0gY3NzU3R5bGUuc3BsaXQoJzsnKTtcblxuXHRcdFx0XHRcdFx0aWNvblN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGNzc1N0eWxlUGFydHNbMF0uc3Vic3RyaW5nKFxuXHRcdFx0XHRcdFx0XHRjc3NTdHlsZVBhcnRzWzBdLmluZGV4T2YoJzonKSArIDFcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRpY29uU3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gY3NzU3R5bGVQYXJ0c1sxXS5zdWJzdHJpbmcoXG5cdFx0XHRcdFx0XHRcdGNzc1N0eWxlUGFydHNbMV0uaW5kZXhPZignOicpICsgMVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGljb25TdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IGNzc1N0eWxlUGFydHNbMl0uc3Vic3RyaW5nKFxuXHRcdFx0XHRcdFx0XHRjc3NTdHlsZVBhcnRzWzJdLmluZGV4T2YoJzonKSArIDFcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdFx0YXJpYS1sYWJlbD17YnV0dG9uTGFiZWx9XG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17YnV0dG9uQ2xhc3NOYW1lfVxuXHRcdFx0XHRcdFx0XHRkYXRhLXR5cGU9e2J1dHRvblR5cGV9XG5cdFx0XHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX2hhbmRsZUNsaWNrfVxuXHRcdFx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHRcdFx0dGl0bGU9e2J1dHRvbkxhYmVsfT5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPXtpY29uQ2xhc3NOYW1lfSBzdHlsZT17aWNvblN0eWxlfSAvPlxuXHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9oYW5kbGVDbGljayA9ICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdFx0XHRjb25zdCBidXR0b25Db21tYW5kID1cblx0XHRcdFx0XHRcdEJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVtidXR0b25OYW1lXS5jb21tYW5kO1xuXG5cdFx0XHRcdFx0Y29uc3QgYnV0dG9uT25DbGljayA9XG5cdFx0XHRcdFx0XHRCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bYnV0dG9uTmFtZV0ub25DbGljaztcblxuXHRcdFx0XHRcdGlmIChidXR0b25PbkNsaWNrKSB7XG5cdFx0XHRcdFx0XHRidXR0b25PbkNsaWNrLmNhbGwodGhpcyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVkaXRvci5leGVjQ29tbWFuZChidXR0b25Db21tYW5kKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0XHRBbGxveUVkaXRvci5CdXR0b25zW2J1dHRvbk5hbWVdID0gQnV0dG9uQnJpZGdlO1xuXHRcdH1cblxuXHRcdHJldHVybiBCdXR0b25CcmlkZ2U7XG5cdH1cblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHRpZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdidXR0b24nKSkge1xuXHRcdENLRURJVE9SLlVJX0JVVFRPTiA9ICdidXR0b24nO1xuXG5cdFx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2J1dHRvbicsIHt9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gdGhhdCBicmlkZ2VzIHRoZSBzdXBwb3J0IG9mZmVyZWQgYnkgQ0tFZGl0b3IgQnV0dG9uIHBsdWdpbi4gSXQgdGFrZXMgb3ZlciB0aGVcblx0ICogcmVzcG9uc2liaWxpdHkgb2YgcmVnaXN0ZXJpbmcgYW5kIGNyZWF0aW5nIGJ1dHRvbnMgdmlhOlxuXHQgKiAtIGVkaXRvci51aS5hZGRCdXR0b24obmFtZSwgZGVmaW5pdGlvbilcblx0ICogLSBlZGl0b3IudWkuYWRkKG5hbWUsIENLRURJVE9SLlVJX0JVVFRPTiwgZGVmaW5pdGlvbilcblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfYnV0dG9uYnJpZGdlXG5cdCAqIEByZXF1aXJlcyBDS0VESVRPUi5wbHVnaW5zLmFlX3VpYnJpZGdlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX2J1dHRvbmJyaWRnZScsIHtcblx0XHRyZXF1aXJlczogWydhZV91aWJyaWRnZSddLFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBhZGQgaGFuZGxlciBmb3IgVUlfQlVUVE9OIHRvIG91ciBvd24uIFdlIGRvIHRoaXMgaW4gdGhlIGluaXQgcGhhc2UgdG8gb3ZlcnJpZGVcblx0XHQgKiB0aGUgb25lIGluIHRoZSBuYXRpdmUgcGx1Z2luIGluIGNhc2UgaXQncyBwcmVzZW50LlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBpbml0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgQ0tFZGl0b3IgaW5zdGFuY2UgYmVpbmcgaW5pdGlhbGl6ZWRcblx0XHQgKi9cblx0XHRiZWZvcmVJbml0KGVkaXRvcikge1xuXHRcdFx0QlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdID0ge307XG5cblx0XHRcdGVkaXRvci51aS5hZGRCdXR0b24gPSBmdW5jdGlvbihidXR0b25OYW1lLCBidXR0b25EZWZpbml0aW9uKSB7XG5cdFx0XHRcdHRoaXMuYWRkKGJ1dHRvbk5hbWUsIENLRURJVE9SLlVJX0JVVFRPTiwgYnV0dG9uRGVmaW5pdGlvbik7XG5cdFx0XHR9O1xuXG5cdFx0XHRlZGl0b3IudWkuYWRkSGFuZGxlcihDS0VESVRPUi5VSV9CVVRUT04sIHtcblx0XHRcdFx0YWRkOiBnZW5lcmF0ZUJ1dHRvbkJyaWRnZSxcblx0XHRcdFx0Y3JlYXRlKGJ1dHRvbkRlZmluaXRpb24pIHtcblx0XHRcdFx0XHRjb25zdCBidXR0b25OYW1lID1cblx0XHRcdFx0XHRcdCdidXR0b25CcmlkZ2UnICsgKChNYXRoLnJhbmRvbSgpICogMWU5KSA+Pj4gMCk7XG5cdFx0XHRcdFx0Y29uc3QgQnV0dG9uQnJpZGdlID0gZ2VuZXJhdGVCdXR0b25CcmlkZ2UoXG5cdFx0XHRcdFx0XHRidXR0b25OYW1lLFxuXHRcdFx0XHRcdFx0YnV0dG9uRGVmaW5pdGlvblxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IEJ1dHRvbkJyaWRnZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCAnLi9idXR0b24uanN4JztcblxuaW1wb3J0ICcuL21lbnUtYnV0dG9uLmpzeCc7XG5cbmltcG9ydCAnLi9tZW51LmpzeCc7XG5cbmltcG9ydCAnLi9wYW5lbC1tZW51LWJ1dHRvbi5qc3gnO1xuXG5pbXBvcnQgJy4vcmljaGNvbWJvLmpzeCc7XG5cbmltcG9ydCAnLi91aWJyaWRnZSc7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJy4uL2J1dHRvbnMvYnV0dG9uLWRyb3Bkb3duLmpzeCc7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfbWVudWJ1dHRvbmJyaWRnZScpKSB7XG5cdGNvbnN0IE1FTlVCVVRUT05fREVGUyA9IHt9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBNZW51QnV0dG9uQnJpZGdlIFJlYWN0IGNsYXNzIGZvciBhIGdpdmVuIG1lbnVCdXR0b24gZGVmaW5pdGlvbiBpZiBpdCBoYXMgbm90IGJlZW5cblx0ICogYWxyZWFkeSBjcmVhdGVkIGJhc2VkIG9uIHRoZSBidXR0b24gbmFtZSBhbmQgZGVmaW5pdGlvbi5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG1ldGhvZCBnZW5lcmF0ZU1lbnVCdXR0b25CcmlkZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1lbnVCdXR0b25OYW1lIFRoZSBtZW51QnV0dG9uJ3MgbmFtZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gbWVudUJ1dHRvbkRlZmluaXRpb24gVGhlIG1lbnVCdXR0b24ncyBkZWZpbml0aW9uXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGdlbmVyYXRlZCBvciBhbHJlYWR5IGV4aXN0aW5nIFJlYWN0IE1lbnVCdXR0b24gQ2xhc3Ncblx0ICovXG5cdGZ1bmN0aW9uIGdlbmVyYXRlTWVudUJ1dHRvbkJyaWRnZShcblx0XHRtZW51QnV0dG9uTmFtZSxcblx0XHRtZW51QnV0dG9uRGVmaW5pdGlvbixcblx0XHRlZGl0b3Jcblx0KSB7XG5cdFx0bGV0IE1lbnVCdXR0b25CcmlkZ2UgPSBBbGxveUVkaXRvci5CdXR0b25zW21lbnVCdXR0b25OYW1lXTtcblxuXHRcdE1FTlVCVVRUT05fREVGU1tlZGl0b3IubmFtZV0gPSBNRU5VQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdIHx8IHt9O1xuXHRcdE1FTlVCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bbWVudUJ1dHRvbk5hbWVdID1cblx0XHRcdE1FTlVCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bbWVudUJ1dHRvbk5hbWVdIHx8XG5cdFx0XHRtZW51QnV0dG9uRGVmaW5pdGlvbjtcblxuXHRcdGlmICghTWVudUJ1dHRvbkJyaWRnZSkge1xuXHRcdFx0TWVudUJ1dHRvbkJyaWRnZSA9IGNsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0XHRcdFx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRcdFx0XHRzdGF0aWMgZGlzcGxheU5hbWUgPSBtZW51QnV0dG9uTmFtZTtcblxuXHRcdFx0XHRzdGF0aWMga2V5ID0gbWVudUJ1dHRvbk5hbWU7XG5cblx0XHRcdFx0Ly8gQVBJIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW5zaWRlIHRoZSBtZW51YnV0dG9uXG5cdFx0XHRcdC8vIGJyaWRnZS4gQnkgbW9ja2luZyB0aGUgdW5zdXBwb3J0ZWQgbWV0aG9kLCB3ZSBwcmV2ZW50XG5cdFx0XHRcdC8vIHBsdWdpbnMgZnJvbSBjcmFzaGluZyBpZiB0aGV5IG1ha2UgdXNlIG9mIGl0LlxuXG5cdFx0XHRcdHRvRmVhdHVyZSgpIHt9XG5cblx0XHRcdFx0cmVuZGVyKCkge1xuXHRcdFx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0XHRcdGNvbnN0IHBhbmVsTWVudUJ1dHRvbkRpc3BsYXlOYW1lID1cblx0XHRcdFx0XHRcdE1FTlVCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bbWVudUJ1dHRvbk5hbWVdLm5hbWUgfHxcblx0XHRcdFx0XHRcdE1FTlVCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bbWVudUJ1dHRvbk5hbWVdLmNvbW1hbmQgfHxcblx0XHRcdFx0XHRcdG1lbnVCdXR0b25OYW1lO1xuXG5cdFx0XHRcdFx0Y29uc3QgYnV0dG9uQ2xhc3NOYW1lID0gJ2FlLWJ1dHRvbiBhZS1idXR0b24tYnJpZGdlJztcblxuXHRcdFx0XHRcdGNvbnN0IGljb25DbGFzc05hbWUgPVxuXHRcdFx0XHRcdFx0J2FlLWljb24tJyArIHBhbmVsTWVudUJ1dHRvbkRpc3BsYXlOYW1lO1xuXG5cdFx0XHRcdFx0Y29uc3QgaWNvblN0eWxlID0ge307XG5cblx0XHRcdFx0XHRjb25zdCBjc3NTdHlsZSA9IENLRURJVE9SLnNraW4uZ2V0SWNvblN0eWxlKFxuXHRcdFx0XHRcdFx0cGFuZWxNZW51QnV0dG9uRGlzcGxheU5hbWVcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKGNzc1N0eWxlKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjc3NTdHlsZVBhcnRzID0gY3NzU3R5bGUuc3BsaXQoJzsnKTtcblxuXHRcdFx0XHRcdFx0aWNvblN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGNzc1N0eWxlUGFydHNbMF0uc3Vic3RyaW5nKFxuXHRcdFx0XHRcdFx0XHRjc3NTdHlsZVBhcnRzWzBdLmluZGV4T2YoJzonKSArIDFcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRpY29uU3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gY3NzU3R5bGVQYXJ0c1sxXS5zdWJzdHJpbmcoXG5cdFx0XHRcdFx0XHRcdGNzc1N0eWxlUGFydHNbMV0uaW5kZXhPZignOicpICsgMVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGljb25TdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IGNzc1N0eWxlUGFydHNbMl0uc3Vic3RyaW5nKFxuXHRcdFx0XHRcdFx0XHRjc3NTdHlsZVBhcnRzWzJdLmluZGV4T2YoJzonKSArIDFcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyIGFlLWhhcy1kcm9wZG93blwiPlxuXHRcdFx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRcdFx0YXJpYS1leHBhbmRlZD17dGhpcy5wcm9wcy5leHBhbmRlZH1cblx0XHRcdFx0XHRcdFx0XHRhcmlhLWxhYmVsPXtcblx0XHRcdFx0XHRcdFx0XHRcdE1FTlVCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bbWVudUJ1dHRvbk5hbWVdXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5sYWJlbFxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9e2J1dHRvbkNsYXNzTmFtZX1cblx0XHRcdFx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdFx0XHRcdHJvbGU9XCJjb21ib2JveFwiXG5cdFx0XHRcdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0XHRcdFx0dGl0bGU9e1xuXHRcdFx0XHRcdFx0XHRcdFx0TUVOVUJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVttZW51QnV0dG9uTmFtZV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0LmxhYmVsXG5cdFx0XHRcdFx0XHRcdFx0fT5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXtpY29uQ2xhc3NOYW1lfVxuXHRcdFx0XHRcdFx0XHRcdFx0c3R5bGU9e2ljb25TdHlsZX1cblx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHRcdFx0e3RoaXMucHJvcHMuZXhwYW5kZWQgJiYgKFxuXHRcdFx0XHRcdFx0XHRcdDxCdXR0b25Ecm9wZG93blxuXHRcdFx0XHRcdFx0XHRcdFx0b25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufT5cblx0XHRcdFx0XHRcdFx0XHRcdHt0aGlzLl9nZXRNZW51SXRlbXMoKX1cblx0XHRcdFx0XHRcdFx0XHQ8L0J1dHRvbkRyb3Bkb3duPlxuXHRcdFx0XHRcdFx0XHQpfVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nZXRNZW51SXRlbXMoKSB7XG5cdFx0XHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdFx0XHRcdGNvbnN0IGl0ZW1zID0gbWVudUJ1dHRvbkRlZmluaXRpb24ub25NZW51KCk7XG5cdFx0XHRcdFx0Y29uc3QgbWVudUl0ZW1zID0gT2JqZWN0LmtleXMoaXRlbXMpLm1hcChrZXkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgbWVudUl0ZW0gPSBlZGl0b3IuZ2V0TWVudUl0ZW0oa2V5KTtcblxuXHRcdFx0XHRcdFx0aWYgKCFtZW51SXRlbSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgbWVudUl0ZW1EZWZpbml0aW9uID1cblx0XHRcdFx0XHRcdFx0bWVudUl0ZW0uZGVmaW5pdGlvbiB8fCBtZW51SXRlbTtcblx0XHRcdFx0XHRcdGNvbnN0IG1lbnVJdGVtU3RhdGUgPSBpdGVtc1trZXldO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBjbGFzc05hbWUgPVxuXHRcdFx0XHRcdFx0XHQnYWUtdG9vbGJhci1lbGVtZW50ICcgK1xuXHRcdFx0XHRcdFx0XHQobWVudUl0ZW1TdGF0ZSA9PT0gQ0tFRElUT1IuVFJJU1RBVEVfT05cblx0XHRcdFx0XHRcdFx0XHQ/ICdhY3RpdmUnXG5cdFx0XHRcdFx0XHRcdFx0OiAnJyk7XG5cdFx0XHRcdFx0XHRjb25zdCBkaXNhYmxlZCA9XG5cdFx0XHRcdFx0XHRcdG1lbnVJdGVtU3RhdGUgPT09IENLRURJVE9SLlRSSVNUQVRFX0RJU0FCTEVEO1xuXHRcdFx0XHRcdFx0Y29uc3Qgb25DbGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRpZiAobWVudUl0ZW1EZWZpbml0aW9uLmNvbW1hbmQpIHtcblx0XHRcdFx0XHRcdFx0XHRlZGl0b3IuZXhlY0NvbW1hbmQobWVudUl0ZW1EZWZpbml0aW9uLmNvbW1hbmQpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG1lbnVJdGVtRGVmaW5pdGlvbi5vbkNsaWNrKSB7XG5cdFx0XHRcdFx0XHRcdFx0bWVudUl0ZW1EZWZpbml0aW9uLm9uQ2xpY2suYXBwbHkoXG5cdFx0XHRcdFx0XHRcdFx0XHRtZW51SXRlbURlZmluaXRpb25cblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHQ8bGkga2V5PXttZW51SXRlbS5uYW1lfSByb2xlPVwib3B0aW9uXCI+XG5cdFx0XHRcdFx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc05hbWV9XG5cdFx0XHRcdFx0XHRcdFx0XHRkaXNhYmxlZD17ZGlzYWJsZWR9XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkNsaWNrPXtvbkNsaWNrfT5cblx0XHRcdFx0XHRcdFx0XHRcdHttZW51SXRlbURlZmluaXRpb24ubGFiZWx9XG5cdFx0XHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG1lbnVJdGVtcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0QWxsb3lFZGl0b3IuQnV0dG9uc1ttZW51QnV0dG9uTmFtZV0gPSBNZW51QnV0dG9uQnJpZGdlO1xuXHRcdH1cblxuXHRcdHJldHVybiBNZW51QnV0dG9uQnJpZGdlO1xuXHR9XG5cblx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0aWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnbWVudWJ1dHRvbicpKSB7XG5cdFx0Q0tFRElUT1IuVUlfTUVOVV9CVVRUT04gPSAnbWVudWJ1dHRvbic7XG5cblx0XHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnbWVudWJ1dHRvbicsIHt9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gdGhhdCBicmlkZ2VzIHRoZSBzdXBwb3J0IG9mZmVyZWQgYnkgQ0tFZGl0b3IgTWVudUJ1dHRvbiBwbHVnaW4uIEl0IHRha2VzIG92ZXIgdGhlXG5cdCAqIHJlc3BvbnNpYmlsaXR5IG9mIHJlZ2lzdGVyaW5nIGFuZCBjcmVhdGluZyBtZW51QnV0dG9ucyB2aWE6XG5cdCAqIC0gZWRpdG9yLnVpLmFkZE1lbnVCdXR0b24obmFtZSwgZGVmaW5pdGlvbilcblx0ICogLSBlZGl0b3IudWkuYWRkKG5hbWUsIENLRURJVE9SLlVJX01FTlVCVVRUT04sIGRlZmluaXRpb24pXG5cdCAqXG5cdCAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX21lbnVidXR0b25icmlkZ2Vcblx0ICogQHJlcXVpcmVzIENLRURJVE9SLnBsdWdpbnMuYWVfdWlicmlkZ2Vcblx0ICogQHJlcXVpcmVzIENLRURJVE9SLnBsdWdpbnMuYWVfbWVudWJyaWRnZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV9tZW51YnV0dG9uYnJpZGdlJywge1xuXHRcdHJlcXVpcmVzOiBbJ2FlX3VpYnJpZGdlJywgJ2FlX21lbnVicmlkZ2UnXSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgYWRkIGhhbmRsZXIgZm9yIFVJX01FTlVCVVRUT04gdG8gb3VyIG93bi4gV2UgZG8gdGhpcyBpbiB0aGUgaW5pdCBwaGFzZSB0byBvdmVycmlkZVxuXHRcdCAqIHRoZSBvbmUgaW4gdGhlIG5hdGl2ZSBwbHVnaW4gaW4gY2FzZSBpdCdzIHByZXNlbnQuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIGluaXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBDS0VkaXRvciBpbnN0YW5jZSBiZWluZyBpbml0aWFsaXplZFxuXHRcdCAqL1xuXHRcdGJlZm9yZUluaXQoZWRpdG9yKSB7XG5cdFx0XHRNRU5VQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdID0ge307XG5cblx0XHRcdGVkaXRvci51aS5hZGRNZW51QnV0dG9uID0gZnVuY3Rpb24oXG5cdFx0XHRcdG1lbnVCdXR0b25OYW1lLFxuXHRcdFx0XHRtZW51QnV0dG9uRGVmaW5pdGlvblxuXHRcdFx0KSB7XG5cdFx0XHRcdHRoaXMuYWRkKFxuXHRcdFx0XHRcdG1lbnVCdXR0b25OYW1lLFxuXHRcdFx0XHRcdENLRURJVE9SLlVJX01FTlVCVVRUT04sXG5cdFx0XHRcdFx0bWVudUJ1dHRvbkRlZmluaXRpb25cblx0XHRcdFx0KTtcblx0XHRcdH07XG5cblx0XHRcdGVkaXRvci51aS5hZGRIYW5kbGVyKENLRURJVE9SLlVJX01FTlVCVVRUT04sIHtcblx0XHRcdFx0YWRkOiBnZW5lcmF0ZU1lbnVCdXR0b25CcmlkZ2UsXG5cdFx0XHRcdGNyZWF0ZShtZW51QnV0dG9uRGVmaW5pdGlvbikge1xuXHRcdFx0XHRcdGNvbnN0IG1lbnVCdXR0b25OYW1lID1cblx0XHRcdFx0XHRcdCdidXR0b25CcmlkZ2UnICsgKChNYXRoLnJhbmRvbSgpICogMWU5KSA+Pj4gMCk7XG5cdFx0XHRcdFx0Y29uc3QgTWVudUJ1dHRvbkJyaWRnZSA9IGdlbmVyYXRlTWVudUJ1dHRvbkJyaWRnZShcblx0XHRcdFx0XHRcdG1lbnVCdXR0b25OYW1lLFxuXHRcdFx0XHRcdFx0bWVudUJ1dHRvbkRlZmluaXRpb25cblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBNZW51QnV0dG9uQnJpZGdlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblx0XHR9LFxuXHR9KTtcbn1cbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9tZW51YnJpZGdlJykpIHtcblx0LyoqXG5cdCAqIENLRWRpdG9yIHBsdWdpbiB0aGF0IGJyaWRnZXMgdGhlIHN1cHBvcnQgb2ZmZXJlZCBieSBDS0VkaXRvciBNZW51IHBsdWdpbi4gSXQgdGFrZXMgb3ZlciB0aGVcblx0ICogcmVzcG9uc2liaWxpdHkgb2YgYWRkaW5nLCByZW1vdmluZyBhbmQgcmV0cmlldmluZyBtZW51IGdyb3VwcyBhbmQgaXRlbXNcblx0ICogLSBlZGl0b3IuYWRkTWVudUdyb3VwKG5hbWUsIG9yZGVyKVxuXHQgKiAtIGVkaXRvci5hZGRNZW51SXRlbShuYW1lLCBkZWZpbml0aW9uKVxuXHQgKiAtIGVkaXRvci5hZGRNZW51SXRlbXMoZGVmaW5pdGlvbnMpXG5cdCAqIC0gZWRpdG9yLmdldE1lbnVJdGVtKG5hbWUpXG5cdCAqIC0gZWRpdG9yLnJlbW92ZU1lbnVJdGVtKG5hbWUpXG5cdCAqXG5cdCAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX21lbnVicmlkZ2Vcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfbWVudWJyaWRnZScsIHtcblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIGFkZCBoYW5kbGVyIGZvciBVSV9CVVRUT04gdG8gb3VyIG93bi4gV2UgZG8gdGhpcyBpbiB0aGUgaW5pdCBwaGFzZSB0byBvdmVycmlkZVxuXHRcdCAqIHRoZSBvbmUgaW4gdGhlIG5hdGl2ZSBwbHVnaW4gaW4gY2FzZSBpdCdzIHByZXNlbnQuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIGluaXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBDS0VkaXRvciBpbnN0YW5jZSBiZWluZyBpbml0aWFsaXplZFxuXHRcdCAqL1xuXHRcdGJlZm9yZUluaXQoZWRpdG9yKSB7XG5cdFx0XHQvLyBEbyBub3RoaW5nIGlmIHRoZSByZWFsIG1lbnUgcGx1Z2luIGlzIHByZXNlbnRcblxuXHRcdFx0aWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdtZW51JykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBncm91cHMgPSBbXTtcblx0XHRcdGNvbnN0IGdyb3Vwc09yZGVyID0gKGVkaXRvci5fLm1lbnVHcm91cHMgPSB7fSk7XG5cdFx0XHRjb25zdCBtZW51SXRlbXMgPSAoZWRpdG9yLl8ubWVudUl0ZW1zID0ge30pO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRncm91cHNPcmRlcltncm91cHNbaV1dID0gaSArIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmVnaXN0ZXJzIGFuIGl0ZW0gZ3JvdXAgdG8gdGhlIGVkaXRvciBjb250ZXh0IG1lbnUgaW4gb3JkZXIgdG8gbWFrZSBpdFxuXHRcdFx0ICogcG9zc2libGUgdG8gYXNzb2NpYXRlIGl0IHdpdGggbWVudSBpdGVtcyBsYXRlci5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWV0aG9kIGFkZE1lbnVHcm91cFxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgU3BlY2lmeSBhIGdyb3VwIG5hbWUuXG5cdFx0XHQgKiBAcGFyYW0ge051bWJlcn0gW29yZGVyPTEwMF0gRGVmaW5lIHRoZSBkaXNwbGF5IHNlcXVlbmNlIG9mIHRoaXMgZ3JvdXBcblx0XHRcdCAqIGluc2lkZSB0aGUgbWVudS4gQSBzbWFsbGVyIHZhbHVlIGdldHMgZGlzcGxheWVkIGZpcnN0LlxuXHRcdFx0ICovXG5cdFx0XHRlZGl0b3IuYWRkTWVudUdyb3VwID0gZnVuY3Rpb24obmFtZSwgb3JkZXIpIHtcblx0XHRcdFx0Z3JvdXBzT3JkZXJbbmFtZV0gPSBvcmRlciB8fCAxMDA7XG5cdFx0XHR9O1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFkZHMgYW4gaXRlbSBmcm9tIHRoZSBzcGVjaWZpZWQgZGVmaW5pdGlvbiB0byB0aGUgZWRpdG9yIGNvbnRleHQgbWVudS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWV0aG9kIGFkZE1lbnVJdGVtXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbWVudSBpdGVtIG5hbWUuXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZGVmaW5pdGlvbiBUaGUgbWVudSBpdGVtIGRlZmluaXRpb24uXG5cdFx0XHQgKi9cblx0XHRcdGVkaXRvci5hZGRNZW51SXRlbSA9IGZ1bmN0aW9uKG5hbWUsIGRlZmluaXRpb24pIHtcblx0XHRcdFx0aWYgKGdyb3Vwc09yZGVyW2RlZmluaXRpb24uZ3JvdXBdKSB7XG5cdFx0XHRcdFx0bWVudUl0ZW1zW25hbWVdID0ge1xuXHRcdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRcdGRlZmluaXRpb24sXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBZGRzIG9uZSBvciBtb3JlIGl0ZW1zIGZyb20gdGhlIHNwZWNpZmllZCBkZWZpbml0aW9uIG9iamVjdCB0byB0aGUgZWRpdG9yIGNvbnRleHQgbWVudS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWV0aG9kIGFkZE1lbnVJdGVtc1xuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGRlZmluaXRpb25zIE9iamVjdCB3aGVyZSBrZXlzIGFyZSB1c2VkIGFzIGl0ZW1OYW1lIGFuZCBjb3JyZXNwb25kaW5nIHZhbHVlcyBhcyBkZWZpbml0aW9uIGZvciBhIHtAbGluayAjYWRkTWVudUl0ZW19IGNhbGwuXG5cdFx0XHQgKi9cblx0XHRcdGVkaXRvci5hZGRNZW51SXRlbXMgPSBmdW5jdGlvbihkZWZpbml0aW9ucykge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGl0ZW1OYW1lIGluIGRlZmluaXRpb25zKSB7XG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuXHRcdFx0XHRcdFx0XHRkZWZpbml0aW9ucyxcblx0XHRcdFx0XHRcdFx0aXRlbU5hbWVcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdHRoaXMuYWRkTWVudUl0ZW0oaXRlbU5hbWUsIGRlZmluaXRpb25zW2l0ZW1OYW1lXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHJpZXZlcyBhIHBhcnRpY3VsYXIgbWVudSBpdGVtIGRlZmluaXRpb24gZnJvbSB0aGUgZWRpdG9yIGNvbnRleHQgbWVudS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWV0aG9kIGdldE1lbnVJdGVtXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVzaXJlZCBtZW51IGl0ZW0uXG5cdFx0XHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdFx0XHQgKi9cblx0XHRcdGVkaXRvci5nZXRNZW51SXRlbSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIG1lbnVJdGVtc1tuYW1lXTtcblx0XHRcdH07XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmVtb3ZlcyBhIHBhcnRpY3VsYXIgbWVudSBpdGVtIGFkZGVkIGJlZm9yZSBmcm9tIHRoZSBlZGl0b3IgY29udGV4dCBtZW51LlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZXRob2QgIHJlbW92ZU1lbnVJdGVtXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVzaXJlZCBtZW51IGl0ZW0uXG5cdFx0XHQgKi9cblx0XHRcdGVkaXRvci5yZW1vdmVNZW51SXRlbSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0ZGVsZXRlIG1lbnVJdGVtc1tuYW1lXTtcblx0XHRcdH07XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJy4uL2J1dHRvbnMvYnV0dG9uLWRyb3Bkb3duLmpzeCc7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfcGFuZWxtZW51YnV0dG9uYnJpZGdlJykpIHtcblx0Y29uc3QgUEFORUxfTUVOVV9ERUZTID0ge307XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIFBhbmVsTWVudUJ1dHRvbkJyaWRnZSBSZWFjdCBjbGFzcyBmb3IgYSBnaXZlbiBwYW5lbG1lbnVidXR0b24gZGVmaW5pdGlvbiBpZiBpdCBoYXMgbm90IGJlZW5cblx0ICogYWxyZWFkeSBjcmVhdGVkIGJhc2VkIG9uIHRoZSBwYW5lbG1lbnVidXR0b24gbmFtZSBhbmQgZGVmaW5pdGlvbi5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG1ldGhvZCBnZW5lcmF0ZVBhbmVsTWVudUJ1dHRvbkJyaWRnZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGFuZWxNZW51QnV0dG9uTmFtZSBUaGUgcGFuZWwgYnV0dG9uIG5hbWVcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhbmVsTWVudUJ1dHRvbkRlZmluaXRpb24gVGhlIHBhbmVsIGJ1dHRvbiBkZWZpbml0aW9uXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGdlbmVyYXRlZCBvciBhbHJlYWR5IGV4aXN0aW5nIFJlYWN0IFBhbmVsTWVudUJ1dHRvbiBDbGFzc1xuXHQgKi9cblx0Y29uc3QgZ2VuZXJhdGVQYW5lbE1lbnVCdXR0b25CcmlkZ2UgPSBmdW5jdGlvbihcblx0XHRwYW5lbE1lbnVCdXR0b25OYW1lLFxuXHRcdHBhbmVsTWVudUJ1dHRvbkRlZmluaXRpb24sXG5cdFx0ZWRpdG9yXG5cdCkge1xuXHRcdGxldCBQYW5lbE1lbnVCdXR0b25CcmlkZ2UgPSBBbGxveUVkaXRvci5CdXR0b25zW3BhbmVsTWVudUJ1dHRvbk5hbWVdO1xuXG5cdFx0UEFORUxfTUVOVV9ERUZTW2VkaXRvci5uYW1lXSA9IFBBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV0gfHwge307XG5cdFx0UEFORUxfTUVOVV9ERUZTW2VkaXRvci5uYW1lXVtwYW5lbE1lbnVCdXR0b25OYW1lXSA9XG5cdFx0XHRQQU5FTF9NRU5VX0RFRlNbZWRpdG9yLm5hbWVdW3BhbmVsTWVudUJ1dHRvbk5hbWVdIHx8XG5cdFx0XHRwYW5lbE1lbnVCdXR0b25EZWZpbml0aW9uO1xuXG5cdFx0aWYgKCFQYW5lbE1lbnVCdXR0b25CcmlkZ2UpIHtcblx0XHRcdFBhbmVsTWVudUJ1dHRvbkJyaWRnZSA9IGNsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0XHRcdFx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRcdFx0XHRzdGF0aWMgZGlzcGxheU5hbWUgPSBwYW5lbE1lbnVCdXR0b25OYW1lO1xuXG5cdFx0XHRcdHN0YXRpYyBrZXkgPSBwYW5lbE1lbnVCdXR0b25OYW1lO1xuXG5cdFx0XHRcdC8vIEFQSSBub3QgeWV0IGltcGxlbWVudGVkIGluc2lkZSB0aGUgcGFuZWwgbWVudSBidXR0b24gYnJpZGdlLiBCeSBtb2NraW5nIHRoZSB1bnN1cHBvcnRlZCBtZXRob2RzLCB3ZVxuXHRcdFx0XHQvLyBwcmV2ZW50IHBsdWdpbnMgZnJvbSBjcmFzaGluZyBpZiB0aGV5IG1ha2UgdXNlIG9mIHRoZW0uXG5cblx0XHRcdFx0Y3JlYXRlUGFuZWwoKSB7fVxuXG5cdFx0XHRcdHJlbmRlcigpIHtcblx0XHRcdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdFx0XHRjb25zdCBwYW5lbE1lbnVCdXR0b25EaXNwbGF5TmFtZSA9XG5cdFx0XHRcdFx0XHRQQU5FTF9NRU5VX0RFRlNbZWRpdG9yLm5hbWVdW3BhbmVsTWVudUJ1dHRvbk5hbWVdXG5cdFx0XHRcdFx0XHRcdC5uYW1lIHx8XG5cdFx0XHRcdFx0XHRQQU5FTF9NRU5VX0RFRlNbZWRpdG9yLm5hbWVdW3BhbmVsTWVudUJ1dHRvbk5hbWVdXG5cdFx0XHRcdFx0XHRcdC5jb21tYW5kIHx8XG5cdFx0XHRcdFx0XHRwYW5lbE1lbnVCdXR0b25OYW1lO1xuXG5cdFx0XHRcdFx0Y29uc3QgYnV0dG9uQ2xhc3NOYW1lID0gJ2FlLWJ1dHRvbiBhZS1idXR0b24tYnJpZGdlJztcblxuXHRcdFx0XHRcdGNvbnN0IGljb25DbGFzc05hbWUgPVxuXHRcdFx0XHRcdFx0J2FlLWljb24tJyArIHBhbmVsTWVudUJ1dHRvbkRpc3BsYXlOYW1lO1xuXG5cdFx0XHRcdFx0Y29uc3QgaWNvblN0eWxlID0ge307XG5cblx0XHRcdFx0XHRjb25zdCBjc3NTdHlsZSA9IENLRURJVE9SLnNraW4uZ2V0SWNvblN0eWxlKFxuXHRcdFx0XHRcdFx0cGFuZWxNZW51QnV0dG9uRGlzcGxheU5hbWVcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKGNzc1N0eWxlKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjc3NTdHlsZVBhcnRzID0gY3NzU3R5bGUuc3BsaXQoJzsnKTtcblxuXHRcdFx0XHRcdFx0aWNvblN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGNzc1N0eWxlUGFydHNbMF0uc3Vic3RyaW5nKFxuXHRcdFx0XHRcdFx0XHRjc3NTdHlsZVBhcnRzWzBdLmluZGV4T2YoJzonKSArIDFcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRpY29uU3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gY3NzU3R5bGVQYXJ0c1sxXS5zdWJzdHJpbmcoXG5cdFx0XHRcdFx0XHRcdGNzc1N0eWxlUGFydHNbMV0uaW5kZXhPZignOicpICsgMVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGljb25TdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IGNzc1N0eWxlUGFydHNbMl0uc3Vic3RyaW5nKFxuXHRcdFx0XHRcdFx0XHRjc3NTdHlsZVBhcnRzWzJdLmluZGV4T2YoJzonKSArIDFcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IHBhbmVsO1xuXG5cdFx0XHRcdFx0aWYgKHRoaXMucHJvcHMuZXhwYW5kZWQpIHtcblx0XHRcdFx0XHRcdHBhbmVsID0gdGhpcy5fZ2V0UGFuZWwoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXIgYWUtaGFzLWRyb3Bkb3duXCI+XG5cdFx0XHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfVxuXHRcdFx0XHRcdFx0XHRcdGFyaWEtbGFiZWw9e1xuXHRcdFx0XHRcdFx0XHRcdFx0UEFORUxfTUVOVV9ERUZTW2VkaXRvci5uYW1lXVtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFuZWxNZW51QnV0dG9uTmFtZVxuXHRcdFx0XHRcdFx0XHRcdFx0XS5sYWJlbFxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9e2J1dHRvbkNsYXNzTmFtZX1cblx0XHRcdFx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdFx0XHRcdHJvbGU9XCJjb21ib2JveFwiXG5cdFx0XHRcdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0XHRcdFx0dGl0bGU9e1xuXHRcdFx0XHRcdFx0XHRcdFx0UEFORUxfTUVOVV9ERUZTW2VkaXRvci5uYW1lXVtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFuZWxNZW51QnV0dG9uTmFtZVxuXHRcdFx0XHRcdFx0XHRcdFx0XS5sYWJlbFxuXHRcdFx0XHRcdFx0XHRcdH0+XG5cdFx0XHRcdFx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17aWNvbkNsYXNzTmFtZX1cblx0XHRcdFx0XHRcdFx0XHRcdHN0eWxlPXtpY29uU3R5bGV9XG5cdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0XHRcdHtwYW5lbH1cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZ2V0UGFuZWwoKSB7XG5cdFx0XHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRcdFx0Y29uc3QgcGFuZWxNZW51QnV0dG9uT25CbG9jayA9XG5cdFx0XHRcdFx0XHRQQU5FTF9NRU5VX0RFRlNbZWRpdG9yLm5hbWVdW3BhbmVsTWVudUJ1dHRvbk5hbWVdXG5cdFx0XHRcdFx0XHRcdC5vbkJsb2NrO1xuXG5cdFx0XHRcdFx0Y29uc3QgcGFuZWwgPSB7XG5cdFx0XHRcdFx0XHRoaWRlOiB0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3duLFxuXHRcdFx0XHRcdFx0c2hvdzogdGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bixcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Y29uc3QgYmxvY2tFbGVtZW50ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCdkaXYnKTtcblxuXHRcdFx0XHRcdGNvbnN0IGJsb2NrID0ge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogYmxvY2tFbGVtZW50LFxuXHRcdFx0XHRcdFx0a2V5czoge30sXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdFx0XHRcdFx0aWYgKHBhbmVsTWVudUJ1dHRvbk9uQmxvY2spIHtcblx0XHRcdFx0XHRcdHBhbmVsTWVudUJ1dHRvbk9uQmxvY2suY2FsbCh0aGlzLCBwYW5lbCwgYmxvY2spO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFRPRE9cblx0XHRcdFx0XHQvLyBVc2UgYmxvY2sua2V5cyB0byBjb25maWd1cmUgdGhlIHBhbmVsIGtleWJvYXJkIG5hdmlnYXRpb25cblxuXHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHQ8QnV0dG9uRHJvcGRvd24gb25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufT5cblx0XHRcdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17YmxvY2tFbGVtZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKX1cblx0XHRcdFx0XHRcdFx0XHRkYW5nZXJvdXNseVNldElubmVySFRNTD17e1xuXHRcdFx0XHRcdFx0XHRcdFx0X19odG1sOiBibG9ja0VsZW1lbnQuZ2V0SHRtbCgpLFxuXHRcdFx0XHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHQ8L0J1dHRvbkRyb3Bkb3duPlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdEFsbG95RWRpdG9yLkJ1dHRvbnNbcGFuZWxNZW51QnV0dG9uTmFtZV0gPSBQYW5lbE1lbnVCdXR0b25CcmlkZ2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFBhbmVsTWVudUJ1dHRvbkJyaWRnZTtcblx0fTtcblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHRpZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdwYW5lbG1lbnVidXR0b24nKSkge1xuXHRcdENLRURJVE9SLlVJX1BBTkVMQlVUVE9OID0gJ3BhbmVsbWVudWJ1dHRvbic7XG5cblx0XHRDS0VESVRPUi5wbHVnaW5zLmFkZCgncGFuZWxtZW51YnV0dG9uJywge30pO1xuXHR9XG5cblx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0aWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgncGFuZWxidXR0b24nKSkge1xuXHRcdENLRURJVE9SLlVJX1BBTkVMQlVUVE9OID0gJ3BhbmVsYnV0dG9uJztcblxuXHRcdENLRURJVE9SLnBsdWdpbnMuYWRkKCdwYW5lbGJ1dHRvbicsIHt9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gdGhhdCBicmlkZ2VzIHRoZSBzdXBwb3J0IG9mZmVyZWQgYnkgQ0tFZGl0b3IgUGFuZWxCdXR0b24gcGx1Z2luLiBJdCB0YWtlcyBvdmVyIHRoZVxuXHQgKiByZXNwb25zaWJpbGl0eSBvZiByZWdpc3RlcmluZyBhbmQgY3JlYXRpbmcgYnV0dG9ucyB2aWE6XG5cdCAqIC0gZWRpdG9yLnVpLmFkZFBhbmVsTWVudUJ1dHRvbihuYW1lLCBkZWZpbml0aW9uKVxuXHQgKiAtIGVkaXRvci51aS5hZGQobmFtZSwgQ0tFRElUT1IuVUlfUEFORUxCVVRUT04sIGRlZmluaXRpb24pXG5cdCAqXG5cdCAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX3BhbmVsbWVudWJ1dHRvbmJyaWRnZVxuXHQgKiBAcmVxdWlyZXMgQ0tFRElUT1IucGx1Z2lucy5hZV91aWJyaWRnZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV9wYW5lbG1lbnVidXR0b25icmlkZ2UnLCB7XG5cdFx0cmVxdWlyZXM6IFsnYWVfdWlicmlkZ2UnXSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgYWRkIGhhbmRsZXIgZm9yIFVJX1BBTkVMQlVUVE9OIHRvIG91ciBvd24uIFdlIGRvIHRoaXMgaW4gdGhlIGluaXQgcGhhc2UgdG8gb3ZlcnJpZGVcblx0XHQgKiB0aGUgb25lIGluIHRoZSBuYXRpdmUgcGx1Z2luIGluIGNhc2UgaXQncyBwcmVzZW50XG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIGluaXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBDS0VkaXRvciBpbnN0YW5jZSBiZWluZyBpbml0aWFsaXplZFxuXHRcdCAqL1xuXHRcdGJlZm9yZUluaXQoZWRpdG9yKSB7XG5cdFx0XHRQQU5FTF9NRU5VX0RFRlNbZWRpdG9yLm5hbWVdID0ge307XG5cblx0XHRcdGVkaXRvci51aS5hZGRQYW5lbE1lbnVCdXR0b24gPSBmdW5jdGlvbihcblx0XHRcdFx0cGFuZWxNZW51QnV0dG9uTmFtZSxcblx0XHRcdFx0cGFuZWxNZW51QnV0dG9uRGVmaW5pdGlvblxuXHRcdFx0KSB7XG5cdFx0XHRcdHRoaXMuYWRkKFxuXHRcdFx0XHRcdHBhbmVsTWVudUJ1dHRvbk5hbWUsXG5cdFx0XHRcdFx0Q0tFRElUT1IuVUlfUEFORUxCVVRUT04sXG5cdFx0XHRcdFx0cGFuZWxNZW51QnV0dG9uRGVmaW5pdGlvblxuXHRcdFx0XHQpO1xuXHRcdFx0fTtcblxuXHRcdFx0ZWRpdG9yLnVpLmFkZEhhbmRsZXIoQ0tFRElUT1IuVUlfUEFORUxCVVRUT04sIHtcblx0XHRcdFx0YWRkOiBnZW5lcmF0ZVBhbmVsTWVudUJ1dHRvbkJyaWRnZSxcblx0XHRcdFx0Y3JlYXRlKHBhbmVsTWVudUJ1dHRvbkRlZmluaXRpb24pIHtcblx0XHRcdFx0XHRjb25zdCBwYW5lbE1lbnVCdXR0b25OYW1lID1cblx0XHRcdFx0XHRcdCdwYW5lbE1lbnVCdXR0b25CcmlkZ2UnICsgKChNYXRoLnJhbmRvbSgpICogMWU5KSA+Pj4gMCk7XG5cdFx0XHRcdFx0Y29uc3QgUGFuZWxNZW51QnV0dG9uQnJpZGdlID0gZ2VuZXJhdGVQYW5lbE1lbnVCdXR0b25CcmlkZ2UoXG5cdFx0XHRcdFx0XHRwYW5lbE1lbnVCdXR0b25OYW1lLFxuXHRcdFx0XHRcdFx0cGFuZWxNZW51QnV0dG9uRGVmaW5pdGlvblxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFBhbmVsTWVudUJ1dHRvbkJyaWRnZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJy4uL2J1dHRvbnMvYnV0dG9uLWRyb3Bkb3duLmpzeCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuLi9idXR0b25zL2J1dHRvbi1pY29uLmpzeCc7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfcmljaGNvbWJvYnJpZGdlJykpIHtcblx0Y29uc3QgUklDSF9DT01CT19ERUZTID0ge307XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIFJpY2hDb21ib0JyaWRnZSBSZWFjdCBjbGFzcyBmb3IgYSBnaXZlbiByaWNoY29tYm8gZGVmaW5pdGlvbiBpZiBpdCBoYXMgbm90IGJlZW5cblx0ICogYWxyZWFkeSBjcmVhdGVkIGJhc2VkIG9uIHRoZSByaWNoY29tYm8gbmFtZSBhbmQgZGVmaW5pdGlvbi5cblx0ICpcblx0ICogQG1ldGhvZCBnZW5lcmF0ZVJpY2hDb21ib0JyaWRnZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcmljaENvbWJvTmFtZSBUaGUgcmljaCBjb21ibyBuYW1lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByaWNoQ29tYm9EZWZpbml0aW9uIFRoZSByaWNoIGNvbWJvIGRlZmluaXRpb25cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZ2VuZXJhdGVkIG9yIGFscmVhZHkgZXhpc3RpbmcgUmVhY3QgUmljaENvbWJvIENsYXNzXG5cdCAqL1xuXHRjb25zdCBnZW5lcmF0ZVJpY2hDb21ib0JyaWRnZSA9IGZ1bmN0aW9uKFxuXHRcdHJpY2hDb21ib05hbWUsXG5cdFx0cmljaENvbWJvRGVmaW5pdGlvbixcblx0XHRlZGl0b3Jcblx0KSB7XG5cdFx0bGV0IFJpY2hDb21ib0JyaWRnZSA9IEFsbG95RWRpdG9yLkJ1dHRvbnNbcmljaENvbWJvTmFtZV07XG5cblx0XHRSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdID0gUklDSF9DT01CT19ERUZTW2VkaXRvci5uYW1lXSB8fCB7fTtcblx0XHRSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW3JpY2hDb21ib05hbWVdID1cblx0XHRcdFJJQ0hfQ09NQk9fREVGU1tlZGl0b3IubmFtZV1bcmljaENvbWJvTmFtZV0gfHwgcmljaENvbWJvRGVmaW5pdGlvbjtcblx0XHRSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW3JpY2hDb21ib05hbWVdLmN1cnJlbnRWYWx1ZSA9IHVuZGVmaW5lZDtcblxuXHRcdGlmICghUmljaENvbWJvQnJpZGdlKSB7XG5cdFx0XHRSaWNoQ29tYm9CcmlkZ2UgPSBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdFx0XHRcdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0XHRcdFx0c3RhdGljIGRpc3BsYXlOYW1lID0gcmljaENvbWJvTmFtZTtcblxuXHRcdFx0XHRzdGF0aWMga2V5ID0gcmljaENvbWJvTmFtZTtcblxuXHRcdFx0XHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdFx0XHRcdHN1cGVyKHByb3BzKTtcblx0XHRcdFx0XHR0aGlzLnN0YXRlID0ge1xuXHRcdFx0XHRcdFx0dmFsdWU6XG5cdFx0XHRcdFx0XHRcdFJJQ0hfQ09NQk9fREVGU1tlZGl0b3IubmFtZV1bcmljaENvbWJvTmFtZV1cblx0XHRcdFx0XHRcdFx0XHQuY3VycmVudFZhbHVlLFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBUEkgbm90IHlldCBpbXBsZW1lbnRlZCBpbnNpZGUgdGhlIHJpY2hjb21ibyBicmlkZ2UuIEJ5IG1vY2tpbmcgdGhlIHVuc3VwcG9ydGVkIG1ldGhvZHMsIHdlXG5cdFx0XHRcdC8vIHByZXZlbnQgcGx1Z2lucyBmcm9tIGNyYXNoaW5nIGlmIHRoZXkgbWFrZSB1c2Ugb2YgdGhlbS5cblxuXHRcdFx0XHRjb21taXQoKSB7fVxuXHRcdFx0XHRjcmVhdGVQYW5lbCgpIHt9XG5cdFx0XHRcdGRpc2FibGUoKSB7fVxuXHRcdFx0XHRlbmFibGUoKSB7fVxuXHRcdFx0XHRnZXRTdGF0ZSgpIHt9XG5cdFx0XHRcdGhpZGVHcm91cCgpIHt9XG5cdFx0XHRcdGhpZGVJdGVtKCkge31cblx0XHRcdFx0bWFyaygpIHt9XG5cdFx0XHRcdHNob3dBbGwoKSB7fVxuXHRcdFx0XHRzdGFydEdyb3VwKCkge31cblx0XHRcdFx0dW5tYXJrQWxsKCkge31cblxuXHRcdFx0XHRhZGQodmFsdWUsIHByZXZpZXcsIHRpdGxlKSB7XG5cdFx0XHRcdFx0dGhpcy5faXRlbXMucHVzaCh7XG5cdFx0XHRcdFx0XHRwcmV2aWV3LFxuXHRcdFx0XHRcdFx0dGl0bGUsXG5cdFx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbXBvbmVudFdpbGxNb3VudCgpIHtcblx0XHRcdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdFx0XHRjb25zdCBlZGl0b3JDb21ibyA9XG5cdFx0XHRcdFx0XHRSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW3JpY2hDb21ib05hbWVdO1xuXG5cdFx0XHRcdFx0dGhpcy5faXRlbXMgPSBbXTtcblxuXHRcdFx0XHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZTtcblxuXHRcdFx0XHRcdGlmIChlZGl0b3JDb21iby5pbml0KSB7XG5cdFx0XHRcdFx0XHRlZGl0b3JDb21iby5pbml0LmNhbGwodGhpcyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGVkaXRvckNvbWJvLm9uUmVuZGVyKSB7XG5cdFx0XHRcdFx0XHRlZGl0b3JDb21iby5vblJlbmRlci5jYWxsKHRoaXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdFx0XHRcdHRoaXMuX2NhY2hlVmFsdWUodGhpcy5zdGF0ZS52YWx1ZSk7XG5cblx0XHRcdFx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fY2FjaGVWYWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdldFZhbHVlKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnN0YXRlLnZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVuZGVyKCkge1xuXHRcdFx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0XHRcdGNvbnN0IHJpY2hDb21ib0xhYmVsID1cblx0XHRcdFx0XHRcdFJJQ0hfQ09NQk9fREVGU1tlZGl0b3IubmFtZV1bcmljaENvbWJvTmFtZV1cblx0XHRcdFx0XHRcdFx0LmN1cnJlbnRWYWx1ZSB8fCByaWNoQ29tYm9EZWZpbml0aW9uLmxhYmVsO1xuXG5cdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWRyb3Bkb3duIGFlLWhhcy1kcm9wZG93blwiPlxuXHRcdFx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRcdFx0YXJpYS1leHBhbmRlZD17dGhpcy5wcm9wcy5leHBhbmRlZH1cblx0XHRcdFx0XHRcdFx0XHRhcmlhLWxhYmVsPXtyaWNoQ29tYm9MYWJlbH1cblx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIlxuXHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdFx0XHRcdFx0cm9sZT1cImNvbWJvYm94XCJcblx0XHRcdFx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHRcdFx0XHR0aXRsZT17cmljaENvbWJvTGFiZWx9PlxuXHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24tc2VsZWN0ZWQtaXRlbVwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7cmljaENvbWJvTGFiZWx9XG5cdFx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJjYXJldC1ib3R0b21cIiAvPlxuXHRcdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHRcdFx0e3RoaXMucHJvcHMuZXhwYW5kZWQgJiYgKFxuXHRcdFx0XHRcdFx0XHRcdDxCdXR0b25Ecm9wZG93blxuXHRcdFx0XHRcdFx0XHRcdFx0b25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufT5cblx0XHRcdFx0XHRcdFx0XHRcdHt0aGlzLl9nZXRJdGVtcygpfVxuXHRcdFx0XHRcdFx0XHRcdDwvQnV0dG9uRHJvcGRvd24+XG5cdFx0XHRcdFx0XHRcdCl9XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2NhY2hlVmFsdWUodmFsdWUpIHtcblx0XHRcdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdFx0XHRSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW1xuXHRcdFx0XHRcdFx0cmljaENvbWJvTmFtZVxuXHRcdFx0XHRcdF0uY3VycmVudFZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZ2V0SXRlbXMoKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmljaENvbWJvID0gdGhpcztcblxuXHRcdFx0XHRcdGNvbnN0IGl0ZW1zID0gdGhpcy5faXRlbXMubWFwKGl0ZW0gPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgY2xhc3NOYW1lID1cblx0XHRcdFx0XHRcdFx0J2FlLXRvb2xiYXItZWxlbWVudCAnICtcblx0XHRcdFx0XHRcdFx0KGl0ZW0udmFsdWUgPT09IHRoaXMuc3RhdGUudmFsdWUgPyAnYWN0aXZlJyA6ICcnKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdFx0PGxpIGtleT17aXRlbS50aXRsZX0gcm9sZT1cIm9wdGlvblwiPlxuXHRcdFx0XHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuXHRcdFx0XHRcdFx0XHRcdFx0ZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0X19odG1sOiBpdGVtLnByZXZpZXcsXG5cdFx0XHRcdFx0XHRcdFx0XHR9fVxuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS12YWx1ZT17aXRlbS52YWx1ZX1cblx0XHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9e3JpY2hDb21iby5fb25DbGlja31cblx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdHJldHVybiBpdGVtcztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9vbkNsaWNrID0gZXZlbnQgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0XHRcdGNvbnN0IGVkaXRvckNvbWJvID1cblx0XHRcdFx0XHRcdFJJQ0hfQ09NQk9fREVGU1tlZGl0b3IubmFtZV1bcmljaENvbWJvTmFtZV07XG5cblx0XHRcdFx0XHRpZiAoZWRpdG9yQ29tYm8ub25DbGljaykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbmV3VmFsdWUgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcblx0XHRcdFx0XHRcdFx0J2RhdGEtdmFsdWUnXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRlZGl0b3JDb21iby5vbkNsaWNrLmNhbGwodGhpcywgbmV3VmFsdWUpO1xuXG5cdFx0XHRcdFx0XHRSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW1xuXHRcdFx0XHRcdFx0XHRyaWNoQ29tYm9OYW1lXG5cdFx0XHRcdFx0XHRdLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuXG5cdFx0XHRcdFx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdF9zZXRWYWx1ZSh2YWx1ZSkge1xuXHRcdFx0XHRcdHRoaXMuX2NhY2hlVmFsdWUodmFsdWUpO1xuXG5cdFx0XHRcdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0QWxsb3lFZGl0b3IuQnV0dG9uc1tyaWNoQ29tYm9OYW1lXSA9IFJpY2hDb21ib0JyaWRnZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gUmljaENvbWJvQnJpZGdlO1xuXHR9O1xuXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdGlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ3JpY2hjb21ibycpKSB7XG5cdFx0Q0tFRElUT1IuVUlfUklDSENPTUJPID0gJ3JpY2hjb21ibyc7XG5cblx0XHRDS0VESVRPUi5wbHVnaW5zLmFkZCgncmljaGNvbWJvJywge30pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENLRWRpdG9yIHBsdWdpbiB0aGF0IGJyaWRnZXMgdGhlIHN1cHBvcnQgb2ZmZXJlZCBieSBDS0VkaXRvciBSaWNoQ29tYm8gcGx1Z2luLiBJdCB0YWtlcyBvdmVyIHRoZVxuXHQgKiByZXNwb25zaWJpbGl0eSBvZiByZWdpc3RlcmluZyBhbmQgY3JlYXRpbmcgcmljaCBjb21ibyBlbGVtZW50cyB2aWE6XG5cdCAqIC0gZWRpdG9yLnVpLmFkZFJpY2hDb21ibyhuYW1lLCBkZWZpbml0aW9uKVxuXHQgKiAtIGVkaXRvci51aS5hZGQobmFtZSwgQ0tFRElUT1IuVUlfUklDSENPTUJPLCBkZWZpbml0aW9uKVxuXHQgKlxuXHQgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9yaWNoY29tYm9icmlkZ2Vcblx0ICogQHJlcXVpcmVzIENLRURJVE9SLnBsdWdpbnMuYWVfdWlicmlkZ2Vcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfcmljaGNvbWJvYnJpZGdlJywge1xuXHRcdHJlcXVpcmVzOiBbJ2FlX3VpYnJpZGdlJ10sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIGFkZCBoYW5kbGVyIGZvciBVSV9SSUNIQ09NQk8gdG8gb3VyIG93bi4gV2UgZG8gdGhpcyBpbiB0aGUgaW5pdCBwaGFzZSB0byBvdmVycmlkZVxuXHRcdCAqIHRoZSBvbmUgaW4gdGhlIG9yaWdpbmFsIHBsdWdpbiBpbiBjYXNlIGl0J3MgcHJlc2VudFxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBpbml0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgQ0tFZGl0b3IgaW5zdGFuY2UgYmVpbmcgaW5pdGlhbGl6ZWRcblx0XHQgKi9cblx0XHRiZWZvcmVJbml0KGVkaXRvcikge1xuXHRcdFx0UklDSF9DT01CT19ERUZTW2VkaXRvci5uYW1lXSA9IHt9O1xuXG5cdFx0XHRlZGl0b3IudWkuYWRkUmljaENvbWJvID0gZnVuY3Rpb24oXG5cdFx0XHRcdHJpY2hDb21ib05hbWUsXG5cdFx0XHRcdHJpY2hDb21ib0RlZmluaXRpb25cblx0XHRcdCkge1xuXHRcdFx0XHR0aGlzLmFkZChcblx0XHRcdFx0XHRyaWNoQ29tYm9OYW1lLFxuXHRcdFx0XHRcdENLRURJVE9SLlVJX1JJQ0hDT01CTyxcblx0XHRcdFx0XHRyaWNoQ29tYm9EZWZpbml0aW9uXG5cdFx0XHRcdCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRlZGl0b3IudWkuYWRkSGFuZGxlcihDS0VESVRPUi5VSV9SSUNIQ09NQk8sIHtcblx0XHRcdFx0YWRkOiBnZW5lcmF0ZVJpY2hDb21ib0JyaWRnZSxcblx0XHRcdFx0Y3JlYXRlKHJpY2hDb21ib0RlZmluaXRpb24pIHtcblx0XHRcdFx0XHRjb25zdCByaWNoQ29tYm9OYW1lID1cblx0XHRcdFx0XHRcdCdyaWNoQ29tYm9CcmlkZ2UnICsgKChNYXRoLnJhbmRvbSgpICogMWU5KSA+Pj4gMCk7XG5cdFx0XHRcdFx0Y29uc3QgUmljaENvbWJvQnJpZGdlID0gZ2VuZXJhdGVSaWNoQ29tYm9CcmlkZ2UoXG5cdFx0XHRcdFx0XHRyaWNoQ29tYm9OYW1lLFxuXHRcdFx0XHRcdFx0cmljaENvbWJvRGVmaW5pdGlvblxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFJpY2hDb21ib0JyaWRnZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfdWlicmlkZ2UnKSkge1xuXHQvKipcblx0ICogQ0tFZGl0b3IgcGx1Z2luIHRoYXQgZXh0ZW5kcyBDS0VESVRPUi51aS5hZGQgZnVuY3Rpb24gc28gYW4gYWRkIGhhbmRsZXIgY2FuIGJlIHNwZWNpZmllZFxuXHQgKiBvbiB0b3Agb2YgdGhlIG9yaWdpbmFsIG9uZXMuIEl0IGJyaWRnZXMgdGhlIGNhbGxzIHRvIGFkZCBjb21wb25lbnRzIHZpYTpcblx0ICogLSBlZGl0b3IudWkuYWRkKG5hbWUsIHR5cGUsIGRlZmluaXRpb24pXG5cdCAqXG5cdCAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX3VpYnJpZGdlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3VpYnJpZGdlJywge1xuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBwbHVnaW4sIHBhcnQgb2YgQ0tFZGl0b3IgcGx1Z2luIGxpZmVjeWNsZS5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgYmVmb3JlSW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICovXG5cdFx0YmVmb3JlSW5pdChlZGl0b3IpIHtcblx0XHRcdGNvbnN0IG9yaWdpbmFsVUlBZGRGbiA9IGVkaXRvci51aS5hZGQ7XG5cblx0XHRcdGVkaXRvci51aS5hZGQgPSBmdW5jdGlvbihuYW1lLCB0eXBlLCBkZWZpbml0aW9uKSB7XG5cdFx0XHRcdG9yaWdpbmFsVUlBZGRGbi5jYWxsKHRoaXMsIG5hbWUsIHR5cGUsIGRlZmluaXRpb24pO1xuXG5cdFx0XHRcdGNvbnN0IHR5cGVIYW5kbGVyID0gdGhpcy5fLmhhbmRsZXJzW3R5cGVdO1xuXG5cdFx0XHRcdGlmICh0eXBlSGFuZGxlciAmJiB0eXBlSGFuZGxlci5hZGQpIHtcblx0XHRcdFx0XHR0eXBlSGFuZGxlci5hZGQobmFtZSwgZGVmaW5pdGlvbiwgZWRpdG9yKTtcblx0XHRcdFx0XHRBbGxveUVkaXRvci5yZWdpc3RlckJyaWRnZUJ1dHRvbihcblx0XHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0XHRlZGl0b3IuX19wcm9jZXNzaW5nUGx1Z2luX18ucGx1Z2luLm5hbWVcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0sXG5cdH0pO1xufVxuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG4vKipcbiAqIERlYm91bmNlIHV0aWwgZnVuY3Rpb24uIElmIGEgZnVuY3Rpb24gZXhlY3V0aW9uIGlzIGV4cGVuc2l2ZSwgaXQgbWlnaHQgYmUgZGVib3VuY2VkLiBUaGlzIG1lYW5zXG4gKiB0aGF0IGl0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgc29tZSBhbW91bnQgb2YgdGltZSBhZnRlciBpdHMgbGFzdCBjYWxsLiBGb3IgZXhhbXBsZSwgaWYgd2UgYXR0YWNoIGFcbiAqIGEgZnVuY3Rpb24gb24gc2Nyb2xsIGV2ZW50LCBpdCBtaWdodCBiZSBjYWxsZWQgaHVuZHJlZHMgdGltZXMgcGVyIHNlY29uZC4gSW4gdGhpcyBjYXNlIGl0IG1heSBiZVxuICogZGVib3VuY2VkIHdpdGgsIGxldCdzIHNheSAxMDBtcy4gVGhlIHJlYWwgZXhlY3V0aW9uIG9mIHRoaXMgZnVuY3Rpb24gd2lsbCBoYXBwZW4gMTAwbXMgYWZ0ZXIgbGFzdFxuICogc2Nyb2xsIGV2ZW50LlxuICpcbiAqIEBtZW1iZXJvZiBDS0VESVRPUi50b29sc1xuICogQG1ldGhvZCBkZWJvdW5jZVxuICogQHBhcmFtIHtBcnJheX0gYXJncyBBbiBhcnJheSBvZiBhcmd1bWVudHMgd2hpY2ggdGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB3aGljaCBoYXMgdG8gYmUgY2FsbGVkIGFmdGVyIGdpdmVuIHRpbWVvdXQuXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgY29udGV4dCBpbiB3aGljaCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwuXG4gKiBAc3RhdGljXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGNhbGxiYWNrLCB0aW1lb3V0LCBjb250ZXh0LCBhcmdzID0gW10pIHtcblx0bGV0IGRlYm91bmNlSGFuZGxlO1xuXG5cdGNvbnN0IGNhbGxGbiA9IGZ1bmN0aW9uKC4uLmNhbGxBcmdzKSB7XG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cdFx0Y29uc3QgY2FsbENvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG5cdFx0LyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuXHRcdGNsZWFyVGltZW91dChkZWJvdW5jZUhhbmRsZSk7XG5cblx0XHRkZWJvdW5jZUhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0Y2FsbGJhY2suYXBwbHkoY2FsbENvbnRleHQsIFsuLi5jYWxsQXJncywgLi4uYXJnc10pO1xuXHRcdH0sIHRpbWVvdXQpO1xuXHR9O1xuXG5cdGNhbGxGbi5kZXRhY2ggPSBmdW5jdGlvbigpIHtcblx0XHRjbGVhclRpbWVvdXQoZGVib3VuY2VIYW5kbGUpO1xuXHR9O1xuXG5cdHJldHVybiBjYWxsRm47XG59XG5cbkNLRURJVE9SLnRvb2xzLmRlYm91bmNlID0gQ0tFRElUT1IudG9vbHMuZGVib3VuY2UgfHwgZGVib3VuY2U7XG5cbmV4cG9ydCBkZWZhdWx0IGRlYm91bmNlO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnLi9kZWJvdW5jZSc7XG5cbmltcG9ydCAnLi9saW5rJztcblxuaW1wb3J0ICcuL3BsdWdpbnMnO1xuXG5pbXBvcnQgJy4vc2VsZWN0aW9uLXJlZ2lvbic7XG5cbmltcG9ydCAnLi90YWJsZSc7XG5cbmltcG9ydCAnLi90b29scyc7XG5cbmltcG9ydCAnLi91aWNvcmUnO1xuXG5leHBvcnQge2RlYm91bmNlfTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuY29uc3QgUkVHRVhfQk9PS01BUktfU0NIRU1FID0gL14jLiovaTtcbmNvbnN0IFJFR0VYX0VNQUlMX1NDSEVNRSA9IC9eW2EtejAtOVxcdTA0MzAtXFx1MDQ0Ri5fLV0rQC9pO1xuY29uc3QgUkVHRVhfVVJJX1NDSEVNRSA9IC9eKD86W2Etel1bYS16MC05K1xcLS5dKik6fF5cXC8vaTtcblxuLyoqXG4gKiBMaW5rIGNsYXNzIHV0aWxpdHkuIFByb3ZpZGVzIG1ldGhvZHMgZm9yIGNyZWF0ZSwgZGVsZXRlIGFuZCB1cGRhdGUgbGlua3MuXG4gKlxuICogQGNsYXNzIENLRURJVE9SLkxpbmtcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgQ0tFZGl0b3IgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIExpbmsoZWRpdG9yLCBjb25maWcpIHtcblx0dGhpcy5fZWRpdG9yID0gZWRpdG9yO1xuXHR0aGlzLmFwcGVuZFByb3RvY29sID1cblx0XHRjb25maWcgJiYgY29uZmlnLmFwcGVuZFByb3RvY29sID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbn1cblxuTGluay5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBMaW5rLFxuXG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGUgZWRpdG9yIHNlbGVjdGlvbiB0byB0aGUgbmV4dCBhdmFpbGFibGUgcG9zaXRpb24gYWZ0ZXIgYVxuXHQgKiBnaXZlbiBsaW5rIG9yIHRoZSBvbmUgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLkxpbmtcblx0ICogQG1ldGhvZCBhZHZhbmNlU2VsZWN0aW9uXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGxpbmsgVGhlIGxpbmsgZWxlbWVudCB3aGljaCBsaW5rIHN0eWxlIHNob3VsZCBiZSByZW1vdmVkLlxuXHQgKi9cblx0YWR2YW5jZVNlbGVjdGlvbihsaW5rKSB7XG5cdFx0bGluayA9IGxpbmsgfHwgdGhpcy5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cblx0XHRjb25zdCByYW5nZSA9IHRoaXMuX2VkaXRvci5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZXMoKVswXTtcblxuXHRcdGlmIChsaW5rKSB7XG5cdFx0XHRyYW5nZS5tb3ZlVG9FbGVtZW50RWRpdEVuZChsaW5rKTtcblxuXHRcdFx0Y29uc3QgbmV4dE5vZGUgPSByYW5nZS5nZXROZXh0RWRpdGFibGVOb2RlKCk7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0bmV4dE5vZGUgJiZcblx0XHRcdFx0IXRoaXMuX2VkaXRvci5lbGVtZW50LmVxdWFscyhuZXh0Tm9kZS5nZXRDb21tb25BbmNlc3RvcihsaW5rKSlcblx0XHRcdCkge1xuXHRcdFx0XHRjb25zdCB3aGl0ZXNwYWNlID0gL1xccy8uZXhlYyhuZXh0Tm9kZS5nZXRUZXh0KCkpO1xuXG5cdFx0XHRcdGNvbnN0IG9mZnNldCA9IHdoaXRlc3BhY2UgPyB3aGl0ZXNwYWNlLmluZGV4ICsgMSA6IDA7XG5cblx0XHRcdFx0cmFuZ2Uuc2V0U3RhcnQobmV4dE5vZGUsIG9mZnNldCk7XG5cdFx0XHRcdHJhbmdlLnNldEVuZChuZXh0Tm9kZSwgb2Zmc2V0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9lZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0UmFuZ2VzKFtyYW5nZV0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBsaW5rIHdpdGggZ2l2ZW4gVVJJIGFzIGhyZWYuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IuTGlua1xuXHQgKiBAbWV0aG9kIGNyZWF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXR0cnMgQSBjb25maWcgb2JqZWN0IHdpdGggbGluayBhdHRyaWJ1dGVzLiBUaGVzZSBtaWdodCBiZSBhcmJpdHJhcnkgRE9NIGF0dHJpYnV0ZXMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtb2RpZnlTZWxlY3Rpb24gQSBjb25maWcgb2JqZWN0IHdpdGggYW4gYWR2YW5jZSBhdHRyaWJ1dGUgdG8gaW5kaWNhdGUgaWYgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgbW92ZWQgYWZ0ZXIgdGhlIGxpbmsgY3JlYXRpb24uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBVUkkgVGhlIFVSSSBvZiB0aGUgbGluay5cblx0ICovXG5cdGNyZWF0ZShVUkksIGF0dHJzLCBtb2RpZnlTZWxlY3Rpb24pIHtcblx0XHRjb25zdCBzZWxlY3Rpb24gPSB0aGlzLl9lZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZXMoKVswXTtcblxuXHRcdGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcblx0XHRcdGNvbnN0IHRleHQgPSBuZXcgQ0tFRElUT1IuZG9tLnRleHQoVVJJLCB0aGlzLl9lZGl0b3IuZG9jdW1lbnQpO1xuXHRcdFx0cmFuZ2UuaW5zZXJ0Tm9kZSh0ZXh0KTtcblx0XHRcdHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyh0ZXh0KTtcblx0XHR9XG5cblx0XHRVUkkgPSB0aGlzLl9nZXRDb21wbGV0ZVVSSShVUkkpO1xuXG5cdFx0Y29uc3QgbGlua0F0dHJzID0gQ0tFRElUT1IudG9vbHMubWVyZ2UoXG5cdFx0XHR7XG5cdFx0XHRcdCdkYXRhLWNrZS1zYXZlZC1ocmVmJzogVVJJLFxuXHRcdFx0XHRocmVmOiBVUkksXG5cdFx0XHRcdHJlbDogJ25vb3BlbmVyIG5vcmVmZXJyZXInLFxuXHRcdFx0fSxcblx0XHRcdGF0dHJzXG5cdFx0KTtcblxuXHRcdGlmICghbGlua0F0dHJzLnRhcmdldCkge1xuXHRcdFx0Y29uc3QgbGlua0NmZyA9IHRoaXMuX2VkaXRvci5jb25maWcubGlua0NmZyB8fCB7fTtcblx0XHRcdGNvbnN0IGRlZmF1bHRUYXJnZXQgPSBsaW5rQ2ZnICYmIGxpbmtDZmcuZGVmYXVsdFRhcmdldDtcblx0XHRcdGlmIChkZWZhdWx0VGFyZ2V0KSB7XG5cdFx0XHRcdGxpbmtBdHRycy50YXJnZXQgPSBkZWZhdWx0VGFyZ2V0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IHN0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKHtcblx0XHRcdGF0dHJpYnV0ZXM6IGxpbmtBdHRycyxcblx0XHRcdGVsZW1lbnQ6ICdhJyxcblx0XHR9KTtcblxuXHRcdHN0eWxlLnR5cGUgPSBDS0VESVRPUi5TVFlMRV9JTkxJTkU7XG5cdFx0c3R5bGUuYXBwbHlUb1JhbmdlKHJhbmdlLCB0aGlzLl9lZGl0b3IpO1xuXG5cdFx0aWYgKG1vZGlmeVNlbGVjdGlvbiAmJiBtb2RpZnlTZWxlY3Rpb24uYWR2YW5jZSkge1xuXHRcdFx0dGhpcy5hZHZhbmNlU2VsZWN0aW9uKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJhbmdlLnNlbGVjdCgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmV0cmlldmVzIGEgbGluayBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5MaW5rXG5cdCAqIEBtZXRob2QgZ2V0RnJvbVNlbGVjdGlvblxuXHQgKiBAcmV0dXJuIHtDS0VESVRPUi5kb20uZWxlbWVudH0gVGhlIHJldHJpZXZlZCBsaW5rIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuXHQgKi9cblx0Z2V0RnJvbVNlbGVjdGlvbigpIHtcblx0XHRjb25zdCBzZWxlY3Rpb24gPSB0aGlzLl9lZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRFbGVtZW50KCk7XG5cblx0XHRpZiAoc2VsZWN0ZWRFbGVtZW50ICYmIHNlbGVjdGVkRWxlbWVudC5pcygnYScpKSB7XG5cdFx0XHRyZXR1cm4gc2VsZWN0ZWRFbGVtZW50O1xuXHRcdH1cblxuXHRcdGlmIChzZWxlY3RlZEVsZW1lbnQgJiYgQ0tFRElUT1IuZW52LmllKSB7XG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IHNlbGVjdGVkRWxlbWVudC5nZXRDaGlsZHJlbigpO1xuXG5cdFx0XHRjb25zdCBjb3VudCA9IGNoaWxkcmVuLmNvdW50KCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0XHRjb25zdCBub2RlID0gY2hpbGRyZW4uZ2V0SXRlbShpKTtcblxuXHRcdFx0XHRpZiAobm9kZS5pcygnYScpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZXMoKVswXTtcblxuXHRcdGlmIChyYW5nZSkge1xuXHRcdFx0cmFuZ2Uuc2hyaW5rKENLRURJVE9SLlNIUklOS19URVhUKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX2VkaXRvclxuXHRcdFx0XHQuZWxlbWVudFBhdGgocmFuZ2UuZ2V0Q29tbW9uQW5jZXN0b3IoKSlcblx0XHRcdFx0LmNvbnRhaW5zKCdhJywgMSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYSBsaW5rIGZyb20gdGhlIGVkaXRvci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5MaW5rXG5cdCAqIEBtZXRob2QgcmVtb3ZlXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGxpbmsgVGhlIGxpbmsgZWxlbWVudCB3aGljaCBsaW5rIHN0eWxlIHNob3VsZCBiZSByZW1vdmVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gbW9kaWZ5U2VsZWN0aW9uIEEgY29uZmlnIG9iamVjdCB3aXRoIGFuIGFkdmFuY2UgYXR0cmlidXRlIHRvIGluZGljYXRlIGlmIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIG1vdmVkIGFmdGVyIHRoZSBsaW5rIGNyZWF0aW9uLlxuXHQgKi9cblx0cmVtb3ZlKGxpbmssIG1vZGlmeVNlbGVjdGlvbikge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcblxuXHRcdGlmIChsaW5rKSB7XG5cdFx0XHRpZiAobW9kaWZ5U2VsZWN0aW9uICYmIG1vZGlmeVNlbGVjdGlvbi5hZHZhbmNlKSB7XG5cdFx0XHRcdHRoaXMuYWR2YW5jZVNlbGVjdGlvbigpO1xuXHRcdFx0fVxuXG5cdFx0XHRsaW5rLnJlbW92ZShlZGl0b3IpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZSh7XG5cdFx0XHRcdGFsd2F5c1JlbW92ZUVsZW1lbnQ6IDEsXG5cdFx0XHRcdGVsZW1lbnQ6ICdhJyxcblx0XHRcdFx0dHlwZTogQ0tFRElUT1IuU1RZTEVfSU5MSU5FLFxuXHRcdFx0fSk7XG5cblx0XHRcdC8vICdyZW1vdmVTdHlsZSgpJyByZW1vdmVzIHRoZSBzdHlsZSBmcm9tIHRoZSBlZGl0b3IncyBjdXJyZW50IHNlbGVjdGlvbi5cblx0XHRcdC8vICBXZSBuZWVkIHRvIGZvcmNlIHRoZSBzZWxlY3Rpb24gdG8gYmUgdGhlIHdob2xlIGxpbmsgZWxlbWVudFxuXHRcdFx0Ly8gIHRvIHJlbW92ZSBpdCBwcm9wZXJseS5cblxuXHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0c2VsZWN0aW9uLnNlbGVjdEVsZW1lbnQoc2VsZWN0aW9uLmdldFN0YXJ0RWxlbWVudCgpKTtcblxuXHRcdFx0ZWRpdG9yLnJlbW92ZVN0eWxlKHN0eWxlKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGhyZWYgb2YgYW4gYWxyZWFkeSBleGlzdGluZyBsaW5rLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLkxpbmtcblx0ICogQG1ldGhvZCB1cGRhdGVcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gbGluayBUaGUgbGluayBlbGVtZW50IHdoaWNoIGhyZWYgc2hvdWxkIGJlIHJlbW92ZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gYXR0cnMgVGhlIGF0dHJpYnV0ZXMgdG8gdXBkYXRlIG9yIHJlbW92ZS4gQXR0cmlidXRlcyB3aXRoIG51bGwgdmFsdWVzIHdpbGwgYmUgcmVtb3ZlZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG1vZGlmeVNlbGVjdGlvbiBBIGNvbmZpZyBvYmplY3Qgd2l0aCBhbiBhZHZhbmNlIGF0dHJpYnV0ZSB0byBpbmRpY2F0ZSBpZiB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBtb3ZlZCBhZnRlciB0aGUgbGluayBjcmVhdGlvbi5cblx0ICovXG5cdHVwZGF0ZShhdHRycywgbGluaywgbW9kaWZ5U2VsZWN0aW9uKSB7XG5cdFx0Y29uc3QgaW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0bGluayA9IGxpbmsgfHwgdGhpcy5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cblx0XHRpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xuXHRcdFx0Y29uc3QgdXJpID0gaW5zdGFuY2UuX2dldENvbXBsZXRlVVJJKGF0dHJzKTtcblxuXHRcdFx0bGluay5zZXRBdHRyaWJ1dGVzKHtcblx0XHRcdFx0J2RhdGEtY2tlLXNhdmVkLWhyZWYnOiB1cmksXG5cdFx0XHRcdGhyZWY6IHVyaSxcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGF0dHJzID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Y29uc3QgcmVtb3ZlQXR0cnMgPSBbXTtcblxuXHRcdFx0Y29uc3Qgc2V0QXR0cnMgPSB7fTtcblxuXHRcdFx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IHtcblx0XHRcdFx0aWYgKGF0dHJzW2tleV0gPT09IG51bGwpIHtcblx0XHRcdFx0XHRpZiAoa2V5ID09PSAnaHJlZicpIHtcblx0XHRcdFx0XHRcdHJlbW92ZUF0dHJzLnB1c2goJ2RhdGEtY2tlLXNhdmVkLWhyZWYnKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZW1vdmVBdHRycy5wdXNoKGtleSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGtleSA9PT0gJ2hyZWYnKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB1cmkgPSBpbnN0YW5jZS5fZ2V0Q29tcGxldGVVUkkoYXR0cnNba2V5XSk7XG5cblx0XHRcdFx0XHRcdHNldEF0dHJzWydkYXRhLWNrZS1zYXZlZC1ocmVmJ10gPSB1cmk7XG5cdFx0XHRcdFx0XHRzZXRBdHRyc1trZXldID0gdXJpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZXRBdHRyc1trZXldID0gYXR0cnNba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRsaW5rLnJlbW92ZUF0dHJpYnV0ZXMocmVtb3ZlQXR0cnMpO1xuXHRcdFx0bGluay5zZXRBdHRyaWJ1dGVzKHNldEF0dHJzKTtcblx0XHR9XG5cblx0XHRpZiAobW9kaWZ5U2VsZWN0aW9uICYmIG1vZGlmeVNlbGVjdGlvbi5hZHZhbmNlKSB7XG5cdFx0XHR0aGlzLmFkdmFuY2VTZWxlY3Rpb24obGluayk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIFVSSSBiZWdpbnMgd2l0aCBhICcjJyBzeW1ib2wgdG8gZGV0ZXJtaW5lIGlmIGl0J3MgYW4gb24gcGFnZSBib29rbWFyay5cblx0ICogSWYgaXQgZG9lc24ndCwgaXQgdGhlbiBjaGVja3MgaWYgdGhlIFVSSSBoYXMgYW4gJ0AnIHN5bWJvbC4gSWYgaXQgZG9lcyBhbmQgdGhlIFVSSVxuXHQgKiBsb29rcyBsaWtlIGFuIGVtYWlsIGFuZCBkb2Vzbid0IGhhdmUgJ21haWx0bzonLCAnbWFpbHRvOicgaXMgYWRkZWQgdG8gdGhlIFVSSS5cblx0ICogSWYgaXQgZG9lc24ndCBhbmQgdGhlIFVSSSBkb2Vzbid0IGhhdmUgYSBzY2hlbWUsIHRoZSBkZWZhdWx0ICdodHRwJyBzY2hlbWUgd2l0aFxuXHQgKiBoaWVyYXJjaGljYWwgcGF0aCAnLy8nIGlzIGFkZGVkIHRvIHRoZSBVUkkuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IuTGlua1xuXHQgKiBAbWV0aG9kIF9nZXRDb21wbGV0ZVVSSVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gVVJJIFRoZSBVUkkgb2YgdGhlIGxpbmsuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgVVJJIHVwZGF0ZWQgd2l0aCB0aGUgcHJvdG9jb2wuXG5cdCAqL1xuXHRfZ2V0Q29tcGxldGVVUkkoVVJJKSB7XG5cdFx0aWYgKFJFR0VYX0JPT0tNQVJLX1NDSEVNRS50ZXN0KFVSSSkpIHtcblx0XHRcdHJldHVybiBVUkk7XG5cdFx0fSBlbHNlIGlmIChSRUdFWF9FTUFJTF9TQ0hFTUUudGVzdChVUkkpKSB7XG5cdFx0XHRVUkkgPSAnbWFpbHRvOicgKyBVUkk7XG5cdFx0fSBlbHNlIGlmICghUkVHRVhfVVJJX1NDSEVNRS50ZXN0KFVSSSkpIHtcblx0XHRcdFVSSSA9IHRoaXMuYXBwZW5kUHJvdG9jb2wgPyAnaHR0cDovLycgKyBVUkkgOiBVUkk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFVSSTtcblx0fSxcbn07XG5cbkNLRURJVE9SLkxpbmsgPSBDS0VESVRPUi5MaW5rIHx8IExpbms7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbi8vIFdyYXBzIGVhY2ggb2YgdGhlIHBsdWdpbiBsaWZlY3ljbGUgbWV0aG9kcyBpbiBhIGNsb3N1cmUgdGhhdCB3aWxsXG4vLyBzZXQgdXAgdGhlIGVkaXRvci5fX3Byb2Nlc3NpbmdQbHVnaW5fXyB2YXJpYWJsZSBzbyBpdCBjYW4gYmUgZ2xvYmFsbHlcbi8vIGFjY2Vzc2VkIGV4cG9zaW5nIHRoZSBwbHVnaW4gYmVpbmcgcHJvY2Vzc2VkIGFuZCB0aGUgbGlmZWN5Y2xlIHBoYXNlXG4vLyBpbiB3aGljaCBpdCBpcyBoYXBwZW5pbmdcbi8vXG4vLyBAcGFyYW0ge09iamVjdH0gcGx1Z2luIFRoZSBwbHVnaW4gdG8gd3JhcCBsaWZlY3ljbGUgbWV0aG9kc1xuXG5jb25zdCB3cmFwUGx1Z2luTGlmZWN5Y2xlID0gZnVuY3Rpb24ocGx1Z2luKSB7XG5cdGNvbnN0IG1ldGhvZHMgPSBbJ2JlZm9yZUluaXQnLCAnaW5pdCcsICdhZnRlckluaXQnXTtcblxuXHRtZXRob2RzLmZvckVhY2gobWV0aG9kTmFtZSA9PiB7XG5cdFx0aWYgKHBsdWdpblttZXRob2ROYW1lXSkge1xuXHRcdFx0cGx1Z2luW21ldGhvZE5hbWVdID0gQ0tFRElUT1IudG9vbHMub3ZlcnJpZGUoXG5cdFx0XHRcdHBsdWdpblttZXRob2ROYW1lXSxcblx0XHRcdFx0b3JpZ2luYWxQbHVnaW5NZXRob2QgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHBheWxvYWQgPSB7XG5cdFx0XHRcdFx0XHRwaGFzZTogbWV0aG9kTmFtZSxcblx0XHRcdFx0XHRcdHBsdWdpbixcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0ZWRpdG9yLl9fcHJvY2Vzc2luZ1BsdWdpbl9fID0gcGF5bG9hZDtcblxuXHRcdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWludmFsaWQtdGhpc1xuXHRcdFx0XHRcdFx0b3JpZ2luYWxQbHVnaW5NZXRob2QuY2FsbCh0aGlzLCBlZGl0b3IpO1xuXG5cdFx0XHRcdFx0XHRlZGl0b3IuX19wcm9jZXNzaW5nUGx1Z2luX18gPSBudWxsO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbi8vIEZpbHRlcnMgdGhlIHJlcXVpcmVzIG9iamVjdCB0byByZW1vdmUgdW53YW50ZWQgZGVwZW5kZW5jaWVzLiBBdCB0aGlzIHBvaW50XG4vLyBvbmx5ICd0b29sYmFyJyBoYXMgYmVlbiBpZGVudGlmaWVkLCBidXQgbW9yZSBjYW4gYXBwZWFyLiBBbiB1bndhbnRlZCBwbHVnaW5cbi8vIGRlcGVuZGVuY3kgaXMgb25lIHRoYXQgcHJldmVudHMgYSBuZWNlc3NhcnkgcGx1Z2luIGZyb20gYmVpbmcgcmVtb3ZlZFxuLy9cbi8vIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHJlcXVpcmVzIFRoZSByZXF1aXJlcyBvYmplY3Rcbi8vIEByZXR1cm4ge3N0cmluZ30gVGhlIGZpbHRlcmVkIHJlcXVpcmVzIG9iamVjdFxuXG5jb25zdCBmaWx0ZXJVbndhbnRlZERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uKHJlcXVpcmVzKSB7XG5cdGlmICh0eXBlb2YgcmVxdWlyZXMgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmVxdWlyZXMgPSByZXF1aXJlcy5zcGxpdCgnLCcpO1xuXHR9XG5cblx0cmV0dXJuIHJlcXVpcmVzLmZpbHRlcihyZXF1aXJlID0+IHtcblx0XHRyZXR1cm4gcmVxdWlyZSAhPT0gJ3Rvb2xiYXInO1xuXHR9KTtcbn07XG5cbi8qKlxuICogQ0tFRElUT1IucGx1Z2lucyBjbGFzcyB1dGlsaXR5IHdoaWNoIGFkZHMgYWRkaXRpb25hbCBtZXRob2RzIHRvIHRob3NlIG9mIENLRWRpdG9yLlxuICpcbiAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zXG4gKi9cblxuLyoqXG4gKiBPdmVycmlkZXMgQ0tFRElUT1IucGx1Z2lucy5sb2FkIG1ldGhvZCBzbyB3ZSBjYW4gZXh0ZW5kIHRoZSBsaWZlY3ljbGUgbWV0aG9kcyBvZlxuICogdGhlIGxvYWRlZCBwbHVnaW5zIHRvIGFkZCBzb21lIG1ldGFpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGx1Z2luIGJlaW5nIHByb2Nlc3NlZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nL0FycmF5fSBuYW1lcyBUaGUgbmFtZSBvZiB0aGUgcmVzb3VyY2UgdG8gbG9hZC4gSXQgbWF5IGJlIGFcbiAqIHN0cmluZyB3aXRoIGEgc2luZ2xlIHJlc291cmNlIG5hbWUsIG9yIGFuIGFycmF5IHdpdGggc2V2ZXJhbCBuYW1lcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gYWxsIHJlc291cmNlc1xuICogYXJlIGxvYWRlZC4gVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSBhbiBhcnJheSBjb250YWluaW5nIGFsbCBsb2FkZWQgbmFtZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBUaGUgc2NvcGUgb2JqZWN0IHRvIGJlIHVzZWQgZm9yIHRoZSBjYWxsYmFjayBjYWxsLlxuICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnNcbiAqIEBtZXRob2QgbG9hZFxuICogQHN0YXRpY1xuICovXG5DS0VESVRPUi5wbHVnaW5zLmxvYWQgPSBDS0VESVRPUi50b29scy5vdmVycmlkZShcblx0Q0tFRElUT1IucGx1Z2lucy5sb2FkLFxuXHRwbHVnaW5zTG9hZCA9PiB7XG5cdFx0Ly8gV3JhcCBvcmlnaW5hbCBsb2FkIGZ1bmN0aW9uIHNvIHdlIGNhbiB0cmFuc2Zvcm0gdGhlIHBsdWdpbiBpbnB1dCBwYXJhbWV0ZXJcblx0XHQvLyBiZWZvcmUgcGFzc2luZyBpdCBkb3duIHRvIHRoZSBvcmlnaW5hbCBjYWxsYmFja1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKG5hbWVzLCBjYWxsYmFjaywgc2NvcGUpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcblx0XHRcdHBsdWdpbnNMb2FkLmNhbGwodGhpcywgbmFtZXMsIHBsdWdpbnMgPT4ge1xuXHRcdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhwbHVnaW5zKS5mb3JFYWNoKHBsdWdpbk5hbWUgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgcGx1Z2luID0gcGx1Z2luc1twbHVnaW5OYW1lXTtcblxuXHRcdFx0XHRcdFx0aWYgKHBsdWdpbi5yZXF1aXJlcykge1xuXHRcdFx0XHRcdFx0XHRwbHVnaW4ucmVxdWlyZXMgPSBmaWx0ZXJVbndhbnRlZERlcGVuZGVuY2llcyhcblx0XHRcdFx0XHRcdFx0XHRwbHVnaW4ucmVxdWlyZXNcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0d3JhcFBsdWdpbkxpZmVjeWNsZShwbHVnaW4pO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbChzY29wZSwgcGx1Z2lucyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cdH1cbik7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3NlbGVjdGlvbnJlZ2lvbicpKSB7XG5cdENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NID0gMDtcblx0Q0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1AgPSAxO1xuXHRDS0VESVRPUi5TRUxFQ1RJT05fTEVGVF9UT19SSUdIVCA9IDI7XG5cdENLRURJVE9SLlNFTEVDVElPTl9SSUdIVF9UT19MRUZUID0gMztcblxuXHQvKipcblx0ICogU2VsZWN0aW9uUmVnaW9uIHV0aWxpdHkgY2xhc3Mgd2hpY2ggcHJvdmlkZXMgbWV0YWRhdGEgYWJvdXQgdGhlIHNlbGVjdGlvbi4gVGhlIG1ldGFkYXRhIG1heSBiZSB0aGUgc3RhcnQgYW5kIGVuZFxuXHQgKiByZWN0YW5nbGVzLCBjYXJldCByZWdpb24sIGV0Yy4gKipUaGlzIGNsYXNzIGlzIG5vdCBpbnRlbmRlZCB0byBiZSB1c2VkIHN0YW5kYWxvbmUuIEl0cyBmdW5jdGlvbnMgd2lsbFxuXHQgKiBiZSBtZXJnZWQgaW50byBlYWNoIGVkaXRvciBpbnN0YW5jZSwgc28gdGhlIGRldmVsb3BlciBtYXkgdXNlIHRoZW0gZGlyZWN0bHkgdmlhIHRoZSBlZGl0b3IsIHdpdGhvdXQgbWFraW5nXG5cdCAqIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MqKi5cblx0ICpcblx0ICogQGNsYXNzIFNlbGVjdGlvblJlZ2lvblxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFNlbGVjdGlvblJlZ2lvbigpIHt9XG5cblx0U2VsZWN0aW9uUmVnaW9uLnByb3RvdHlwZSA9IHtcblx0XHRjb25zdHJ1Y3RvcjogU2VsZWN0aW9uUmVnaW9uLFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBzZWxlY3Rpb24gZnJvbSB0d28gcG9pbnRzIGluIHBhZ2UgY29vcmRpbmF0ZXMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG5cdFx0ICogQG1ldGhvZCBjcmVhdGVTZWxlY3Rpb25Gcm9tUG9pbnRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geCBYIHBvaW50IGluIHBhZ2UgY29vcmRpbmF0ZXMuXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb2ludCBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuXHRcdCAqL1xuXHRcdGNyZWF0ZVNlbGVjdGlvbkZyb21Qb2ludCh4LCB5KSB7XG5cdFx0XHR0aGlzLmNyZWF0ZVNlbGVjdGlvbkZyb21SYW5nZSh4LCB5LCB4LCB5KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBzZWxlY3Rpb24gZnJvbSByYW5nZS4gQSByYW5nZSBjb25zaXN0cyBmcm9tIHR3byBwb2ludHMgaW4gcGFnZSBjb29yZGluYXRlcy5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cblx0XHQgKiBAbWV0aG9kIGNyZWF0ZVNlbGVjdGlvbkZyb21SYW5nZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFggWCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludC5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRZIFkgY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgcG9pbnQuXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZFggWCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZFkgWSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG5cdFx0ICovXG5cdFx0Y3JlYXRlU2VsZWN0aW9uRnJvbVJhbmdlKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZKSB7XG5cdFx0XHRsZXQgZW5kO1xuXHRcdFx0bGV0IGVuZENvbnRhaW5lcjtcblx0XHRcdGxldCBlbmRPZmZzZXQ7XG5cdFx0XHRsZXQgcmFuZ2U7XG5cdFx0XHRsZXQgc3RhcnQ7XG5cdFx0XHRsZXQgc3RhcnRDb250YWluZXI7XG5cdFx0XHRsZXQgc3RhcnRPZmZzZXQ7XG5cblx0XHRcdGlmICh0eXBlb2YgZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRzdGFydCA9IGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoc3RhcnRYLCBzdGFydFkpO1xuXHRcdFx0XHRlbmQgPSBkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50KGVuZFgsIGVuZFkpO1xuXG5cdFx0XHRcdHN0YXJ0Q29udGFpbmVyID0gc3RhcnQub2Zmc2V0Tm9kZTtcblx0XHRcdFx0ZW5kQ29udGFpbmVyID0gZW5kLm9mZnNldE5vZGU7XG5cblx0XHRcdFx0c3RhcnRPZmZzZXQgPSBzdGFydC5vZmZzZXQ7XG5cdFx0XHRcdGVuZE9mZnNldCA9IGVuZC5vZmZzZXQ7XG5cblx0XHRcdFx0cmFuZ2UgPSB0aGlzLmNyZWF0ZVJhbmdlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHN0YXJ0ID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludChzdGFydFgsIHN0YXJ0WSk7XG5cdFx0XHRcdGVuZCA9IGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQoZW5kWCwgZW5kWSk7XG5cblx0XHRcdFx0c3RhcnRDb250YWluZXIgPSBzdGFydC5zdGFydENvbnRhaW5lcjtcblx0XHRcdFx0ZW5kQ29udGFpbmVyID0gZW5kLnN0YXJ0Q29udGFpbmVyO1xuXG5cdFx0XHRcdHN0YXJ0T2Zmc2V0ID0gc3RhcnQuc3RhcnRPZmZzZXQ7XG5cdFx0XHRcdGVuZE9mZnNldCA9IGVuZC5zdGFydE9mZnNldDtcblxuXHRcdFx0XHRyYW5nZSA9IHRoaXMuY3JlYXRlUmFuZ2UoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJhbmdlICYmIGRvY3VtZW50LmdldFNlbGVjdGlvbikge1xuXHRcdFx0XHRyYW5nZS5zZXRTdGFydChcblx0XHRcdFx0XHRuZXcgQ0tFRElUT1IuZG9tLm5vZGUoc3RhcnRDb250YWluZXIpLFxuXHRcdFx0XHRcdHN0YXJ0T2Zmc2V0XG5cdFx0XHRcdCk7XG5cdFx0XHRcdHJhbmdlLnNldEVuZChuZXcgQ0tFRElUT1IuZG9tLm5vZGUoZW5kQ29udGFpbmVyKSwgZW5kT2Zmc2V0KTtcblxuXHRcdFx0XHR0aGlzLmdldFNlbGVjdGlvbigpLnNlbGVjdFJhbmdlcyhbcmFuZ2VdKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuY3JlYXRlVGV4dFJhbmdlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRcdFx0c2VsZWN0aW9uLnVubG9jaygpO1xuXG5cdFx0XHRcdHJhbmdlID0gZG9jdW1lbnQuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKTtcblx0XHRcdFx0cmFuZ2UubW92ZVRvUG9pbnQoc3RhcnRYLCBzdGFydFkpO1xuXG5cdFx0XHRcdGNvbnN0IGVuZFJhbmdlID0gcmFuZ2UuZHVwbGljYXRlKCk7XG5cdFx0XHRcdGVuZFJhbmdlLm1vdmVUb1BvaW50KGVuZFgsIGVuZFkpO1xuXG5cdFx0XHRcdHJhbmdlLnNldEVuZFBvaW50KCdFbmRUb0VuZCcsIGVuZFJhbmdlKTtcblx0XHRcdFx0cmFuZ2Uuc2VsZWN0KCk7XG5cblx0XHRcdFx0dGhpcy5nZXRTZWxlY3Rpb24oKS5sb2NrKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHJlZ2lvbiBvZiB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgY2FyZXQuIFRoZSBwb2ludHMgYXJlIGluIHBhZ2UgY29vcmRpbmF0ZXMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG5cdFx0ICogQG1ldGhvZCBnZXRDYXJldFJlZ2lvblxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cdFx0ICogLSBib3R0b21cblx0XHQgKiAtIGxlZnRcblx0XHQgKiAtIHJpZ2h0XG5cdFx0ICogLSB0b3Bcblx0XHQgKi9cblx0XHRnZXRDYXJldFJlZ2lvbigpIHtcblx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRcdGxldCByZWdpb24gPSB7XG5cdFx0XHRcdGJvdHRvbTogMCxcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IGJvb2ttYXJrcyA9IHNlbGVjdGlvbi5jcmVhdGVCb29rbWFya3MoKTtcblxuXHRcdFx0aWYgKCFib29rbWFya3MubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiByZWdpb247XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGJvb2ttYXJrTm9kZUVsID0gYm9va21hcmtzWzBdLnN0YXJ0Tm9kZS4kO1xuXG5cdFx0XHRib29rbWFya05vZGVFbC5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG5cblx0XHRcdHJlZ2lvbiA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChib29rbWFya05vZGVFbCkuZ2V0Q2xpZW50UmVjdCgpO1xuXG5cdFx0XHRib29rbWFya05vZGVFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJvb2ttYXJrTm9kZUVsKTtcblxuXHRcdFx0Y29uc3Qgc2Nyb2xsUG9zID0gbmV3IENLRURJVE9SLmRvbS53aW5kb3coXG5cdFx0XHRcdHdpbmRvd1xuXHRcdFx0KS5nZXRTY3JvbGxQb3NpdGlvbigpO1xuXG5cdFx0XHRyZWdpb24uYm90dG9tID0gc2Nyb2xsUG9zLnkgKyByZWdpb24uYm90dG9tO1xuXHRcdFx0cmVnaW9uLmxlZnQgPSBzY3JvbGxQb3MueCArIHJlZ2lvbi5sZWZ0O1xuXHRcdFx0cmVnaW9uLnJpZ2h0ID0gc2Nyb2xsUG9zLnggKyByZWdpb24ucmlnaHQ7XG5cdFx0XHRyZWdpb24udG9wID0gc2Nyb2xsUG9zLnkgKyByZWdpb24udG9wO1xuXG5cdFx0XHRyZXR1cm4gcmVnaW9uO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGRhdGEgZm9yIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cblx0XHQgKiBAbWV0aG9kIGdldFNlbGVjdGlvbkRhdGFcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGRhdGE6XG5cdFx0ICogLSBlbGVtZW50IC0gVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBlbGVtZW50LCBpZiBhbnlcblx0XHQgKiAtIHRleHQgLSBUaGUgc2VsZWN0ZWQgdGV4dFxuXHRcdCAqIC0gcmVnaW9uIC0gVGhlIGRhdGEsIHJldHVybmVkIGZyb20ge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9zZWxlY3Rpb25yZWdpb24vZ2V0U2VsZWN0aW9uUmVnaW9uOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqL1xuXHRcdGdldFNlbGVjdGlvbkRhdGEoKSB7XG5cdFx0XHRjb25zdCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0XHRpZiAoIXNlbGVjdGlvbi5nZXROYXRpdmUoKSkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcmVzdWx0ID0ge1xuXHRcdFx0XHRlbGVtZW50OiBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRFbGVtZW50KCksXG5cdFx0XHRcdHRleHQ6IHNlbGVjdGlvbi5nZXRTZWxlY3RlZFRleHQoKSxcblx0XHRcdH07XG5cblx0XHRcdHJlc3VsdC5yZWdpb24gPSB0aGlzLmdldFNlbGVjdGlvblJlZ2lvbihzZWxlY3Rpb24pO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSByZWdpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFNlbGVjdGlvblJlZ2lvblxuXHRcdCAqIEBtZXRob2QgZ2V0U2VsZWN0aW9uUmVnaW9uXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIG9iamVjdCB3aGljaCBpcyBiZWluZyByZXR1cm5lZCBmcm9tXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9zZWxlY3Rpb25yZWdpb24vZ2V0Q2xpZW50UmVjdHNSZWdpb246bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319IHdpdGggdGhyZWUgbW9yZSBwcm9wZXJ0aWVzOlxuXHRcdCAqIC0gZGlyZWN0aW9uIC0gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2VsZWN0aW9uLiBDYW4gYmUgb25lIG9mIHRoZXNlOlxuXHRcdCAqICAgMS4gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT01cblx0XHQgKiAgIDIuIENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QXG5cdFx0ICogLSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBzZWxlY3Rpb24gcmVnaW9uXG5cdFx0ICogLSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgc2VsZWN0aW9uIHJlZ2lvblxuXHRcdCAqL1xuXHRcdGdldFNlbGVjdGlvblJlZ2lvbigpIHtcblx0XHRcdGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0Q2xpZW50UmVjdHNSZWdpb24oKTtcblxuXHRcdFx0cmVnaW9uLmRpcmVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uRGlyZWN0aW9uKCk7XG5cblx0XHRcdHJlZ2lvbi5oZWlnaHQgPSByZWdpb24uYm90dG9tIC0gcmVnaW9uLnRvcDtcblx0XHRcdHJlZ2lvbi53aWR0aCA9IHJlZ2lvbi5yaWdodCAtIHJlZ2lvbi5sZWZ0O1xuXG5cdFx0XHRyZXR1cm4gcmVnaW9uO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGVtcHR5LCBmYWxzZSBvdGhlcndpc2UuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG5cdFx0ICogQG1ldGhvZCBpc1NlbGVjdGlvbkVtcHR5XG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBlbXB0eSwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHRcdCAqL1xuXHRcdGlzU2VsZWN0aW9uRW1wdHkoKSB7XG5cdFx0XHRjb25zdCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0XHRpZiAoc2VsZWN0aW9uLmdldFR5cGUoKSA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX05PTkUpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJhbmdlcyA9IHNlbGVjdGlvbi5nZXRSYW5nZXMoKTtcblxuXHRcdFx0cmV0dXJuIHJhbmdlcyAmJiByYW5nZXMubGVuZ3RoID09PSAxICYmIHJhbmdlc1swXS5jb2xsYXBzZWQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgb2JqZWN0IHdpdGggZGF0YSBhYm91dCB0aGUgW2NsaWVudCByZWN0YW5nbGVzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC5nZXRDbGllbnRSZWN0cykgb2YgdGhlIHNlbGVjdGlvbixcblx0XHQgKiBub3JtYWxpemVkIGFjcm9zcyBicm93c2VzLiBBbGwgb2Zmc2V0cyBiZWxvdyBhcmUgaW4gcGFnZSBjb29yZGluYXRlcy5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cblx0XHQgKiBAbWV0aG9kIGdldENsaWVudFJlY3RzUmVnaW9uXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgZGF0YTpcblx0XHQgKiAtIGJvdHRvbSAtIGJvdHRvbSBvZmZzZXQgb2YgYWxsIGNsaWVudCByZWN0YW5nbGVzXG5cdFx0ICogLSBsZWZ0IC0gbGVmdCBvZmZzZXQgb2YgYWxsIGNsaWVudCByZWN0YW5nbGVzXG5cdFx0ICogLSByaWdodCAtIHJpZ2h0IG9mZnNldCBvZiBhbGwgY2xpZW50IHJlY3RhbmdsZXNcblx0XHQgKiAtIHRvcCAtIHRvcCBvZmZzZXQgb2YgYWxsIGNsaWVudCByZWN0YW5nbGVzXG5cdFx0ICogLSBzdGFydFJlY3QgLSBBbiBPYmplY3QsIHdoaWNoIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb246XG5cdFx0ICogICAgICsgYm90dG9tIC0gYm90dG9tIG9mZnNldFxuXHRcdCAqICAgICArIGhlaWdodCAtIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuXHRcdCAqICAgICArIGxlZnQgLSBsZWZ0IG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uXG5cdFx0ICogICAgICsgcmlnaHQgLSByaWdodCBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvblxuXHRcdCAqICAgICArIHRvcCAtIHRvcCBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvblxuXHRcdCAqICAgICArIHdpZHRoIC0gdGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcblx0XHQgKiAtIGVuZFJlY3QgLSBBbiBPYmplY3QsIHdoaWNoIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb246XG5cdFx0ICogICAgICsgYm90dG9tIC0gYm90dG9tIG9mZnNldFxuXHRcdCAqICAgICArIGhlaWdodCAtIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuXHRcdCAqICAgICArIGxlZnQgLSBsZWZ0IG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uXG5cdFx0ICogICAgICsgcmlnaHQgLSByaWdodCBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvblxuXHRcdCAqICAgICArIHRvcCAtIHRvcCBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvblxuXHRcdCAqICAgICArIHdpZHRoIC0gdGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcblx0XHQgKlxuXHRcdCAqIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBzZWxlY3Rpb24sIHRoZSBvYmplY3RzIHdpbGwgYmUgZmlsbGVkIHdpdGggMC5cblx0XHQgKi9cblx0XHRnZXRDbGllbnRSZWN0c1JlZ2lvbigpIHtcblx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRjb25zdCBuYXRpdmVTZWxlY3Rpb24gPSBzZWxlY3Rpb24uZ2V0TmF0aXZlKCk7XG5cblx0XHRcdGNvbnN0IGRlZmF1bHRSZWN0ID0ge1xuXHRcdFx0XHRib3R0b206IDAsXG5cdFx0XHRcdGhlaWdodDogMCxcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0d2lkdGg6IDAsXG5cdFx0XHR9O1xuXG5cdFx0XHRsZXQgcmVnaW9uID0ge1xuXHRcdFx0XHRib3R0b206IDAsXG5cdFx0XHRcdGVuZFJlY3Q6IGRlZmF1bHRSZWN0LFxuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRzdGFydFJlY3Q6IGRlZmF1bHRSZWN0LFxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCFuYXRpdmVTZWxlY3Rpb24pIHtcblx0XHRcdFx0cmV0dXJuIHJlZ2lvbjtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGJvdHRvbSA9IDA7XG5cdFx0XHRsZXQgY2xpZW50UmVjdHM7XG5cdFx0XHRsZXQgbGVmdCA9IEluZmluaXR5O1xuXHRcdFx0bGV0IHJpZ2h0ID0gLUluZmluaXR5O1xuXHRcdFx0bGV0IHRvcCA9IEluZmluaXR5O1xuXG5cdFx0XHRpZiAobmF0aXZlU2VsZWN0aW9uLmNyZWF0ZVJhbmdlKSB7XG5cdFx0XHRcdGNsaWVudFJlY3RzID0gbmF0aXZlU2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZ2V0Q2xpZW50UmVjdHMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsaWVudFJlY3RzID1cblx0XHRcdFx0XHRuYXRpdmVTZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDBcblx0XHRcdFx0XHRcdD8gbmF0aXZlU2VsZWN0aW9uLmdldFJhbmdlQXQoMCkuZ2V0Q2xpZW50UmVjdHMoKVxuXHRcdFx0XHRcdFx0OiBbXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNsaWVudFJlY3RzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRyZWdpb24gPSB0aGlzLmdldENhcmV0UmVnaW9uKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gY2xpZW50UmVjdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBpdGVtID0gY2xpZW50UmVjdHNbaV07XG5cblx0XHRcdFx0XHRpZiAoaXRlbS5sZWZ0IDwgbGVmdCkge1xuXHRcdFx0XHRcdFx0bGVmdCA9IGl0ZW0ubGVmdDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaXRlbS5yaWdodCA+IHJpZ2h0KSB7XG5cdFx0XHRcdFx0XHRyaWdodCA9IGl0ZW0ucmlnaHQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGl0ZW0udG9wIDwgdG9wKSB7XG5cdFx0XHRcdFx0XHR0b3AgPSBpdGVtLnRvcDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaXRlbS5ib3R0b20gPiBib3R0b20pIHtcblx0XHRcdFx0XHRcdGJvdHRvbSA9IGl0ZW0uYm90dG9tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHNjcm9sbFBvcyA9IG5ldyBDS0VESVRPUi5kb20ud2luZG93KFxuXHRcdFx0XHRcdHdpbmRvd1xuXHRcdFx0XHQpLmdldFNjcm9sbFBvc2l0aW9uKCk7XG5cblx0XHRcdFx0cmVnaW9uLmJvdHRvbSA9IHNjcm9sbFBvcy55ICsgYm90dG9tO1xuXHRcdFx0XHRyZWdpb24ubGVmdCA9IHNjcm9sbFBvcy54ICsgbGVmdDtcblx0XHRcdFx0cmVnaW9uLnJpZ2h0ID0gc2Nyb2xsUG9zLnggKyByaWdodDtcblx0XHRcdFx0cmVnaW9uLnRvcCA9IHNjcm9sbFBvcy55ICsgdG9wO1xuXG5cdFx0XHRcdGlmIChjbGllbnRSZWN0cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRjb25zdCBlbmRSZWN0ID0gY2xpZW50UmVjdHNbY2xpZW50UmVjdHMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnRSZWN0ID0gY2xpZW50UmVjdHNbMF07XG5cblx0XHRcdFx0XHRyZWdpb24uZW5kUmVjdCA9IHtcblx0XHRcdFx0XHRcdGJvdHRvbTogc2Nyb2xsUG9zLnkgKyBlbmRSZWN0LmJvdHRvbSxcblx0XHRcdFx0XHRcdGhlaWdodDogZW5kUmVjdC5oZWlnaHQsXG5cdFx0XHRcdFx0XHRsZWZ0OiBzY3JvbGxQb3MueCArIGVuZFJlY3QubGVmdCxcblx0XHRcdFx0XHRcdHJpZ2h0OiBzY3JvbGxQb3MueCArIGVuZFJlY3QucmlnaHQsXG5cdFx0XHRcdFx0XHR0b3A6IHNjcm9sbFBvcy55ICsgZW5kUmVjdC50b3AsXG5cdFx0XHRcdFx0XHR3aWR0aDogZW5kUmVjdC53aWR0aCxcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0cmVnaW9uLnN0YXJ0UmVjdCA9IHtcblx0XHRcdFx0XHRcdGJvdHRvbTogc2Nyb2xsUG9zLnkgKyBzdGFydFJlY3QuYm90dG9tLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBzdGFydFJlY3QuaGVpZ2h0LFxuXHRcdFx0XHRcdFx0bGVmdDogc2Nyb2xsUG9zLnggKyBzdGFydFJlY3QubGVmdCxcblx0XHRcdFx0XHRcdHJpZ2h0OiBzY3JvbGxQb3MueCArIHN0YXJ0UmVjdC5yaWdodCxcblx0XHRcdFx0XHRcdHRvcDogc2Nyb2xsUG9zLnkgKyBzdGFydFJlY3QudG9wLFxuXHRcdFx0XHRcdFx0d2lkdGg6IHN0YXJ0UmVjdC53aWR0aCxcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZWdpb247XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHJpZXZlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzZWxlY3Rpb24uIFRoZSBkaXJlY3Rpb24gaXMgZnJvbSB0b3AgdG8gYm90dG9tIG9yIGZyb20gYm90dG9tIHRvIHRvcC5cblx0XHQgKiBGb3IgSUUgPCA5IGl0IGlzIG5vdCBwb3NzaWJsZSwgc28gdGhlIGRpcmVjdGlvbiBmb3IgdGhlc2UgYnJvd3NlcnMgd2lsbCBiZSBhbHdheXMgQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT00uXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG5cdFx0ICogQG1ldGhvZCBnZXRTZWxlY3Rpb25EaXJlY3Rpb25cblx0XHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgYSBudW1iZXIgd2hpY2ggcmVwcmVzZW50cyBzZWxlY3Rpb24gZGlyZWN0aW9uLiBJdCBtaWdodCBiZSBvbmUgb2YgdGhlc2U6XG5cdFx0ICogLSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTTtcblx0XHQgKiAtIENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QO1xuXHRcdCAqL1xuXHRcdGdldFNlbGVjdGlvbkRpcmVjdGlvbigpIHtcblx0XHRcdGxldCBkaXJlY3Rpb24gPSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTTtcblx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRjb25zdCBuYXRpdmVTZWxlY3Rpb24gPSBzZWxlY3Rpb24uZ2V0TmF0aXZlKCk7XG5cblx0XHRcdGlmICghbmF0aXZlU2VsZWN0aW9uKSB7XG5cdFx0XHRcdHJldHVybiBkaXJlY3Rpb247XG5cdFx0XHR9XG5cblx0XHRcdGxldCBhbmNob3JOb2RlO1xuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdChhbmNob3JOb2RlID0gbmF0aXZlU2VsZWN0aW9uLmFuY2hvck5vZGUpICYmXG5cdFx0XHRcdGFuY2hvck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHRcdCkge1xuXHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9IGFuY2hvck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oXG5cdFx0XHRcdFx0bmF0aXZlU2VsZWN0aW9uLmZvY3VzTm9kZVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQoIXBvc2l0aW9uICYmXG5cdFx0XHRcdFx0XHRuYXRpdmVTZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ID5cblx0XHRcdFx0XHRcdFx0bmF0aXZlU2VsZWN0aW9uLmZvY3VzT2Zmc2V0KSB8fFxuXHRcdFx0XHRcdHBvc2l0aW9uID09PSBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElOR1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRkaXJlY3Rpb24gPSBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGlyZWN0aW9uO1xuXHRcdH0sXG5cdH07XG5cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3NlbGVjdGlvbnJlZ2lvbicsIHtcblx0XHRpbml0KGVkaXRvcikge1xuXHRcdFx0bGV0IGF0dHI7XG5cdFx0XHRjb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblx0XHRcdGZvciAoYXR0ciBpbiBTZWxlY3Rpb25SZWdpb24ucHJvdG90eXBlKSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRoYXNPd25Qcm9wZXJ0eS5jYWxsKFNlbGVjdGlvblJlZ2lvbi5wcm90b3R5cGUsIGF0dHIpICYmXG5cdFx0XHRcdFx0dHlwZW9mIGVkaXRvclthdHRyXSA9PT0gJ3VuZGVmaW5lZCdcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZWRpdG9yW2F0dHJdID0gU2VsZWN0aW9uUmVnaW9uLnByb3RvdHlwZVthdHRyXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdH0pO1xufVxuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5jb25zdCBJRV9OT05fRElSRUNUTFlfRURJVEFCTEVfRUxFTUVOVCA9IHtcblx0dGFibGU6IDEsXG5cdGNvbDogMSxcblx0Y29sZ3JvdXA6IDEsXG5cdHRib2R5OiAxLFxuXHR0ZDogMSxcblx0dGZvb3Q6IDEsXG5cdHRoOiAxLFxuXHR0aGVhZDogMSxcblx0dHI6IDEsXG59O1xuXG4vKipcbiAqIFRhYmxlIGNsYXNzIHV0aWxpdHkuIFByb3ZpZGVzIG1ldGhvZHMgZm9yIGNyZWF0ZSwgZGVsZXRlIGFuZCB1cGRhdGUgdGFibGVzLlxuICpcbiAqIEBjbGFzcyBDS0VESVRPUi5UYWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBDS0VkaXRvciBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBUYWJsZShlZGl0b3IpIHtcblx0dGhpcy5fZWRpdG9yID0gZWRpdG9yO1xufVxuXG5UYWJsZS5IRUFESU5HX0JPVEggPSAnQm90aCc7XG5UYWJsZS5IRUFESU5HX0NPTCA9ICdDb2x1bW4nO1xuVGFibGUuSEVBRElOR19OT05FID0gJ05vbmUnO1xuVGFibGUuSEVBRElOR19ST1cgPSAnUm93JztcblxuVGFibGUucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVGFibGUsXG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSB0YWJsZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuXHQgKiBAbWV0aG9kIGNyZWF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRhYmxlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNyZWF0ZWQgdGFibGVcblx0ICovXG5cdGNyZWF0ZShjb25maWcpIHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG5cdFx0Y29uc3QgdGFibGUgPSB0aGlzLl9jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xuXG5cdFx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdFx0Ly8gR2VuZXJhdGUgdGhlIHJvd3MgYW5kIGNvbHMuXG5cblx0XHRjb25zdCB0Ym9keSA9IHRhYmxlLmFwcGVuZCh0aGlzLl9jcmVhdGVFbGVtZW50KCd0Ym9keScpKTtcblx0XHRjb25zdCByb3dzID0gY29uZmlnLnJvd3MgfHwgMTtcblx0XHRjb25zdCBjb2xzID0gY29uZmlnLmNvbHMgfHwgMTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG5cdFx0XHRjb25zdCByb3cgPSB0Ym9keS5hcHBlbmQodGhpcy5fY3JlYXRlRWxlbWVudCgndHInKSk7XG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7IGorKykge1xuXHRcdFx0XHRjb25zdCBjZWxsID0gcm93LmFwcGVuZCh0aGlzLl9jcmVhdGVFbGVtZW50KCd0ZCcpKTtcblxuXHRcdFx0XHRjZWxsLmFwcGVuZEJvZ3VzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGVzKHRhYmxlLCBjb25maWcuYXR0cnMpO1xuXHRcdHRoaXMuc2V0SGVhZGluZyh0YWJsZSwgY29uZmlnLmhlYWRpbmcpO1xuXG5cdFx0Ly8gSW5zZXJ0IHRoZSB0YWJsZSBlbGVtZW50IGlmIHdlJ3JlIGNyZWF0aW5nIG9uZS5cblxuXHRcdGVkaXRvci5pbnNlcnRFbGVtZW50KHRhYmxlKTtcblxuXHRcdGNvbnN0IGZpcnN0Q2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCh0YWJsZS4kLnJvd3NbMF0uY2VsbHNbMF0pO1xuXHRcdGNvbnN0IHJhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG5cdFx0cmFuZ2UubW92ZVRvUG9zaXRpb24oZmlyc3RDZWxsLCBDS0VESVRPUi5QT1NJVElPTl9BRlRFUl9TVEFSVCk7XG5cdFx0cmFuZ2Uuc2VsZWN0KCk7XG5cblx0XHRyZXR1cm4gdGFibGU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyBhIHRhYmxlIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG5cdCAqIEBtZXRob2QgZ2V0RnJvbVNlbGVjdGlvblxuXHQgKiBAcmV0dXJuIHtDS0VESVRPUi5kb20uZWxlbWVudH0gVGhlIHJldHJpZXZlZCB0YWJsZSBvciBudWxsIGlmIG5vdCBmb3VuZC5cblx0ICovXG5cdGdldEZyb21TZWxlY3Rpb24oKSB7XG5cdFx0bGV0IHRhYmxlO1xuXHRcdGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuX2VkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRjb25zdCBzZWxlY3RlZCA9IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuXHRcdGlmIChzZWxlY3RlZCAmJiBzZWxlY3RlZC5pcygndGFibGUnKSkge1xuXHRcdFx0dGFibGUgPSBzZWxlY3RlZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgcmFuZ2VzID0gc2VsZWN0aW9uLmdldFJhbmdlcygpO1xuXG5cdFx0XHRpZiAocmFuZ2VzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Ly8gV2Via2l0IGNvdWxkIHJlcG9ydCB0aGUgZm9sbG93aW5nIHJhbmdlIG9uIGNlbGwgc2VsZWN0aW9uICgjNDk0OCk6XG5cdFx0XHRcdC8vIDx0YWJsZT48dHI+PHRkPlsmbmJzcDs8L3RkPjwvdHI+PC90YWJsZT5dXG5cblx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0XHRcdFx0aWYgKENLRURJVE9SLmVudi53ZWJraXQpIHtcblx0XHRcdFx0XHRyYW5nZXNbMF0uc2hyaW5rKENLRURJVE9SLk5PREVfRUxFTUVOVCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YWJsZSA9IHRoaXMuX2VkaXRvclxuXHRcdFx0XHRcdC5lbGVtZW50UGF0aChyYW5nZXNbMF0uZ2V0Q29tbW9uQW5jZXN0b3IodHJ1ZSkpXG5cdFx0XHRcdFx0LmNvbnRhaW5zKCd0YWJsZScsIDEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0YWJsZTtcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGEgZ2l2ZW4gdGFibGUgY2FuIGJlIGNvbnNpZGVyZWQgYXMgZWRpdGFibGUuIFRoaXMgbWV0aG9kXG5cdCAqIHdvcmthcm91bmRzIGEgbGltaXRhdGlvbiBvZiBJRSB3aGVyZSBmb3Igc29tZSBlbGVtZW50cyAobGlrZSB0YWJsZSksXG5cdCAqIGBpc0NvbnRlbnRFZGl0YWJsZWAgcmV0dXJucyBhbHdheXMgZmFsc2UuIFRoaXMgaXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBzdXBwb3J0XG5cdCAqIGBjb250ZW50ZWRpdGFibGVgIG9uIHN1Y2ggZWxlbWVudHMuIEhvd2V2ZXIsIGRlc3BpdGUgc3VjaCBlbGVtZW50c1xuXHQgKiBjYW5ub3QgYmUgc2V0IGFzIGNvbnRlbnQgZWRpdGFibGUgZGlyZWN0bHksIGEgY29udGVudCBlZGl0YWJsZSBTUEFOLFxuXHQgKiBvciBESVYgZWxlbWVudCBjYW4gYmUgcGxhY2VkIGluc2lkZSB0aGUgaW5kaXZpZHVhbCB0YWJsZSBjZWxscy5cblx0ICogU2VlIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1Mzc4MzclMjh2PVZTLjg1JTI5LmFzcHhcblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuXHQgKiBAbWV0aG9kIGlzRWRpdGFibGVcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZWwgVGhlIHRhYmxlIGVsZW1lbnQgdG8gdGVzdCBpZiBlZGl0YWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0aXNFZGl0YWJsZShlbCkge1xuXHRcdGlmICghQ0tFRElUT1IuZW52LmllIHx8ICFlbC5pcyhJRV9OT05fRElSRUNUTFlfRURJVEFCTEVfRUxFTUVOVCkpIHtcblx0XHRcdHJldHVybiAhZWwuaXNSZWFkT25seSgpO1xuXHRcdH1cblxuXHRcdGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XG5cdFx0XHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSAhPT0gJ2ZhbHNlJztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5pc0VkaXRhYmxlKGVsLmdldFBhcmVudCgpKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB3aGljaCBoZWFkaW5nIHN0eWxlIGlzIHNldCBmb3IgdGhlIGdpdmVuIHRhYmxlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG5cdCAqIEBtZXRob2QgZ2V0SGVhZGluZ1xuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSB0YWJsZSBUaGUgdGFibGUgdG8gZ2F0aGVyIHRoZSBoZWFkaW5nIGZyb20uIElmIG51bGwsIGl0IHdpbGwgYmUgcmV0cmlldmVkIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBoZWFkaW5nIG9mIHRoZSB0YWJsZS4gRXhwZWN0ZWQgdmFsdWVzIGFyZSBgQ0tFRElUT1IuVGFibGUuTk9ORWAsIGBDS0VESVRPUi5UYWJsZS5ST1dgLCBgQ0tFRElUT1IuVGFibGUuQ09MYCBhbmQgYENLRURJVE9SLlRhYmxlLkJPVEhgLlxuXHQgKi9cblx0Z2V0SGVhZGluZyh0YWJsZSkge1xuXHRcdHRhYmxlID0gdGFibGUgfHwgdGhpcy5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cblx0XHRpZiAoIXRhYmxlKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRjb25zdCByb3dIZWFkaW5nU2V0dGluZ3MgPSB0YWJsZS4kLnRIZWFkICE9PSBudWxsO1xuXG5cdFx0bGV0IGNvbEhlYWRpbmdTZXR0aW5ncyA9IHRydWU7XG5cblx0XHQvLyBDaGVjayBpZiBhbGwgb2YgdGhlIGZpcnN0IGNlbGxzIGluIGV2ZXJ5IHJvdyBhcmUgVEhcblxuXHRcdGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRhYmxlLiQucm93cy5sZW5ndGg7IHJvdysrKSB7XG5cdFx0XHQvLyBJZiBqdXN0IG9uZSBjZWxsIGlzbid0IGEgVEggdGhlbiBpdCBpc24ndCBhIGhlYWRlciBjb2x1bW5cblxuXHRcdFx0Y29uc3QgY2VsbCA9IHRhYmxlLiQucm93c1tyb3ddLmNlbGxzWzBdO1xuXG5cdFx0XHRpZiAoY2VsbCAmJiBjZWxsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICd0aCcpIHtcblx0XHRcdFx0Y29sSGVhZGluZ1NldHRpbmdzID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCBoZWFkaW5nU2V0dGluZ3MgPSBUYWJsZS5IRUFESU5HX05PTkU7XG5cblx0XHRpZiAocm93SGVhZGluZ1NldHRpbmdzKSB7XG5cdFx0XHRoZWFkaW5nU2V0dGluZ3MgPSBUYWJsZS5IRUFESU5HX1JPVztcblx0XHR9XG5cblx0XHRpZiAoY29sSGVhZGluZ1NldHRpbmdzKSB7XG5cdFx0XHRoZWFkaW5nU2V0dGluZ3MgPVxuXHRcdFx0XHRoZWFkaW5nU2V0dGluZ3MgPT09IFRhYmxlLkhFQURJTkdfUk9XXG5cdFx0XHRcdFx0PyBUYWJsZS5IRUFESU5HX0JPVEhcblx0XHRcdFx0XHQ6IFRhYmxlLkhFQURJTkdfQ09MO1xuXHRcdH1cblxuXHRcdHJldHVybiBoZWFkaW5nU2V0dGluZ3M7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYSB0YWJsZSBmcm9tIHRoZSBlZGl0b3IuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IuVGFibGVcblx0ICogQG1ldGhvZCByZW1vdmVcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gdGFibGUgVGhlIHRhYmxlIGVsZW1lbnQgd2hpY2ggdGFibGUgc3R5bGUgc2hvdWxkIGJlIHJlbW92ZWQuXG5cdCAqL1xuXHRyZW1vdmUodGFibGUpIHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLl9lZGl0b3I7XG5cblx0XHRpZiAodGFibGUpIHtcblx0XHRcdHRhYmxlLnJlbW92ZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YWJsZSA9IGVkaXRvci5lbGVtZW50UGF0aCgpLmNvbnRhaW5zKCd0YWJsZScsIDEpO1xuXG5cdFx0XHRpZiAodGFibGUpIHtcblx0XHRcdFx0Ly8gSWYgdGhlIHRhYmxlJ3MgcGFyZW50IGhhcyBvbmx5IG9uZSBjaGlsZCByZW1vdmUgaXQgYXMgd2VsbCAodW5sZXNzIGl0J3MgYSB0YWJsZSBjZWxsLCBvciB0aGUgZWRpdGFibGUgZWxlbWVudCkgKCM1NDE2LCAjNjI4OSwgIzEyMTEwKVxuXG5cdFx0XHRcdGNvbnN0IHBhcmVudCA9IHRhYmxlLmdldFBhcmVudCgpO1xuXHRcdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRwYXJlbnQuZ2V0Q2hpbGRDb3VudCgpID09PSAxICYmXG5cdFx0XHRcdFx0IXBhcmVudC5pcygndGQnLCAndGgnKSAmJlxuXHRcdFx0XHRcdCFwYXJlbnQuZXF1YWxzKGVkaXRhYmxlKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHR0YWJsZSA9IHBhcmVudDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHJhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG5cdFx0XHRcdHJhbmdlLm1vdmVUb1Bvc2l0aW9uKHRhYmxlLCBDS0VESVRPUi5QT1NJVElPTl9CRUZPUkVfU1RBUlQpO1xuXHRcdFx0XHR0YWJsZS5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFzc2lnbnMgcHJvdmlkZWQgYXR0cmlidXRlcyB0byBhIHRhYmxlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG5cdCAqIEBtZXRob2Qgc2V0QXR0cmlidXRlc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFibGUgVGhlIHRhYmxlIHRvIHdoaWNoIHRoZSBhdHRyaWJ1dGVzIHNob3VsZCBiZSBhc3NpZ25lZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXR0cnMgVGhlIGF0dHJpYnV0ZXMgd2hpY2ggaGF2ZSB0byBiZSBhc3NpZ25lZCB0byB0aGUgdGFibGVcblx0ICovXG5cdHNldEF0dHJpYnV0ZXModGFibGUsIGF0dHJzKSB7XG5cdFx0aWYgKGF0dHJzKSB7XG5cdFx0XHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChhdHRyID0+IHtcblx0XHRcdFx0dGFibGUuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0cyB0aGUgYXBwcm9wcmlhdGUgdGFibGUgaGVhZGluZyBzdHlsZSB0byBhIHRhYmxlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG5cdCAqIEBtZXRob2Qgc2V0SGVhZGluZ1xuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSB0YWJsZSBUaGUgdGFibGUgZWxlbWVudCB0byB3aGljaCB0aGUgaGVhZGluZyBzaG91bGQgYmUgc2V0LiBJZiBudWxsLCBpdCB3aWxsIGJlIHJldHJpZXZlZCBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGhlYWRpbmcgVGhlIHRhYmxlIGhlYWRpbmcgdG8gYmUgc2V0LiBBY2NlcHRlZCB2YWx1ZXMgYXJlOiBgQ0tFRElUT1IuVGFibGUuTk9ORWAsIGBDS0VESVRPUi5UYWJsZS5ST1dgLCBgQ0tFRElUT1IuVGFibGUuQ09MYCBhbmQgYENLRURJVE9SLlRhYmxlLkJPVEhgLlxuXHQgKi9cblx0c2V0SGVhZGluZyh0YWJsZSwgaGVhZGluZykge1xuXHRcdHRhYmxlID0gdGFibGUgfHwgdGhpcy5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbmV3Q2VsbDtcblx0XHRsZXQgdGFibGVIZWFkO1xuXHRcdGNvbnN0IHRhYmxlQm9keSA9IHRhYmxlLmdldEVsZW1lbnRzQnlUYWcoJ3Rib2R5JykuZ2V0SXRlbSgwKTtcblxuXHRcdGxldCB0YWJsZUhlYWRpbmcgPSB0aGlzLmdldEhlYWRpbmcodGFibGUpO1xuXHRcdGNvbnN0IGhhZENvbEhlYWRpbmcgPVxuXHRcdFx0dGFibGVIZWFkaW5nID09PSBUYWJsZS5IRUFESU5HX0NPTCB8fFxuXHRcdFx0dGFibGVIZWFkaW5nID09PSBUYWJsZS5IRUFESU5HX0JPVEg7XG5cblx0XHRjb25zdCBuZWVkQ29sSGVhZGluZyA9XG5cdFx0XHRoZWFkaW5nID09PSBUYWJsZS5IRUFESU5HX0NPTCB8fCBoZWFkaW5nID09PSBUYWJsZS5IRUFESU5HX0JPVEg7XG5cdFx0Y29uc3QgbmVlZFJvd0hlYWRpbmcgPVxuXHRcdFx0aGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19ST1cgfHwgaGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19CT1RIO1xuXG5cdFx0Ly8gSWYgd2UgbmVlZCByb3cgaGVhZGluZyBhbmQgZG9uJ3QgaGF2ZSBhIDx0aGVhZD4gZWxlbWVudCB5ZXQsIG1vdmUgdGhlXG5cdFx0Ly8gZmlyc3Qgcm93IG9mIHRoZSB0YWJsZSB0byB0aGUgaGVhZCBhbmQgY29udmVydCB0aGUgbm9kZXMgdG8gPHRoPiBvbmVzLlxuXG5cdFx0aWYgKCF0YWJsZS4kLnRIZWFkICYmIG5lZWRSb3dIZWFkaW5nKSB7XG5cdFx0XHRjb25zdCB0YWJsZUZpcnN0Um93ID0gdGFibGVCb2R5LmdldEVsZW1lbnRzQnlUYWcoJ3RyJykuZ2V0SXRlbSgwKTtcblx0XHRcdGNvbnN0IHRhYmxlRmlyc3RSb3dDaGlsZENvdW50ID0gdGFibGVGaXJzdFJvdy5nZXRDaGlsZENvdW50KCk7XG5cblx0XHRcdC8vIENoYW5nZSBURCB0byBUSDpcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHRhYmxlRmlyc3RSb3dDaGlsZENvdW50OyBpKyspIHtcblx0XHRcdFx0Y29uc3QgY2VsbCA9IHRhYmxlRmlyc3RSb3cuZ2V0Q2hpbGQoaSk7XG5cblx0XHRcdFx0Ly8gU2tpcCBib29rbWFyayBub2Rlcy4gKCM2MTU1KVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRjZWxsLnR5cGUgPT09IENLRURJVE9SLk5PREVfRUxFTUVOVCAmJlxuXHRcdFx0XHRcdCFjZWxsLmRhdGEoJ2NrZS1ib29rbWFyaycpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGNlbGwucmVuYW1lTm9kZSgndGgnKTtcblx0XHRcdFx0XHRjZWxsLnNldEF0dHJpYnV0ZSgnc2NvcGUnLCAnY29sJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGFibGVIZWFkID0gdGhpcy5fY3JlYXRlRWxlbWVudCh0YWJsZS4kLmNyZWF0ZVRIZWFkKCkpO1xuXHRcdFx0dGFibGVIZWFkLmFwcGVuZCh0YWJsZUZpcnN0Um93LnJlbW92ZSgpKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBkb24ndCBuZWVkIHJvdyBoZWFkaW5nIGFuZCB3ZSBoYXZlIGEgPHRoZWFkPiBlbGVtZW50LCBtb3ZlIHRoZVxuXHRcdC8vIHJvdyBvdXQgb2YgdGhlcmUgYW5kIGludG8gdGhlIDx0Ym9keT4gZWxlbWVudC5cblxuXHRcdGlmICh0YWJsZS4kLnRIZWFkICE9PSBudWxsICYmICFuZWVkUm93SGVhZGluZykge1xuXHRcdFx0Ly8gTW92ZSB0aGUgcm93IG91dCBvZiB0aGUgVEhlYWQgYW5kIHB1dCBpdCBpbiB0aGUgVEJvZHk6XG5cblx0XHRcdHRhYmxlSGVhZCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQodGFibGUuJC50SGVhZCk7XG5cblx0XHRcdGNvbnN0IHByZXZpb3VzRmlyc3RSb3cgPSB0YWJsZUJvZHkuZ2V0Rmlyc3QoKTtcblxuXHRcdFx0d2hpbGUgKHRhYmxlSGVhZC5nZXRDaGlsZENvdW50KCkgPiAwKSB7XG5cdFx0XHRcdGNvbnN0IG5ld0ZpcnN0Um93ID0gdGFibGVIZWFkLmdldEZpcnN0KCk7XG5cdFx0XHRcdGNvbnN0IG5ld0ZpcnN0Um93Q2hpbGRDb3VudCA9IG5ld0ZpcnN0Um93LmdldENoaWxkQ291bnQoKTtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbmV3Rmlyc3RSb3dDaGlsZENvdW50OyBpKyspIHtcblx0XHRcdFx0XHRuZXdDZWxsID0gbmV3Rmlyc3RSb3cuZ2V0Q2hpbGQoaSk7XG5cblx0XHRcdFx0XHRpZiAobmV3Q2VsbC50eXBlID09PSBDS0VESVRPUi5OT0RFX0VMRU1FTlQpIHtcblx0XHRcdFx0XHRcdG5ld0NlbGwucmVuYW1lTm9kZSgndGQnKTtcblx0XHRcdFx0XHRcdG5ld0NlbGwucmVtb3ZlQXR0cmlidXRlKCdzY29wZScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5ld0ZpcnN0Um93Lmluc2VydEJlZm9yZShwcmV2aW91c0ZpcnN0Um93KTtcblx0XHRcdH1cblxuXHRcdFx0dGFibGVIZWFkLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdHRhYmxlSGVhZGluZyA9IHRoaXMuZ2V0SGVhZGluZyh0YWJsZSk7XG5cdFx0Y29uc3QgaGFzQ29sSGVhZGluZyA9XG5cdFx0XHR0YWJsZUhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfQ09MIHx8XG5cdFx0XHR0YWJsZUhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfQk9USDtcblxuXHRcdC8vIElmIHdlIG5lZWQgY29sdW1uIGhlYWRpbmcgYW5kIHRoZSB0YWJsZSBkb2Vzbid0IGhhdmUgaXQsIGNvbnZlcnQgZXZlcnkgZmlyc3QgY2VsbCBpblxuXHRcdC8vIGV2ZXJ5IHJvdyBpbnRvIGEgYDx0aCBzY29wZT1cInJvd1wiPmAgZWxlbWVudC5cblxuXHRcdGlmICghaGFzQ29sSGVhZGluZyAmJiBuZWVkQ29sSGVhZGluZykge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHRhYmxlLiQucm93cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodGFibGUuJC5yb3dzW2ldLmNlbGxzWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICd0aCcpIHtcblx0XHRcdFx0XHRuZXdDZWxsID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KFxuXHRcdFx0XHRcdFx0dGFibGUuJC5yb3dzW2ldLmNlbGxzWzBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRuZXdDZWxsLnJlbmFtZU5vZGUoJ3RoJyk7XG5cdFx0XHRcdFx0bmV3Q2VsbC5zZXRBdHRyaWJ1dGUoJ3Njb3BlJywgJ3JvdycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZG9uJ3QgbmVlZCBjb2x1bW4gaGVhZGluZyBidXQgdGhlIHRhYmxlIGhhcyBpdCwgY29udmVydCBldmVyeSBmaXJzdCBjZWxsIGluIGV2ZXJ5XG5cdFx0Ly8gcm93IGJhY2sgaW50byBhIGA8dGQ+YCBlbGVtZW50LlxuXG5cdFx0aWYgKGhhZENvbEhlYWRpbmcgJiYgIW5lZWRDb2xIZWFkaW5nKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGFibGUuJC5yb3dzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHJvdyA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCh0YWJsZS4kLnJvd3NbaV0pO1xuXG5cdFx0XHRcdGlmIChyb3cuZ2V0UGFyZW50KCkuZ2V0TmFtZSgpID09PSAndGJvZHknKSB7XG5cdFx0XHRcdFx0bmV3Q2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChyb3cuJC5jZWxsc1swXSk7XG5cdFx0XHRcdFx0bmV3Q2VsbC5yZW5hbWVOb2RlKCd0ZCcpO1xuXHRcdFx0XHRcdG5ld0NlbGwucmVtb3ZlQXR0cmlidXRlKCdzY29wZScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IENLRURJVE9SLmRvbS5lbGVtZW50IHVzaW5nIHRoZSBwYXNzZWQgdGFnIG5hbWUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IuVGFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF9jcmVhdGVFbGVtZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSB0YWcgbmFtZSBmcm9tIHdoaWNoIGFuIGVsZW1lbnQgc2hvdWxkIGJlIGNyZWF0ZWRcblx0ICogQHJldHVybiB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IEluc3RhbmNlIG9mIENLRURJVE9SIERPTSBlbGVtZW50IGNsYXNzXG5cdCAqL1xuXHRfY3JlYXRlRWxlbWVudChuYW1lKSB7XG5cdFx0cmV0dXJuIG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChuYW1lLCB0aGlzLl9lZGl0b3IuZG9jdW1lbnQpO1xuXHR9LFxufTtcblxuQ0tFRElUT1Iub24oJ2luc3RhbmNlUmVhZHknLCBldmVudCA9PiB7XG5cdGNvbnN0IGhlYWRpbmdDb21tYW5kcyA9IFtcblx0XHRUYWJsZS5IRUFESU5HX05PTkUsXG5cdFx0VGFibGUuSEVBRElOR19ST1csXG5cdFx0VGFibGUuSEVBRElOR19DT0wsXG5cdFx0VGFibGUuSEVBRElOR19CT1RILFxuXHRdO1xuXG5cdGNvbnN0IHRhYmxlVXRpbHMgPSBuZXcgVGFibGUoZXZlbnQuZWRpdG9yKTtcblxuXHRoZWFkaW5nQ29tbWFuZHMuZm9yRWFjaChoZWFkaW5nID0+IHtcblx0XHRldmVudC5lZGl0b3IuYWRkQ29tbWFuZCgndGFibGVIZWFkaW5nJyArIGhlYWRpbmcsIHtcblx0XHRcdGV4ZWMoX2VkaXRvcikge1xuXHRcdFx0XHR0YWJsZVV0aWxzLnNldEhlYWRpbmcobnVsbCwgaGVhZGluZyk7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXHR9KTtcbn0pO1xuXG5DS0VESVRPUi5UYWJsZSA9IENLRURJVE9SLlRhYmxlIHx8IFRhYmxlO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG4vKipcbiAqIENLRURJVE9SLnRvb2xzIGNsYXNzIHV0aWxpdHkgd2hpY2ggYWRkcyBhZGRpdGlvbmFsIG1ldGhvZHMgdG8gdGhvc2Ugb2YgQ0tFZGl0b3IuXG4gKlxuICogQGNsYXNzIENLRURJVE9SLnRvb2xzXG4gKi9cblxuLyoqXG4gKiBTZW5kcyBhIHJlcXVlc3QgdXNpbmcgdGhlIEpTT05QIHRlY2huaXF1ZS5cbiAqXG4gKiBAbWVtYmVyb2YgQ0tFRElUT1IudG9vbHNcbiAqIEBtZXRob2QganNvbnBcbiAqIEBwYXJhbSB7Q0tFRElUT1IudGVtcGxhdGV9IHVybFRlbXBsYXRlIFRoZSB0ZW1wbGF0ZSBvZiB0aGUgVVJMIHRvIGJlIHJlcXVlc3RlZC4gQWxsIHByb3BlcnRpZXMgcGFzc2VkIGluIGB1cmxQYXJhbXNgIGNhbiBiZSB1c2VkLCBwbHVzIGEgYHtjYWxsYmFja31gLCB3aGljaCByZXByZXNlbnQgYSBKU09OUCBjYWxsYmFjaywgbXVzdCBiZSBkZWZpbmVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaW4gY2FzZSBvZiBzdWNjZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3JDYWxsYmFjayBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gKiBAcGFyYW0ge09iamVjdH0gdXJsUGFyYW1zIFBhcmFtZXRlcnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBgdXJsVGVtcGxhdGVgLlxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAgLSBpZDogdGhlIHRyYW5zYWN0aW9uIElEXG4gKiAgLSBhIGBjYW5jZWwoKWAgbWV0aG9kXG4gKiBAc3RhdGljXG4gKi9cbkNLRURJVE9SLnRvb2xzLmpzb25wID0gZnVuY3Rpb24oXG5cdHVybFRlbXBsYXRlLFxuXHR1cmxQYXJhbXMsXG5cdGNhbGxiYWNrLFxuXHRlcnJvckNhbGxiYWNrXG4pIHtcblx0Y29uc3QgY2FsbGJhY2tLZXkgPSBDS0VESVRPUi50b29scy5nZXROZXh0TnVtYmVyKCk7XG5cblx0dXJsUGFyYW1zID0gdXJsUGFyYW1zIHx8IHt9O1xuXHR1cmxQYXJhbXMuY2FsbGJhY2sgPSAnQ0tFRElUT1IuXy5qc29ucENhbGxiYWNrc1snICsgY2FsbGJhY2tLZXkgKyAnXSc7XG5cblx0aWYgKCFDS0VESVRPUi5fLmpzb25wQ2FsbGJhY2tzKSB7XG5cdFx0Q0tFRElUT1IuXy5qc29ucENhbGxiYWNrcyA9IHt9O1xuXHR9XG5cblx0Q0tFRElUT1IuXy5qc29ucENhbGxiYWNrc1tjYWxsYmFja0tleV0gPSBmdW5jdGlvbihyZXNwb25zZSkge1xuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0Y2xlYW5VcCgpO1xuXG5cdFx0XHRjYWxsYmFjayhyZXNwb25zZSk7XG5cdFx0fSk7XG5cdH07XG5cblx0bGV0IHNjcmlwdEVsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRzY3JpcHRFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3JjJywgdXJsVGVtcGxhdGUub3V0cHV0KHVybFBhcmFtcykpO1xuXHRzY3JpcHRFbGVtZW50Lm9uKCdlcnJvcicsICgpID0+IHtcblx0XHRjbGVhblVwKCk7XG5cblx0XHRpZiAoZXJyb3JDYWxsYmFjaykge1xuXHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gY2xlYW5VcCgpIHtcblx0XHRpZiAoc2NyaXB0RWxlbWVudCkge1xuXHRcdFx0c2NyaXB0RWxlbWVudC5yZW1vdmUoKTtcblx0XHRcdGRlbGV0ZSBDS0VESVRPUi5fLmpzb25wQ2FsbGJhY2tzW2NhbGxiYWNrS2V5XTtcblx0XHRcdHNjcmlwdEVsZW1lbnQgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdENLRURJVE9SLmRvY3VtZW50LmdldEJvZHkoKS5hcHBlbmQoc2NyaXB0RWxlbWVudCk7XG5cblx0cmV0dXJuIHtcblx0XHRjYW5jZWw6IGNsZWFuVXAsXG5cdFx0aWQ6IGNhbGxiYWNrS2V5LFxuXHR9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IG9iamVjdCBjb250YWluaW5nIGFsbCBvZiB0aGUgcHJvcGVydGllcyBvZiBhbGwgdGhlIHN1cHBsaWVkXG4gKiBvYmplY3RzLiBUaGUgcHJvcGVydGllcyBmcm9tIGxhdGVyIG9iamVjdHMgd2lsbCBvdmVyd3JpdGUgdGhvc2UgaW4gZWFybGllclxuICogb2JqZWN0cy5cbiAqXG4gKiBQYXNzaW5nIGluIGEgc2luZ2xlIG9iamVjdCB3aWxsIGNyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiBpdC5cbiAqXG4gKiBAbWVtYmVyb2YgQ0tFRElUT1IudG9vbHNcbiAqIEBtZXRob2QgbWVyZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RzKiBPbmUgb3IgbW9yZSBvYmplY3RzIHRvIG1lcmdlLlxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBtZXJnZWQgb2JqZWN0LlxuICogQHN0YXRpY1xuICovXG5DS0VESVRPUi50b29scy5tZXJnZSA9XG5cdENLRURJVE9SLnRvb2xzLm1lcmdlIHx8XG5cdGZ1bmN0aW9uKC4uLmFyZ3MpIHtcblx0XHRjb25zdCByZXN1bHQgPSB7fTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuXHRcdFx0Y29uc3Qgb2JqID0gYXJnc1tpXTtcblxuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG5cdFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG5cdFx0XHRcdFx0cmVzdWx0W2tleV0gPSBvYmpba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cbi8qKlxuICogU2ltdWxhdGVzIGV2ZW50IG9uIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogQG1lbWJlcm9mIENLRURJVE9SLnRvb2xzXG4gKiBAbWV0aG9kIHNpbXVsYXRlXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgb24gd2hpY2ggdGhlIGV2ZW50IHNob3VkIGJlIHNpbXVhbHRlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgd2hpY2ggaGF2ZSB0byBiZSBzaW11bGF0ZWQuXG4gKiBAc3RhdGljXG4gKi9cbkNLRURJVE9SLnRvb2xzLnNpbXVsYXRlID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQpIHtcblx0Y29uc3QgZXZlbnRJbnN0YW5jZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudHMnKTtcblx0ZXZlbnRJbnN0YW5jZS5pbml0RXZlbnQoZXZlbnQsIHRydWUsIGZhbHNlKTtcblx0ZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50SW5zdGFuY2UpO1xufTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfdWljb3JlJykpIHtcblx0LyoqXG5cdCAqIFVJQ29yZSBjbGFzcyB3aGljaCB3aWxsIGhhbmRsZSB1c2VyIGludGVyYWN0aW9ucyB3aXRoIHRoZSBlZGl0b3IuIFRoZXNlIGludGVyYWN0aW9uc1xuXHQgKiBtaWdodCBiZSB0cmlnZ2VyZWQgdmlhIG1vdXNlLCBrZXlib2FyZCBvciB0b3VjaCBkZXZpY2VzLiBUaGUgY2xhc3MgZmlsbCBmaXJlIGFuIGV2ZW50IHZpYVxuXHQgKiBDS0VkaXRvcidzIGV2ZW50IHN5c3RlbSAtIFwiZWRpdG9ySW50ZXJhY3Rpb25cIi4gVGhlIFVJIG1heSBsaXN0ZW4gdG8gdGhpcyBldmVudCBhbmRcblx0ICogZXhlY3V0ZSBzb21lIGFjdGlvbnMgLSBmb3IgZXhhbXBsZSB0byBzaG93L2hpZGUgdG9vbGJhcnMuXG5cdCAqXG5cdCAqIEJ5IGRlZmF1bHQgaWYgdXNlciBwcmVzc2VzIHRoZSBFc2Mga2V5LCAnZWRpdG9ySW50ZXJhY3Rpb24nIGV2ZW50IHdvbid0IGJlIGZpcmVkLiBIb3dldmVyLCB0aGlzIGJlaGF2aW91ciBjYW4gYmUgY2hhbmdlZFxuXHQgKiBieSBzZXR0aW5nIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfdWljb3JlL2FsbG93RXNjOmF0dHJpYnV0ZVwifX17ey9jcm9zc0xpbmt9fSBjb25maWcgcHJvcGVydHkgaW4gZWRpdG9yJ3MgY29uZmlndXJhdGlvbiB0byB0cnVlLlxuXHQgKlxuXHQgKiBAY2xhc3MgYWVfdWljb3JlXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBGaXJlZCB3aGVuIHVzZXIgaW50ZXJhY3RzIHNvbWVob3cgd2l0aCB0aGUgYnJvd3Nlci4gVGhpcyBtYXkgYmUgY2xpY2tpbmcgd2l0aCB0aGUgbW91c2UsIHByZXNzaW5nIGtleWJvYXJkIGJ1dHRvbixcblx0ICogb3IgdG91Y2hpbmcgc2NyZWVuLiBUaGlzIGV2ZW4gd2lsbCBiZSBub3QgZmlyZWQgYWZ0ZXIgZWFjaCBpbnRlcmFjdGlvbi4gSXQgd2lsbCBiZSBkZWJvdW5jZWQuIEJ5IGRlZmF1bHQgdGhlIHRpbWVvdXRcblx0ICogaXMgNTBtcy4gVGhpcyB2YWx1ZSBjYW4gYmUgb3ZlcndyaXR0ZW4gdmlhIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfdWljb3JlL3RpbWVvdXQ6YXR0cmlidXRlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHByb3BlcnR5IG9mIGVkaXRvcidzIGNvbmZpZ3VyYXRpb24sIGxpa2U6IGVkaXRvci5jb25maWcudWljb3JlLnRpbWVvdXQgPSAxMDBcblx0ICpcblx0ICogQG1lbWJlcm9mIGFlX3VpY29yZVxuXHQgKiBAZXZlbnQgYWVfdWljb3JlI2VkaXRvckludGVyYWN0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFuIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cdCAqIC0gbmF0aXZlRXZlbnQgLSBUaGUgZXZlbnQgYXMgcmVjZWl2ZWQgZnJvbSBDS0VkaXRvci5cblx0ICogLSBzZWxlY3Rpb25EYXRhIC0gVGhlIGRhdGEsIHJldHVybmVkIGZyb20ge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9zZWxlY3Rpb25yZWdpb24vZ2V0U2VsZWN0aW9uRGF0YTptZXRob2RcIn19e3svY3Jvc3NMaW5rfX1cblx0ICovXG5cblx0LyoqXG5cdCAqIEZpcmVkIGJ5IFVJIGVsZW1lbnRzIGxpa2UgVG9vbGJhcnMgb3IgQnV0dG9ucyB3aGVuIHRoZWlyIHN0YXRlIGNoYW5nZXMuIFRoZSBsaXN0ZW5lciB1cGRhdGVzIHRoZSBsaXZlIHJlZ2lvbiB3aXRoIHRoZSBwcm92aWRlZCBkYXRhLlxuXHQgKlxuXHQgKiBAbWVtYmVyb2YgYWVfdWljb3JlXG5cdCAqIEBldmVudCBhZV91aWNvcmUjYXJpYVVwZGF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXHQgKiAtIG1lc3NhZ2UgLSBUaGUgcHJvdmlkZWQgbWVzc2FnZSBmcm9tIHRoZSBVSSBlbGVtZW50LlxuXHQgKi9cblxuXHQvKipcblx0ICogSWYgc2V0IHRvIHRydWUsIHRoZSBlZGl0b3Igd2lsbCBzdGlsbCBmaXJlIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfdWljb3JlL2VkaXRvckludGVyYWN0aW9uOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50LFxuXHQgKiBpZiB1c2VyIHByZXNzZXMgRXNjIGtleS5cblx0ICpcblx0ICogQG1lbWJlcm9mIGFlX3VpY29yZVxuXHQgKiBAYXR0cmlidXRlIGFsbG93RXNjXG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqIEB0eXBlIEJvb2xlYW5cblx0ICovXG5cblx0LyoqXG5cdCAqIFNwZWNpZmllcyB0aGUgZGVmYXVsdCB0aW1lb3V0IGFmdGVyIHdoaWNoIHRoZSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3VpY29yZS9lZGl0b3JJbnRlcmFjdGlvbjpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudFxuXHQgKiB3aWxsIGJlIGZpcmVkLlxuXHQgKlxuXHQgKiBAbWVtYmVyb2YgYWVfdWljb3JlXG5cdCAqIEBhdHRyaWJ1dGUgdGltZW91dFxuXHQgKiBAZGVmYXVsdCA1MCAobXMpXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblxuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfdWljb3JlJywge1xuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemVyIGxpZmVjeWNsZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIFVJQ29yZSBwbHVnaW4uXG5cdFx0ICpcblx0XHQgKiBAbWVtYmVyb2YgYWVfdWljb3JlXG5cdFx0ICogQG1ldGhvZCBpbml0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBDS0VkaXRvciBpbnN0YW5jZS5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0aW5pdChlZGl0b3IpIHtcblx0XHRcdGxldCBhcmlhU3RhdGUgPSBbXTtcblxuXHRcdFx0Y29uc3QgYXJpYUVsZW1lbnQgPSB0aGlzLl9jcmVhdGVBcmlhRWxlbWVudChlZGl0b3IuaWQpO1xuXG5cdFx0XHRjb25zdCB1aVRhc2tzVGltZW91dCA9IGVkaXRvci5jb25maWcudWljb3JlXG5cdFx0XHRcdD8gZWRpdG9yLmNvbmZpZy51aWNvcmUudGltZW91dFxuXHRcdFx0XHQ6IDUwO1xuXG5cdFx0XHRjb25zdCBoYW5kbGVVSSA9IENLRURJVE9SLnRvb2xzLmRlYm91bmNlKGV2ZW50ID0+IHtcblx0XHRcdFx0YXJpYVN0YXRlID0gW107XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGV2ZW50Lm5hbWUgIT09ICdrZXl1cCcgfHxcblx0XHRcdFx0XHRldmVudC5kYXRhLiQua2V5Q29kZSAhPT0gMjcgfHxcblx0XHRcdFx0XHRlZGl0b3IuY29uZmlnLmFsbG93RXNjXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uRGF0YSgpO1xuXG5cdFx0XHRcdFx0aWYgKHNlbGVjdGlvbkRhdGEpIHtcblx0XHRcdFx0XHRcdGVkaXRvci5maXJlKCdlZGl0b3JJbnRlcmFjdGlvbicsIHtcblx0XHRcdFx0XHRcdFx0bmF0aXZlRXZlbnQ6IGV2ZW50LmRhdGEuJCxcblx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uRGF0YSxcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSwgdWlUYXNrc1RpbWVvdXQpO1xuXG5cdFx0XHRjb25zdCBoYW5kbGVBcmlhID0gQ0tFRElUT1IudG9vbHMuZGVib3VuY2UoX2V2ZW50ID0+IHtcblx0XHRcdFx0YXJpYUVsZW1lbnQuaW5uZXJIVE1MID0gYXJpYVN0YXRlLmpvaW4oJy4gJyk7XG5cdFx0XHR9LCB1aVRhc2tzVGltZW91dCk7XG5cblx0XHRcdGNvbnN0IGhhbmRsZU1vdXNlTGVhdmUgPSBDS0VESVRPUi50b29scy5kZWJvdW5jZShldmVudCA9PiB7XG5cdFx0XHRcdGNvbnN0IGFlVUlOb2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5hZS11aScpO1xuXG5cdFx0XHRcdGxldCBmb3VuZDtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFlVUlOb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChhZVVJTm9kZXNbaV0uY29udGFpbnMoZXZlbnQuZGF0YS4kLnJlbGF0ZWRUYXJnZXQpKSB7XG5cdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIWZvdW5kKSB7XG5cdFx0XHRcdFx0aGFuZGxlVUkoZXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB1aVRhc2tzVGltZW91dCk7XG5cblx0XHRcdGVkaXRvci5vbignYXJpYVVwZGF0ZScsIGV2ZW50ID0+IHtcblx0XHRcdFx0Ly8gaGFuZGxlQXJpYSBpcyBkZWJvdW5jZWQgZnVuY3Rpb24sIHNvIGlmIGl0IGlzIGJlaW5nIGNhbGxlZCBtdWx0aXBsZSB0aW1lcywgaXQgd2lsbFxuXHRcdFx0XHQvLyBiZSBjYW5jZWxlZCB1bnRpbCBzb21lIHRpbWUgcGFzc2VzLlxuXHRcdFx0XHQvLyBGb3IgdGhhdCByZWFzb24gaGVyZSB3ZSBleHBsaWNpdGx5IGFwcGVuZCB0aGUgY3VycmVudCBtZXNzYWdlIHRvIHRoZSBsaXN0IG9mIG1lc3NhZ2VzXG5cdFx0XHRcdC8vIGFuZCBjYWxsIGhhbmRsZUFyaWEuIFNpbmNlIGl0IGlzIGRlYm91bmNlZCwgd2hlbiBzb21lIHRpbWVvdXQgcGFzc2VzLFxuXHRcdFx0XHQvLyBhbGwgdGhlIG1lc3NhZ2VzIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgbGl2ZSByZWdpb24gYW5kIG5vdCBvbmx5IHRoZSBsYXN0IG9uZS5cblxuXHRcdFx0XHRhcmlhU3RhdGUucHVzaChldmVudC5kYXRhLm1lc3NhZ2UpO1xuXG5cdFx0XHRcdGhhbmRsZUFyaWEoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRlZGl0b3Iub25jZSgnY29udGVudERvbScsICgpID0+IHtcblx0XHRcdFx0Y29uc3QgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuXHRcdFx0XHRjb25zdCBmb2N1c0hhbmRsZXIgPSBlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0XHQnZm9jdXMnLFxuXHRcdFx0XHRcdGV2ZW50ID0+IHtcblx0XHRcdFx0XHRcdGZvY3VzSGFuZGxlci5yZW1vdmVMaXN0ZW5lcigpO1xuXG5cdFx0XHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ2tleXVwJywgaGFuZGxlVUkpO1xuXHRcdFx0XHRcdFx0ZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoZWRpdGFibGUsICdtb3VzZXVwJywgaGFuZGxlVUkpO1xuXHRcdFx0XHRcdFx0ZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoXG5cdFx0XHRcdFx0XHRcdGVkaXRhYmxlLFxuXHRcdFx0XHRcdFx0XHQnbW91c2VsZWF2ZScsXG5cdFx0XHRcdFx0XHRcdGhhbmRsZU1vdXNlTGVhdmVcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGhhbmRsZVVJKGV2ZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0ZWRpdG9yLm9uKCdkZXN0cm95JywgX2V2ZW50ID0+IHtcblx0XHRcdFx0YXJpYUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhcmlhRWxlbWVudCk7XG5cblx0XHRcdFx0aGFuZGxlVUkuZGV0YWNoKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhbmQgYXBwbGllcyBhbiBIVE1MIGVsZW1lbnQgdG8gdGhlIGJvZHkgb2YgdGhlIGRvY3VtZW50IHdoaWNoIHdpbGwgY29udGFpbiBBUklBIG1lc3NhZ2VzLlxuXHRcdCAqXG5cdFx0ICogQG1lbWJlcm9mIGFlX3VpY29yZVxuXHRcdCAqIEBtZXRob2QgX2NyZWF0ZUFyaWFFbGVtZW50XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBwcm92aWRlZCBpZCBvZiB0aGUgZWxlbWVudC4gSXQgd2lsbCBiZSB1c2VkIGFzIHByZWZpeCBmb3IgdGhlIGZpbmFsIGVsZW1lbnQgSWQuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgY3JlYXRlZCBhbmQgYXBwbGllZCB0byBET00gZWxlbWVudC5cblx0XHQgKi9cblx0XHRfY3JlYXRlQXJpYUVsZW1lbnQoaWQpIHtcblx0XHRcdGNvbnN0IHN0YXR1c0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuXHRcdFx0c3RhdHVzRWxlbWVudC5jbGFzc05hbWUgPSAnYWUtc3Itb25seSc7XG5cblx0XHRcdHN0YXR1c0VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XG5cdFx0XHRzdGF0dXNFbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdzdGF0dXMnKTtcblx0XHRcdHN0YXR1c0VsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGlkICsgJ0xpdmVSZWdpb24nKTtcblxuXHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0dXNFbGVtZW50KTtcblxuXHRcdFx0cmV0dXJuIHN0YXR1c0VsZW1lbnQ7XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBMYW5nIGZyb20gJy4vbGFuZyc7XG5cbi8qKlxuICogQXR0cmlidXRlIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBjbGFzcyBBdHRyaWJ1dGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBdHRyaWJ1dGUoY29uZmlnKSB7XG5cdHRoaXMuX19jb25maWdfXyA9IGNvbmZpZyB8fCB7fTtcblx0dGhpcy5fX0FUVFJTX18gPSB7fTtcbn1cblxuQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IEF0dHJpYnV0ZSxcblxuXHQvKipcblx0ICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQXR0cmlidXRlXG5cdCAqIEBtZXRob2QgZ2V0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFRoZSBhdHRyaWJ1dGUgd2hpY2ggdmFsdWUgc2hvdWxkIGJlIHJldHJpZXZlZC5cblx0ICogQHJldHVybiB7QW55fSBUaGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS5cblx0ICovXG5cdGdldChhdHRyKSB7XG5cdFx0Y29uc3QgY3VycmVudEF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLkFUVFJTW2F0dHJdO1xuXG5cdFx0aWYgKCFjdXJyZW50QXR0cikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5faXNJbml0aWFsaXplZChhdHRyKSkge1xuXHRcdFx0dGhpcy5faW5pdChhdHRyKTtcblx0XHR9XG5cblx0XHRsZXQgY3VyVmFsdWUgPSB0aGlzLl9fQVRUUlNfX1thdHRyXTtcblxuXHRcdGlmIChjdXJyZW50QXR0ci5nZXR0ZXIpIHtcblx0XHRcdGN1clZhbHVlID0gdGhpcy5fY2FsbFN0cmluZ09yRnVuY3Rpb24oY3VycmVudEF0dHIuZ2V0dGVyLCBjdXJWYWx1ZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGN1clZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQXR0cmlidXRlXG5cdCAqIEBtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFRoZSBhdHRyaWJ1dGUgd2hpY2ggdmFsdWUgc2hvdWxkIGJlIHNldC5cblx0ICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBzaG91bGQgYmUgc2V0IHRvIHRoZSBhdHRyaWJ1dGUuXG5cdCAqL1xuXHRzZXQoYXR0ciwgdmFsdWUpIHtcblx0XHRjb25zdCBjdXJyZW50QXR0ciA9IHRoaXMuY29uc3RydWN0b3IuQVRUUlNbYXR0cl07XG5cblx0XHRpZiAoIWN1cnJlbnRBdHRyKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9pc0luaXRpYWxpemVkKGF0dHIpKSB7XG5cdFx0XHR0aGlzLl9pbml0KGF0dHIpO1xuXHRcdH1cblxuXHRcdGlmIChjdXJyZW50QXR0ci5yZWFkT25seSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChjdXJyZW50QXR0ci53cml0ZU9uY2UgJiYgdGhpcy5faXNJbml0aWFsaXplZChhdHRyKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdGN1cnJlbnRBdHRyLnZhbGlkYXRvciAmJlxuXHRcdFx0IXRoaXMuX2NhbGxTdHJpbmdPckZ1bmN0aW9uKGN1cnJlbnRBdHRyLnZhbGlkYXRvciwgdmFsdWUpXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGN1cnJlbnRBdHRyLnNldHRlcikge1xuXHRcdFx0dmFsdWUgPSB0aGlzLl9jYWxsU3RyaW5nT3JGdW5jdGlvbihjdXJyZW50QXR0ci5zZXR0ZXIsIHZhbHVlKTtcblx0XHR9XG5cblx0XHR0aGlzLl9fQVRUUlNfX1thdHRyXSA9IHZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDYWxscyB0aGUgcHJvdmlkZWQgcGFyYW0gYXMgZnVuY3Rpb24gd2l0aCB0aGUgc3VwcGxpZWQgYXJndW1lbnRzLlxuXHQgKiBJZiBwYXJhbSBwcm92aWRlZCBhcyBzdHJpbmcsIGEgY29ycmVzcG9uZGluZyBmdW5jdGlvbiBpbiB0aGlzIG9iamVjdCB3aWxsXG5cdCAqIGJlIGNhbGxlZC4gSWYgcHJvdmlkZWQgcGFyYW0gaXMgYSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBkaXJlY3RseSBjYWxsZWQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQXR0cmlidXRlXG5cdCAqIEBtZXRob2QgX2NhbGxTdHJpbmdPckZ1bmN0aW9uXG5cdCAqIEBwYXJhbSAge0FueXxBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHdoaWNoIHdpbGwgYmUgcHJvdmlkZWQgdG8gdGhlIGNhbGxlZCBmdW5jdGlvblxuXHQgKiBAcGFyYW0gIHtTdHJpbmd8RnVuY3Rpb259IHN0cmluZ09yRnVuY3Rpb24gVGhlIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSBjYWxsZWRcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBbnl9IFRoZSByZXR1cm5lZCB2YWx1ZSBmcm9tIHRoZSBjYWxsZWQgZnVuY3Rpb25cblx0ICovXG5cdF9jYWxsU3RyaW5nT3JGdW5jdGlvbihzdHJpbmdPckZ1bmN0aW9uLCBhcmdzKSB7XG5cdFx0bGV0IHJlc3VsdCA9IG51bGw7XG5cblx0XHRpZiAoIUxhbmcuaXNBcnJheShhcmdzKSkge1xuXHRcdFx0YXJncyA9IFthcmdzXTtcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHRMYW5nLmlzU3RyaW5nKHN0cmluZ09yRnVuY3Rpb24pICYmXG5cdFx0XHRMYW5nLmlzRnVuY3Rpb24odGhpc1tzdHJpbmdPckZ1bmN0aW9uXSlcblx0XHQpIHtcblx0XHRcdHJlc3VsdCA9IHRoaXNbc3RyaW5nT3JGdW5jdGlvbl0oLi4uYXJncyk7XG5cdFx0fSBlbHNlIGlmIChMYW5nLmlzRnVuY3Rpb24oc3RyaW5nT3JGdW5jdGlvbikpIHtcblx0XHRcdHJlc3VsdCA9IHN0cmluZ09yRnVuY3Rpb24uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgYW4gYXR0cmlidXRlLiBTZXRzIGl0cyBkZWZhdWx0IHZhbHVlIGRlcGVuZGluZyBvbiB0aGUgZmxhZ3Mgb2YgdGhlXG5cdCAqIGF0dHJpYnV0ZSBhbmQgdGhlIHBhc3NlZCBjb25maWd1cmF0aW9uIG9iamVjdCB0byB0aGUgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQXR0cmlidXRlXG5cdCAqIEBtZXRob2QgX2luaXRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB3aGljaCBoYXZlIHRvIGJlIGluaXRpYWxpemVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfaW5pdChhdHRyKSB7XG5cdFx0bGV0IHZhbHVlO1xuXG5cdFx0Y29uc3QgY3VycmVudEF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLkFUVFJTW2F0dHJdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlcmUgaXMgZGVmYXVsdCB2YWx1ZSBvciBwYXNzZWQgb25lIHZpYSBjb25maWd1cmF0aW9uIG9iamVjdFxuXG5cdFx0Y29uc3QgaGFzRGVmYXVsdFZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuXHRcdFx0Y3VycmVudEF0dHIsXG5cdFx0XHQndmFsdWUnXG5cdFx0KTtcblx0XHRjb25zdCBoYXNQYXNzZWRWYWx1ZVZpYUNvbmZpZyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcblx0XHRcdHRoaXMuX19jb25maWdfXyxcblx0XHRcdGF0dHJcblx0XHQpO1xuXG5cdFx0Ly8gSWYgdGhlcmUgaXMgdmFsdWVGbiwgc2V0IHRoZSB2YWx1ZSB0byBiZSB0aGUgcmVzdWx0IG9mIGludm9jYXRpb24gb2YgdGhpcyBmdW5jdGlvblxuXG5cdFx0aWYgKGN1cnJlbnRBdHRyLnZhbHVlRm4pIHtcblx0XHRcdHZhbHVlID0gdGhpcy5fY2FsbFN0cmluZ09yRnVuY3Rpb24oY3VycmVudEF0dHIudmFsdWVGbiwgdmFsdWUpO1xuXG5cdFx0XHR0aGlzLl9fQVRUUlNfX1thdHRyXSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdC8vIGVsc2UgaWYgdGhlIGF0dHJpYnV0ZSBoYXMgcmVhZE9ubHkgZmxhZywgc2V0IHRoZSBkZWZhdWx0IHZhbHVlIGZyb20gdGhlIGF0dHJpYnV0ZSxcblx0XHQvLyByZWdhcmRsZXNzIGlmIHRoZXJlIGlzIHZhbHVlIG9yIG5vdFxuXHRcdGVsc2UgaWYgKGN1cnJlbnRBdHRyLnJlYWRPbmx5KSB7XG5cdFx0XHR2YWx1ZSA9IGN1cnJlbnRBdHRyLnZhbHVlO1xuXHRcdH1cblxuXHRcdC8vIGVsc2UgaWYgdGhlIGF0dHJpYnV0ZSBoYXMgd3JpdGVPbmNlIHZhbHVlLCBzZXQgaXQgZnJvbSB0aGUgcGFzc2VkIGNvbmZpZ3VyYXRpb24gb3IgZnJvbSB0aGVcblx0XHQvLyBkZWZhdWx0IHZhbHVlLCBpbiB0aGlzIG9yZGVyLiBPdGhlcndpc2UsIHJldHVybiBtaXNlcmFibGUuXG5cdFx0ZWxzZSBpZiAoY3VycmVudEF0dHIud3JpdGVPbmNlKSB7XG5cdFx0XHRpZiAoaGFzUGFzc2VkVmFsdWVWaWFDb25maWcpIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLl9fY29uZmlnX19bYXR0cl07XG5cdFx0XHR9IGVsc2UgaWYgKGhhc0RlZmF1bHRWYWx1ZSkge1xuXHRcdFx0XHR2YWx1ZSA9IGN1cnJlbnRBdHRyLnZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFRoZXNlIHR3byBjYXNlcyBiZWxvdyBhcmUgZWFzeSAtIHNldCB0aGUgdmFsdWUgdG8gYmUgZnJvbSB0aGUgcGFzc2VkIGNvbmZpZyBvclxuXHRcdC8vIGZyb20gdGhlIGRlZmF1bHQgdmFsdWUsIGluIHRoaXMgb3JkZXIuXG5cdFx0ZWxzZSBpZiAoaGFzUGFzc2VkVmFsdWVWaWFDb25maWcpIHtcblx0XHRcdHZhbHVlID0gdGhpcy5fX2NvbmZpZ19fW2F0dHJdO1xuXHRcdH0gZWxzZSBpZiAoaGFzRGVmYXVsdFZhbHVlKSB7XG5cdFx0XHR2YWx1ZSA9IGN1cnJlbnRBdHRyLnZhbHVlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGlzIHZhbGlkYXRvciwgYW5kIHVzZXIgcGFzc2VkIGNvbmZpZyBvYmplY3QgLSBjaGVjayB0aGUgcmV0dXJuZWQgdmFsdWUuXG5cdFx0Ly8gSWYgaXQgaXMgZmFsc2UsIHRoZW4gc2V0IGFzIGluaXRpYWwgdmFsdWUgdGhlIGRlZmF1bHQgb25lLlxuXHRcdC8vIEhvd2V2ZXIsIGlmIHRoZXJlIGlzIG5vIGRlZmF1bHQgdmFsdWUsIGp1c3QgcmV0dXJuLlxuXG5cdFx0aWYgKFxuXHRcdFx0Y3VycmVudEF0dHIudmFsaWRhdG9yICYmXG5cdFx0XHRoYXNQYXNzZWRWYWx1ZVZpYUNvbmZpZyAmJlxuXHRcdFx0IXRoaXMuX2NhbGxTdHJpbmdPckZ1bmN0aW9uKGN1cnJlbnRBdHRyLnZhbGlkYXRvciwgdmFsdWUpXG5cdFx0KSB7XG5cdFx0XHRpZiAoaGFzRGVmYXVsdFZhbHVlKSB7XG5cdFx0XHRcdHZhbHVlID0gY3VycmVudEF0dHIudmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgaXMgc2V0dGVyIGFuZCB1c2VyIHBhc3NlZCBjb25maWcgb2JqZWN0IC0gcGFzcyB0aGUgdmFsdWUgdGhvdWdodCB0aGUgc2V0dGVyLlxuXHRcdC8vIFRoZSB2YWx1ZSBtaWdodCBiZSBvbmUgZnJvbSBkZWZhdWx0Rm4sIGRlZmF1bHQgdmFsdWUgb3IgcHJvdmlkZWQgZnJvbSB0aGUgY29uZmlnLlxuXG5cdFx0aWYgKGN1cnJlbnRBdHRyLnNldHRlciAmJiBoYXNQYXNzZWRWYWx1ZVZpYUNvbmZpZykge1xuXHRcdFx0dmFsdWUgPSB0aGlzLl9jYWxsU3RyaW5nT3JGdW5jdGlvbihjdXJyZW50QXR0ci5zZXR0ZXIsIHZhbHVlKTtcblx0XHR9XG5cblx0XHQvLyBGaW5hbGx5LCBzZXQgdGhlIHZhbHVlIGFzIGluaXRpYWwgdmFsdWUgdG8gdGhlIHN0b3JhZ2Ugd2l0aCB2YWx1ZXMuXG5cblx0XHR0aGlzLl9fQVRUUlNfX1thdHRyXSA9IHZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYW4gYXR0cmlidXRlIGlzIGluaXRpYWxpemVkLiBBbiBhdHRyaWJ1dGUgaXMgY29uc2lkZXJlZCBhcyBpbml0aWFsaXplZFxuXHQgKiB3aGVuIHRoZXJlIGlzIGFuIG93biBwcm9wZXJ0eSB3aXRoIHRoaXMgbmFtZSBpbiB0aGUgbG9jYWwgY29sbGVjdGlvbiBvZiBhdHRyaWJ1dGUgdmFsdWVzXG5cdCAqIGZvciB0aGUgY3VycmVudCBpbnN0YW5jZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBBdHRyaWJ1dGVcblx0ICogQG1ldGhvZCBfaXNJbml0aWFsaXplZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBUaGUgYXR0cmlidXRlIHdoaWNoIHNob3VsZCBiZSBjaGVja2VkIGlmIGl0IGlzIGluaXRpYWxpemVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgYXR0cmlidXRlIGhhcyBiZWVuIGluaXRpYWxpemVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuXHRfaXNJbml0aWFsaXplZChhdHRyKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9fQVRUUlNfXywgYXR0cik7XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBBdHRyaWJ1dGU7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBBdHRyaWJ1dGUgZnJvbSAnLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IExhbmcgZnJvbSAnLi9sYW5nJztcbmltcG9ydCBleHRlbmQgZnJvbSAnLi9vb3AnO1xuXG4vKipcbiAqIFF1aWNrIGFuZCBkaXJ0eSBpbXBsIG9mIEJhc2UgY2xhc3MuXG4gKlxuICogQGNsYXNzIEJhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCYXNlKGNvbmZpZykge1xuXHRCYXNlLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBjb25maWcpO1xuXG5cdHRoaXMuaW5pdChjb25maWcpO1xufVxuXG5leHRlbmQoQmFzZSwgQXR0cmlidXRlLCB7XG5cdC8qKlxuXHQgKiBDYWxscyB0aGUgYGluaXRpYWxpemVyYCBtZXRob2Qgb2YgZWFjaCBjbGFzcyB3aGljaCBleHRlbmRzIEJhc2Ugc3RhcnRpbmcgZnJvbSB0aGUgcGFyZW50IHRvIHRoZSBjaGlsZC5cblx0ICogV2lsbCBwYXNzIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCB0byBlYWNoIGluaXRpYWxpemVyIG1ldGhvZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCYXNlXG5cdCAqIEBtZXRob2QgaW5pdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0XG5cdCAqL1xuXHRpbml0KGNvbmZpZykge1xuXHRcdHRoaXMuX2NhbGxDaGFpbignaW5pdGlhbGl6ZXInLCBjb25maWcpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDYWxscyB0aGUgYGRlc3RydWN0b3JgIG1ldGhvZCBvZiBlYWNoIGNsYXNzIHdoaWNoIGV4dGVuZHMgQmFzZSBzdGFydGluZyBmcm9tIHRoZSBwYXJlbnQgdG8gdGhlIGNoaWxkLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJhc2Vcblx0ICogQG1ldGhvZCBkZXN0cm95XG5cdCAqL1xuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMuX2NhbGxDaGFpbignZGVzdHJ1Y3RvcicpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDYWxscyBhIG1ldGhvZCBvZiBlYWNoIGNsYXNzLCB3aGljaCBpcyBiZWluZyBwcmVzZW50IGluIHRoZSBoaWVyYXJjaHkgc3RhcnRpbmcgZnJvbSBwYXJlbnQgdG8gdGhlIGNoaWxkLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJhc2Vcblx0ICogQG1ldGhvZCBfY2FsbENoYWluXG5cdCAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCB0aGUgbWV0aG9kIHNob3VsZCBiZSBpbnZva2VkXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB3YXQgIFRoZSBtZXRob2QsIHdoaWNoIHNob3VsZCBiZSBpbnZva2VkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9jYWxsQ2hhaW4od2F0LCBhcmdzKSB7XG5cdFx0bGV0IGFyciA9IFtdO1xuXG5cdFx0bGV0IGN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG5cdFx0d2hpbGUgKGN0b3IpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oY3Rvci5wcm90b3R5cGVbd2F0XSkpIHtcblx0XHRcdFx0YXJyLnB1c2goY3Rvci5wcm90b3R5cGVbd2F0XSk7XG5cdFx0XHR9XG5cblx0XHRcdGN0b3IgPSBjdG9yLnN1cGVyY2xhc3MgPyBjdG9yLnN1cGVyY2xhc3MuY29uc3RydWN0b3IgOiBudWxsO1xuXHRcdH1cblxuXHRcdGFyciA9IGFyci5yZXZlcnNlKCk7XG5cblx0XHRhcmdzID0gTGFuZy5pc0FycmF5KGFyZ3MpID8gYXJncyA6IFthcmdzXTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBpdGVtID0gYXJyW2ldO1xuXG5cdFx0XHRpdGVtLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBCYXNlO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG4vKipcbiAqIFByb3ZpZGVzIGNvcmUgbGFuZ3VhZ2UgdXRpbGl0aWVzLlxuICpcbiAqIEBjbGFzcyBMYW5nXG4gKi9cbmNvbnN0IExhbmcgPSB7XG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIGFycmF5LlxuXHQgKlxuXHQgKiBAbWVtYmVyb2YgTGFuZ1xuXHQgKiBAbWV0aG9kIGlzQXJyYXlcblx0ICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNoZWNrZWQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhbiBhcnJheSwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRpc0FycmF5KHZhbHVlKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYm9vbGVhbi5cblx0ICpcblx0ICogQG1lbWJlcm9mIExhbmdcblx0ICogQG1ldGhvZCBpc0Jvb2xlYW5cblx0ICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNoZWNrZWQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBib29sZWFuLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdGlzQm9vbGVhbih2YWx1ZSkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuXHQgKlxuXHQgKiBAbWVtYmVyb2YgTGFuZ1xuXHQgKiBAbWV0aG9kIGlzRnVuY3Rpb25cblx0ICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNoZWNrZWQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdGlzRnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIE5VTEwuXG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBMYW5nXG5cdCAqIEBtZXRob2QgaXNOdWxsXG5cdCAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjaGVja2VkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgTlVMTCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRpc051bGwodmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgPT09IG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgbnVtYmVyLlxuXHQgKlxuXHQgKiBAbWVtYmVyb2YgTGFuZ1xuXHQgKiBAbWV0aG9kIGlzTnVtYmVyXG5cdCAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjaGVja2VkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgbnVtYmVyLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdGlzTnVtYmVyKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIG9iamVjdFxuXHQgKlxuXHQgKiBAbWVtYmVyb2YgTGFuZ1xuXHQgKiBAbWV0aG9kIGlzT2JqZWN0XG5cdCAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjaGVja2VkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gb2JqZWN0LCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdGlzT2JqZWN0KHZhbHVlKSB7XG5cdFx0Y29uc3QgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0cmV0dXJuIHZhbHVlICYmICh2YWx1ZVR5cGUgPT09ICdvYmplY3QnIHx8IExhbmcuaXNGdW5jdGlvbih2YWx1ZSkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgc3RyaW5nLlxuXHQgKlxuXHQgKiBAbWVtYmVyb2YgTGFuZ1xuXHQgKiBAbWV0aG9kIGlzU3RyaW5nXG5cdCAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjaGVja2VkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0aXNTdHJpbmcodmFsdWUpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcblx0fSxcblxuXHQvKipcblx0ICogQWRkcyBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBzdXBwbGllciB0byB0aGUgcmVjZWl2ZXIuXG5cdCAqIFRoZSBmdW5jdGlvbiB3aWxsIGFkZCBhbGwgcHJvcGVydGllcywgbm90IG9ubHkgdGhlc2Ugb3duZWQgYnkgdGhlIHN1cHBsaWVyLlxuXHQgKlxuXHQgKiBAbWVtYmVyb2YgTGFuZ1xuXHQgKiBAbWV0aG9kIG1peFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmVjZWl2ZXIgVGhlIG9iamVjdCB3aGljaCB3aWxsIHJlY2VpdmUgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IHN1cHBsaWVyIFRoZSBvYmplY3Qgd2hpY2ggcHJvdmlkZXMgcHJvcGVydGllcy5cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgbW9kaWZpZWQgcmVjZWl2ZXIuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdG1peChyZWNlaXZlciwgc3VwcGxpZXIpIHtcblx0XHRjb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblx0XHRmb3IgKGNvbnN0IGtleSBpbiBzdXBwbGllcikge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoc3VwcGxpZXIsIGtleSkpIHtcblx0XHRcdFx0cmVjZWl2ZXJba2V5XSA9IHN1cHBsaWVyW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB2YWx1ZSB0byBJbnRlZ2VyLlxuXHQgKlxuXHQgKiBAbWVtYmVyb2YgTGFuZ1xuXHQgKiBAbWV0aG9kIHRvSW50XG5cdCAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggaGF2ZSB0byBiZSBjb252ZXJ0ZWQgdG8gSW50ZWdlci5cblx0ICogQHJldHVybiB7SW50ZWdlcn0gVGhlIGNvbnZlcnRlZCB2YWx1ZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0dG9JbnQodmFsdWUpIHtcblx0XHRyZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IExhbmc7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBMYW5nIGZyb20gJy4vbGFuZyc7XG5cbi8qKlxuICogU2V0cyB0aGUgcHJvdG90eXBlLCBjb25zdHJ1Y3RvciBhbmQgc3VwZXJjbGFzcyBwcm9wZXJ0aWVzIHRvIHN1cHBvcnQgYW4gaW5oZXJpdGFuY2Ugc3RyYXRlZ3lcbiAqIHRoYXQgY2FuIGNoYWluIGNvbnN0cnVjdG9ycyBhbmQgbWV0aG9kcy4gU3RhdGljIG1lbWJlcnMgd2lsbCBub3QgYmUgaW5oZXJpdGVkLlxuICpcbiAqIEBtZW1iZXJvZiBPT1BcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWNlaXZlciBUaGUgY2xhc3Mgd2hpY2ggd2lsbCBleHRlbmQgYW5vdGhlciBjbGFzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cHBsaWVyIFRoZSBjbGFzcyB3aGljaCB3aWxsIHByb3ZpZGUgdGhlIHByb3BlcnRpZXMgdGhlIGNoaWxkIGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvUHJvcHMgUHJvdG90eXBlIHByb3BlcnRpZXMgdG8gYWRkL292ZXJyaWRlLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRpY1Byb3BzIFN0YXRpYyBwcm9wZXJ0aWVzIHRvIGFkZC9vdmVyd3JpdGUuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGV4dGVuZGVkIGNsYXNzLlxuICogQHN0YXRpY1xuICovXG5jb25zdCBleHRlbmQgPSBmdW5jdGlvbihyZWNlaXZlciwgc3VwcGxpZXIsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG5cdGlmICghc3VwcGxpZXIgfHwgIXJlY2VpdmVyKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdleHRlbmQgZmFpbGVkLCB2ZXJpZnkgZGVwZW5kZW5jaWVzJyk7XG5cdH1cblxuXHRjb25zdCBzdXBwbGllclByb3RvID0gc3VwcGxpZXIucHJvdG90eXBlO1xuXG5cdGNvbnN0IHJlY2VpdmVyUHJvdG8gPSBPYmplY3QuY3JlYXRlKHN1cHBsaWVyUHJvdG8pO1xuXHRyZWNlaXZlci5wcm90b3R5cGUgPSByZWNlaXZlclByb3RvO1xuXG5cdHJlY2VpdmVyUHJvdG8uY29uc3RydWN0b3IgPSByZWNlaXZlcjtcblx0cmVjZWl2ZXIuc3VwZXJjbGFzcyA9IHN1cHBsaWVyUHJvdG87XG5cblx0Ly8gYXNzaWduIGNvbnN0cnVjdG9yIHByb3BlcnR5XG5cblx0aWYgKFxuXHRcdHN1cHBsaWVyICE9PSBPYmplY3QgJiZcblx0XHRzdXBwbGllclByb3RvLmNvbnN0cnVjdG9yID09PSBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yXG5cdCkge1xuXHRcdHN1cHBsaWVyUHJvdG8uY29uc3RydWN0b3IgPSBzdXBwbGllcjtcblx0fVxuXG5cdC8vIGFkZCBwcm90b3R5cGUgb3ZlcnJpZGVzXG5cblx0aWYgKHByb3RvUHJvcHMpIHtcblx0XHRMYW5nLm1peChyZWNlaXZlclByb3RvLCBwcm90b1Byb3BzKTtcblx0fVxuXG5cdC8vIGFkZCBvYmplY3Qgb3ZlcnJpZGVzXG5cblx0aWYgKHN0YXRpY1Byb3BzKSB7XG5cdFx0TGFuZy5taXgocmVjZWl2ZXIsIHN0YXRpY1Byb3BzKTtcblx0fVxuXG5cdHJldHVybiByZWNlaXZlcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGV4dGVuZDtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuY2xhc3MgRHJhZ0V2ZW50IHtcblx0Y29uc3RydWN0b3Iod2luZG93LCBkb2N1bWVudCkge1xuXHRcdHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcblx0XHR0aGlzLndpbmRvdyA9IHdpbmRvdztcblxuXHRcdHRoaXMuZXZlbnRzID0ge1xuXHRcdFx0a2V5ZG93bjogdGhpcy5rZXlkb3duLmJpbmQodGhpcyksXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMubW91c2Vtb3ZlLmJpbmQodGhpcyksXG5cdFx0XHRtb3VzZXVwOiB0aGlzLm1vdXNldXAuYmluZCh0aGlzKSxcblx0XHR9O1xuXHR9XG5cblx0c3RhcnQoZXZlbnQpIHtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0dGhpcy50YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cblx0XHR0aGlzLmNsYXNzTmFtZSA9IHRoaXMudGFyZ2V0LmNsYXNzTmFtZTtcblxuXHRcdHRoaXMuc3RhcnRQb3MgPSB7XG5cdFx0XHR4OiBldmVudC5jbGllbnRYLFxuXHRcdFx0eTogZXZlbnQuY2xpZW50WSxcblx0XHR9O1xuXG5cdFx0dGhpcy51cGRhdGUoZXZlbnQpO1xuXG5cdFx0dGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5ldmVudHMua2V5ZG93biwgZmFsc2UpO1xuXHRcdHRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcblx0XHRcdCdtb3VzZW1vdmUnLFxuXHRcdFx0dGhpcy5ldmVudHMubW91c2Vtb3ZlLFxuXHRcdFx0ZmFsc2Vcblx0XHQpO1xuXHRcdHRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuZXZlbnRzLm1vdXNldXAsIGZhbHNlKTtcblxuXHRcdHRoaXMuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGBkcmFnZ2luZy0ke3RoaXMuY2xhc3NOYW1lfWApO1xuXG5cdFx0aWYgKHR5cGVvZiB0aGlzLm9uU3RhcnQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRoaXMub25TdGFydCgpO1xuXHRcdH1cblx0fVxuXG5cdHVwZGF0ZShldmVudCkge1xuXHRcdHRoaXMuY3VycmVudFBvcyA9IHtcblx0XHRcdHg6IGV2ZW50LmNsaWVudFgsXG5cdFx0XHR5OiBldmVudC5jbGllbnRZLFxuXHRcdH07XG5cblx0XHR0aGlzLmRlbHRhID0ge1xuXHRcdFx0eDogZXZlbnQuY2xpZW50WCAtIHRoaXMuc3RhcnRQb3MueCxcblx0XHRcdHk6IGV2ZW50LmNsaWVudFkgLSB0aGlzLnN0YXJ0UG9zLnksXG5cdFx0fTtcblxuXHRcdHRoaXMua2V5cyA9IHtcblx0XHRcdGFsdDogZXZlbnQuYWx0S2V5LFxuXHRcdFx0Y3RybDogZXZlbnQuY3RybEtleSxcblx0XHRcdHNoaWZ0OiBldmVudC5zaGlmdEtleSxcblx0XHR9O1xuXHR9XG5cblx0bW91c2Vtb3ZlKGV2ZW50KSB7XG5cdFx0dGhpcy51cGRhdGUoZXZlbnQpO1xuXG5cdFx0aWYgKHR5cGVvZiB0aGlzLm9uRHJhZyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhpcy5vbkRyYWcoKTtcblx0XHR9XG5cblx0XHRpZiAoZXZlbnQud2hpY2ggPT09IDApIHtcblx0XHRcdHRoaXMubW91c2V1cChldmVudCk7XG5cdFx0fVxuXHR9XG5cblx0a2V5ZG93bihldmVudCkge1xuXHRcdGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuXHRcdFx0dGhpcy5yZWxlYXNlKCk7XG5cdFx0fVxuXHR9XG5cblx0bW91c2V1cChldmVudCkge1xuXHRcdHRoaXMudXBkYXRlKGV2ZW50KTtcblxuXHRcdHRoaXMucmVsZWFzZSgpO1xuXG5cdFx0aWYgKHR5cGVvZiB0aGlzLm9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRoaXMub25Db21wbGV0ZSgpO1xuXHRcdH1cblx0fVxuXG5cdHJlbGVhc2UoKSB7XG5cdFx0dGhpcy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoYGRyYWdnaW5nLSR7dGhpcy5jbGFzc05hbWV9YCk7XG5cblx0XHR0aGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG5cdFx0XHQna2V5ZG93bicsXG5cdFx0XHR0aGlzLmV2ZW50cy5rZXlkb3duLFxuXHRcdFx0ZmFsc2Vcblx0XHQpO1xuXHRcdHRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcblx0XHRcdCdtb3VzZW1vdmUnLFxuXHRcdFx0dGhpcy5ldmVudHMubW91c2Vtb3ZlLFxuXHRcdFx0ZmFsc2Vcblx0XHQpO1xuXHRcdHRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcblx0XHRcdCdtb3VzZXVwJyxcblx0XHRcdHRoaXMuZXZlbnRzLm1vdXNldXAsXG5cdFx0XHRmYWxzZVxuXHRcdCk7XG5cblx0XHRpZiAodHlwZW9mIHRoaXMub25SZWxlYXNlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLm9uUmVsZWFzZSgpO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQge0RyYWdFdmVudH07XG5leHBvcnQgZGVmYXVsdCBEcmFnRXZlbnQ7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBEcmFnRXZlbnQgZnJvbSAnLi9EcmFnRXZlbnQuZXMnO1xuXG5jb25zdCBJTUFHRV9IQU5ETEVTID0gWyd0bCcsICd0cicsICdibCcsICdiciddO1xuXG5jb25zdCBQT1NJVElPTl9FTEVNRU5UX0ZOID0ge1xuXHRibChoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG5cdFx0cG9zaXRpb25FbGVtZW50KGhhbmRsZSwgLTMgKyBsZWZ0LCBib3guaGVpZ2h0IC0gNCArIHRvcCk7XG5cdH0sXG5cdGJyKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcblx0XHRwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCBib3gud2lkdGggLSA0ICsgbGVmdCwgYm94LmhlaWdodCAtIDQgKyB0b3ApO1xuXHR9LFxuXHRybShoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG5cdFx0cG9zaXRpb25FbGVtZW50KFxuXHRcdFx0aGFuZGxlLFxuXHRcdFx0Ym94LndpZHRoIC0gNCArIGxlZnQsXG5cdFx0XHRNYXRoLnJvdW5kKGJveC5oZWlnaHQgLyAyKSAtIDMgKyB0b3Bcblx0XHQpO1xuXHR9LFxuXHR0bChoYW5kbGUsIGxlZnQsIHRvcCwgX2JveCkge1xuXHRcdHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIGxlZnQgLSAzLCB0b3AgLSAzKTtcblx0fSxcblx0dHIoaGFuZGxlLCBsZWZ0LCB0b3AsIGJveCkge1xuXHRcdHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIGJveC53aWR0aCAtIDQgKyBsZWZ0LCAtMyArIHRvcCk7XG5cdH0sXG59O1xuXG5jb25zdCBwb3NpdGlvbkVsZW1lbnQgPSAoZWwsIGxlZnQsIHRvcCkgPT4ge1xuXHRlbC5zdHlsZS5sZWZ0ID0gYCR7bGVmdH1weGA7XG5cdGVsLnN0eWxlLnRvcCA9IGAke3RvcH1weGA7XG59O1xuXG5jb25zdCBnZXRCb3VuZGluZ0JveCA9ICh3aW5kb3csIGVsKSA9PiB7XG5cdGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRyZXR1cm4ge1xuXHRcdGhlaWdodDogcmVjdC5oZWlnaHQsXG5cdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxuXHRcdHRvcDogcmVjdC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQsXG5cdFx0d2lkdGg6IHJlY3Qud2lkdGgsXG5cdH07XG59O1xuXG5jbGFzcyBSZXNpemVyIHtcblx0Y29uc3RydWN0b3IoZWRpdG9yLCBjZmcgPSB7fSkge1xuXHRcdHRoaXMuY2ZnID0gY2ZnO1xuXHRcdHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuXG5cdFx0dGhpcy5kb2N1bWVudCA9IGVkaXRvci5kb2N1bWVudCA/IGVkaXRvci5kb2N1bWVudC4kIDogZG9jdW1lbnQ7XG5cdFx0dGhpcy53aW5kb3cgPSBlZGl0b3Iud2luZG93ID8gZWRpdG9yLndpbmRvdy4kIDogd2luZG93O1xuXG5cdFx0dGhpcy5ib3ggPSBudWxsO1xuXHRcdHRoaXMuY29udGFpbmVyID0gbnVsbDtcblx0XHR0aGlzLmhhbmRsZXMgPSB7fTtcblx0XHR0aGlzLnByZXZpZXcgPSBudWxsO1xuXHRcdHRoaXMucHJldmlld0JveCA9IG51bGw7XG5cdFx0dGhpcy5yZXN1bHQgPSBudWxsO1xuXG5cdFx0dGhpcy5pbml0KCk7XG5cdH1cblxuXHRpbml0KCkge1xuXHRcdHRoaXMuY29udGFpbmVyID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHR0aGlzLmNvbnRhaW5lci5pZCA9ICdja2ltZ3Jzeic7XG5cblx0XHR0aGlzLnByZXZpZXcgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblxuXHRcdHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucHJldmlldyk7XG5cblx0XHR0aGlzLmhhbmRsZXMgPSB7fTtcblxuXHRcdElNQUdFX0hBTkRMRVMuZm9yRWFjaChoYW5kbGVOYW1lID0+IHtcblx0XHRcdHRoaXMuaGFuZGxlc1toYW5kbGVOYW1lXSA9IHRoaXMuY3JlYXRlSGFuZGxlKGhhbmRsZU5hbWUpO1xuXHRcdH0pO1xuXG5cdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuaGFuZGxlcyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuaGFuZGxlc1trZXlzW2ldXSk7XG5cdFx0fVxuXHR9XG5cblx0Y3JlYXRlSGFuZGxlKG5hbWUpIHtcblx0XHRjb25zdCBlbCA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpO1xuXG5cdFx0ZWwuY2xhc3NMaXN0LmFkZChuYW1lKTtcblxuXHRcdHJldHVybiBlbDtcblx0fVxuXG5cdGlzSGFuZGxlKGVsKSB7XG5cdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuaGFuZGxlcyk7XG5cblx0XHRsZXQgcmVzdWx0ID0gZmFsc2U7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLmhhbmRsZXNba2V5c1tpXV0gPT09IGVsKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdHNob3coZWwpIHtcblx0XHRjb25zdCB1aU5vZGUgPSB0aGlzLmVkaXRvci5jb25maWcudWlOb2RlIHx8IGRvY3VtZW50LmJvZHk7XG5cblx0XHR0aGlzLmVsID0gZWw7XG5cblx0XHR0aGlzLmJveCA9IGdldEJvdW5kaW5nQm94KHRoaXMud2luZG93LCB0aGlzLmVsKTtcblxuXHRcdHBvc2l0aW9uRWxlbWVudChcblx0XHRcdHRoaXMuY29udGFpbmVyLFxuXHRcdFx0dGhpcy5ib3gubGVmdCxcblx0XHRcdHRoaXMuYm94LnRvcCArIHVpTm9kZS5zY3JvbGxUb3Bcblx0XHQpO1xuXG5cdFx0dWlOb2RlLmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcblxuXHRcdHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgnY2tpbWdyc3onKTtcblxuXHRcdHRoaXMuc2hvd0hhbmRsZXMoKTtcblx0fVxuXG5cdGhpZGUoKSB7XG5cdFx0Y29uc3QgZWxlbWVudHMgPSB0aGlzLmRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NraW1ncnN6Jyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRlbGVtZW50c1tpXS5jbGFzc0xpc3QucmVtb3ZlKCdja2ltZ3JzeicpO1xuXHRcdH1cblxuXHRcdHRoaXMuaGlkZUhhbmRsZXMoKTtcblxuXHRcdGlmICh0aGlzLmNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY29udGFpbmVyKTtcblx0XHR9XG5cdH1cblxuXHRpbml0RHJhZyhldmVudCkge1xuXHRcdGlmIChldmVudC5idXR0b24gIT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBkcmFnID0gbmV3IERyYWdFdmVudCh0aGlzLndpbmRvdywgdGhpcy5kb2N1bWVudCk7XG5cblx0XHRkcmFnLm9uU3RhcnQgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLnNob3dQcmV2aWV3KCk7XG5cblx0XHRcdHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG5cblx0XHRcdHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpLmxvY2soKTtcblx0XHR9O1xuXG5cdFx0ZHJhZy5vbkRyYWcgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLmNhbGN1bGF0ZVNpemUoZHJhZyk7XG5cblx0XHRcdGNvbnN0IGVkaXRvckJvdW5kcyA9IHRoaXMuZWRpdG9yLmVsZW1lbnQuJC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdFx0aWYgKHRoaXMucHJldmlld0JveC53aWR0aCA+PSBlZGl0b3JCb3VuZHMud2lkdGgpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnVwZGF0ZVByZXZpZXcoKTtcblxuXHRcdFx0Y29uc3QgYm94ID0gdGhpcy5wcmV2aWV3Qm94O1xuXG5cdFx0XHR0aGlzLnVwZGF0ZUhhbmRsZXMoYm94LCBib3gubGVmdCwgYm94LnRvcCk7XG5cdFx0fTtcblxuXHRcdGRyYWcub25SZWxlYXNlID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5oaWRlUHJldmlldygpO1xuXG5cdFx0XHR0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcblxuXHRcdFx0dGhpcy5oaWRlKCk7XG5cblx0XHRcdHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpLnVubG9jaygpO1xuXG5cdFx0XHR0aGlzLmVkaXRvci5maXJlKCdzYXZlU25hcHNob3QnKTtcblx0XHR9O1xuXG5cdFx0ZHJhZy5vbkNvbXBsZXRlID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5yZXNpemVDb21wbGV0ZSgpO1xuXG5cdFx0XHR0aGlzLmVkaXRvci5maXJlKCdzYXZlU25hcHNob3QnKTtcblx0XHR9O1xuXG5cdFx0ZHJhZy5zdGFydChldmVudCk7XG5cdH1cblxuXHR1cGRhdGVIYW5kbGVzKGJveCwgbGVmdCA9IDAsIHRvcCA9IDApIHtcblx0XHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5oYW5kbGVzKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0UE9TSVRJT05fRUxFTUVOVF9GTltrZXlzW2ldXSh0aGlzLmhhbmRsZXNba2V5c1tpXV0sIGxlZnQsIHRvcCwgYm94KTtcblx0XHR9XG5cdH1cblxuXHRzaG93SGFuZGxlcygpIHtcblx0XHR0aGlzLnVwZGF0ZUhhbmRsZXModGhpcy5ib3gpO1xuXG5cdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuaGFuZGxlcyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuaGFuZGxlc1trZXlzW2ldXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0XHR9XG5cdH1cblxuXHRoaWRlSGFuZGxlcygpIHtcblx0XHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5oYW5kbGVzKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5oYW5kbGVzW2tleXNbaV1dLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0fVxuXHR9XG5cblx0c2hvd1ByZXZpZXcoKSB7XG5cdFx0dGhpcy5jYWxjdWxhdGVTaXplKCk7XG5cblx0XHR0aGlzLnVwZGF0ZVByZXZpZXcoKTtcblxuXHRcdHRoaXMucHJldmlldy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0fVxuXG5cdHVwZGF0ZVByZXZpZXcoKSB7XG5cdFx0cG9zaXRpb25FbGVtZW50KFxuXHRcdFx0dGhpcy5wcmV2aWV3LFxuXHRcdFx0dGhpcy5wcmV2aWV3Qm94LmxlZnQsXG5cdFx0XHR0aGlzLnByZXZpZXdCb3gudG9wXG5cdFx0KTtcblxuXHRcdHRoaXMucHJldmlldy5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLnByZXZpZXdCb3guaGVpZ2h0fXB4YDtcblx0XHR0aGlzLnByZXZpZXcuc3R5bGUud2lkdGggPSBgJHt0aGlzLnByZXZpZXdCb3gud2lkdGh9cHhgO1xuXHR9XG5cblx0aGlkZVByZXZpZXcoKSB7XG5cdFx0Y29uc3QgYm94ID0gZ2V0Qm91bmRpbmdCb3godGhpcy53aW5kb3csIHRoaXMucHJldmlldyk7XG5cblx0XHR0aGlzLnJlc3VsdCA9IHtcblx0XHRcdGhlaWdodDogYm94LmhlaWdodCxcblx0XHRcdHdpZHRoOiBib3gud2lkdGgsXG5cdFx0fTtcblxuXHRcdHRoaXMucHJldmlldy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHR9XG5cblx0Y2FsY3VsYXRlU2l6ZShkYXRhKSB7XG5cdFx0dGhpcy5wcmV2aWV3Qm94ID0ge1xuXHRcdFx0aGVpZ2h0OiB0aGlzLmJveC5oZWlnaHQsXG5cdFx0XHRsZWZ0OiAwLFxuXHRcdFx0dG9wOiAwLFxuXHRcdFx0d2lkdGg6IHRoaXMuYm94LndpZHRoLFxuXHRcdH07XG5cblx0XHRpZiAoIWRhdGEpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBjbGFzc05hbWUgPSBkYXRhLnRhcmdldC5jbGFzc05hbWU7XG5cblx0XHRpZiAoY2xhc3NOYW1lLmluZGV4T2YoJ3InKSA+PSAwKSB7XG5cdFx0XHR0aGlzLnByZXZpZXdCb3gud2lkdGggPSBNYXRoLm1heCgzMiwgdGhpcy5ib3gud2lkdGggKyBkYXRhLmRlbHRhLngpO1xuXHRcdH1cblxuXHRcdGlmIChjbGFzc05hbWUuaW5kZXhPZignYicpID49IDApIHtcblx0XHRcdHRoaXMucHJldmlld0JveC5oZWlnaHQgPSBNYXRoLm1heChcblx0XHRcdFx0MzIsXG5cdFx0XHRcdHRoaXMuYm94LmhlaWdodCArIGRhdGEuZGVsdGEueVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoY2xhc3NOYW1lLmluZGV4T2YoJ2wnKSA+PSAwKSB7XG5cdFx0XHR0aGlzLnByZXZpZXdCb3gud2lkdGggPSBNYXRoLm1heCgzMiwgdGhpcy5ib3gud2lkdGggLSBkYXRhLmRlbHRhLngpO1xuXHRcdH1cblxuXHRcdGlmIChjbGFzc05hbWUuaW5kZXhPZigndCcpID49IDApIHtcblx0XHRcdHRoaXMucHJldmlld0JveC5oZWlnaHQgPSBNYXRoLm1heChcblx0XHRcdFx0MzIsXG5cdFx0XHRcdHRoaXMuYm94LmhlaWdodCAtIGRhdGEuZGVsdGEueVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoY2xhc3NOYW1lLmluZGV4T2YoJ20nKSA8IDAgJiYgIWRhdGEua2V5cy5zaGlmdCkge1xuXHRcdFx0Y29uc3QgcmF0aW8gPSB0aGlzLmJveC53aWR0aCAvIHRoaXMuYm94LmhlaWdodDtcblxuXHRcdFx0aWYgKHRoaXMucHJldmlld0JveC53aWR0aCAvIHRoaXMucHJldmlld0JveC5oZWlnaHQgPiByYXRpbykge1xuXHRcdFx0XHR0aGlzLnByZXZpZXdCb3guaGVpZ2h0ID0gTWF0aC5yb3VuZChcblx0XHRcdFx0XHR0aGlzLnByZXZpZXdCb3gud2lkdGggLyByYXRpb1xuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5wcmV2aWV3Qm94LndpZHRoID0gTWF0aC5yb3VuZChcblx0XHRcdFx0XHR0aGlzLnByZXZpZXdCb3guaGVpZ2h0ICogcmF0aW9cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY2xhc3NOYW1lLmluZGV4T2YoJ2wnKSA+PSAwKSB7XG5cdFx0XHR0aGlzLnByZXZpZXdCb3gubGVmdCA9IHRoaXMuYm94LndpZHRoIC0gdGhpcy5wcmV2aWV3Qm94LndpZHRoO1xuXHRcdH1cblxuXHRcdGlmIChjbGFzc05hbWUuaW5kZXhPZigndCcpID49IDApIHtcblx0XHRcdHRoaXMucHJldmlld0JveC50b3AgPSB0aGlzLmJveC5oZWlnaHQgLSB0aGlzLnByZXZpZXdCb3guaGVpZ2h0O1xuXHRcdH1cblx0fVxuXG5cdHJlc2l6ZUNvbXBsZXRlKCkge1xuXHRcdHRoaXMuY2ZnLm9uQ29tcGxldGUodGhpcy5lbCwgdGhpcy5yZXN1bHQud2lkdGgsIHRoaXMucmVzdWx0LmhlaWdodCk7XG5cdH1cbn1cblxuZXhwb3J0IHtSZXNpemVyfTtcbmV4cG9ydCBkZWZhdWx0IFJlc2l6ZXI7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmNvbnN0IGlzSUUgPSBDS0VESVRPUi5lbnYuaWU7XG5cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2FkZGltYWdlcycpKSB7XG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gd2hpY2ggYWxsb3dzIERyYWcmRHJvcCBvZiBpbWFnZXMgZGlyZWN0bHkgaW50byB0aGUgZWRpdGFibGUgYXJlYS4gVGhlIGltYWdlIHdpbGwgYmUgZW5jb2RlZFxuXHQgKiBhcyBEYXRhIFVSSS4gQW4gZXZlbnQgYGJlZm9yZUltYWdlQWRkYCB3aWxsIGJlIGZpcmVkIHdpdGggdGhlIGxpc3Qgb2YgZHJvcHBlZCBpbWFnZXMuIElmIGFueSBvZiB0aGUgbGlzdGVuZXJzXG5cdCAqIHJldHVybnMgYGZhbHNlYCBvciBjYW5jZWxzIHRoZSBldmVudCwgdGhlIGltYWdlcyB3b24ndCBiZSBhZGRlZCB0byB0aGUgY29udGVudC4gT3RoZXJ3aXNlLFxuXHQgKiBhbiBldmVudCBgaW1hZ2VBZGRgIHdpbGwgYmUgZmlyZWQgd2l0aCB0aGUgaW5zZXJ0ZWQgZWxlbWVudCBpbnRvIHRoZSBlZGl0YWJsZSBhcmVhLlxuXHQgKlxuXHQgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcblx0ICovXG5cblx0LyoqXG5cdCAqIEZpcmVkIGJlZm9yZSBhZGRpbmcgaW1hZ2VzIHRvIHRoZSBlZGl0b3IuXG5cdCAqXG5cdCAqIEBldmVudCBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcyNiZWZvcmVJbWFnZUFkZFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGltYWdlRmlsZXMgQXJyYXkgb2YgaW1hZ2UgZmlsZXNcblx0ICovXG5cblx0LyoqXG5cdCAqIEZpcmVkIHdoZW4gYW4gaW1hZ2UgaXMgYmVpbmcgYWRkZWQgdG8gdGhlIGVkaXRvciBzdWNjZXNzZnVsbHkuXG5cdCAqXG5cdCAqIEBldmVudCBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcyNpbWFnZUFkZFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGVsIFRoZSBjcmVhdGVkIGltYWdlIHdpdGggc3JjIGFzIERhdGEgVVJJXG5cdCAqIEBwYXJhbSB7RmlsZX0gZmlsZSBUaGUgaW1hZ2UgZmlsZVxuXHQgKi9cblxuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfYWRkaW1hZ2VzJywge1xuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBwbHVnaW4sIHBhcnQgb2YgQ0tFZGl0b3IgcGx1Z2luIGxpZmVjeWNsZS5cblx0XHQgKiBUaGUgZnVuY3Rpb24gcmVnaXN0ZXJzIGEgJ2RyYWdlbnRlcicsICdkcmFnb3ZlcicsICdkcm9wJyBhbmQgYHBhc3RlYCBldmVudHMgb24gdGhlIGVkaXRpbmcgYXJlYS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuXHRcdCAqIEBtZXRob2QgaW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICovXG5cdFx0aW5pdChlZGl0b3IpIHtcblx0XHRcdGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRcdGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKFxuXHRcdFx0XHRcdGVkaXRhYmxlLFxuXHRcdFx0XHRcdCdkcmFnZW50ZXInLFxuXHRcdFx0XHRcdHRoaXMuX29uRHJhZ0VudGVyLFxuXHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZWRpdG9yLFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0XHQnZHJhZ292ZXInLFxuXHRcdFx0XHRcdHRoaXMuX29uRHJhZ092ZXIsXG5cdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKFxuXHRcdFx0XHRcdGVkaXRhYmxlLFxuXHRcdFx0XHRcdCdkcm9wJyxcblx0XHRcdFx0XHR0aGlzLl9vbkRyYWdEcm9wLFxuXHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZWRpdG9yLFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0XHQncGFzdGUnLFxuXHRcdFx0XHRcdHRoaXMuX29uUGFzdGUsXG5cdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFjY2VwdHMgYW4gYXJyYXkgb2YgZHJvcHBlZCBmaWxlcyB0byB0aGUgZWRpdG9yLiBUaGVuLCBpdCBmaWx0ZXJzIHRoZSBpbWFnZXMgYW5kIHNlbmRzIHRoZW0gZm9yIGZ1cnRoZXJcblx0XHQgKiBwcm9jZXNzaW5nIHRvIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzL19wcm9jZXNzRmlsZTptZXRob2RcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKlxuXHRcdCAqIEBmaXJlcyBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcyNiZWZvcmVJbWFnZUFkZFxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuXHRcdCAqIEBtZXRob2QgX2hhbmRsZUZpbGVzXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gZmlsZXMgQXJyYXkgb2YgZHJvcHBlZCBmaWxlcy4gT25seSB0aGUgaW1hZ2VzIGZyb20gdGhpcyBsaXN0IHdpbGwgYmUgcHJvY2Vzc2VkLlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9oYW5kbGVGaWxlcyhmaWxlcywgZWRpdG9yKSB7XG5cdFx0XHRsZXQgZmlsZTtcblx0XHRcdGxldCBpO1xuXG5cdFx0XHRjb25zdCBpbWFnZUZpbGVzID0gW107XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRmaWxlID0gZmlsZXNbaV07XG5cblx0XHRcdFx0aWYgKGZpbGUudHlwZS5pbmRleE9mKCdpbWFnZScpID09PSAwKSB7XG5cdFx0XHRcdFx0aW1hZ2VGaWxlcy5wdXNoKGZpbGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJlc3VsdCA9IGVkaXRvci5maXJlKCdiZWZvcmVJbWFnZUFkZCcsIHtcblx0XHRcdFx0aW1hZ2VGaWxlcyxcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBpbWFnZUZpbGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0ZmlsZSA9IGltYWdlRmlsZXNbaV07XG5cblx0XHRcdFx0XHR0aGlzLl9wcm9jZXNzRmlsZShmaWxlLCBlZGl0b3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlcyBkcmFnIGRyb3AgZXZlbnQuIFRoZSBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBhIHNlbGVjdGlvbiBmcm9tIHRoZSBjdXJyZW50XG5cdFx0ICogcG9pbnQgYW5kIHdpbGwgc2VuZCBhIGxpc3Qgb2YgZmlsZXMgdG8gYmUgcHJvY2Vzc2VkIHRvXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXMvX2hhbmRsZUZpbGVzOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcblx0XHQgKiBAbWV0aG9kIF9vbkRyYWdEcm9wXG5cdFx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZXZlbnR9IGV2ZW50IGRyYWdkcm9wIGV2ZW50LCBhcyByZWNlaXZlZCBuYXRpdmVseSBmcm9tIENLRWRpdG9yXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9vbkRyYWdEcm9wKGV2ZW50KSB7XG5cdFx0XHRjb25zdCBuYXRpdmVFdmVudCA9IGV2ZW50LmRhdGEuJDtcblxuXHRcdFx0Y29uc3QgdHJhbnNmZXJGaWxlcyA9IG5hdGl2ZUV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcztcblxuXHRcdFx0aWYgKHRyYW5zZmVyRmlsZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRuZXcgQ0tFRElUT1IuZG9tLmV2ZW50KG5hdGl2ZUV2ZW50KS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdGNvbnN0IGVkaXRvciA9IGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3I7XG5cblx0XHRcdFx0ZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvci5jcmVhdGVTZWxlY3Rpb25Gcm9tUG9pbnQoXG5cdFx0XHRcdFx0bmF0aXZlRXZlbnQuY2xpZW50WCxcblx0XHRcdFx0XHRuYXRpdmVFdmVudC5jbGllbnRZXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0dGhpcy5faGFuZGxlRmlsZXModHJhbnNmZXJGaWxlcywgZWRpdG9yKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlcyBkcmFnIGVudGVyIGV2ZW50LiBJbiBjYXNlIG9mIElFLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcHJldmVudCB0aGUgZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcblx0XHQgKiBAbWV0aG9kIF9vbkRyYWdFbnRlclxuXHRcdCAqIEBwYXJhbSB7RE9NIGV2ZW50fSBldmVudCBkcmFnZW50ZXIgZXZlbnQsIGFzIHJlY2VpdmVkIG5hdGl2ZWx5IGZyb20gQ0tFZGl0b3Jcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X29uRHJhZ0VudGVyKGV2ZW50KSB7XG5cdFx0XHRpZiAoaXNJRSkge1xuXHRcdFx0XHR0aGlzLl9wcmV2ZW50RXZlbnQoZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVzIGRyYWcgb3ZlciBldmVudC4gSW4gY2FzZSBvZiBJRSwgdGhpcyBmdW5jdGlvbiB3aWxsIHByZXZlbnQgdGhlIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG5cdFx0ICogQG1ldGhvZCBfb25EcmFnT3ZlclxuXHRcdCAqIEBwYXJhbSB7RE9NIGV2ZW50fSBldmVudCBkcmFnb3ZlciBldmVudCwgYXMgcmVjZWl2ZWQgbmF0aXZlbHkgZnJvbSBDS0VkaXRvclxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRfb25EcmFnT3ZlcihldmVudCkge1xuXHRcdFx0aWYgKGlzSUUpIHtcblx0XHRcdFx0dGhpcy5fcHJldmVudEV2ZW50KGV2ZW50KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2hlY2tzIGlmIHRoZSBwYXN0ZWQgZGF0YSBpcyBpbWFnZSBhbmQgcGFzc2VzIGl0IHRvXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXMvX3Byb2Nlc3NGaWxlOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgcHJvY2Vzc2luZy5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuXHRcdCAqIEBtZXRob2QgX29uUGFzdGVcblx0XHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5ldmVudH0gZXZlbnQgQSBgcGFzdGVgIGV2ZW50LCBhcyByZWNlaXZlZCBuYXRpdmVseSBmcm9tIENLRWRpdG9yXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9vblBhc3RlKGV2ZW50KSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdGV2ZW50LmRhdGEgJiZcblx0XHRcdFx0ZXZlbnQuZGF0YS4kICYmXG5cdFx0XHRcdGV2ZW50LmRhdGEuJC5jbGlwYm9hcmREYXRhICYmXG5cdFx0XHRcdGV2ZW50LmRhdGEuJC5jbGlwYm9hcmREYXRhLml0ZW1zICYmXG5cdFx0XHRcdGV2ZW50LmRhdGEuJC5jbGlwYm9hcmREYXRhLml0ZW1zLmxlbmd0aCA+IDBcblx0XHRcdCkge1xuXHRcdFx0XHRjb25zdCBwYXN0ZWREYXRhID0gZXZlbnQuZGF0YS4kLmNsaXBib2FyZERhdGEuaXRlbXNbMF07XG5cblx0XHRcdFx0aWYgKHBhc3RlZERhdGEudHlwZS5pbmRleE9mKCdpbWFnZScpID09PSAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgaW1hZ2VGaWxlID0gcGFzdGVkRGF0YS5nZXRBc0ZpbGUoKTtcblxuXHRcdFx0XHRcdHRoaXMuX3Byb2Nlc3NGaWxlKGltYWdlRmlsZSwgZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUHJldmVudHMgYSBuYXRpdmUgZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcblx0XHQgKiBAbWV0aG9kIF9wcmV2ZW50RXZlbnRcblx0XHQgKiBAcGFyYW0ge0RPTSBldmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGJlIHByZXZlbnRlZC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X3ByZXZlbnRFdmVudChldmVudCkge1xuXHRcdFx0ZXZlbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmV2ZW50KGV2ZW50LmRhdGEuJCk7XG5cblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUHJvY2Vzc2VzIGFuIGltYWdlIGZpbGUuIFRoZSBmdW5jdGlvbiBjcmVhdGVzIGFuIGltZyBlbGVtZW50IGFuZCBzZXRzIGFzIHNvdXJjZVxuXHRcdCAqIGEgRGF0YSBVUkksIHRoZW4gZmlyZXMgYW4gJ2ltYWdlQWRkJyBldmVudCB2aWEgQ0tFZGl0b3IncyBldmVudCBzeXN0ZW0uXG5cdFx0ICpcblx0XHQgKiBAZmlyZXMgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXMjaW1hZ2VBZGRcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcblx0XHQgKiBAbWV0aG9kIF9wcmV2ZW50RXZlbnRcblx0XHQgKiBAcGFyYW0ge0RPTSBldmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGJlIHByZXZlbnRlZC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X3Byb2Nlc3NGaWxlKGZpbGUsIGVkaXRvcikge1xuXHRcdFx0Y29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuXHRcdFx0cmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGJpbiA9IHJlYWRlci5yZXN1bHQ7XG5cblx0XHRcdFx0Y29uc3QgZWwgPSBDS0VESVRPUi5kb20uZWxlbWVudC5jcmVhdGVGcm9tSHRtbChcblx0XHRcdFx0XHQnPGltZyBzcmM9XCInICsgYmluICsgJ1wiPidcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRlZGl0b3IuaW5zZXJ0RWxlbWVudChlbCk7XG5cblx0XHRcdFx0Y29uc3QgaW1hZ2VEYXRhID0ge1xuXHRcdFx0XHRcdGVsLFxuXHRcdFx0XHRcdGZpbGUsXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0ZWRpdG9yLmZpcmUoJ2ltYWdlQWRkJywgaW1hZ2VEYXRhKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRyZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcblx0XHR9LFxuXHR9KTtcbn1cbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfYXV0b2xpbmsnKSkge1xuXHQvLyBEaXNhYmxlcyB0aGUgYXV0byBVUkwgZGV0ZWN0aW9uIGZlYXR1cmUgaW4gSUUsIHRoZWlyIGxhY2tzIGZ1bmN0aW9uYWxpdHk6XG5cdC8vIFRoZXkgY29udmVydCB0aGUgbGlua3Mgb25seSBvbiBzcGFjZS4gV2UgZG8gb24gc3BhY2UsIGNvbW1hLCBzZW1pY29sb24gYW5kIEVudGVyLlxuXG5cdGlmICgvTVNJRSAoW147XSopfFRyaWRlbnQuKjsgcnY6KFswLTkuXSspLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG5cdFx0ZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ0F1dG9VcmxEZXRlY3QnLCBmYWxzZSwgZmFsc2UpO1xuXHR9XG5cblx0Y29uc3QgS0VZX0JBQ0sgPSA4O1xuXG5cdGNvbnN0IEtFWV9DT01NQSA9IDE4ODtcblxuXHRjb25zdCBLRVlfRU5URVIgPSAxMztcblxuXHRjb25zdCBLRVlfU0VNSUNPTE9OID0gMTg2O1xuXG5cdGNvbnN0IEtFWV9TUEFDRSA9IDMyO1xuXG5cdGNvbnN0IERFTElNSVRFUlMgPSBbS0VZX0NPTU1BLCBLRVlfRU5URVIsIEtFWV9TRU1JQ09MT04sIEtFWV9TUEFDRV07XG5cblx0Y29uc3QgUkVHRVhfTEFTVF9XT1JEID0gL1teXFxzXSsvZ2ltO1xuXG5cdC8vIFNlZW4gYXQgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU3MTcxMzMvMjEwMzk5NlxuXG5cdGNvbnN0IFJFR0VYX1VSTCA9XG5cdFx0J14oaHR0cHM/OlxcXFwvXFxcXC8pPycgKyAvLyBwcm90b2NvbFxuXHRcdCcoKChbYS16XFxcXGRdKFthLXpcXFxcZC1dKlthLXpcXFxcZF0pKilcXFxcLikrW2Etel17Mix9fCcgKyAvLyBkb21haW4gbmFtZVxuXHRcdCcoKFxcXFxkezEsM31cXFxcLil7M31cXFxcZHsxLDN9KSknICsgLy8gT1IgaXAgKHY0KSBhZGRyZXNzXG5cdFx0JyhcXFxcOlxcXFxkKyk/KFxcXFwvWy1hLXpcXFxcZCVfLn4rXSopKicgKyAvLyBwb3J0IGFuZCBwYXRoXG5cdFx0JyhcXFxcP1s7JmEtelxcXFxkJV8ufis9LV0qKT8nICsgLy8gcXVlcnkgc3RyaW5nXG5cdFx0JyhcXFxcI1stYS16XFxcXGRfXSopPyQnO1xuXG5cdGNvbnN0IFJFR0VYX0VNQUlMID0gL1thLXpBLVowLTkuXy1dK0BbYS16QS1aMC05Li1dK1xcLlthLXpBLVpdezIsNH0vaTtcblxuXHQvKipcblx0ICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVzIGxpbmtzIHdoZW4gdXNlciB0eXBlcyB0ZXh0IHdoaWNoIGxvb2tzIGxpa2UgVVJMLlxuXHQgKlxuXHQgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlua1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV9hdXRvbGluaycsIHtcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXphdGlvbiBvZiB0aGUgcGx1Z2luLCBwYXJ0IG9mIENLRWRpdG9yIHBsdWdpbiBsaWZlY3ljbGUuXG5cdFx0ICogVGhlIGZ1bmN0aW9uIHJlZ2lzdGVycyB0aGUgYGtleXVwYCBldmVudCBvbiB0aGUgZWRpdGluZyBhcmVhLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcblx0XHQgKiBAbWV0aG9kIGluaXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuXHRcdCAqL1xuXHRcdGluaXQoZWRpdG9yKSB7XG5cdFx0XHRlZGl0b3Iub25jZSgnY29udGVudERvbScsICgpID0+IHtcblx0XHRcdFx0Y29uc3QgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuXHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0XHQna2V5dXAnLFxuXHRcdFx0XHRcdHRoaXMuX29uS2V5VXAsXG5cdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGVkaXRvci5vbigncGFzdGUnLCBldmVudCA9PiB7XG5cdFx0XHRcdGlmIChldmVudC5kYXRhLm1ldGhvZCA9PT0gJ3Bhc3RlJykge1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdGV2ZW50LmRhdGEuZGF0YVZhbHVlLmluZGV4T2YoJzwnKSA+IC0xIHx8XG5cdFx0XHRcdFx0XHRldmVudC5kYXRhLmRhdGFWYWx1ZS5pbmRleE9mKCcmbHQ7JykgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRldmVudC5kYXRhLmRhdGFWYWx1ZS5pbmRleE9mKCc8dT48Zm9udCBjb2xvcj1cIicpID5cblx0XHRcdFx0XHRcdFx0LTFcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5kYXRhLmRhdGFWYWx1ZSA9IGV2ZW50LmRhdGEuZGF0YVZhbHVlLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHRcdFx0Lzx1Pjxmb250IGNvbG9yPVwiIyguKj8pXCI+fDxcXC9mb250PjxcXC91Pi9nLFxuXHRcdFx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBpbnN0YW5jZSA9IHRoaXM7XG5cblx0XHRcdFx0XHRldmVudC5kYXRhLmRhdGFWYWx1ZSA9IGV2ZW50LmRhdGEuZGF0YVZhbHVlLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHRSZWdFeHAoUkVHRVhfVVJMLCAnZ2ltJyksXG5cdFx0XHRcdFx0XHR1cmwgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5zdGFuY2UuX2lzVmFsaWRVUkwodXJsKSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpbnN0YW5jZS5faXNWYWxpZEVtYWlsKHVybCkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCc8YSBocmVmPVwibWFpbHRvOicgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR1cmwgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQnXCI+JyArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHVybCArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCc8L2E+J1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdFx0XHRcdFx0JzxhIGhyZWY9XCInICsgdXJsICsgJ1wiPicgKyB1cmwgKyAnPC9hPidcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHJpZXZlcyB0aGUgbGFzdCB3b3JkIGludHJvZHVjZWQgYnkgdGhlIHVzZXIuIFJlYWRzIGZyb20gdGhlIGN1cnJlbnRcblx0XHQgKiBjYXJldCBwb3NpdGlvbiBiYWNrd2FyZHMgdW50aWwgaXQgZmluZHMgdGhlIGZpcnN0IHdoaXRlIHNwYWNlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcblx0XHQgKiBAbWV0aG9kIF9nZXRMYXN0V29yZFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBsYXN0IHdvcmQgaW50cm9kdWNlZCBieSB1c2VyXG5cdFx0ICovXG5cdFx0X2dldExhc3RXb3JkKGVkaXRvcikge1xuXHRcdFx0Y29uc3QgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cblx0XHRcdGlmICghcmFuZ2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBvZmZzZXQgPSByYW5nZS5zdGFydE9mZnNldDtcblxuXHRcdFx0bGV0IHByZXZpb3VzVGV4dCA9ICcnO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBwcmVzc2VkIEVudGVyLCBzbyB3ZSBoYXZlIHRvIGxvb2sgb24gdGhlIHByZXZpb3VzIG5vZGVcblxuXHRcdFx0aWYgKHRoaXMuX2N1cnJlbnRLZXlDb2RlID09PSBLRVlfRU5URVIpIHtcblx0XHRcdFx0bGV0IHByZXZpb3VzTm9kZSA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLmdldFByZXZpb3VzKCk7XG5cblx0XHRcdFx0bGV0IGxhc3RDaGlsZDtcblxuXHRcdFx0XHRpZiAocHJldmlvdXNOb2RlKSB7XG5cdFx0XHRcdFx0Ly8gSWYgcHJldmlvdXMgbm9kZSBpcyBhIFNQQUNFLCAoaXQgZG9lcyBub3QgaGF2ZSAnZ2V0TGFzdCcgbWV0aG9kKSxcblx0XHRcdFx0XHQvLyBpZ25vcmUgaXQgYW5kIGZpbmQgdGhlIHByZXZpb3VzIHRleHQgbm9kZVxuXG5cdFx0XHRcdFx0d2hpbGUgKCFwcmV2aW91c05vZGUuZ2V0TGFzdCkge1xuXHRcdFx0XHRcdFx0cHJldmlvdXNOb2RlID0gcHJldmlvdXNOb2RlLmdldFByZXZpb3VzKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGFzdENoaWxkID0gcHJldmlvdXNOb2RlLmdldExhc3QoKTtcblxuXHRcdFx0XHRcdC8vIERlcGVuZGluZyBvbiB0aGUgYnJvd3NlciwgdGhlIGxhc3QgY2hpbGQgbm9kZSBtYXkgYmUgYSA8QlI+XG5cdFx0XHRcdFx0Ly8gKHdoaWNoIGRvZXMgbm90IGhhdmUgJ2dldFRleHQnIG1ldGhvZCksXG5cdFx0XHRcdFx0Ly8gc28gaWdub3JlIGl0IGFuZCBmaW5kIHRoZSBwcmV2aW91cyB0ZXh0IG5vZGVcblxuXHRcdFx0XHRcdHdoaWxlIChsYXN0Q2hpbGQgJiYgIWxhc3RDaGlsZC5nZXRUZXh0KCkpIHtcblx0XHRcdFx0XHRcdGxhc3RDaGlsZCA9IGxhc3RDaGlsZC5nZXRQcmV2aW91cygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENoZWNrIGlmIHRoZSBsYXN0Q2hpbGQgaXMgYWxyZWFkeSBhIGxpbmtcblxuXHRcdFx0XHRpZiAoIShsYXN0Q2hpbGQgJiYgbGFzdENoaWxkLiQuaHJlZikpIHtcblx0XHRcdFx0XHR0aGlzLl9zdGFydENvbnRhaW5lciA9IGxhc3RDaGlsZDtcblx0XHRcdFx0XHRwcmV2aW91c1RleHQgPSBsYXN0Q2hpbGQgPyBsYXN0Q2hpbGQuZ2V0VGV4dCgpIDogJyc7XG5cdFx0XHRcdFx0dGhpcy5fb2Zmc2V0ID0gcHJldmlvdXNUZXh0Lmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc3RhcnRDb250YWluZXIgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcblxuXHRcdFx0XHQvLyBMYXN0IGNoYXJhY3RlciBpcyB0aGUgZGVsaW1pdGVyLCBpZ25vcmUgaXRcblxuXHRcdFx0XHRwcmV2aW91c1RleHQgPSB0aGlzLl9zdGFydENvbnRhaW5lclxuXHRcdFx0XHRcdC5nZXRUZXh0KClcblx0XHRcdFx0XHQuc3Vic3RyaW5nKDAsIG9mZnNldCAtIDEpO1xuXG5cdFx0XHRcdHRoaXMuX29mZnNldCA9IG9mZnNldCAtIDE7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBsYXN0V29yZCA9ICcnO1xuXG5cdFx0XHRjb25zdCBtYXRjaCA9IHByZXZpb3VzVGV4dC5tYXRjaChSRUdFWF9MQVNUX1dPUkQpO1xuXG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0bGFzdFdvcmQgPSBtYXRjaC5wb3AoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxhc3RXb3JkO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGxpbmsgaXMgYSB2YWxpZCBFbWFpbC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBpc1ZhbGlkRW1haWxcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbGluayBUaGUgZW1haWwgd2Ugd2FudCB0byBrbm93IGlmIGl0IGlzIGEgdmFsaWQgRW1haWxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbWFpbCBpcyBhIHZhbGlkIEVtYWlsLCBmYWxzZSBvdGhlcndpc2Vcblx0XHQgKi9cblx0XHRfaXNWYWxpZEVtYWlsKGVtYWlsKSB7XG5cdFx0XHRyZXR1cm4gUkVHRVhfRU1BSUwudGVzdChlbWFpbCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gbGluayBpcyBhIHZhbGlkIFVSTC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBpc1ZhbGlkVVJMXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGxpbmsgVGhlIGxpbmsgd2Ugd2FudCB0byBrbm93IGlmIGl0IGlzIGEgdmFsaWQgVVJMXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgbGluayBpcyBhIHZhbGlkIFVSTCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdFx0ICovXG5cdFx0X2lzVmFsaWRVUkwobGluaykge1xuXHRcdFx0cmV0dXJuIFJlZ0V4cChSRUdFWF9VUkwsICdpJykudGVzdChsaW5rKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTGlzdGVucyB0byB0aGUgYGtleWRvd25gIGV2ZW50IGFuZCBpZiB0aGUga2V5Y29kZSBpcyBgQmFja3NwYWNlYCwgcmVtb3ZlcyB0aGUgcHJldmlvdXNseVxuXHRcdCAqIGNyZWF0ZWQgbGluay5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBfb25LZXlEb3duXG5cdFx0ICogQHBhcmFtIHtFdmVudEZhY2FkZX0gZXZlbnQgRXZlbnRGYWNhZGUgb2JqZWN0XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9vbktleURvd24oZXZlbnQpIHtcblx0XHRcdGNvbnN0IG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS4kO1xuXG5cdFx0XHRjb25zdCBlZGl0b3IgPSBldmVudC5saXN0ZW5lckRhdGEuZWRpdG9yO1xuXG5cdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRlZGl0YWJsZS5yZW1vdmVMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93bik7XG5cblx0XHRcdGlmIChuYXRpdmVFdmVudC5rZXlDb2RlID09PSBLRVlfQkFDSykge1xuXHRcdFx0XHRldmVudC5jYW5jZWwoKTtcblx0XHRcdFx0ZXZlbnQuZGF0YS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUxpbmsoZWRpdG9yKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fY2tMaW5rID0gbnVsbDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTGlzdGVucyB0byB0aGUgYEVudGVyYCBhbmQgYFNwYWNlYCBrZXkgZXZlbnRzIGluIG9yZGVyIHRvIGNoZWNrIGlmIHRoZSBsYXN0IHdvcmRcblx0XHQgKiBpbnRyb2R1Y2VkIGJ5IHRoZSB1c2VyIHNob3VsZCBiZSByZXBsYWNlZCBieSBhIGxpbmsgZWxlbWVudC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBfb25LZXlVcFxuXHRcdCAqIEBwYXJhbSB7RXZlbnRGYWNhZGV9IGV2ZW50IEV2ZW50RmFjYWRlIG9iamVjdFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRfb25LZXlVcChldmVudCkge1xuXHRcdFx0Y29uc3QgbmF0aXZlRXZlbnQgPSBldmVudC5kYXRhLiQ7XG5cblx0XHRcdHRoaXMuX2N1cnJlbnRLZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuXHRcdFx0aWYgKERFTElNSVRFUlMuaW5kZXhPZih0aGlzLl9jdXJyZW50S2V5Q29kZSkgIT09IC0xKSB7XG5cdFx0XHRcdGNvbnN0IGVkaXRvciA9IGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3I7XG5cblx0XHRcdFx0Y29uc3QgbGFzdFdvcmQgPSB0aGlzLl9nZXRMYXN0V29yZChlZGl0b3IpO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9pc1ZhbGlkVVJMKGxhc3RXb3JkKSkge1xuXHRcdFx0XHRcdHRoaXMuX3JlcGxhY2VDb250ZW50QnlMaW5rKGVkaXRvciwgbGFzdFdvcmQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlcGxhY2VzIGNvbnRlbnQgYnkgYSBsaW5rIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBAZmlyZXMgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGluayNhdXRvbGlua0FkZFxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBfcmVwbGFjZUNvbnRlbnRCeUxpbmtcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudCBUaGUgdGV4dCB0aGF0IGhhcyB0byBiZSByZXBsYWNlZCBieSBhbiBsaW5rIGVsZW1lbnRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X3JlcGxhY2VDb250ZW50QnlMaW5rKGVkaXRvciwgY29udGVudCkge1xuXHRcdFx0bGV0IHJhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG5cdFx0XHRjb25zdCBub2RlID0gQ0tFRElUT1IuZG9tLmVsZW1lbnQuZ2V0KHRoaXMuX3N0YXJ0Q29udGFpbmVyKTtcblx0XHRcdGNvbnN0IG9mZnNldCA9IHRoaXMuX29mZnNldDtcblxuXHRcdFx0Ly8gU2VsZWN0IHRoZSBjb250ZW50LCBzbyBDS0VESVRPUi5MaW5rIGNhbiBwcm9wZXJseSByZXBsYWNlIGl0XG5cblx0XHRcdHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCAtIGNvbnRlbnQubGVuZ3RoKTtcblx0XHRcdHJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQpO1xuXHRcdFx0cmFuZ2Uuc2VsZWN0KCk7XG5cblx0XHRcdGNvbnN0IGNrTGluayA9IG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvcik7XG5cdFx0XHRja0xpbmsuY3JlYXRlKGNvbnRlbnQpO1xuXHRcdFx0dGhpcy5fY2tMaW5rID0gY2tMaW5rO1xuXG5cdFx0XHRjb25zdCBsaW5rTm9kZSA9IGNrTGluay5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cdFx0XHRlZGl0b3IuZmlyZSgnYXV0b2xpbmtBZGQnLCBsaW5rTm9kZSk7XG5cblx0XHRcdHRoaXMuX3N1YnNjcmliZVRvS2V5RXZlbnQoZWRpdG9yKTtcblxuXHRcdFx0Ly8gTm93IHJhbmdlIGlzIG9uIHRoZSBsaW5rIGFuZCBpdCBpcyBzZWxlY3RlZC4gV2UgaGF2ZSB0b1xuXHRcdFx0Ly8gcmV0dXJuIGZvY3VzIHRvIHRoZSBjYXJldCBwb3NpdGlvbi5cblxuXHRcdFx0cmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cblx0XHRcdC8vIElmIHVzZXIgcHJlc3NlZCBgRW50ZXJgLCBnZXQgdGhlIG5leHQgZWRpdGFibGUgbm9kZSBhdCBwb3NpdGlvbiAwLFxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHNldCB0aGUgY3Vyc29yIGF0IHRoZSBuZXh0IGNoYXJhY3RlciBvZiB0aGUgbGluayAodGhlIHdoaXRlIHNwYWNlKVxuXG5cdFx0XHRpZiAodGhpcy5fY3VycmVudEtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuXHRcdFx0XHRjb25zdCBuZXh0RWRpdGFibGVOb2RlID0gcmFuZ2UuZ2V0TmV4dEVkaXRhYmxlTm9kZSgpO1xuXG5cdFx0XHRcdHJhbmdlLnNldFN0YXJ0KG5leHRFZGl0YWJsZU5vZGUsIDApO1xuXHRcdFx0XHRyYW5nZS5zZXRFbmQobmV4dEVkaXRhYmxlTm9kZSwgMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBlbmNsb3NlZE5vZGUgPSByYW5nZS5nZXRFbmNsb3NlZE5vZGUoKTtcblxuXHRcdFx0XHRyYW5nZS5zZXRTdGFydChlbmNsb3NlZE5vZGUsIDApO1xuXHRcdFx0XHRyYW5nZS5zZXRFbmQoZW5jbG9zZWROb2RlLCAwKTtcblx0XHRcdH1cblxuXHRcdFx0cmFuZ2Uuc2VsZWN0KCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZpcmVkIHdoZW4gYSBVUkwgaXMgZGV0ZWN0ZWQgaW4gdGV4dCBhbmQgY29udmVydGVkIHRvIGEgbGluay5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rI2F1dG9saW5rQWRkXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcblx0XHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBlbCBOb2RlIG9mIHRoZSBjcmVhdGVkIGxpbmsuXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHRoZSBjcmVhdGVkIGxpbmsgZWxlbWVudCwgYW5kIHJlcGxhY2VzIGl0IGJ5IGl0cyB0ZXh0LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcblx0XHQgKiBAbWV0aG9kIF9yZW1vdmVMaW5rXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9yZW1vdmVMaW5rKGVkaXRvcikge1xuXHRcdFx0Y29uc3QgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cdFx0XHRjb25zdCBjYXJldE9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuXG5cdFx0XHQvLyBTZWxlY3QgdGhlIGxpbmssIHNvIENLRURJVE9SLkxpbmsgY2FuIHByb3Blcmx5IHJlbW92ZSBpdFxuXG5cdFx0XHRjb25zdCBsaW5rTm9kZSA9XG5cdFx0XHRcdHRoaXMuX3N0YXJ0Q29udGFpbmVyLmdldE5leHQoKSB8fCB0aGlzLl9zdGFydENvbnRhaW5lcjtcblxuXHRcdFx0Y29uc3QgbmV3UmFuZ2UgPSBlZGl0b3IuY3JlYXRlUmFuZ2UoKTtcblx0XHRcdG5ld1JhbmdlLnNldFN0YXJ0KGxpbmtOb2RlLCAwKTtcblx0XHRcdG5ld1JhbmdlLnNldEVuZEFmdGVyKGxpbmtOb2RlKTtcblx0XHRcdG5ld1JhbmdlLnNlbGVjdCgpO1xuXG5cdFx0XHR0aGlzLl9ja0xpbmsucmVtb3ZlKCk7XG5cblx0XHRcdC8vIFJldHVybiBmb2N1cyB0byB0aGUgY2FyZXQgcG9zaXRpb25cblxuXHRcdFx0cmFuZ2Uuc2V0RW5kKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBjYXJldE9mZnNldCk7XG5cdFx0XHRyYW5nZS5zZXRTdGFydChyYW5nZS5zdGFydENvbnRhaW5lciwgY2FyZXRPZmZzZXQpO1xuXG5cdFx0XHRyYW5nZS5zZWxlY3QoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU3Vic2NyaWJlIHRvIGEga2V5IGV2ZW50IG9mIHRoZSBlZGl0YWJsZSBhcmlhLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcblx0XHQgKiBAbWV0aG9kIF9zdWJzY3JpYmVUb0tleUV2ZW50XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9zdWJzY3JpYmVUb0tleUV2ZW50KGVkaXRvcikge1xuXHRcdFx0Y29uc3QgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuXHRcdFx0Ly8gQ2hhbmdlIHRoZSBwcmlvcml0eSBvZiBrZXlkb3duIGxpc3RlbmVyIC0gMSBtZWFucyB0aGUgaGlnaGVzdCBwcmlvcml0eS5cblx0XHRcdC8vIEluIENocm9tZSBvbiBwcmVzc2luZyBgRW50ZXJgIHRoZSBsaXN0ZW5lciBpcyBub3QgYmVpbmcgaW52b2tlZC5cblx0XHRcdC8vIFNlZSBodHRwOi8vZGV2LmNrZWRpdG9yLmNvbS90aWNrZXQvMTE4NjEgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cblx0XHRcdGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKFxuXHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0J2tleWRvd24nLFxuXHRcdFx0XHR0aGlzLl9vbktleURvd24sXG5cdFx0XHRcdHRoaXMsXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdDFcblx0XHRcdCk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2F1dG9saXN0JykpIHtcblx0Y29uc3QgS0VZX0JBQ0sgPSA4O1xuXG5cdGNvbnN0IEtFWV9TUEFDRSA9IDMyO1xuXG5cdGNvbnN0IERFRkFVTFRfQ09ORklHID0gW1xuXHRcdHtcblx0XHRcdHJlZ2V4OiAvXlxcKiQvLFxuXHRcdFx0dHlwZTogJ2J1bGxldGVkbGlzdCcsXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRyZWdleDogL14xXFwuJC8sXG5cdFx0XHR0eXBlOiAnbnVtYmVyZWRsaXN0Jyxcblx0XHR9LFxuXHRdO1xuXG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gd2hpY2ggYXV0b21hdGljYWxseSBnZW5lcmF0ZXMgb3JkZXJlZC91bm9yZGVyZWQgbGlzdCB3aGVuIHVzZXIgdHlwZXMgdGV4dCB3aGljaCBsb29rcyBsaWtlIGEgbGlzdC5cblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpc3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfYXV0b2xpc3QnLCB7XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS2VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuXHRcdCAqIFRoZSBmdW5jdGlvbiByZWdpc3RlcnMgdGhlIGBrZXlkb3duYCBldmVudCBvbiB0aGUgY29udGVudCBlZGl0aW5nIGFyZWEuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlzdFxuXHRcdCAqIEBtZXRob2QgaW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICovXG5cdFx0aW5pdChlZGl0b3IpIHtcblx0XHRcdGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRcdGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKFxuXHRcdFx0XHRcdGVkaXRhYmxlLFxuXHRcdFx0XHRcdCdrZXlkb3duJyxcblx0XHRcdFx0XHR0aGlzLl9vbktleURvd24sXG5cdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrcyBmb3IgcHJlc3NpbmcgdGhlIGBCYWNrc3BhY2VgIGtleSBpbiBvcmRlciB0byB1bmRvIHRoZSBsaXN0IGNyZWF0aW9uLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpc3Rcblx0XHQgKiBAbWV0aG9kIF9jaGVja0ZvckJhY2tzcGFjZUFuZFVuZG9cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudCBvYmplY3Rcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X2NoZWNrRm9yQmFja3NwYWNlQW5kVW5kbyhldmVudCkge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcjtcblxuXHRcdFx0Y29uc3QgbmF0aXZlRXZlbnQgPSBldmVudC5kYXRhLiQ7XG5cblx0XHRcdGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdGVkaXRhYmxlLnJlbW92ZUxpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fY2hlY2tGb3JCYWNrc3BhY2VBbmRVbmRvKTtcblxuXHRcdFx0aWYgKG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IEtFWV9CQUNLKSB7XG5cdFx0XHRcdGVkaXRvci5leGVjQ29tbWFuZCgndW5kbycpO1xuXHRcdFx0XHRlZGl0b3IuaW5zZXJ0SHRtbChldmVudC5saXN0ZW5lckRhdGEuYnVsbGV0ICsgJyZuYnNwOycpO1xuXHRcdFx0XHRldmVudC5kYXRhLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrcyBjdXJyZW50IGxpbmUgdG8gZmluZCBtYXRjaCB3aXRoIE1BVENIRVMgb2JqZWN0IHRvIGNyZWF0ZSBPTCBvciBVTC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saXN0XG5cdFx0ICogQG1ldGhvZCBfY2hlY2tMaW5lXG5cdFx0ICogQHBhcmFtIHtlZGl0b3J9IEVkaXRvciBvYmplY3Rcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fG51bGx9IFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBkZXRlY3RlZCBsaXN0IGNvbmZpZyBpZiBhbnlcblx0XHQgKi9cblx0XHRfZ2V0TGlzdENvbmZpZyhlZGl0b3IpIHtcblx0XHRcdGNvbnN0IGNvbmZpZ1JlZ2V4ID0gZWRpdG9yLmNvbmZpZy5hdXRvbGlzdCB8fCBERUZBVUxUX0NPTkZJRztcblxuXHRcdFx0Y29uc3QgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cblx0XHRcdGNvbnN0IHRleHRDb250YWluZXIgPSByYW5nZS5lbmRDb250YWluZXIuZ2V0VGV4dCgpO1xuXG5cdFx0XHRjb25zdCBidWxsZXQgPSB0ZXh0Q29udGFpbmVyLnN1YnN0cmluZygwLCByYW5nZS5zdGFydE9mZnNldCk7XG5cblx0XHRcdGNvbnN0IHRleHQgPSB0ZXh0Q29udGFpbmVyLnN1YnN0cmluZyhcblx0XHRcdFx0cmFuZ2Uuc3RhcnRPZmZzZXQsXG5cdFx0XHRcdHRleHRDb250YWluZXIubGVuZ3RoXG5cdFx0XHQpO1xuXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXG5cdFx0XHRjb25zdCByZWdleExlbiA9IGNvbmZpZ1JlZ2V4Lmxlbmd0aDtcblxuXHRcdFx0bGV0IGF1dG9saXN0Q2ZnID0gbnVsbDtcblxuXHRcdFx0d2hpbGUgKCFhdXRvbGlzdENmZyAmJiByZWdleExlbiA+IGluZGV4KSB7XG5cdFx0XHRcdGNvbnN0IHJlZ2V4SXRlbSA9IGNvbmZpZ1JlZ2V4W2luZGV4XTtcblxuXHRcdFx0XHRpZiAocmVnZXhJdGVtLnJlZ2V4LnRlc3QoYnVsbGV0KSkge1xuXHRcdFx0XHRcdGF1dG9saXN0Q2ZnID0ge1xuXHRcdFx0XHRcdFx0YnVsbGV0LFxuXHRcdFx0XHRcdFx0ZWRpdG9yLFxuXHRcdFx0XHRcdFx0dGV4dCxcblx0XHRcdFx0XHRcdHR5cGU6IHJlZ2V4SXRlbS50eXBlLFxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhdXRvbGlzdENmZztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGxpc3Qgd2l0aCBkaWZmZXJlbnQgdHlwZXM6IEJ1bGxldGVkIG9yIE51bWJlcmVkIGxpc3Rcblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saXN0XG5cdFx0ICogQG1ldGhvZCBfY3JlYXRlTGlzdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBsaXN0Q29uZmlnIE9iamVjdCB0aGF0IGNvbnRhaW5zIGJ1bGxldCwgdGV4dCBhbmQgdHlwZSBmb3IgY3JlYXRpbmcgdGhlIGxpc3Rcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X2NyZWF0ZUxpc3QobGlzdENvbmZpZykge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gbGlzdENvbmZpZy5lZGl0b3I7XG5cblx0XHRcdGNvbnN0IHJhbmdlID0gZWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFJhbmdlcygpWzBdO1xuXG5cdFx0XHRyYW5nZS5lbmRDb250YWluZXIuc2V0VGV4dChsaXN0Q29uZmlnLnRleHQpO1xuXHRcdFx0ZWRpdG9yLmV4ZWNDb21tYW5kKGxpc3RDb25maWcudHlwZSk7XG5cblx0XHRcdGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdC8vIFN1YnNjcmliZSB0byBrZXlkb3duIGluIG9yZGVyIHRvIGNoZWNrIGlmIHRoZSBuZXh0IGtleSBwcmVzcyBpcyBgQmFja3NwYWNlYC5cblx0XHRcdC8vIElmIHNvLCB0aGUgY3JlYXRpb24gb2YgdGhlIGxpc3Qgd2lsbCBiZSBkaXNjYXJkZWQuXG5cblx0XHRcdGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKFxuXHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0J2tleWRvd24nLFxuXHRcdFx0XHR0aGlzLl9jaGVja0ZvckJhY2tzcGFjZUFuZFVuZG8sXG5cdFx0XHRcdHRoaXMsXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdFx0YnVsbGV0OiBsaXN0Q29uZmlnLmJ1bGxldCxcblx0XHRcdFx0fSxcblx0XHRcdFx0MVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTGlzdGVucyB0byB0aGUgYFNwYWNlYCBrZXkgZXZlbnRzIHRvIGNoZWNrIGlmIHRoZSBsYXN0IHdvcmRcblx0XHQgKiBpbnRyb2R1Y2VkIGJ5IHRoZSB1c2VyIHNob3VsZCBiZSByZXBsYWNlZCBieSBhIGxpc3QgKE9MIG9yIFVMKVxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpc3Rcblx0XHQgKiBAbWV0aG9kIF9vbktleURvd25cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudCBvYmplY3Rcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X29uS2V5RG93bihldmVudCkge1xuXHRcdFx0Y29uc3QgbmF0aXZlRXZlbnQgPSBldmVudC5kYXRhLiQ7XG5cblx0XHRcdGlmIChuYXRpdmVFdmVudC5rZXlDb2RlID09PSBLRVlfU1BBQ0UpIHtcblx0XHRcdFx0Y29uc3QgbGlzdENvbmZpZyA9IHRoaXMuX2dldExpc3RDb25maWcoXG5cdFx0XHRcdFx0ZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvclxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmIChsaXN0Q29uZmlnKSB7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHRoaXMuX2NyZWF0ZUxpc3QobGlzdENvbmZpZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHR9KTtcbn1cbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuLyoqXG4gKiBDS0VkaXRvciBwbHVnaW46IERyYWdhYmxlIGltYWdlIHJlc2l6aW5nXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc3N0dXIvY2stZHJhZ3Jlc2l6ZVxuICogLSBTaG93cyBzZW1pLXRyYW5zcGFyZW50IG92ZXJsYXkgd2hpbGUgcmVzaXppbmdcbiAqIC0gRW5mb3JjZXMgQXNwZWN0IFJhdGlvICh1bmxlc3MgaG9sZGluZyBzaGlmdClcbiAqIC0gU25hcCB0byBzaXplIG9mIG90aGVyIGltYWdlcyBpbiBlZGl0b3JcbiAqIC0gRXNjYXBlIHdoaWxlIGRyYWdnaW5nIGNhbmNlbHMgcmVzaXplXG4gKi9cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2RyYWdyZXNpemUnKSkge1xuXHRjb25zdCBJTUFHRV9IQU5ETEVTID0ge1xuXHRcdGJvdGg6IFsndGwnLCAndG0nLCAndHInLCAnbG0nLCAncm0nLCAnYmwnLCAnYm0nLCAnYnInXSxcblx0XHRoZWlnaHQ6IFsndGwnLCAndG0nLCAndHInLCAnYmwnLCAnYm0nLCAnYnInXSxcblx0XHRzY2FsZTogWyd0bCcsICd0cicsICdibCcsICdiciddLFxuXHRcdHdpZHRoOiBbJ3RsJywgJ3RyJywgJ2xtJywgJ3JtJywgJ2JsJywgJ2JyJ10sXG5cdH07XG5cblx0Y29uc3QgUE9TSVRJT05fRUxFTUVOVF9GTiA9IHtcblx0XHRibChoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG5cdFx0XHRwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCAtMyArIGxlZnQsIGJveC5oZWlnaHQgLSA0ICsgdG9wKTtcblx0XHR9LFxuXHRcdGJtKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcblx0XHRcdHBvc2l0aW9uRWxlbWVudChcblx0XHRcdFx0aGFuZGxlLFxuXHRcdFx0XHRNYXRoLnJvdW5kKGJveC53aWR0aCAvIDIpIC0gMyArIGxlZnQsXG5cdFx0XHRcdGJveC5oZWlnaHQgLSA0ICsgdG9wXG5cdFx0XHQpO1xuXHRcdH0sXG5cdFx0YnIoaGFuZGxlLCBsZWZ0LCB0b3AsIGJveCkge1xuXHRcdFx0cG9zaXRpb25FbGVtZW50KGhhbmRsZSwgYm94LndpZHRoIC0gNCArIGxlZnQsIGJveC5oZWlnaHQgLSA0ICsgdG9wKTtcblx0XHR9LFxuXHRcdGxtKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcblx0XHRcdHBvc2l0aW9uRWxlbWVudChcblx0XHRcdFx0aGFuZGxlLFxuXHRcdFx0XHQtMyArIGxlZnQsXG5cdFx0XHRcdE1hdGgucm91bmQoYm94LmhlaWdodCAvIDIpIC0gMyArIHRvcFxuXHRcdFx0KTtcblx0XHR9LFxuXHRcdHRsKGhhbmRsZSwgbGVmdCwgdG9wLCBfYm94KSB7XG5cdFx0XHRwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCBsZWZ0IC0gMywgdG9wIC0gMyk7XG5cdFx0fSxcblx0XHR0bShoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG5cdFx0XHRwb3NpdGlvbkVsZW1lbnQoXG5cdFx0XHRcdGhhbmRsZSxcblx0XHRcdFx0TWF0aC5yb3VuZChib3gud2lkdGggLyAyKSAtIDMgKyBsZWZ0LFxuXHRcdFx0XHQtMyArIHRvcFxuXHRcdFx0KTtcblx0XHR9LFxuXHRcdHRyKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcblx0XHRcdHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIGJveC53aWR0aCAtIDQgKyBsZWZ0LCAtMyArIHRvcCk7XG5cdFx0fSxcblx0XHRybShoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG5cdFx0XHRwb3NpdGlvbkVsZW1lbnQoXG5cdFx0XHRcdGhhbmRsZSxcblx0XHRcdFx0Ym94LndpZHRoIC0gNCArIGxlZnQsXG5cdFx0XHRcdE1hdGgucm91bmQoYm94LmhlaWdodCAvIDIpIC0gMyArIHRvcFxuXHRcdFx0KTtcblx0XHR9LFxuXHR9O1xuXG5cdGNvbnN0IElNQUdFX1NOQVBfVE9fU0laRSA9IDc7XG5cblx0Y29uc3QgaXNGaXJlZm94ID0gJ01vekFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcblxuXHRjb25zdCBpc1dlYktpdCA9ICdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5cblx0Y29uc3QgZW5hYmxlUGx1Z2luID0gaXNXZWJLaXQgfHwgaXNGaXJlZm94O1xuXG5cdGlmIChlbmFibGVQbHVnaW4pIHtcblx0XHQvLyBDU1MgaXMgYWRkZWQgaW4gYSBjb21wcmVzc2VkIGZvcm1cblxuXHRcdENLRURJVE9SLmFkZENzcyhcblx0XHRcdCdpbWc6OnNlbGVjdGlvbntjb2xvcjpyZ2JhKDAsMCwwLDApfWltZy5ja2ltZ3JzentvdXRsaW5lOjFweCBkYXNoZWQgIzAwMH0jY2tpbWdyc3p7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MDtoZWlnaHQ6MDtjdXJzb3I6ZGVmYXVsdDt6LWluZGV4OjEwMDAxfSNja2ltZ3JzeiBzcGFue2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MDtoZWlnaHQ6MDtiYWNrZ3JvdW5kLXNpemU6MTAwJSAxMDAlO29wYWNpdHk6LjY1O291dGxpbmU6MXB4IGRhc2hlZCAjMDAwfSNja2ltZ3JzeiBpe3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7d2lkdGg6NXB4O2hlaWdodDo1cHg7YmFja2dyb3VuZDojZmZmO2JvcmRlcjoxcHggc29saWQgIzAwMH0jY2tpbWdyc3ogaS5hY3RpdmUsI2NraW1ncnN6IGk6aG92ZXJ7YmFja2dyb3VuZDojMDAwfSNja2ltZ3JzeiBpLmJyLCNja2ltZ3JzeiBpLnRse2N1cnNvcjpud3NlLXJlc2l6ZX0jY2tpbWdyc3ogaS5ibSwjY2tpbWdyc3ogaS50bXtjdXJzb3I6bnMtcmVzaXplfSNja2ltZ3JzeiBpLmJsLCNja2ltZ3JzeiBpLnRye2N1cnNvcjpuZXN3LXJlc2l6ZX0jY2tpbWdyc3ogaS5sbSwjY2tpbWdyc3ogaS5ybXtjdXJzb3I6ZXctcmVzaXplfWJvZHkuZHJhZ2dpbmctYnIsYm9keS5kcmFnZ2luZy1iciAqLGJvZHkuZHJhZ2dpbmctdGwsYm9keS5kcmFnZ2luZy10bCAqe2N1cnNvcjpud3NlLXJlc2l6ZSFpbXBvcnRhbnR9Ym9keS5kcmFnZ2luZy1ibSxib2R5LmRyYWdnaW5nLWJtICosYm9keS5kcmFnZ2luZy10bSxib2R5LmRyYWdnaW5nLXRtICp7Y3Vyc29yOm5zLXJlc2l6ZSFpbXBvcnRhbnR9Ym9keS5kcmFnZ2luZy1ibCxib2R5LmRyYWdnaW5nLWJsICosYm9keS5kcmFnZ2luZy10cixib2R5LmRyYWdnaW5nLXRyICp7Y3Vyc29yOm5lc3ctcmVzaXplIWltcG9ydGFudH1ib2R5LmRyYWdnaW5nLWxtLGJvZHkuZHJhZ2dpbmctbG0gKixib2R5LmRyYWdnaW5nLXJtLGJvZHkuZHJhZ2dpbmctcm0gKntjdXJzb3I6ZXctcmVzaXplIWltcG9ydGFudH0nXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luXG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfZHJhZ3Jlc2l6ZScsIHtcblx0XHRvbkxvYWQoKSB7XG5cdFx0XHRpZiAoIWVuYWJsZVBsdWdpbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRpbml0KGVkaXRvcikge1xuXHRcdFx0aWYgKCFlbmFibGVQbHVnaW4pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRlZGl0b3Iub25jZSgnY29udGVudERvbScsIF9ldnQgPT4ge1xuXHRcdFx0XHRpbml0KGVkaXRvcik7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHR9KTtcblxuXHRmdW5jdGlvbiBpbml0KGVkaXRvcikge1xuXHRcdGNvbnN0IHdpbmRvdyA9IGVkaXRvci53aW5kb3cuJDtcblxuXHRcdGNvbnN0IGRvY3VtZW50ID0gZWRpdG9yLmRvY3VtZW50LiQ7XG5cblx0XHRpZiAoaXNGaXJlZm94KSB7XG5cdFx0XHQvLyBEaXNhYmxlIHRoZSBuYXRpdmUgaW1hZ2UgcmVzaXppbmdcblxuXHRcdFx0ZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2VuYWJsZU9iamVjdFJlc2l6aW5nJywgZmFsc2UsIGZhbHNlKTtcblx0XHR9XG5cblx0XHRjb25zdCBzbmFwVG9TaXplID1cblx0XHRcdHR5cGVvZiBJTUFHRV9TTkFQX1RPX1NJWkUgPT09ICd1bmRlZmluZWQnXG5cdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHQ6IElNQUdFX1NOQVBfVE9fU0laRTtcblxuXHRcdGVkaXRvci5jb25maWcuaW1hZ2VTY2FsZVJlc2l6ZSA9XG5cdFx0XHRlZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemUgfHwgJ2JvdGgnO1xuXG5cdFx0Y29uc3QgcmVzaXplciA9IG5ldyBSZXNpemVyKGVkaXRvciwge1xuXHRcdFx0aW1hZ2VTY2FsZVJlc2l6ZTogZWRpdG9yLmNvbmZpZy5pbWFnZVNjYWxlUmVzaXplLFxuXHRcdFx0c25hcFRvU2l6ZSxcblx0XHR9KTtcblxuXHRcdGNvbnN0IG1vdXNlRG93bkxpc3RlbmVyID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKHJlc2l6ZXIuaXNIYW5kbGUoZS50YXJnZXQpKSB7XG5cdFx0XHRcdHJlc2l6ZXIuaW5pdERyYWcoZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bkxpc3RlbmVyLCBmYWxzZSk7XG5cblx0XHRmdW5jdGlvbiBzZWxlY3Rpb25DaGFuZ2UoKSB7XG5cdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRcdGlmICghc2VsZWN0aW9uKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYW4gZWxlbWVudCBpcyBzZWxlY3RlZCBhbmQgdGhhdCBlbGVtZW50IGlzIGFuIElNR1xuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHNlbGVjdGlvbi5nZXRUeXBlKCkgIT09IENLRURJVE9SLlNFTEVDVElPTl9OT05FICYmXG5cdFx0XHRcdHNlbGVjdGlvbi5nZXRTdGFydEVsZW1lbnQoKS5pcygnaW1nJylcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBBbmQgd2UncmUgbm90IHJpZ2h0IG9yIG1pZGRsZSBjbGlja2luZyBvbiB0aGUgaW1hZ2VcblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0IXdpbmRvdy5ldmVudCB8fFxuXHRcdFx0XHRcdCF3aW5kb3cuZXZlbnQuYnV0dG9uIHx8XG5cdFx0XHRcdFx0d2luZG93LmV2ZW50LmJ1dHRvbiA9PT0gMFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXNpemVyLnNob3coc2VsZWN0aW9uLmdldFN0YXJ0RWxlbWVudCgpLiQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXNpemVyLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRlZGl0b3Iub24oJ3NlbGVjdGlvbkNoYW5nZScsIHNlbGVjdGlvbkNoYW5nZSk7XG5cblx0XHRlZGl0b3Iub24oJ2dldERhdGEnLCBlID0+IHtcblx0XHRcdGxldCBodG1sID0gZS5kYXRhLmRhdGFWYWx1ZSB8fCAnJztcblx0XHRcdGh0bWwgPSBodG1sLnJlcGxhY2UoLzxkaXYgaWQ9XCJja2ltZ3JzelwiKFtcXHNcXFNdKj8pPFxcL2Rpdj4vaSwgJycpO1xuXHRcdFx0aHRtbCA9IGh0bWwucmVwbGFjZSgvXFxiKGNraW1ncnN6KVxcYi9nLCAnJyk7XG5cdFx0XHRlLmRhdGEuZGF0YVZhbHVlID0gaHRtbDtcblx0XHR9KTtcblxuXHRcdGVkaXRvci5vbignYmVmb3JlVW5kb0ltYWdlJywgKCkgPT4ge1xuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBoYW5kbGVzIGJlZm9yZSB1bmRvIGltYWdlcyBhcmUgc2F2ZWRcblxuXHRcdFx0cmVzaXplci5oaWRlKCk7XG5cdFx0fSk7XG5cblx0XHRlZGl0b3Iub24oJ2FmdGVyVW5kb0ltYWdlJywgKCkgPT4ge1xuXHRcdFx0Ly8gUmVzdG9yZSB0aGUgaGFuZGxlcyBhZnRlciB1bmRvIGltYWdlcyBhcmUgc2F2ZWRcblxuXHRcdFx0c2VsZWN0aW9uQ2hhbmdlKCk7XG5cdFx0fSk7XG5cblx0XHRlZGl0b3Iub24oJ2JsdXInLCAoKSA9PiB7XG5cdFx0XHQvLyBSZW1vdmUgdGhlIGhhbmRsZXMgd2hlbiBlZGl0b3IgbG9zZXMgZm9jdXNcblxuXHRcdFx0cmVzaXplci5oaWRlKCk7XG5cdFx0fSk7XG5cblx0XHRlZGl0b3Iub24oJ2JlZm9yZU1vZGVVbmxvYWQnLCBmdW5jdGlvbiBzZWxmKCkge1xuXHRcdFx0ZWRpdG9yLnJlbW92ZUxpc3RlbmVyKCdiZWZvcmVNb2RlVW5sb2FkJywgc2VsZik7XG5cdFx0XHRyZXNpemVyLmhpZGUoKTtcblx0XHR9KTtcblxuXHRcdGVkaXRvci5vbignZGVzdHJveScsICgpID0+IHtcblx0XHRcdGNvbnN0IHJlc2l6ZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2tpbWdyc3onKTtcblxuXHRcdFx0aWYgKHJlc2l6ZUVsZW1lbnQpIHtcblx0XHRcdFx0cmVzaXplRWxlbWVudC5yZW1vdmUoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzRmlyZWZveCkge1xuXHRcdFx0XHRkb2N1bWVudC5leGVjQ29tbWFuZCgnZW5hYmxlT2JqZWN0UmVzaXppbmcnLCBmYWxzZSwgdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bkxpc3RlbmVyKTtcblx0XHR9KTtcblxuXHRcdC8vIFVwZGF0ZSB0aGUgc2VsZWN0aW9uIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93IGlzIHJlc2l6ZWRcblxuXHRcdGxldCByZXNpemVUaW1lb3V0O1xuXHRcdGVkaXRvci53aW5kb3cub24oJ3Jlc2l6ZScsICgpID0+IHtcblx0XHRcdC8vIENhbmNlbCBhbnkgcmVzaXplIHdhaXRpbmcgdG8gaGFwcGVuXG5cblx0XHRcdGNsZWFyVGltZW91dChyZXNpemVUaW1lb3V0KTtcblxuXHRcdFx0Ly8gRGVsYXkgcmVzaXplIHRvIFwiZGVib3VuY2VcIlxuXG5cdFx0XHRyZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dChzZWxlY3Rpb25DaGFuZ2UsIDUwKTtcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIFJlc2l6ZXIoZWRpdG9yLCBjZmcpIHtcblx0XHR0aGlzLmVkaXRvciA9IGVkaXRvcjtcblx0XHR0aGlzLndpbmRvdyA9IGVkaXRvci53aW5kb3cuJDtcblx0XHR0aGlzLmRvY3VtZW50ID0gZWRpdG9yLmRvY3VtZW50LiQ7XG5cdFx0dGhpcy5jZmcgPSBjZmcgfHwge307XG5cdFx0dGhpcy5pbml0KCk7XG5cdH1cblxuXHRSZXNpemVyLnByb3RvdHlwZSA9IHtcblx0XHRpbml0KCkge1xuXHRcdFx0Y29uc3QgaW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0XHRjb25zdCBjb250YWluZXIgPSAodGhpcy5jb250YWluZXIgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdCdkaXYnXG5cdFx0XHQpKTtcblxuXHRcdFx0Y29udGFpbmVyLmlkID0gJ2NraW1ncnN6Jztcblx0XHRcdHRoaXMucHJldmlldyA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucHJldmlldyk7XG5cblx0XHRcdGNvbnN0IGhhbmRsZXMgPSAodGhpcy5oYW5kbGVzID0ge30pO1xuXG5cdFx0XHRJTUFHRV9IQU5ETEVTW3RoaXMuY2ZnLmltYWdlU2NhbGVSZXNpemVdLmZvckVhY2goaGFuZGxlTmFtZSA9PiB7XG5cdFx0XHRcdGhhbmRsZXNbaGFuZGxlTmFtZV0gPSBpbnN0YW5jZS5oYW5kbGVzW1xuXHRcdFx0XHRcdGhhbmRsZU5hbWVcblx0XHRcdFx0XSA9IGluc3RhbmNlLmNyZWF0ZUhhbmRsZShoYW5kbGVOYW1lKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKGNvbnN0IG4gaW4gaGFuZGxlcykge1xuXHRcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhhbmRsZXMsIG4pKSB7XG5cdFx0XHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGhhbmRsZXNbbl0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjcmVhdGVIYW5kbGUobmFtZSkge1xuXHRcdFx0Y29uc3QgZWwgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKTtcblx0XHRcdGVsLmNsYXNzTGlzdC5hZGQobmFtZSk7XG5cblx0XHRcdHJldHVybiBlbDtcblx0XHR9LFxuXHRcdGlzSGFuZGxlKGVsKSB7XG5cdFx0XHRjb25zdCBoYW5kbGVzID0gdGhpcy5oYW5kbGVzO1xuXHRcdFx0Zm9yIChjb25zdCBuIGluIGhhbmRsZXMpIHtcblx0XHRcdFx0aWYgKGhhbmRsZXNbbl0gPT09IGVsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0c2hvdyhlbCkge1xuXHRcdFx0bGV0IHVpTm9kZSA9IHRoaXMuZWRpdG9yLmNvbmZpZy51aU5vZGU7XG5cblx0XHRcdGNvbnN0IHNjcm9sbFRvcCA9IHVpTm9kZSA/IHVpTm9kZS5zY3JvbGxUb3AgOiAwO1xuXG5cdFx0XHR0aGlzLmVsID0gZWw7XG5cdFx0XHRpZiAodGhpcy5jZmcuc25hcFRvU2l6ZSkge1xuXHRcdFx0XHR0aGlzLm90aGVySW1hZ2VzID0gdG9BcnJheShcblx0XHRcdFx0XHR0aGlzLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHR0aGlzLm90aGVySW1hZ2VzLnNwbGljZSh0aGlzLm90aGVySW1hZ2VzLmluZGV4T2YoZWwpLCAxKTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IGJveCA9ICh0aGlzLmJveCA9IGdldEJvdW5kaW5nQm94KHRoaXMud2luZG93LCBlbCkpO1xuXHRcdFx0cG9zaXRpb25FbGVtZW50KHRoaXMuY29udGFpbmVyLCBib3gubGVmdCwgYm94LnRvcCArIHNjcm9sbFRvcCk7XG5cblx0XHRcdHVpTm9kZSA9IHVpTm9kZSB8fCBkb2N1bWVudC5ib2R5O1xuXG5cdFx0XHR1aU5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xuXG5cdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2NraW1ncnN6Jyk7XG5cdFx0XHR0aGlzLnNob3dIYW5kbGVzKCk7XG5cdFx0fSxcblx0XHRoaWRlKCkge1xuXHRcdFx0Ly8gUmVtb3ZlIGNsYXNzIGZyb20gYWxsIGltZy5ja2ltZ3JzelxuXG5cdFx0XHRjb25zdCBlbGVtZW50cyA9IHRoaXMuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2tpbWdyc3onKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0ZWxlbWVudHNbaV0uY2xhc3NMaXN0LnJlbW92ZSgnY2tpbWdyc3onKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGlkZUhhbmRsZXMoKTtcblx0XHRcdGlmICh0aGlzLmNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdHRoaXMuY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aW5pdERyYWcoZSkge1xuXHRcdFx0aWYgKGUuYnV0dG9uICE9PSAwKSB7XG5cdFx0XHRcdC8vIHJpZ2h0LWNsaWNrIG9yIG1pZGRsZS1jbGlja1xuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHJlc2l6ZXIgPSB0aGlzO1xuXHRcdFx0Y29uc3QgZHJhZyA9IG5ldyBEcmFnRXZlbnQodGhpcy53aW5kb3csIHRoaXMuZG9jdW1lbnQpO1xuXHRcdFx0ZHJhZy5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlc2l6ZXIuc2hvd1ByZXZpZXcoKTtcblx0XHRcdFx0cmVzaXplci5pc0RyYWdnaW5nID0gdHJ1ZTtcblx0XHRcdFx0cmVzaXplci5lZGl0b3IuZ2V0U2VsZWN0aW9uKCkubG9jaygpO1xuXHRcdFx0fTtcblx0XHRcdGRyYWcub25EcmFnID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlc2l6ZXIuY2FsY3VsYXRlU2l6ZSh0aGlzKTtcblx0XHRcdFx0cmVzaXplci51cGRhdGVQcmV2aWV3KCk7XG5cdFx0XHRcdGNvbnN0IGJveCA9IHJlc2l6ZXIucHJldmlld0JveDtcblx0XHRcdFx0cmVzaXplci51cGRhdGVIYW5kbGVzKGJveCwgYm94LmxlZnQsIGJveC50b3ApO1xuXHRcdFx0fTtcblx0XHRcdGRyYWcub25SZWxlYXNlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlc2l6ZXIuaXNEcmFnZ2luZyA9IGZhbHNlO1xuXHRcdFx0XHRyZXNpemVyLmhpZGVQcmV2aWV3KCk7XG5cdFx0XHRcdHJlc2l6ZXIuaGlkZSgpO1xuXHRcdFx0XHRyZXNpemVyLmVkaXRvci5nZXRTZWxlY3Rpb24oKS51bmxvY2soKTtcblxuXHRcdFx0XHQvLyBTYXZlIGFuIHVuZG8gc25hcHNob3QgYmVmb3JlIHRoZSBpbWFnZSBpcyBwZXJtYW5lbnRseSBjaGFuZ2VkXG5cblx0XHRcdFx0cmVzaXplci5lZGl0b3IuZmlyZSgnc2F2ZVNuYXBzaG90Jyk7XG5cdFx0XHR9O1xuXHRcdFx0ZHJhZy5vbkNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlc2l6ZXIucmVzaXplQ29tcGxldGUoKTtcblxuXHRcdFx0XHQvLyBTYXZlIGFub3RoZXIgc25hcHNob3QgYWZ0ZXIgdGhlIGltYWdlIGlzIGNoYW5nZWRcblxuXHRcdFx0XHRyZXNpemVyLmVkaXRvci5maXJlKCdzYXZlU25hcHNob3QnKTtcblx0XHRcdH07XG5cdFx0XHRkcmFnLnN0YXJ0KGUpO1xuXHRcdH0sXG5cdFx0dXBkYXRlSGFuZGxlcyhib3gsIGxlZnQsIHRvcCkge1xuXHRcdFx0bGVmdCA9IGxlZnQgfHwgMDtcblx0XHRcdHRvcCA9IHRvcCB8fCAwO1xuXHRcdFx0Y29uc3QgaGFuZGxlcyA9IHRoaXMuaGFuZGxlcztcblxuXHRcdFx0Zm9yIChjb25zdCBoYW5kbGUgaW4gaGFuZGxlcykge1xuXHRcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhhbmRsZXMsIGhhbmRsZSkpIHtcblx0XHRcdFx0XHRQT1NJVElPTl9FTEVNRU5UX0ZOW2hhbmRsZV0oXG5cdFx0XHRcdFx0XHRoYW5kbGVzW2hhbmRsZV0sXG5cdFx0XHRcdFx0XHRsZWZ0LFxuXHRcdFx0XHRcdFx0dG9wLFxuXHRcdFx0XHRcdFx0Ym94XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hvd0hhbmRsZXMoKSB7XG5cdFx0XHRjb25zdCBoYW5kbGVzID0gdGhpcy5oYW5kbGVzO1xuXHRcdFx0dGhpcy51cGRhdGVIYW5kbGVzKHRoaXMuYm94KTtcblx0XHRcdGZvciAoY29uc3QgbiBpbiBoYW5kbGVzKSB7XG5cdFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGFuZGxlcywgbikpIHtcblx0XHRcdFx0XHRoYW5kbGVzW25dLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRoaWRlSGFuZGxlcygpIHtcblx0XHRcdGNvbnN0IGhhbmRsZXMgPSB0aGlzLmhhbmRsZXM7XG5cdFx0XHRmb3IgKGNvbnN0IG4gaW4gaGFuZGxlcykge1xuXHRcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhhbmRsZXMsIG4pKSB7XG5cdFx0XHRcdFx0aGFuZGxlc1tuXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaG93UHJldmlldygpIHtcblx0XHRcdHRoaXMucHJldmlldy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKFwiJyArIHRoaXMuZWwuc3JjICsgJ1wiKSc7XG5cdFx0XHR0aGlzLmNhbGN1bGF0ZVNpemUoKTtcblx0XHRcdHRoaXMudXBkYXRlUHJldmlldygpO1xuXHRcdFx0dGhpcy5wcmV2aWV3LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRcdH0sXG5cdFx0dXBkYXRlUHJldmlldygpIHtcblx0XHRcdGNvbnN0IGJveCA9IHRoaXMucHJldmlld0JveDtcblx0XHRcdHBvc2l0aW9uRWxlbWVudCh0aGlzLnByZXZpZXcsIGJveC5sZWZ0LCBib3gudG9wKTtcblx0XHRcdHRoaXMucHJldmlldy5zdHlsZS53aWR0aCA9IHRoaXMucHJldmlld0JveC53aWR0aCArICdweCc7XG5cdFx0XHR0aGlzLnByZXZpZXcuc3R5bGUuaGVpZ2h0ID0gdGhpcy5wcmV2aWV3Qm94LmhlaWdodCArICdweCc7XG5cdFx0fSxcblx0XHRoaWRlUHJldmlldygpIHtcblx0XHRcdGNvbnN0IGJveCA9IGdldEJvdW5kaW5nQm94KHRoaXMud2luZG93LCB0aGlzLnByZXZpZXcpO1xuXHRcdFx0dGhpcy5yZXN1bHQgPSB7XG5cdFx0XHRcdHdpZHRoOiBib3gud2lkdGgsXG5cdFx0XHRcdGhlaWdodDogYm94LmhlaWdodCxcblx0XHRcdH07XG5cdFx0XHR0aGlzLnByZXZpZXcuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHR9LFxuXHRcdGNhbGN1bGF0ZVNpemUoZGF0YSkge1xuXHRcdFx0Y29uc3QgYm94ID0gKHRoaXMucHJldmlld0JveCA9IHtcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHR3aWR0aDogdGhpcy5ib3gud2lkdGgsXG5cdFx0XHRcdGhlaWdodDogdGhpcy5ib3guaGVpZ2h0LFxuXHRcdFx0fSk7XG5cblx0XHRcdGlmICghZGF0YSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGF0dHIgPSBkYXRhLnRhcmdldC5jbGFzc05hbWU7XG5cblx0XHRcdGlmICh+YXR0ci5pbmRleE9mKCdyJykpIHtcblx0XHRcdFx0Ym94LndpZHRoID0gTWF0aC5tYXgoMzIsIHRoaXMuYm94LndpZHRoICsgZGF0YS5kZWx0YS54KTtcblx0XHRcdH1cblx0XHRcdGlmICh+YXR0ci5pbmRleE9mKCdiJykpIHtcblx0XHRcdFx0Ym94LmhlaWdodCA9IE1hdGgubWF4KDMyLCB0aGlzLmJveC5oZWlnaHQgKyBkYXRhLmRlbHRhLnkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKH5hdHRyLmluZGV4T2YoJ2wnKSkge1xuXHRcdFx0XHRib3gud2lkdGggPSBNYXRoLm1heCgzMiwgdGhpcy5ib3gud2lkdGggLSBkYXRhLmRlbHRhLngpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKH5hdHRyLmluZGV4T2YoJ3QnKSkge1xuXHRcdFx0XHRib3guaGVpZ2h0ID0gTWF0aC5tYXgoMzIsIHRoaXMuYm94LmhlaWdodCAtIGRhdGEuZGVsdGEueSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIGRyYWdnaW5nIGNvcm5lciwgZW5mb3JjZSBhc3BlY3QgcmF0aW8gKHVubGVzcyBzaGlmdCBrZXkgaXMgYmVpbmcgaGVsZClcblxuXHRcdFx0aWYgKGF0dHIuaW5kZXhPZignbScpIDwgMCAmJiAhZGF0YS5rZXlzLnNoaWZ0KSB7XG5cdFx0XHRcdGNvbnN0IHJhdGlvID0gdGhpcy5ib3gud2lkdGggLyB0aGlzLmJveC5oZWlnaHQ7XG5cdFx0XHRcdGlmIChib3gud2lkdGggLyBib3guaGVpZ2h0ID4gcmF0aW8pIHtcblx0XHRcdFx0XHRib3guaGVpZ2h0ID0gTWF0aC5yb3VuZChib3gud2lkdGggLyByYXRpbyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ym94LndpZHRoID0gTWF0aC5yb3VuZChib3guaGVpZ2h0ICogcmF0aW8pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNuYXBUb1NpemUgPSB0aGlzLmNmZy5zbmFwVG9TaXplO1xuXG5cdFx0XHRpZiAoc25hcFRvU2l6ZSkge1xuXHRcdFx0XHRjb25zdCBvdGhlcnMgPSB0aGlzLm90aGVySW1hZ2VzO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG90aGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IG90aGVyID0gZ2V0Qm91bmRpbmdCb3godGhpcy53aW5kb3csIG90aGVyc1tpXSk7XG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0TWF0aC5hYnMoYm94LndpZHRoIC0gb3RoZXIud2lkdGgpIDw9IHNuYXBUb1NpemUgJiZcblx0XHRcdFx0XHRcdE1hdGguYWJzKGJveC5oZWlnaHQgLSBvdGhlci5oZWlnaHQpIDw9IHNuYXBUb1NpemVcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdGJveC53aWR0aCA9IG90aGVyLndpZHRoO1xuXHRcdFx0XHRcdFx0Ym94LmhlaWdodCA9IG90aGVyLmhlaWdodDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWNhbGN1bGF0ZSBsZWZ0IG9yIHRvcCBwb3NpdGlvblxuXG5cdFx0XHRpZiAofmF0dHIuaW5kZXhPZignbCcpKSB7XG5cdFx0XHRcdGJveC5sZWZ0ID0gdGhpcy5ib3gud2lkdGggLSBib3gud2lkdGg7XG5cdFx0XHR9XG5cdFx0XHRpZiAofmF0dHIuaW5kZXhPZigndCcpKSB7XG5cdFx0XHRcdGJveC50b3AgPSB0aGlzLmJveC5oZWlnaHQgLSBib3guaGVpZ2h0O1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cmVzaXplQ29tcGxldGUoKSB7XG5cdFx0XHRyZXNpemVFbGVtZW50LmNhbGwoXG5cdFx0XHRcdHRoaXMsXG5cdFx0XHRcdHRoaXMuZWwsXG5cdFx0XHRcdHRoaXMucmVzdWx0LndpZHRoLFxuXHRcdFx0XHR0aGlzLnJlc3VsdC5oZWlnaHRcblx0XHRcdCk7XG5cdFx0fSxcblx0fTtcblxuXHRmdW5jdGlvbiBEcmFnRXZlbnQod2luZG93LCBkb2N1bWVudCkge1xuXHRcdHRoaXMud2luZG93ID0gd2luZG93O1xuXHRcdHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcblx0XHR0aGlzLmV2ZW50cyA9IHtcblx0XHRcdG1vdXNlbW92ZTogYmluZCh0aGlzLm1vdXNlbW92ZSwgdGhpcyksXG5cdFx0XHRrZXlkb3duOiBiaW5kKHRoaXMua2V5ZG93biwgdGhpcyksXG5cdFx0XHRtb3VzZXVwOiBiaW5kKHRoaXMubW91c2V1cCwgdGhpcyksXG5cdFx0fTtcblx0fVxuXG5cdERyYWdFdmVudC5wcm90b3R5cGUgPSB7XG5cdFx0c3RhcnQoZSkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdHRoaXMudGFyZ2V0ID0gZS50YXJnZXQ7XG5cdFx0XHR0aGlzLmF0dHIgPSBlLnRhcmdldC5jbGFzc05hbWU7XG5cdFx0XHR0aGlzLnN0YXJ0UG9zID0ge1xuXHRcdFx0XHR4OiBlLmNsaWVudFgsXG5cdFx0XHRcdHk6IGUuY2xpZW50WSxcblx0XHRcdH07XG5cdFx0XHR0aGlzLnVwZGF0ZShlKTtcblx0XHRcdGNvbnN0IGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuXHRcdFx0dGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuXHRcdFx0XHQnbW91c2Vtb3ZlJyxcblx0XHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSxcblx0XHRcdFx0ZmFsc2Vcblx0XHRcdCk7XG5cdFx0XHR0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBldmVudHMua2V5ZG93biwgZmFsc2UpO1xuXHRcdFx0dGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZXZlbnRzLm1vdXNldXAsIGZhbHNlKTtcblx0XHRcdHRoaXMuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdkcmFnZ2luZy0nICsgdGhpcy5hdHRyKTtcblx0XHRcdGlmICh0aGlzLm9uU3RhcnQpIHtcblx0XHRcdFx0dGhpcy5vblN0YXJ0KCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR1cGRhdGUoZSkge1xuXHRcdFx0dGhpcy5jdXJyZW50UG9zID0ge1xuXHRcdFx0XHR4OiBlLmNsaWVudFgsXG5cdFx0XHRcdHk6IGUuY2xpZW50WSxcblx0XHRcdH07XG5cdFx0XHR0aGlzLmRlbHRhID0ge1xuXHRcdFx0XHR4OiBlLmNsaWVudFggLSB0aGlzLnN0YXJ0UG9zLngsXG5cdFx0XHRcdHk6IGUuY2xpZW50WSAtIHRoaXMuc3RhcnRQb3MueSxcblx0XHRcdH07XG5cdFx0XHR0aGlzLmtleXMgPSB7XG5cdFx0XHRcdHNoaWZ0OiBlLnNoaWZ0S2V5LFxuXHRcdFx0XHRjdHJsOiBlLmN0cmxLZXksXG5cdFx0XHRcdGFsdDogZS5hbHRLZXksXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0bW91c2Vtb3ZlKGUpIHtcblx0XHRcdHRoaXMudXBkYXRlKGUpO1xuXHRcdFx0aWYgKHRoaXMub25EcmFnKSB7XG5cdFx0XHRcdHRoaXMub25EcmFnKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZS53aGljaCA9PT0gMCkge1xuXHRcdFx0XHQvLyBtb3VzZSBidXR0b24gcmVsZWFzZWQgb3V0c2lkZSB3aW5kb3c7IG1vdXNldXAgd2Fzbid0IGZpcmVkIChDaHJvbWUpXG5cblx0XHRcdFx0dGhpcy5tb3VzZXVwKGUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0a2V5ZG93bihlKSB7XG5cdFx0XHQvLyBlc2NhcGUga2V5IGNhbmNlbHMgZHJhZ2dpbmdcblxuXHRcdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdFx0dGhpcy5yZWxlYXNlKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRtb3VzZXVwKGUpIHtcblx0XHRcdHRoaXMudXBkYXRlKGUpO1xuXHRcdFx0dGhpcy5yZWxlYXNlKCk7XG5cdFx0XHRpZiAodGhpcy5vbkNvbXBsZXRlKSB7XG5cdFx0XHRcdHRoaXMub25Db21wbGV0ZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cmVsZWFzZSgpIHtcblx0XHRcdHRoaXMuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdkcmFnZ2luZy0nICsgdGhpcy5hdHRyKTtcblx0XHRcdGNvbnN0IGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuXHRcdFx0dGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuXHRcdFx0XHQnbW91c2Vtb3ZlJyxcblx0XHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSxcblx0XHRcdFx0ZmFsc2Vcblx0XHRcdCk7XG5cdFx0XHR0aGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBldmVudHMua2V5ZG93biwgZmFsc2UpO1xuXHRcdFx0dGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZXZlbnRzLm1vdXNldXAsIGZhbHNlKTtcblx0XHRcdGlmICh0aGlzLm9uUmVsZWFzZSkge1xuXHRcdFx0XHR0aGlzLm9uUmVsZWFzZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdH07XG5cblx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xuXG5cdGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG5cdFx0Y29uc3QgbGVuID0gb2JqLmxlbmd0aDtcblxuXHRcdGNvbnN0IGFyciA9IG5ldyBBcnJheShsZW4pO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGFycltpXSA9IG9ialtpXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyO1xuXHR9XG5cblx0ZnVuY3Rpb24gYmluZChmbiwgY3R4KSB7XG5cdFx0aWYgKGZuLmJpbmQpIHtcblx0XHRcdHJldHVybiBmbi5iaW5kKGN0eCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcblx0XHRcdGZuLmFwcGx5KGN0eCwgYXJncyk7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBvc2l0aW9uRWxlbWVudChlbCwgbGVmdCwgdG9wKSB7XG5cdFx0ZWwuc3R5bGUubGVmdCA9IFN0cmluZyhsZWZ0KSArICdweCc7XG5cdFx0ZWwuc3R5bGUudG9wID0gU3RyaW5nKHRvcCkgKyAncHgnO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVzaXplRWxlbWVudChlbCwgd2lkdGgsIGhlaWdodCkge1xuXHRcdGNvbnN0IGltYWdlU2NhbGVSZXNpemUgPSB0aGlzLmVkaXRvci5jb25maWcuaW1hZ2VTY2FsZVJlc2l6ZTtcblx0XHRpZiAoaW1hZ2VTY2FsZVJlc2l6ZSA9PT0gJ2JvdGgnKSB7XG5cdFx0XHRlbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgU3RyaW5nKHdpZHRoKSk7XG5cdFx0XHRlbC5zdHlsZS53aWR0aCA9IFN0cmluZyh3aWR0aCkgKyAncHgnO1xuXHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBTdHJpbmcoaGVpZ2h0KSk7XG5cdFx0XHRlbC5zdHlsZS5oZWlnaHQgPSBTdHJpbmcoaGVpZ2h0KSArICdweCc7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdGltYWdlU2NhbGVSZXNpemUgPT09ICd3aWR0aCcgfHxcblx0XHRcdGltYWdlU2NhbGVSZXNpemUgPT09ICdzY2FsZSdcblx0XHQpIHtcblx0XHRcdGVsLnJlbW92ZUF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG5cdFx0XHRlbC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG5cdFx0XHRlbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgU3RyaW5nKHdpZHRoKSk7XG5cdFx0XHRlbC5zdHlsZS53aWR0aCA9IFN0cmluZyh3aWR0aCkgKyAncHgnO1xuXHRcdH0gZWxzZSBpZiAoaW1hZ2VTY2FsZVJlc2l6ZSA9PT0gJ2hlaWdodCcpIHtcblx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgU3RyaW5nKGhlaWdodCkpO1xuXHRcdFx0ZWwuc3R5bGUuaGVpZ2h0ID0gU3RyaW5nKGhlaWdodCkgKyAncHgnO1xuXHRcdFx0ZWwucmVtb3ZlQXR0cmlidXRlKCd3aWR0aCcpO1xuXHRcdFx0ZWwuc3R5bGUud2lkdGggPSAnYXV0byc7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3god2luZG93LCBlbCkge1xuXHRcdGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQsXG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxuXHRcdFx0d2lkdGg6IHJlY3Qud2lkdGgsXG5cdFx0XHRoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuXHRcdH07XG5cdH1cbn1cbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAxNywgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHA6Ly9ja2VkaXRvci5jb20vbGljZW5zZVxuICovXG5cbihmdW5jdGlvbigpIHtcblx0aWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9kcmFncmVzaXplX2llMTEnKSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IHRlbXBsYXRlID0gJzxpbWcgYWx0PVwiXCIgc3JjPVwiXCIgLz4nO1xuXG5cdGNvbnN0IHRlbXBsYXRlQmxvY2sgPSBuZXcgQ0tFRElUT1IudGVtcGxhdGUoXG5cdFx0JzxmaWd1cmUgY2xhc3M9XCJ7Y2FwdGlvbmVkQ2xhc3N9XCI+JyArXG5cdFx0XHR0ZW1wbGF0ZSArXG5cdFx0XHQnPGZpZ2NhcHRpb24+e2NhcHRpb25QbGFjZWhvbGRlcn08L2ZpZ2NhcHRpb24+JyArXG5cdFx0XHQnPC9maWd1cmU+J1xuXHQpO1xuXG5cdGNvbnN0IGFsaWdubWVudHNPYmogPSB7bGVmdDogMCwgY2VudGVyOiAxLCByaWdodDogMn07XG5cblx0Y29uc3QgcmVnZXhQZXJjZW50ID0gL15cXHMqKFxcZCslKVxccyokL2k7XG5cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX2RyYWdyZXNpemVfaWUxMScsIHtcblx0XHRyZXF1aXJlczogJ3dpZGdldCcsXG5cdFx0b25Mb2FkKCkge1xuXHRcdFx0Q0tFRElUT1IuYWRkQ3NzKFxuXHRcdFx0XHQnLmNrZV9pbWFnZV9ub2NhcHRpb257JyArXG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyB0byByZW1vdmUgdW53YW50ZWQgc3BhY2Ugc28gcmVzaXplXG5cdFx0XHRcdFx0Ly8gd3JhcHBlciBpcyBkaXNwbGF5ZWQgcHJvcGVydHkuXG5cblx0XHRcdFx0XHQnbGluZS1oZWlnaHQ6MCcgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Jy5ja2VfZWRpdGFibGUuY2tlX2ltYWdlX25lLCAuY2tlX2VkaXRhYmxlLmNrZV9pbWFnZV9uZSAqe2N1cnNvcjpuZS1yZXNpemUgIWltcG9ydGFudH0nICtcblx0XHRcdFx0XHQnLmNrZV9lZGl0YWJsZS5ja2VfaW1hZ2VfbncsIC5ja2VfZWRpdGFibGUuY2tlX2ltYWdlX253ICp7Y3Vyc29yOm53LXJlc2l6ZSAhaW1wb3J0YW50fScgK1xuXHRcdFx0XHRcdCcuY2tlX2VkaXRhYmxlLmNrZV9pbWFnZV9zdywgLmNrZV9lZGl0YWJsZS5ja2VfaW1hZ2Vfc3cgKntjdXJzb3I6c3ctcmVzaXplICFpbXBvcnRhbnR9JyArXG5cdFx0XHRcdFx0Jy5ja2VfZWRpdGFibGUuY2tlX2ltYWdlX3NlLCAuY2tlX2VkaXRhYmxlLmNrZV9pbWFnZV9zZSAqe2N1cnNvcjpzZS1yZXNpemUgIWltcG9ydGFudH0nICtcblx0XHRcdFx0XHQnLmNrZV9pbWFnZV9yZXNpemVyeycgK1xuXHRcdFx0XHRcdCdkaXNwbGF5Om5vbmU7JyArXG5cdFx0XHRcdFx0J3Bvc2l0aW9uOmFic29sdXRlOycgK1xuXHRcdFx0XHRcdCd3aWR0aDoxMHB4OycgK1xuXHRcdFx0XHRcdCdoZWlnaHQ6MTBweDsnICtcblx0XHRcdFx0XHQnYmFja2dyb3VuZDojMDAwOycgK1xuXHRcdFx0XHRcdCdvdXRsaW5lOjFweCBzb2xpZCAjZmZmOycgK1xuXHRcdFx0XHRcdC8vIFByZXZlbnQgZHJhZyBoYW5kbGVyIGZyb20gYmVpbmcgbWlzcGxhY2VkICgjMTEyMDcpLlxuXG5cdFx0XHRcdFx0J2xpbmUtaGVpZ2h0OjA7JyArXG5cdFx0XHRcdFx0J2N1cnNvcjpzZS1yZXNpemU7JyArXG5cdFx0XHRcdFx0J30nICtcblx0XHRcdFx0XHQnLmNrZV9pbWFnZV9yZXNpemVyX3dyYXBwZXJ7JyArXG5cdFx0XHRcdFx0J3Bvc2l0aW9uOnJlbGF0aXZlOycgK1xuXHRcdFx0XHRcdCdkaXNwbGF5OmlubGluZS1ibG9jazsnICtcblx0XHRcdFx0XHQnbGluZS1oZWlnaHQ6MDsnICtcblx0XHRcdFx0XHQnfScgK1xuXHRcdFx0XHRcdC8vIFRvcC1yaWdodCBjb3JuZXIgc3R5bGUgb2YgdGhlIHJlc2l6ZXIuXG5cblx0XHRcdFx0XHQnLmNrZV9pbWFnZV9yZXNpemVyLmNrZV9pbWFnZV9yZXNpemVyX25leycgK1xuXHRcdFx0XHRcdCdjdXJzb3I6bmUtcmVzaXplOycgK1xuXHRcdFx0XHRcdCdsZWZ0OmF1dG87JyArXG5cdFx0XHRcdFx0J3JpZ2h0Oi01cHg7JyArXG5cdFx0XHRcdFx0J3RvcDotNXB4OycgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Ly8gVG9wLWxlZnQgY29ybmVyIHN0eWxlIG9mIHRoZSByZXNpemVyLlxuXG5cdFx0XHRcdFx0Jy5ja2VfaW1hZ2VfcmVzaXplci5ja2VfaW1hZ2VfcmVzaXplcl9ud3snICtcblx0XHRcdFx0XHQnY3Vyc29yOm53LXJlc2l6ZTsnICtcblx0XHRcdFx0XHQnbGVmdDotNXB4OycgK1xuXHRcdFx0XHRcdCdyaWdodDphdXRvOycgK1xuXHRcdFx0XHRcdCd0b3A6LTVweDsnICtcblx0XHRcdFx0XHQnfScgK1xuXHRcdFx0XHRcdC8vIEJvdHRvbS1yaWdodCBjb3JuZXIgc3R5bGUgb2YgdGhlIHJlc2l6ZXIuXG5cblx0XHRcdFx0XHQnLmNrZV9pbWFnZV9yZXNpemVyLmNrZV9pbWFnZV9yZXNpemVyX3NleycgK1xuXHRcdFx0XHRcdCdib3R0b206LTVweDsnICtcblx0XHRcdFx0XHQnY3Vyc29yOnNlLXJlc2l6ZTsnICtcblx0XHRcdFx0XHQnbGVmdDphdXRvOycgK1xuXHRcdFx0XHRcdCdyaWdodDotNXB4OycgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Ly8gQm90dG9tLWxlZnQgY29ybmVyIHN0eWxlIG9mIHRoZSByZXNpemVyLlxuXG5cdFx0XHRcdFx0Jy5ja2VfaW1hZ2VfcmVzaXplci5ja2VfaW1hZ2VfcmVzaXplcl9zd3snICtcblx0XHRcdFx0XHQnYm90dG9tOi01cHg7JyArXG5cdFx0XHRcdFx0J2N1cnNvcjpzdy1yZXNpemU7JyArXG5cdFx0XHRcdFx0J2xlZnQ6LTVweDsnICtcblx0XHRcdFx0XHQncmlnaHQ6YXV0bzsnICtcblx0XHRcdFx0XHQnfScgK1xuXHRcdFx0XHRcdCcuY2tlX3dpZGdldF93cmFwcGVyOmhvdmVyIC5ja2VfaW1hZ2VfcmVzaXplciwnICtcblx0XHRcdFx0XHQnLmNrZV9pbWFnZV9yZXNpemluZz4uY2tlX2ltYWdlX3Jlc2l6ZXJ7JyArXG5cdFx0XHRcdFx0J2Rpc3BsYXk6YmxvY2snICtcblx0XHRcdFx0XHQnfScgK1xuXHRcdFx0XHRcdC8vIEV4cGFuZCB3aWRnZXQgd3JhcHBlciB3aGVuIGxpbmtlZCBpbmxpbmUgaW1hZ2UuXG5cblx0XHRcdFx0XHQnLmNrZV93aWRnZXRfd3JhcHBlcj5heycgK1xuXHRcdFx0XHRcdCdkaXNwbGF5OmlubGluZS1ibG9jaycgK1xuXHRcdFx0XHRcdCd9J1xuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0aW5pdChlZGl0b3IpIHtcblx0XHRcdC8vIEFkYXB0cyBjb25maWd1cmF0aW9uIGZyb20gb3JpZ2luYWwgaW1hZ2UgcGx1Z2luLiBTaG91bGQgYmUgcmVtb3ZlZFxuXHRcdFx0Ly8gd2hlbiB3ZSdsbCByZW5hbWUgYWVfZHJhZ3Jlc2l6ZV9pZTExIHRvIGltYWdlLlxuXG5cdFx0XHRjb25zdCBpbWFnZSA9IHdpZGdldERlZihlZGl0b3IpO1xuXG5cdFx0XHQvLyBSZWdpc3RlciB0aGUgd2lkZ2V0LlxuXG5cdFx0XHRlZGl0b3Iud2lkZ2V0cy5hZGQoJ2ltYWdlJywgaW1hZ2UpO1xuXG5cdFx0XHQvLyBBZGQgYSBsaXN0ZW5lciB0byBoYW5kbGUgc2VsZWN0aW9uIGNoYW5nZSBldmVudHMgYW5kIHByb3Blcmx5IGRldGVjdCBlZGl0b3Jcblx0XHRcdC8vIGludGVyYWN0aW9ucyBvbiB0aGUgd2lkZ2V0cyB3aXRob3V0IG1lc3Npbmcgd2l0aCB3aWRnZXQgbmF0aXZlIHNlbGVjdGlvblxuXG5cdFx0XHRlZGl0b3Iub24oJ3NlbGVjdGlvbkNoYW5nZScsIF9ldmVudCA9PiB7XG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdFx0XHRpZiAoc2VsZWN0aW9uKSB7XG5cdFx0XHRcdFx0Y29uc3QgZWxlbWVudCA9IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuXHRcdFx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRjb25zdCB3aWRnZXRFbGVtZW50ID0gZWxlbWVudC5maW5kT25lKCdpbWcnKTtcblxuXHRcdFx0XHRcdFx0aWYgKHdpZGdldEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcmVnaW9uID0gZWxlbWVudC5nZXRDbGllbnRSZWN0KCk7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3Qgc2Nyb2xsUG9zaXRpb24gPSBuZXcgQ0tFRElUT1IuZG9tLndpbmRvdyhcblx0XHRcdFx0XHRcdFx0XHR3aW5kb3dcblx0XHRcdFx0XHRcdFx0KS5nZXRTY3JvbGxQb3NpdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRyZWdpb24ubGVmdCAtPSBzY3JvbGxQb3NpdGlvbi54O1xuXHRcdFx0XHRcdFx0XHRyZWdpb24udG9wICs9IHNjcm9sbFBvc2l0aW9uLnk7XG5cblx0XHRcdFx0XHRcdFx0cmVnaW9uLmRpcmVjdGlvbiA9IENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QO1xuXG5cdFx0XHRcdFx0XHRcdGVkaXRvci5maXJlKCdlZGl0b3JJbnRlcmFjdGlvbicsIHtcblx0XHRcdFx0XHRcdFx0XHRuYXRpdmVFdmVudDoge30sXG5cdFx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uRGF0YToge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZWxlbWVudDogd2lkZ2V0RWxlbWVudCxcblx0XHRcdFx0XHRcdFx0XHRcdHJlZ2lvbixcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRhZnRlckluaXQoZWRpdG9yKSB7XG5cdFx0XHQvLyBJbnRlZ3JhdGUgd2l0aCBhbGlnbiBjb21tYW5kcyAoanVzdGlmeSBwbHVnaW4pLlxuXG5cdFx0XHRjb25zdCBhbGlnbiA9IHtsZWZ0OiAxLCByaWdodDogMSwgY2VudGVyOiAxLCBibG9jazogMX07XG5cblx0XHRcdGNvbnN0IGludGVncmF0ZSA9IGFsaWduQ29tbWFuZEludGVncmF0b3IoZWRpdG9yKTtcblxuXHRcdFx0Zm9yIChjb25zdCB2YWx1ZSBpbiBhbGlnbikge1xuXHRcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFsaWduLCB2YWx1ZSkpIHtcblx0XHRcdFx0XHRpbnRlZ3JhdGUodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0fSk7XG5cblx0Ly8gV2lkZ2V0IHN0YXRlcyAoZm9ybXMpIGRlcGVuZGluZyBvbiBhbGlnbm1lbnQgYW5kIGNvbmZpZ3VyYXRpb24uXG5cdC8vXG5cdC8vIE5vbi1jYXB0aW9uZWQgd2lkZ2V0IChpbmxpbmUgc3R5bGVzKVxuXHQvLyBcdFx04pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG5cdC8vIFx0XHTilIJBbGlnbiDilIJJbnRlcm5hbCBmb3JtICAgICAgICAgICAgICAgICAg4pSCRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCbm9uZSAg4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgIOKUgjxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJsZWZ0ICDilII8d3JhcHBlciBzdHlsZT3igJ1mbG9hdDpsZWZ04oCdPiAgIOKUgjxpbWcgc3R5bGU94oCdZmxvYXQ6bGVmdOKAnSAvPiAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCY2VudGVy4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgIOKUgjxwIHN0eWxlPeKAnXRleHQtYWxpZ246Y2VudGVy4oCdPuKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxwIHN0eWxlPeKAnXRleHQtYWxpZ246Y2VudGVy4oCdPiDilIIgIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCICAgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgIOKUgjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJyaWdodCDilII8d3JhcHBlciBzdHlsZT3igJ1mbG9hdDpyaWdodOKAnT4gIOKUgjxpbWcgc3R5bGU94oCdZmxvYXQ6cmlnaHTigJ0gLz4gIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuXHQvL1xuXHQvLyBOb24tY2FwdGlvbmVkIHdpZGdldCAoY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXMgZGVmaW5lZClcblx0Ly8gXHRcdOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuXHQvLyBcdFx04pSCQWxpZ24g4pSCSW50ZXJuYWwgZm9ybSAgICAgICAgICAgICAgICAgIOKUgkRhdGEgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgm5vbmUgIOKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICDilII8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCbGVmdCAg4pSCPHdyYXBwZXIgY2xhc3M94oCdbGVmdOKAnT4gICAgICAgICDilII8aW1nIGNsYXNzPeKAnWxlZnTigJ0gLz4gICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgmNlbnRlcuKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICDilII8cCBjbGFzcz3igJ1jZW50ZXLigJ0+ICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8cCBjbGFzcz3igJ1jZW50ZXLigJ0+ICAgICAgICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiAgIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICDilII8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCcmlnaHQg4pSCPHdyYXBwZXIgY2xhc3M94oCdcmlnaHTigJ0+ICAgICAgICDilII8aW1nIGNsYXNzPeKAnXJpZ2h04oCdIC8+ICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJTilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcblx0Ly9cblx0Ly8gQ2FwdGlvbmVkIHdpZGdldCAoaW5saW5lIHN0eWxlcylcblx0Ly8gXHRcdOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuXHQvLyBcdFx04pSCQWxpZ24g4pSCSW50ZXJuYWwgZm9ybSAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgkRhdGEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCbm9uZSAg4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgjxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJsZWZ0ICDilII8d3JhcHBlciBzdHlsZT3igJ1mbG9hdDpsZWZ04oCdPiAgICAgICAgICAgIOKUgjxmaWd1cmUgc3R5bGU94oCdZmxvYXQ6bGVmdOKAnSAvPiAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCY2VudGVy4pSCPHdyYXBwZXIgc3R5bGU94oCddGV4dC1hbGlnbjpjZW50ZXLigJ0+ICAgICDilII8ZGl2IHN0eWxlPeKAnXRleHQtYWxpZ246Y2VudGVy4oCdPiAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgc3R5bGU94oCdZGlzcGxheTppbmxpbmUtYmxvY2vigJ0gLz7ilIIgPGZpZ3VyZSBzdHlsZT3igJ1kaXNwbGF5OmlubGluZS1ibG9ja+KAnSAvPuKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCcmlnaHQg4pSCPHdyYXBwZXIgc3R5bGU94oCdZmxvYXQ6cmlnaHTigJ0+ICAgICAgICAgICDilII8ZmlndXJlIHN0eWxlPeKAnWZsb2F0OnJpZ2h04oCdIC8+ICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJTilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcblx0Ly9cblx0Ly8gQ2FwdGlvbmVkIHdpZGdldCAoY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXMgZGVmaW5lZClcblx0Ly8gXHRcdOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuXHQvLyBcdFx04pSCQWxpZ24g4pSCSW50ZXJuYWwgZm9ybSAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgkRhdGEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCbm9uZSAg4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgjxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJsZWZ0ICDilII8d3JhcHBlciBjbGFzcz3igJ1sZWZ04oCdPiAgICAgICAgICAgICAgICAgIOKUgjxmaWd1cmUgY2xhc3M94oCdbGVmdOKAnSAvPiAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCY2VudGVy4pSCPHdyYXBwZXIgY2xhc3M94oCdY2VudGVy4oCdPiAgICAgICAgICAgICAgICDilII8ZGl2IGNsYXNzPeKAnWNlbnRlcuKAnT4gICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilII8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgnJpZ2h0IOKUgjx3cmFwcGVyIGNsYXNzPeKAnXJpZ2h04oCdPiAgICAgICAgICAgICAgICAg4pSCPGZpZ3VyZSBjbGFzcz3igJ1yaWdodOKAnSAvPiAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSU4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG5cdC8vXG5cdC8vIEBwYXJhbSB7Q0tFRElUT1IuZWRpdG9yfVxuXHQvLyBAcmV0dXJucyB7T2JqZWN0fVxuXG5cdGZ1bmN0aW9uIHdpZGdldERlZihlZGl0b3IpIHtcblx0XHRjb25zdCBhbGlnbkNsYXNzZXMgPSBlZGl0b3IuY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXM7XG5cblx0XHRjb25zdCBjYXB0aW9uZWRDbGFzcyA9IGVkaXRvci5jb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2NhcHRpb25lZENsYXNzO1xuXG5cdFx0ZnVuY3Rpb24gZGVmbGF0ZSgpIHtcblx0XHRcdGlmICh0aGlzLmRlZmxhdGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtZW1iZXIgd2hldGhlciB3aWRnZXQgd2FzIGZvY3VzZWQgYmVmb3JlIGRlc3Ryb3llZC5cblxuXHRcdFx0aWYgKGVkaXRvci53aWRnZXRzLmZvY3VzZWQgPT0gdGhpcy53aWRnZXQpIHtcblx0XHRcdFx0dGhpcy5mb2N1c2VkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0ZWRpdG9yLndpZGdldHMuZGVzdHJveSh0aGlzLndpZGdldCk7XG5cblx0XHRcdC8vIE1hcmsgd2lkZ2V0IHdhcyBkZXN0cm95ZWQuXG5cblx0XHRcdHRoaXMuZGVmbGF0ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGluZmxhdGUoKSB7XG5cdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRjb25zdCBkb2MgPSBlZGl0b3IuZG9jdW1lbnQ7XG5cblx0XHRcdC8vIENyZWF0ZSBhIG5ldyB3aWRnZXQuIFRoaXMgd2lkZ2V0IHdpbGwgYmUgZWl0aGVyIGNhcHRpb25lZFxuXHRcdFx0Ly8gbm9uLWNhcHRpb25lZCwgYmxvY2sgb3IgaW5saW5lIGFjY29yZGluZyB0byB3aGF0IGlzIHRoZVxuXHRcdFx0Ly8gbmV3IHN0YXRlIG9mIHRoZSB3aWRnZXQuXG5cblx0XHRcdGlmICh0aGlzLmRlZmxhdGVkKSB7XG5cdFx0XHRcdHRoaXMud2lkZ2V0ID0gZWRpdG9yLndpZGdldHMuaW5pdE9uKFxuXHRcdFx0XHRcdHRoaXMuZWxlbWVudCxcblx0XHRcdFx0XHQnaW1hZ2UnLFxuXHRcdFx0XHRcdHRoaXMud2lkZ2V0LmRhdGFcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBPbmNlIHdpZGdldCB3YXMgcmUtY3JlYXRlZCwgaXQgbWF5IGJlY29tZSBhbiBpbmxpbmUgZWxlbWVudCB3aXRob3V0XG5cdFx0XHRcdC8vIGJsb2NrIHdyYXBwZXIgKGkuZS4gd2hlbiB1bmFsaWduZWQsIGVuZCBub3QgY2FwdGlvbmVkKS4gTGV0J3MgZG8gc29tZVxuXHRcdFx0XHQvLyBzb3J0IG9mIGF1dG9wYXJhZ3JhcGhpbmcgaGVyZSAoIzEwODUzKS5cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy53aWRnZXQuaW5saW5lICYmXG5cdFx0XHRcdFx0IW5ldyBDS0VESVRPUi5kb20uZWxlbWVudFBhdGgodGhpcy53aWRnZXQud3JhcHBlciwgZWRpdGFibGUpXG5cdFx0XHRcdFx0XHQuYmxvY2tcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Y29uc3QgYmxvY2sgPSBkb2MuY3JlYXRlRWxlbWVudChcblx0XHRcdFx0XHRcdGVkaXRvci5hY3RpdmVFbnRlck1vZGUgPT0gQ0tFRElUT1IuRU5URVJfUCA/ICdwJyA6ICdkaXYnXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRibG9jay5yZXBsYWNlKHRoaXMud2lkZ2V0LndyYXBwZXIpO1xuXHRcdFx0XHRcdHRoaXMud2lkZ2V0LndyYXBwZXIubW92ZShibG9jayk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGUgZm9jdXMgbXVzdCBiZSB0cmFuc2ZlcnJlZCBmcm9tIHRoZSBvbGQgb25lIChkZXN0cm95ZWQpXG5cdFx0XHRcdC8vIHRvIHRoZSBuZXcgb25lIChqdXN0IGNyZWF0ZWQpLlxuXG5cdFx0XHRcdGlmICh0aGlzLmZvY3VzZWQpIHtcblx0XHRcdFx0XHR0aGlzLndpZGdldC5mb2N1cygpO1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmZvY3VzZWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgdGhpcy5kZWZsYXRlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgbm93IHdpZGdldCB3YXMgZGVzdHJveWVkIGp1c3QgdXBkYXRlIHdyYXBwZXIncyBhbGlnbm1lbnQuXG5cdFx0XHQvLyBBY2NvcmRpbmcgdG8gdGhlIG5ldyBzdGF0ZS5cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzZXRXcmFwcGVyQWxpZ24odGhpcy53aWRnZXQsIGFsaWduQ2xhc3Nlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsbG93ZWRDb250ZW50OiBnZXRXaWRnZXRBbGxvd2VkQ29udGVudChlZGl0b3IpLFxuXG5cdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICdpbWdbc3JjLGFsdF0nLFxuXG5cdFx0XHRmZWF0dXJlczogZ2V0V2lkZ2V0RmVhdHVyZXMoZWRpdG9yKSxcblxuXHRcdFx0c3R5bGVhYmxlRWxlbWVudHM6ICdpbWcgZmlndXJlJyxcblxuXHRcdFx0Ly8gVGhpcyB3aWRnZXQgY29udmVydHMgc3R5bGUtZHJpdmVuIGRpbWVuc2lvbnMgdG8gYXR0cmlidXRlcy5cblxuXHRcdFx0Y29udGVudFRyYW5zZm9ybWF0aW9uczogW1snaW1nW3dpZHRoXTogc2l6ZVRvQXR0cmlidXRlJ11dLFxuXG5cdFx0XHQvLyBUaGlzIHdpZGdldCBoYXMgYW4gZWRpdGFibGUgY2FwdGlvbi5cblxuXHRcdFx0ZWRpdGFibGVzOiB7XG5cdFx0XHRcdGNhcHRpb246IHtcblx0XHRcdFx0XHRzZWxlY3RvcjogJ2ZpZ2NhcHRpb24nLFxuXHRcdFx0XHRcdGFsbG93ZWRDb250ZW50OiAnYnIgZW0gc3Ryb25nIHN1YiBzdXAgdSBzOyBhWyFocmVmLHRhcmdldF0nLFxuXHRcdFx0XHR9LFxuXHRcdFx0fSxcblxuXHRcdFx0cGFydHM6IHtcblx0XHRcdFx0aW1hZ2U6ICdpbWcnLFxuXHRcdFx0XHRjYXB0aW9uOiAnZmlnY2FwdGlvbicsXG5cblx0XHRcdFx0Ly8gcGFydHMjbGluayBkZWZpbmVkIGluIHdpZGdldCNpbml0XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUZW1wbGF0ZSBvZiB0aGUgd2lkZ2V0OiBwbGFpbiBpbWFnZS5cblxuXHRcdFx0dGVtcGxhdGUsXG5cblx0XHRcdGRhdGEoKSB7XG5cdFx0XHRcdGNvbnN0IGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcztcblxuXHRcdFx0XHQvLyBJbWFnZSBjYW4ndCBiZSBjYXB0aW9uZWQgd2hlbiBmaWdjYXB0aW9uIGlzIGRpc2FsbG93ZWQgKCMxMTAwNCkuXG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMuZGF0YS5oYXNDYXB0aW9uICYmXG5cdFx0XHRcdFx0IWVkaXRvci5maWx0ZXIuY2hlY2tGZWF0dXJlKGZlYXR1cmVzLmNhcHRpb24pXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHRoaXMuZGF0YS5oYXNDYXB0aW9uID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJbWFnZSBjYW4ndCBiZSBhbGlnbmVkIHdoZW4gZmxvYXRpbmcgaXMgZGlzYWxsb3dlZCAoIzExMDA0KS5cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy5kYXRhLmFsaWduICE9ICdub25lJyAmJlxuXHRcdFx0XHRcdCFlZGl0b3IuZmlsdGVyLmNoZWNrRmVhdHVyZShmZWF0dXJlcy5hbGlnbilcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmFsaWduID0gJ25vbmUnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ29udmVydCB0aGUgaW50ZXJuYWwgZm9ybSBvZiB0aGUgd2lkZ2V0IGZyb20gdGhlIG9sZCBzdGF0ZSB0byB0aGUgbmV3IG9uZS5cblxuXHRcdFx0XHR0aGlzLnNoaWZ0U3RhdGUoe1xuXHRcdFx0XHRcdHdpZGdldDogdGhpcyxcblx0XHRcdFx0XHRlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG5cdFx0XHRcdFx0b2xkRGF0YTogdGhpcy5vbGREYXRhLFxuXHRcdFx0XHRcdG5ld0RhdGE6IHRoaXMuZGF0YSxcblx0XHRcdFx0XHRkZWZsYXRlLFxuXHRcdFx0XHRcdGluZmxhdGUsXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSB3aWRnZXQucGFydHMubGluayBzaW5jZSBpdCB3aWxsIG5vdCBhdXRvLXVwZGF0ZSB1bmxlc3Mgd2lkZ2V0XG5cdFx0XHRcdC8vIGlzIGRlc3Ryb3llZCBhbmQgcmUtaW5pdGVkLlxuXG5cdFx0XHRcdGlmICghdGhpcy5kYXRhLmxpbmspIHtcblx0XHRcdFx0XHRpZiAodGhpcy5wYXJ0cy5saW5rKSB7XG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpcy5wYXJ0cy5saW5rO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIXRoaXMucGFydHMubGluaykge1xuXHRcdFx0XHRcdFx0dGhpcy5wYXJ0cy5saW5rID0gdGhpcy5wYXJ0cy5pbWFnZS5nZXRQYXJlbnQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnBhcnRzLmltYWdlLnNldEF0dHJpYnV0ZXMoe1xuXHRcdFx0XHRcdHNyYzogdGhpcy5kYXRhLnNyYyxcblxuXHRcdFx0XHRcdC8vIFRoaXMgaW50ZXJuYWwgaXMgcmVxdWlyZWQgYnkgdGhlIGVkaXRvci5cblxuXHRcdFx0XHRcdCdkYXRhLWNrZS1zYXZlZC1zcmMnOiB0aGlzLmRhdGEuc3JjLFxuXG5cdFx0XHRcdFx0YWx0OiB0aGlzLmRhdGEuYWx0LFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBJZiBzaGlmdGluZyBub24tY2FwdGlvbmVkIC0+IGNhcHRpb25lZCwgcmVtb3ZlIGNsYXNzZXNcblx0XHRcdFx0Ly8gcmVsYXRlZCB0byBzdHlsZXMgZnJvbSA8aW1nLz4uXG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMub2xkRGF0YSAmJlxuXHRcdFx0XHRcdCF0aGlzLm9sZERhdGEuaGFzQ2FwdGlvbiAmJlxuXHRcdFx0XHRcdHRoaXMuZGF0YS5oYXNDYXB0aW9uXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGZvciAoY29uc3QgYyBpbiB0aGlzLmRhdGEuY2xhc3Nlcykge1xuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5kYXRhLmNsYXNzZXMsXG5cdFx0XHRcdFx0XHRcdFx0Y1xuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5wYXJ0cy5pbWFnZS5yZW1vdmVDbGFzcyhjKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgZGltZW5zaW9ucyBvZiB0aGUgaW1hZ2UgYWNjb3JkaW5nIHRvIGdhdGhlcmVkIGRhdGEuXG5cdFx0XHRcdC8vIERvIGl0IG9ubHkgd2hlbiB0aGUgYXR0cmlidXRlcyBhcmUgYWxsb3dlZCAoIzExMDA0KS5cblxuXHRcdFx0XHRpZiAoZWRpdG9yLmZpbHRlci5jaGVja0ZlYXR1cmUoZmVhdHVyZXMuZGltZW5zaW9uKSkge1xuXHRcdFx0XHRcdHNldERpbWVuc2lvbnModGhpcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWNoZSBjdXJyZW50IGRhdGEuXG5cblx0XHRcdFx0dGhpcy5vbGREYXRhID0gQ0tFRElUT1IudG9vbHMuZXh0ZW5kKHt9LCB0aGlzLmRhdGEpO1xuXHRcdFx0fSxcblxuXHRcdFx0aW5pdCgpIHtcblx0XHRcdFx0Y29uc3QgaGVscGVycyA9IENLRURJVE9SLnBsdWdpbnMuYWVfZHJhZ3Jlc2l6ZV9pZTExO1xuXG5cdFx0XHRcdGNvbnN0IGltYWdlID0gdGhpcy5wYXJ0cy5pbWFnZTtcblxuXHRcdFx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0XHRcdGhhc0NhcHRpb246ICEhdGhpcy5wYXJ0cy5jYXB0aW9uLFxuXHRcdFx0XHRcdHNyYzogaW1hZ2UuZ2V0QXR0cmlidXRlKCdzcmMnKSxcblx0XHRcdFx0XHRhbHQ6IGltYWdlLmdldEF0dHJpYnV0ZSgnYWx0JykgfHwgJycsXG5cdFx0XHRcdFx0d2lkdGg6IGltYWdlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSB8fCAnJyxcblxuXHRcdFx0XHRcdC8vIExvY2sgcmF0aW8gaXMgb24gYnkgZGVmYXVsdCAoIzEwODMzKS5cblxuXHRcdFx0XHRcdGxvY2s6IHRoaXMucmVhZHlcblx0XHRcdFx0XHRcdD8gaGVscGVycy5jaGVja0hhc05hdHVyYWxSYXRpbyhpbWFnZSlcblx0XHRcdFx0XHRcdDogdHJ1ZSxcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRkYXRhLmhlaWdodCA9IGRhdGEubG9ja1xuXHRcdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHRcdDogaW1hZ2UuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAnJztcblxuXHRcdFx0XHQvLyBJZiB3ZSB1c2VkICdhJyBpbiB3aWRnZXQjcGFydHMgZGVmaW5pdGlvbiwgaXQgY291bGQgaGFwcGVuIHRoYXRcblx0XHRcdFx0Ly8gc2VsZWN0ZWQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIHdpZGdldC5wYXJ0cyNjYXB0aW9uLiBTaW5jZSB0aGVyZSdzIG5vIGNsZXZlclxuXHRcdFx0XHQvLyB3YXkgdG8gc29sdmUgaXQgd2l0aCBDU1Mgc2VsZWN0b3JzLCBpdCdzIGRvbmUgbGlrZSB0aGF0LiAoIzExNzgzKS5cblxuXHRcdFx0XHRjb25zdCBsaW5rID0gaW1hZ2UuZ2V0QXNjZW5kYW50KCdhJyk7XG5cblx0XHRcdFx0aWYgKGxpbmsgJiYgdGhpcy53cmFwcGVyLmNvbnRhaW5zKGxpbmspKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXJ0cy5saW5rID0gbGluaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIERlcGVuZGluZyBvbiBjb25maWd1cmF0aW9uLCByZWFkIHN0eWxlL2NsYXNzIGZyb20gZWxlbWVudCBhbmRcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgaXQuIFJlbW92ZWQgc3R5bGUvY2xhc3Mgd2lsbCBiZSBzZXQgb24gd3JhcHBlciBpbiAjZGF0YSBsaXN0ZW5lci5cblx0XHRcdFx0Ly8gTm90ZTogQ2VudGVyIGFsaWdubWVudCBpcyBkZXRlY3RlZCBkdXJpbmcgdXBjYXN0LCBzbyBvbmx5IGxlZnQvcmlnaHQgY2FzZXNcblx0XHRcdFx0Ly8gYXJlIGNoZWNrZWQgYmVsb3cuXG5cblx0XHRcdFx0aWYgKCFkYXRhLmFsaWduKSB7XG5cdFx0XHRcdFx0Y29uc3QgYWxpZ25FbGVtZW50ID0gZGF0YS5oYXNDYXB0aW9uID8gdGhpcy5lbGVtZW50IDogaW1hZ2U7XG5cblx0XHRcdFx0XHQvLyBSZWFkIHRoZSBpbml0aWFsIGxlZnQvcmlnaHQgYWxpZ25tZW50IGZyb20gdGhlIGNsYXNzIHNldCBvbiBlbGVtZW50LlxuXG5cdFx0XHRcdFx0aWYgKGFsaWduQ2xhc3Nlcykge1xuXHRcdFx0XHRcdFx0aWYgKGFsaWduRWxlbWVudC5oYXNDbGFzcyhhbGlnbkNsYXNzZXNbMF0pKSB7XG5cdFx0XHRcdFx0XHRcdGRhdGEuYWxpZ24gPSAnbGVmdCc7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGFsaWduRWxlbWVudC5oYXNDbGFzcyhhbGlnbkNsYXNzZXNbMl0pKSB7XG5cdFx0XHRcdFx0XHRcdGRhdGEuYWxpZ24gPSAncmlnaHQnO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoZGF0YS5hbGlnbikge1xuXHRcdFx0XHRcdFx0XHRhbGlnbkVsZW1lbnQucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdFx0XHRcdFx0YWxpZ25DbGFzc2VzW2FsaWdubWVudHNPYmpbZGF0YS5hbGlnbl1dXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkYXRhLmFsaWduID0gJ25vbmUnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlYWQgaW5pdGlhbCBmbG9hdCBzdHlsZSBmcm9tIGZpZ3VyZS9pbWFnZSBhbmQgdGhlbiByZW1vdmUgaXQuXG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRkYXRhLmFsaWduID0gYWxpZ25FbGVtZW50LmdldFN0eWxlKCdmbG9hdCcpIHx8ICdub25lJztcblx0XHRcdFx0XHRcdGFsaWduRWxlbWVudC5yZW1vdmVTdHlsZSgnZmxvYXQnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBVcGRhdGUgZGF0YS5saW5rIG9iamVjdCB3aXRoIGF0dHJpYnV0ZXMgaWYgdGhlIGxpbmsgaGFzIGJlZW4gZGlzY292ZXJlZC5cblxuXHRcdFx0XHRpZiAoZWRpdG9yLnBsdWdpbnMubGluayAmJiB0aGlzLnBhcnRzLmxpbmspIHtcblx0XHRcdFx0XHRkYXRhLmxpbmsgPSBoZWxwZXJzLmdldExpbmtBdHRyaWJ1dGVzUGFyc2VyKCkoXG5cdFx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdFx0XHR0aGlzLnBhcnRzLmxpbmtcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHJpZCBvZiBja2Vfd2lkZ2V0XyogY2xhc3NlcyBpbiBkYXRhLiBPdGhlcndpc2Vcblx0XHRcdFx0XHQvLyB0aGV5IG1pZ2h0IGFwcGVhciBpbiBsaW5rIGRpYWxvZy5cblxuXHRcdFx0XHRcdGNvbnN0IGFkdmFuY2VkID0gZGF0YS5saW5rLmFkdmFuY2VkO1xuXHRcdFx0XHRcdGlmIChhZHZhbmNlZCAmJiBhZHZhbmNlZC5hZHZDU1NDbGFzc2VzKSB7XG5cdFx0XHRcdFx0XHRhZHZhbmNlZC5hZHZDU1NDbGFzc2VzID0gQ0tFRElUT1IudG9vbHMudHJpbShcblx0XHRcdFx0XHRcdFx0YWR2YW5jZWQuYWR2Q1NTQ2xhc3Nlcy5yZXBsYWNlKC9ja2VfXFxTKy8sICcnKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgcmlkIG9mIGV4dHJhIHZlcnRpY2FsIHNwYWNlIHdoZW4gdGhlcmUncyBubyBjYXB0aW9uLlxuXHRcdFx0XHQvLyBJdCB3aWxsIGltcHJvdmUgdGhlIGxvb2sgb2YgdGhlIHJlc2l6ZXIuXG5cblx0XHRcdFx0dGhpcy53cmFwcGVyWyhkYXRhLmhhc0NhcHRpb24gPyAncmVtb3ZlJyA6ICdhZGQnKSArICdDbGFzcyddKFxuXHRcdFx0XHRcdCdja2VfaW1hZ2Vfbm9jYXB0aW9uJ1xuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdHRoaXMuc2V0RGF0YShkYXRhKTtcblxuXHRcdFx0XHQvLyBTZXR1cCBkeW5hbWljIGltYWdlIHJlc2l6aW5nIHdpdGggbW91c2UuXG5cdFx0XHRcdC8vIERvbid0IGluaXRpYWxpemUgcmVzaXplciB3aGVuIGRpbWVuc2lvbnMgYXJlIGRpc2FsbG93ZWQgKCMxMTAwNCkuXG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGVkaXRvci5maWx0ZXIuY2hlY2tGZWF0dXJlKHRoaXMuZmVhdHVyZXMuZGltZW5zaW9uKSAmJlxuXHRcdFx0XHRcdGVkaXRvci5jb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2Rpc2FibGVSZXNpemVyICE9PSB0cnVlXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHNldHVwUmVzaXplcih0aGlzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGRyYWdIYW5kbGVyU3R5bGUgPSB0aGlzLmRyYWdIYW5kbGVyQ29udGFpbmVyLiQuc3R5bGU7XG5cdFx0XHRcdGRyYWdIYW5kbGVyU3R5bGUuc2V0QXR0cmlidXRlKFxuXHRcdFx0XHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0XHRcdCdyZ2JhKDI1NSwgMjU1LCAyNTUsIDEnXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGRyYWdIYW5kbGVyU3R5bGUuc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgJzEnKTtcblxuXHRcdFx0XHR0aGlzLnNoaWZ0U3RhdGUgPSBoZWxwZXJzLnN0YXRlU2hpZnRlcih0aGlzLmVkaXRvcik7XG5cblx0XHRcdFx0Ly8gQWRkIHdpZGdldCBlZGl0aW5nIG9wdGlvbiB0byBpdHMgY29udGV4dCBtZW51LlxuXG5cdFx0XHRcdHRoaXMub24oJ2NvbnRleHRNZW51JywgZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHRcdFx0ZXZ0LmRhdGEuaW1hZ2UgPSBDS0VESVRPUi5UUklTVEFURV9PRkY7XG5cblx0XHRcdFx0XHQvLyBJbnRlZ3JhdGUgY29udGV4dCBtZW51IGl0ZW1zIGZvciBsaW5rLlxuXHRcdFx0XHRcdC8vIE5vdGUgdGhhdCB3aWRnZXQgbWF5IGJlIHdyYXBwZWQgaW4gYSBsaW5rLCB3aGljaFxuXHRcdFx0XHRcdC8vIGRvZXMgbm90IGJlbG9uZyB0byB0aGF0IHdpZGdldCAoIzExODE0KS5cblxuXHRcdFx0XHRcdGlmICh0aGlzLnBhcnRzLmxpbmsgfHwgdGhpcy53cmFwcGVyLmdldEFzY2VuZGFudCgnYScpKSB7XG5cdFx0XHRcdFx0XHRldnQuZGF0YS5saW5rID0gZXZ0LmRhdGEudW5saW5rID0gQ0tFRElUT1IuVFJJU1RBVEVfT0ZGO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBPdmVycmlkZXMgZGVmYXVsdCBtZXRob2QgdG8gaGFuZGxlIGludGVybmFsIG11dGFiaWxpdHkgb2YgYWVfZHJhZ3Jlc2l6ZV9pZTExLlxuXHRcdFx0Ly8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNhZGRDbGFzc1xuXG5cdFx0XHRhZGRDbGFzcyhjbGFzc05hbWUpIHtcblx0XHRcdFx0Z2V0U3R5bGVhYmxlRWxlbWVudCh0aGlzKS5hZGRDbGFzcyhjbGFzc05hbWUpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gT3ZlcnJpZGVzIGRlZmF1bHQgbWV0aG9kIHRvIGhhbmRsZSBpbnRlcm5hbCBtdXRhYmlsaXR5IG9mIGFlX2RyYWdyZXNpemVfaWUxMS5cblx0XHRcdC8vIEBzZWUgQ0tFRElUT1IucGx1Z2lucy53aWRnZXQjaGFzQ2xhc3NcblxuXHRcdFx0aGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG5cdFx0XHRcdHJldHVybiBnZXRTdHlsZWFibGVFbGVtZW50KHRoaXMpLmhhc0NsYXNzKGNsYXNzTmFtZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBPdmVycmlkZXMgZGVmYXVsdCBtZXRob2QgdG8gaGFuZGxlIGludGVybmFsIG11dGFiaWxpdHkgb2YgYWVfZHJhZ3Jlc2l6ZV9pZTExLlxuXHRcdFx0Ly8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNyZW1vdmVDbGFzc1xuXG5cdFx0XHRyZW1vdmVDbGFzcyhjbGFzc05hbWUpIHtcblx0XHRcdFx0Z2V0U3R5bGVhYmxlRWxlbWVudCh0aGlzKS5yZW1vdmVDbGFzcyhjbGFzc05hbWUpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gT3ZlcnJpZGVzIGRlZmF1bHQgbWV0aG9kIHRvIGhhbmRsZSBpbnRlcm5hbCBtdXRhYmlsaXR5IG9mIGFlX2RyYWdyZXNpemVfaWUxMS5cblx0XHRcdC8vIEBzZWUgQ0tFRElUT1IucGx1Z2lucy53aWRnZXQjZ2V0Q2xhc3Nlc1xuXG5cdFx0XHRnZXRDbGFzc2VzOiAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbnN0IGNsYXNzUmVnZXggPSBuZXcgUmVnRXhwKFxuXHRcdFx0XHRcdCdeKCcgK1xuXHRcdFx0XHRcdFx0W10uY29uY2F0KGNhcHRpb25lZENsYXNzLCBhbGlnbkNsYXNzZXMpLmpvaW4oJ3wnKSArXG5cdFx0XHRcdFx0XHQnKSQnXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNvbnN0IGNsYXNzZXMgPSB0aGlzLnJlcG9zaXRvcnkucGFyc2VFbGVtZW50Q2xhc3Nlcyhcblx0XHRcdFx0XHRcdGdldFN0eWxlYWJsZUVsZW1lbnQodGhpcykuZ2V0QXR0cmlidXRlKCdjbGFzcycpXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdC8vIE5laXRoZXIgY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9jYXB0aW9uZWRDbGFzcyBub3IgY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXNcblx0XHRcdFx0XHQvLyBkbyBub3QgYmVsb25nIHRvIHN0eWxlIGNsYXNzZXMuXG5cblx0XHRcdFx0XHRmb3IgKGNvbnN0IGMgaW4gY2xhc3Nlcykge1xuXHRcdFx0XHRcdFx0aWYgKGNsYXNzUmVnZXgudGVzdChjKSkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgY2xhc3Nlc1tjXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gY2xhc3Nlcztcblx0XHRcdFx0fTtcblx0XHRcdH0pKCksXG5cblx0XHRcdHVwY2FzdDogdXBjYXN0V2lkZ2V0RWxlbWVudChlZGl0b3IpLFxuXHRcdFx0ZG93bmNhc3Q6IGRvd25jYXN0V2lkZ2V0RWxlbWVudChlZGl0b3IpLFxuXG5cdFx0XHRnZXRMYWJlbCgpIHtcblx0XHRcdFx0Y29uc3QgbGFiZWwgPSAodGhpcy5kYXRhLmFsdCB8fCAnJykgKyAnICcgKyB0aGlzLnBhdGhOYW1lO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLmVkaXRvci5sYW5nLndpZGdldC5sYWJlbC5yZXBsYWNlKC8lMS8sIGxhYmVsKTtcblx0XHRcdH0sXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNldCBvZiBFbmhhbmNlZCBJbWFnZSAoYWVfZHJhZ3Jlc2l6ZV9pZTExKSBwbHVnaW4gaGVscGVycy5cblx0ICpcblx0ICogQGNsYXNzXG5cdCAqIEBzaW5nbGV0b25cblx0ICovXG5cdENLRURJVE9SLnBsdWdpbnMuYWVfZHJhZ3Jlc2l6ZV9pZTExID0ge1xuXHRcdHN0YXRlU2hpZnRlcihlZGl0b3IpIHtcblx0XHRcdC8vIFRhZyBuYW1lIHVzZWQgZm9yIGNlbnRlcmluZyBub24tY2FwdGlvbmVkIHdpZGdldHMuXG5cblx0XHRcdGNvbnN0IGRvYyA9IGVkaXRvci5kb2N1bWVudDtcblxuXHRcdFx0Y29uc3QgYWxpZ25DbGFzc2VzID0gZWRpdG9yLmNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfYWxpZ25DbGFzc2VzO1xuXG5cdFx0XHRjb25zdCBjYXB0aW9uZWRDbGFzcyA9XG5cdFx0XHRcdGVkaXRvci5jb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2NhcHRpb25lZENsYXNzO1xuXG5cdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHQvLyBUaGUgb3JkZXIgdGhhdCBzdGF0ZUFjdGlvbnMgZ2V0IGV4ZWN1dGVkLiBJdCBtYXR0ZXJzIVxuXG5cdFx0XHRjb25zdCBzaGlmdGFibGVzID0gWydoYXNDYXB0aW9uJywgJ2FsaWduJywgJ2xpbmsnXTtcblxuXHRcdFx0Ly8gQXRvbWljIHByb2NlZHVyZXMsIG9uZSBwZXIgc3RhdGUgdmFyaWFibGUuXG5cblx0XHRcdGNvbnN0IHN0YXRlQWN0aW9ucyA9IHtcblx0XHRcdFx0YWxpZ24oc2hpZnQsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuXHRcdFx0XHRcdGNvbnN0IGVsID0gc2hpZnQuZWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEFsaWdubWVudCBjaGFuZ2VkLlxuXG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0c2hpZnQuY2hhbmdlZC5hbGlnbiB8fFxuXHRcdFx0XHRcdFx0KGVsLiQuc3R5bGUubWFyZ2luTGVmdCA9PT0gJ2F1dG8nICYmXG5cdFx0XHRcdFx0XHRcdGVsLiQuc3R5bGUubWFyZ2luUmlnaHQgPT09ICdhdXRvJylcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdC8vIE5vIGNhcHRpb24gaW4gdGhlIG5ldyBzdGF0ZS5cblxuXHRcdFx0XHRcdFx0aWYgKCFzaGlmdC5uZXdEYXRhLmhhc0NhcHRpb24pIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ2hhbmdlZCB0byBcImNlbnRlclwiIChub24tY2FwdGlvbmVkKS5cblxuXHRcdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdFx0bmV3VmFsdWUgPT0gJ2NlbnRlcicgfHxcblx0XHRcdFx0XHRcdFx0XHQoZWwuJC5zdHlsZS5tYXJnaW5MZWZ0ID09PSAnYXV0bycgJiZcblx0XHRcdFx0XHRcdFx0XHRcdGVsLiQuc3R5bGUubWFyZ2luUmlnaHQgPT09ICdhdXRvJylcblx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0c2hpZnQuZGVmbGF0ZSgpO1xuXHRcdFx0XHRcdFx0XHRcdHNoaWZ0LmVsZW1lbnQgPSB3cmFwSW5DZW50ZXJpbmcoZWRpdG9yLCBlbCk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBDaGFuZ2VkIHRvIFwibm9uLWNlbnRlclwiIGZyb20gXCJjZW50ZXJcIiB3aGlsZSBjYXB0aW9uIHJlbW92ZWQuXG5cblx0XHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRcdCFzaGlmdC5jaGFuZ2VkLmhhc0NhcHRpb24gJiZcblx0XHRcdFx0XHRcdFx0XHRvbGRWYWx1ZSA9PSAnY2VudGVyJyAmJlxuXHRcdFx0XHRcdFx0XHRcdG5ld1ZhbHVlICE9ICdjZW50ZXInXG5cdFx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRcdHNoaWZ0LmRlZmxhdGUoKTtcblx0XHRcdFx0XHRcdFx0XHRzaGlmdC5lbGVtZW50ID0gdW53cmFwRnJvbUNlbnRlcmluZyhlbCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBBbGlnbm1lbnQgcmVtYWlucyBhbmQgXCJjZW50ZXJcIiByZW1vdmVkIGNhcHRpb24uXG5cdFx0XHRcdFx0ZWxzZSBpZiAoXG5cdFx0XHRcdFx0XHRuZXdWYWx1ZSA9PSAnY2VudGVyJyAmJlxuXHRcdFx0XHRcdFx0c2hpZnQuY2hhbmdlZC5oYXNDYXB0aW9uICYmXG5cdFx0XHRcdFx0XHQhc2hpZnQubmV3RGF0YS5oYXNDYXB0aW9uXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRzaGlmdC5kZWZsYXRlKCk7XG5cdFx0XHRcdFx0XHRzaGlmdC5lbGVtZW50ID0gd3JhcEluQ2VudGVyaW5nKGVkaXRvciwgZWwpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZpbmFsbHkgc2V0IGRpc3BsYXkgZm9yIGZpZ3VyZS5cblxuXHRcdFx0XHRcdGlmICghYWxpZ25DbGFzc2VzICYmIGVsLmlzKCdmaWd1cmUnKSkge1xuXHRcdFx0XHRcdFx0aWYgKG5ld1ZhbHVlID09ICdjZW50ZXInKSB7XG5cdFx0XHRcdFx0XHRcdGVsLnNldFN0eWxlKCdkaXNwbGF5JywgJ2lubGluZS1ibG9jaycpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZWwucmVtb3ZlU3R5bGUoJ2Rpc3BsYXknKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0aGFzQ2FwdGlvbihzaGlmdCwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyBhY3Rpb24gaXMgZm9yIHJlYWwgc3RhdGUgY2hhbmdlIG9ubHkuXG5cblx0XHRcdFx0XHRpZiAoIXNoaWZ0LmNoYW5nZWQuaGFzQ2FwdGlvbikge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEdldCA8aW1nLz4gb3IgPGE+PGltZy8+PC9hPiBmcm9tIHdpZGdldC4gTm90ZSB0aGF0IHdpZGdldCBlbGVtZW50IG1pZ2h0IGl0c2VsZlxuXHRcdFx0XHRcdC8vIGJlIHdoYXQgd2UncmUgbG9va2luZyBmb3IuIEFsc28gZWxlbWVudCBjYW4gYmUgPHAgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxhPi4uLjwvYT48L3A+LlxuXG5cdFx0XHRcdFx0bGV0IGltYWdlT3JMaW5rO1xuXHRcdFx0XHRcdGlmIChzaGlmdC5lbGVtZW50LmlzKHtpbWc6IDEsIGE6IDF9KSkge1xuXHRcdFx0XHRcdFx0aW1hZ2VPckxpbmsgPSBzaGlmdC5lbGVtZW50O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpbWFnZU9yTGluayA9IHNoaWZ0LmVsZW1lbnQuZmluZE9uZSgnYSxpbWcnKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTd2l0Y2hpbmcgaGFzQ2FwdGlvbiBhbHdheXMgZGVzdHJveXMgdGhlIHdpZGdldC5cblxuXHRcdFx0XHRcdHNoaWZ0LmRlZmxhdGUoKTtcblxuXHRcdFx0XHRcdC8vIFRoZXJlIHdhcyBubyBjYXB0aW9uLCBidXQgdGhlIGNhcHRpb24gaXMgdG8gYmUgYWRkZWQuXG5cblx0XHRcdFx0XHRpZiAobmV3VmFsdWUpIHtcblx0XHRcdFx0XHRcdC8vIENyZWF0ZSBuZXcgPGZpZ3VyZT4gZnJvbSB3aWRnZXQgdGVtcGxhdGUuXG5cblx0XHRcdFx0XHRcdGNvbnN0IGZpZ3VyZSA9IENLRURJVE9SLmRvbS5lbGVtZW50LmNyZWF0ZUZyb21IdG1sKFxuXHRcdFx0XHRcdFx0XHR0ZW1wbGF0ZUJsb2NrLm91dHB1dCh7XG5cdFx0XHRcdFx0XHRcdFx0Y2FwdGlvbmVkQ2xhc3MsXG5cdFx0XHRcdFx0XHRcdFx0Y2FwdGlvblBsYWNlaG9sZGVyOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZWRpdG9yLmxhbmcuYWVfZHJhZ3Jlc2l6ZV9pZTExXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jYXB0aW9uUGxhY2Vob2xkZXIsXG5cdFx0XHRcdFx0XHRcdH0pLFxuXHRcdFx0XHRcdFx0XHRkb2Ncblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIFJlcGxhY2UgZWxlbWVudCB3aXRoIDxmaWd1cmU+LlxuXG5cdFx0XHRcdFx0XHRyZXBsYWNlU2FmZWx5KGZpZ3VyZSwgc2hpZnQuZWxlbWVudCk7XG5cblx0XHRcdFx0XHRcdC8vIFVzZSBvbGQgPGltZy8+IG9yIDxhPjxpbWcvPjwvYT4gaW5zdGVhZCBvZiB0aGUgb25lIGZyb20gdGhlIHRlbXBsYXRlLFxuXHRcdFx0XHRcdFx0Ly8gc28gd2Ugd29uJ3QgbG9zZSBhZGRpdGlvbmFsIGF0dHJpYnV0ZXMuXG5cblx0XHRcdFx0XHRcdGltYWdlT3JMaW5rLnJlcGxhY2UoZmlndXJlLmZpbmRPbmUoJ2ltZycpKTtcblxuXHRcdFx0XHRcdFx0Ly8gVXBkYXRlIHdpZGdldCdzIGVsZW1lbnQuXG5cblx0XHRcdFx0XHRcdHNoaWZ0LmVsZW1lbnQgPSBmaWd1cmU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gVGhlIGNhcHRpb24gd2FzIHByZXNlbnQsIGJ1dCBub3cgaXQncyB0byBiZSByZW1vdmVkLlxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gVW53cmFwIDxpbWcvPiBvciA8YT48aW1nLz48L2E+IGZyb20gZmlndXJlLlxuXG5cdFx0XHRcdFx0XHRpbWFnZU9yTGluay5yZXBsYWNlKHNoaWZ0LmVsZW1lbnQpO1xuXG5cdFx0XHRcdFx0XHQvLyBVcGRhdGUgd2lkZ2V0J3MgZWxlbWVudC5cblxuXHRcdFx0XHRcdFx0c2hpZnQuZWxlbWVudCA9IGltYWdlT3JMaW5rO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRsaW5rKHNoaWZ0LCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoc2hpZnQuY2hhbmdlZC5saW5rKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBpbWcgPSBzaGlmdC5lbGVtZW50LmlzKCdpbWcnKVxuXHRcdFx0XHRcdFx0XHQ/IHNoaWZ0LmVsZW1lbnRcblx0XHRcdFx0XHRcdFx0OiBzaGlmdC5lbGVtZW50LmZpbmRPbmUoJ2ltZycpO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBsaW5rID0gc2hpZnQuZWxlbWVudC5pcygnYScpXG5cdFx0XHRcdFx0XHRcdD8gc2hpZnQuZWxlbWVudFxuXHRcdFx0XHRcdFx0XHQ6IHNoaWZ0LmVsZW1lbnQuZmluZE9uZSgnYScpO1xuXG5cdFx0XHRcdFx0XHQvLyBXaHkgZGVmbGF0ZTpcblx0XHRcdFx0XHRcdC8vIElmIGVsZW1lbnQgaXMgPGltZy8+LCBpdCB3aWxsIGJlIHdyYXBwZWQgaW50byA8YT4sXG5cdFx0XHRcdFx0XHQvLyB3aGljaCBiZWNvbWVzIGEgbmV3IHdpZGdldC5lbGVtZW50LlxuXHRcdFx0XHRcdFx0Ly8gSWYgZWxlbWVudCBpcyA8YT48aW1nLz48L2E+LCBpdCB3aWxsIGJlIHVubGlua2VkXG5cdFx0XHRcdFx0XHQvLyBzbyA8aW1nLz4gYmVjb21lcyBhIG5ldyB3aWRnZXQuZWxlbWVudC5cblxuXHRcdFx0XHRcdFx0Y29uc3QgbmVlZHNEZWZsYXRlID1cblx0XHRcdFx0XHRcdFx0KHNoaWZ0LmVsZW1lbnQuaXMoJ2EnKSAmJiAhbmV3VmFsdWUpIHx8XG5cdFx0XHRcdFx0XHRcdChzaGlmdC5lbGVtZW50LmlzKCdpbWcnKSAmJiBuZXdWYWx1ZSk7XG5cblx0XHRcdFx0XHRcdGxldCBuZXdFbDtcblxuXHRcdFx0XHRcdFx0aWYgKG5lZWRzRGVmbGF0ZSkge1xuXHRcdFx0XHRcdFx0XHRzaGlmdC5kZWZsYXRlKCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIElmIHVubGlua2VkIHRoZSBpbWFnZSwgcmV0dXJuZWQgZWxlbWVudCBpcyA8aW1nPi5cblxuXHRcdFx0XHRcdFx0aWYgKCFuZXdWYWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRuZXdFbCA9IHVud3JhcEZyb21MaW5rKGxpbmspO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gSWYgbGlua2VkIHRoZSBpbWFnZSwgcmV0dXJuZWQgZWxlbWVudCBpcyA8YT4uXG5cblx0XHRcdFx0XHRcdFx0aWYgKCFvbGRWYWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdG5ld0VsID0gd3JhcEluTGluayhpbWcsIHNoaWZ0Lm5ld0RhdGEubGluayk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBTZXQgYW5kIHJlbW92ZSBhbGwgYXR0cmlidXRlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdGF0ZS5cblxuXHRcdFx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gQ0tFRElUT1IucGx1Z2lucy5hZV9kcmFncmVzaXplX2llMTEuZ2V0TGlua0F0dHJpYnV0ZXNHZXR0ZXIoKShcblx0XHRcdFx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdFx0XHRcdFx0bmV3VmFsdWVcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIUNLRURJVE9SLnRvb2xzLmlzRW1wdHkoYXR0cmlidXRlcy5zZXQpKSB7XG5cdFx0XHRcdFx0XHRcdFx0KG5ld0VsIHx8IGxpbmspLnNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcy5zZXQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZXMucmVtb3ZlZC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHQobmV3RWwgfHwgbGluaykucmVtb3ZlQXR0cmlidXRlcyhcblx0XHRcdFx0XHRcdFx0XHRcdGF0dHJpYnV0ZXMucmVtb3ZlZFxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG5lZWRzRGVmbGF0ZSkge1xuXHRcdFx0XHRcdFx0XHRzaGlmdC5lbGVtZW50ID0gbmV3RWw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0fTtcblxuXHRcdFx0ZnVuY3Rpb24gd3JhcEluQ2VudGVyaW5nKGVkaXRvciwgZWxlbWVudCkge1xuXHRcdFx0XHRjb25zdCBhdHRyaWJzQW5kU3R5bGVzID0ge307XG5cblx0XHRcdFx0aWYgKGFsaWduQ2xhc3Nlcykge1xuXHRcdFx0XHRcdGF0dHJpYnNBbmRTdHlsZXMuYXR0cmlidXRlcyA9IHtjbGFzczogYWxpZ25DbGFzc2VzWzFdfTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhdHRyaWJzQW5kU3R5bGVzLnN0eWxlcyA9IHsndGV4dC1hbGlnbic6ICdjZW50ZXInfTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRoZXJlJ3Mgbm8gZ2VudGxlIHdheSB0byBjZW50ZXIgaW5saW5lIGVsZW1lbnQgd2l0aCBDU1MsIHNvIGNyZWF0ZSBwL2RpdlxuXHRcdFx0XHQvLyB0aGF0IHdyYXBzIHdpZGdldCBjb250ZW50cyBhbmQgZG9lcyB0aGUgdHJpY2sgZWl0aGVyIHdpdGggc3R5bGUgb3IgY2xhc3MuXG5cblx0XHRcdFx0Y29uc3QgY2VudGVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdFx0ZWRpdG9yLmFjdGl2ZUVudGVyTW9kZSA9PSBDS0VESVRPUi5FTlRFUl9QID8gJ3AnIDogJ2RpdicsXG5cdFx0XHRcdFx0YXR0cmlic0FuZFN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFJlcGxhY2UgZWxlbWVudCB3aXRoIGNlbnRlcmluZyB3cmFwcGVyLlxuXG5cdFx0XHRcdHJlcGxhY2VTYWZlbHkoY2VudGVyLCBlbGVtZW50KTtcblx0XHRcdFx0ZWxlbWVudC5tb3ZlKGNlbnRlcik7XG5cblx0XHRcdFx0cmV0dXJuIGNlbnRlcjtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gdW53cmFwRnJvbUNlbnRlcmluZyhlbGVtZW50KSB7XG5cdFx0XHRcdGNvbnN0IGltYWdlT3JMaW5rID0gZWxlbWVudC5maW5kT25lKCdhLGltZycpO1xuXG5cdFx0XHRcdGltYWdlT3JMaW5rLnJlcGxhY2UoZWxlbWVudCk7XG5cblx0XHRcdFx0cmV0dXJuIGltYWdlT3JMaW5rO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXcmFwcyA8aW1nLz4gLT4gPGE+PGltZy8+PC9hPi5cblx0XHRcdC8vIFJldHVybnMgcmVmZXJlbmNlIHRvIDxhPi5cblx0XHRcdC8vXG5cdFx0XHQvLyBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBpbWdcblx0XHRcdC8vIEBwYXJhbSB7T2JqZWN0fSBsaW5rRGF0YVxuXHRcdFx0Ly8gQHJldHVybnMge0NLRURJVE9SLmRvbS5lbGVtZW50fVxuXG5cdFx0XHRmdW5jdGlvbiB3cmFwSW5MaW5rKGltZywgbGlua0RhdGEpIHtcblx0XHRcdFx0Y29uc3QgbGluayA9IGRvYy5jcmVhdGVFbGVtZW50KCdhJywge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRcdGhyZWY6IGxpbmtEYXRhLnVybCxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRsaW5rLnJlcGxhY2UoaW1nKTtcblx0XHRcdFx0aW1nLm1vdmUobGluayk7XG5cblx0XHRcdFx0cmV0dXJuIGxpbms7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlLXdyYXBzIDxhPjxpbWcvPjwvYT4gLT4gPGltZy8+LlxuXHRcdFx0Ly8gUmV0dXJucyB0aGUgcmVmZXJlbmNlIHRvIDxpbWcvPlxuXHRcdFx0Ly9cblx0XHRcdC8vIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGxpbmtcblx0XHRcdC8vIEByZXR1cm5zIHtDS0VESVRPUi5kb20uZWxlbWVudH1cblxuXHRcdFx0ZnVuY3Rpb24gdW53cmFwRnJvbUxpbmsobGluaykge1xuXHRcdFx0XHRjb25zdCBpbWcgPSBsaW5rLmZpbmRPbmUoJ2ltZycpO1xuXG5cdFx0XHRcdGltZy5yZXBsYWNlKGxpbmspO1xuXG5cdFx0XHRcdHJldHVybiBpbWc7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHJlcGxhY2VTYWZlbHkocmVwbGFjaW5nLCByZXBsYWNlZCkge1xuXHRcdFx0XHRpZiAocmVwbGFjZWQuZ2V0UGFyZW50KCkpIHtcblx0XHRcdFx0XHRjb25zdCByYW5nZSA9IGVkaXRvci5jcmVhdGVSYW5nZSgpO1xuXG5cdFx0XHRcdFx0cmFuZ2UubW92ZVRvUG9zaXRpb24oXG5cdFx0XHRcdFx0XHRyZXBsYWNlZCxcblx0XHRcdFx0XHRcdENLRURJVE9SLlBPU0lUSU9OX0JFRk9SRV9TVEFSVFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBSZW1vdmUgb2xkIGVsZW1lbnQuIERvIGl0IGJlZm9yZSBpbnNlcnRpb24gdG8gYXZvaWQgYSBjYXNlIHdoZW5cblx0XHRcdFx0XHQvLyBlbGVtZW50IGlzIG1vdmVkIGZyb20gJ3JlcGxhY2VkJyBlbGVtZW50IGJlZm9yZSBpdCwgd2hhdCBjcmVhdGVzXG5cdFx0XHRcdFx0Ly8gYSB0cmlja3kgY2FzZSB3aGljaCBpbnNlcnRFbGVtZW50SW50b3JSYW5nZSBkb2VzIG5vdCBoYW5kbGUuXG5cblx0XHRcdFx0XHRyZXBsYWNlZC5yZW1vdmUoKTtcblxuXHRcdFx0XHRcdGVkaXRhYmxlLmluc2VydEVsZW1lbnRJbnRvUmFuZ2UocmVwbGFjaW5nLCByYW5nZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVwbGFjaW5nLnJlcGxhY2UocmVwbGFjZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbihzaGlmdCkge1xuXHRcdFx0XHRsZXQgbmFtZTtcblx0XHRcdFx0bGV0IGk7XG5cblx0XHRcdFx0c2hpZnQuY2hhbmdlZCA9IHt9O1xuXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBzaGlmdGFibGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0bmFtZSA9IHNoaWZ0YWJsZXNbaV07XG5cblx0XHRcdFx0XHRzaGlmdC5jaGFuZ2VkW25hbWVdID0gc2hpZnQub2xkRGF0YVxuXHRcdFx0XHRcdFx0PyBzaGlmdC5vbGREYXRhW25hbWVdICE9PSBzaGlmdC5uZXdEYXRhW25hbWVdXG5cdFx0XHRcdFx0XHQ6IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSXRlcmF0ZSBvdmVyIHBvc3NpYmxlIHN0YXRlIHZhcmlhYmxlcy5cblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2hpZnRhYmxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG5hbWUgPSBzaGlmdGFibGVzW2ldO1xuXG5cdFx0XHRcdFx0c3RhdGVBY3Rpb25zW25hbWVdKFxuXHRcdFx0XHRcdFx0c2hpZnQsXG5cdFx0XHRcdFx0XHRzaGlmdC5vbGREYXRhID8gc2hpZnQub2xkRGF0YVtuYW1lXSA6IG51bGwsXG5cdFx0XHRcdFx0XHRzaGlmdC5uZXdEYXRhW25hbWVdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNoaWZ0LmluZmxhdGUoKTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IGltYWdlIHJhdGlvIG1hdGNoZXMgdGhlIG5hdHVyYWwgb25lXG5cdFx0ICogYnkgY29tcGFyaW5nIGRpbWVuc2lvbnMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBpbWFnZVxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0Y2hlY2tIYXNOYXR1cmFsUmF0aW8oaW1hZ2UpIHtcblx0XHRcdGNvbnN0ICQgPSBpbWFnZS4kO1xuXG5cdFx0XHRjb25zdCBuYXR1cmFsID0gdGhpcy5nZXROYXR1cmFsKGltYWdlKTtcblxuXHRcdFx0Ly8gVGhlIHJlYXNvbiBmb3IgdHdvIGFsdGVybmF0aXZlIGNvbXBhcmlzb25zIGlzIHRoYXQgdGhlIHJvdW5kaW5nIGNhbiBjb21lIGZyb21cblx0XHRcdC8vIGJvdGggZGltZW5zaW9ucywgZS5nLiB0aGVyZSBhcmUgdHdvIGNhc2VzOlxuXHRcdFx0Ly8gXHQxLiBoZWlnaHQgaXMgY29tcHV0ZWQgYXMgYSByb3VuZGVkIHJlbGF0aW9uIG9mIHRoZSByZWFsIGhlaWdodCBhbmQgdGhlIHZhbHVlIG9mIHdpZHRoLFxuXHRcdFx0Ly9cdDIuIHdpZHRoIGlzIGNvbXB1dGVkIGFzIGEgcm91bmRlZCByZWxhdGlvbiBvZiB0aGUgcmVhbCB3aWR0aCBhbmQgdGhlIHZhbHVlIG9mIGhlaWdoLlxuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRNYXRoLnJvdW5kKCgkLmNsaWVudFdpZHRoIC8gbmF0dXJhbC53aWR0aCkgKiBuYXR1cmFsLmhlaWdodCkgPT1cblx0XHRcdFx0XHQkLmNsaWVudEhlaWdodCB8fFxuXHRcdFx0XHRNYXRoLnJvdW5kKCgkLmNsaWVudEhlaWdodCAvIG5hdHVyYWwuaGVpZ2h0KSAqIG5hdHVyYWwud2lkdGgpID09XG5cdFx0XHRcdFx0JC5jbGllbnRXaWR0aFxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBuYXR1cmFsIGRpbWVuc2lvbnMgb2YgdGhlIGltYWdlLiBGb3IgbW9kZXJuIGJyb3dzZXJzXG5cdFx0ICogaXQgdXNlcyBuYXR1cmFsKFdpZHRofEhlaWdodCkuIEZvciBvbGQgb25lcyAoSUU4KSBpdCBjcmVhdGVzXG5cdFx0ICogYSBuZXcgaW1hZ2UgYW5kIHJlYWRzIHRoZSBkaW1lbnNpb25zLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gaW1hZ2Vcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0Z2V0TmF0dXJhbChpbWFnZSkge1xuXHRcdFx0bGV0IGRpbWVuc2lvbnM7XG5cblx0XHRcdGlmIChpbWFnZS4kLm5hdHVyYWxXaWR0aCkge1xuXHRcdFx0XHRkaW1lbnNpb25zID0ge1xuXHRcdFx0XHRcdHdpZHRoOiBpbWFnZS4kLm5hdHVyYWxXaWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IGltYWdlLiQubmF0dXJhbEhlaWdodCxcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuXHRcdFx0XHRpbWcuc3JjID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCdzcmMnKTtcblxuXHRcdFx0XHRkaW1lbnNpb25zID0ge1xuXHRcdFx0XHRcdHdpZHRoOiBpbWcud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBpbWcuaGVpZ2h0LFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGltZW5zaW9ucztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhbiBhdHRyaWJ1dGUgZ2V0dGVyIGZ1bmN0aW9uLiBEZWZhdWx0IGdldHRlciBjb21lcyBmcm9tIHRoZSBMaW5rIHBsdWdpblxuXHRcdCAqIGFuZCBpcyBkb2N1bWVudGVkIGJ5IHtAbGluayBDS0VESVRPUi5wbHVnaW5zLmxpbmsjZ2V0TGlua0F0dHJpYnV0ZXN9LlxuXHRcdCAqXG5cdFx0ICogKipOb3RlOioqIEl0IGlzIHBvc3NpYmxlIHRvIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGFuZCB1c2UgYSBjdXN0b20gZ2V0dGVyIGUuZy5cblx0XHQgKiBpbiB0aGUgYWJzZW5jZSBvZiB0aGUgTGluayBwbHVnaW4uXG5cdFx0ICpcblx0XHQgKiAqKk5vdGU6KiogSWYgYSBjdXN0b20gZ2V0dGVyIGlzIHVzZWQsIGEgZGF0YSBtb2RlbCBmb3JtYXQgaXQgcHJvZHVjZXNcblx0XHQgKiBtdXN0IGJlIGNvbXBhdGlibGUgd2l0aCB7QGxpbmsgQ0tFRElUT1IucGx1Z2lucy5saW5rI2dldExpbmtBdHRyaWJ1dGVzfS5cblx0XHQgKlxuXHRcdCAqICoqTm90ZToqKiBBIGN1c3RvbSBnZXR0ZXIgbXVzdCB1bmRlcnN0YW5kIHRoZSBkYXRhIG1vZGVsIGZvcm1hdCBwcm9kdWNlZCBieVxuXHRcdCAqIHtAbGluayAjZ2V0TGlua0F0dHJpYnV0ZXNQYXJzZXJ9IHRvIHdvcmsgY29ycmVjdGx5LlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCBnZXRzIChjb21wb3NlcykgbGluayBhdHRyaWJ1dGVzLlxuXHRcdCAqIEBzaW5jZSA0LjUuNVxuXHRcdCAqL1xuXHRcdGdldExpbmtBdHRyaWJ1dGVzR2V0dGVyKCkge1xuXHRcdFx0Ly8gIzEzODg1XG5cblx0XHRcdHJldHVybiBDS0VESVRPUi5wbHVnaW5zLmxpbmsuZ2V0TGlua0F0dHJpYnV0ZXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYW4gYXR0cmlidXRlIHBhcnNlciBmdW5jdGlvbi4gRGVmYXVsdCBwYXJzZXIgY29tZXMgZnJvbSB0aGUgTGluayBwbHVnaW5cblx0XHQgKiBhbmQgaXMgZG9jdW1lbnRlZCBieSB7QGxpbmsgQ0tFRElUT1IucGx1Z2lucy5saW5rI3BhcnNlTGlua0F0dHJpYnV0ZXN9LlxuXHRcdCAqXG5cdFx0ICogKipOb3RlOioqIEl0IGlzIHBvc3NpYmxlIHRvIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGFuZCB1c2UgYSBjdXN0b20gcGFyc2VyIGUuZy5cblx0XHQgKiBpbiB0aGUgYWJzZW5jZSBvZiB0aGUgTGluayBwbHVnaW4uXG5cdFx0ICpcblx0XHQgKiAqKk5vdGU6KiogSWYgYSBjdXN0b20gcGFyc2VyIGlzIHVzZWQsIGEgZGF0YSBtb2RlbCBmb3JtYXQgcHJvZHVjZWQgYnkgdGhlIHBhcnNlclxuXHRcdCAqIG11c3QgYmUgY29tcGF0aWJsZSB3aXRoIHtAbGluayAjZ2V0TGlua0F0dHJpYnV0ZXNHZXR0ZXJ9LlxuXHRcdCAqXG5cdFx0ICogKipOb3RlOioqIElmIGEgY3VzdG9tIHBhcnNlciBpcyB1c2VkLCBpdCBzaG91bGQgYmUgY29tcGF0aWJsZSB3aXRoIHRoZVxuXHRcdCAqIHtAbGluayBDS0VESVRPUi5wbHVnaW5zLmxpbmsjcGFyc2VMaW5rQXR0cmlidXRlc30gZGF0YSBtb2RlbCBmb3JtYXQuIE90aGVyd2lzZSB0aGVcblx0XHQgKiBMaW5rIHBsdWdpbiBkaWFsb2cgbWF5IG5vdCBiZSBwb3B1bGF0ZWQgY29ycmVjdGx5IHdpdGggcGFyc2VkIGRhdGEuIEhvd2V2ZXJcblx0XHQgKiBhcyBsb25nIGFzIEVuaGFuY2VkIEltYWdlIGlzICoqbm90KiogdXNlZCB3aXRoIHRoZSBMaW5rIHBsdWdpbiBkaWFsb2csIGFueSBjdXN0b20gZGF0YSBtb2RlbFxuXHRcdCAqIHdpbGwgd29yaywgYmVpbmcgc3RvcmVkIGFzIGFuIGludGVybmFsIHByb3BlcnR5IG9mIEVuaGFuY2VkIEltYWdlIHdpZGdldCdzIGRhdGEgb25seS5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGF0dHJpYnV0ZXMuXG5cdFx0ICogQHNpbmNlIDQuNS41XG5cdFx0ICovXG5cdFx0Z2V0TGlua0F0dHJpYnV0ZXNQYXJzZXIoKSB7XG5cdFx0XHQvLyAjMTM4ODVcblxuXHRcdFx0cmV0dXJuIENLRURJVE9SLnBsdWdpbnMubGluay5wYXJzZUxpbmtBdHRyaWJ1dGVzO1xuXHRcdH0sXG5cdH07XG5cblx0ZnVuY3Rpb24gc2V0V3JhcHBlckFsaWduKHdpZGdldCwgYWxpZ25DbGFzc2VzKSB7XG5cdFx0Y29uc3Qgd3JhcHBlciA9IHdpZGdldC53cmFwcGVyO1xuXG5cdFx0Y29uc3QgYWxpZ24gPSB3aWRnZXQuZGF0YS5hbGlnbjtcblxuXHRcdGNvbnN0IGhhc0NhcHRpb24gPSB3aWRnZXQuZGF0YS5oYXNDYXB0aW9uO1xuXG5cdFx0aWYgKGFsaWduQ2xhc3Nlcykge1xuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBhbGlnbiBjbGFzc2VzIGZpcnN0LlxuXG5cdFx0XHRmb3IgKGxldCBpID0gMzsgaS0tOyApIHtcblx0XHRcdFx0d3JhcHBlci5yZW1vdmVDbGFzcyhhbGlnbkNsYXNzZXNbaV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYWxpZ24gPT0gJ2NlbnRlcicpIHtcblx0XHRcdFx0Ly8gQXZvaWQgdG91Y2hpbmcgbm9uLWNhcHRpb25lZCwgY2VudGVyZWQgd2lkZ2V0cyBiZWNhdXNlXG5cdFx0XHRcdC8vIHRoZXkgaGF2ZSB0aGUgY2xhc3Mgc2V0IG9uIHRoZSBlbGVtZW50IGluc3RlYWQgb2Ygd3JhcHBlcjpcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gXHQ8ZGl2IGNsYXNzPVwiY2tlX3dpZGdldF93cmFwcGVyXCI+XG5cdFx0XHRcdC8vIFx0XHQ8cCBjbGFzcz1cImNlbnRlci1jbGFzc1wiPlxuXHRcdFx0XHQvLyBcdFx0XHQ8aW1nIC8+XG5cdFx0XHRcdC8vIFx0XHQ8L3A+XG5cdFx0XHRcdC8vIFx0PC9kaXY+XG5cblx0XHRcdFx0aWYgKGhhc0NhcHRpb24pIHtcblx0XHRcdFx0XHR3cmFwcGVyLmFkZENsYXNzKGFsaWduQ2xhc3Nlc1sxXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYWxpZ24gIT0gJ25vbmUnKSB7XG5cdFx0XHRcdHdyYXBwZXIuYWRkQ2xhc3MoYWxpZ25DbGFzc2VzW2FsaWdubWVudHNPYmpbYWxpZ25dXSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChhbGlnbiA9PSAnY2VudGVyJykge1xuXHRcdFx0XHRpZiAoaGFzQ2FwdGlvbikge1xuXHRcdFx0XHRcdHdyYXBwZXIuc2V0U3R5bGUoJ3RleHQtYWxpZ24nLCAnY2VudGVyJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0d3JhcHBlci5yZW1vdmVTdHlsZSgndGV4dC1hbGlnbicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0d3JhcHBlci5yZW1vdmVTdHlsZSgnZmxvYXQnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChhbGlnbiA9PSAnbm9uZScpIHtcblx0XHRcdFx0XHR3cmFwcGVyLnJlbW92ZVN0eWxlKCdmbG9hdCcpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHdyYXBwZXIuc2V0U3R5bGUoJ2Zsb2F0JywgYWxpZ24pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0d3JhcHBlci5yZW1vdmVTdHlsZSgndGV4dC1hbGlnbicpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpbWFnZSA9IHdyYXBwZXIuJC5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcblxuXHRcdFx0Y29uc3QgaW1hZ2VTdHlsZXMgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cblx0XHRcdGlmIChpbWFnZVN0eWxlcykge1xuXHRcdFx0XHRsZXQgc3R5bGVzID0gJyc7XG5cblx0XHRcdFx0Y29uc3QgaGVpZ2h0U3R5bGVzID0gLyhoZWlnaHQ6Lis/OykvLmV4ZWMoaW1hZ2VTdHlsZXMpO1xuXHRcdFx0XHRpZiAoaGVpZ2h0U3R5bGVzKSB7XG5cdFx0XHRcdFx0c3R5bGVzICs9IGhlaWdodFN0eWxlc1swXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHdpZHRoU3R5bGVzID0gLyh3aWR0aDouKz87KS8uZXhlYyhpbWFnZVN0eWxlcyk7XG5cdFx0XHRcdGlmICh3aWR0aFN0eWxlcykge1xuXHRcdFx0XHRcdHN0eWxlcyArPSB3aWR0aFN0eWxlc1swXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGltYWdlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgd2lkZ2V0cyBmcm9tIGFsbCA8aW1nPiBhbmRcblx0Ly8gPGZpZ3VyZSBjbGFzcz1cIntjb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2NhcHRpb25lZENsYXNzfVwiPiBlbGVtZW50cy5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9IGVkaXRvclxuXHQvLyBAcmV0dXJucyB7RnVuY3Rpb259XG5cblx0ZnVuY3Rpb24gdXBjYXN0V2lkZ2V0RWxlbWVudChlZGl0b3IpIHtcblx0XHRjb25zdCBpc0NlbnRlcldyYXBwZXIgPSBjZW50ZXJXcmFwcGVyQ2hlY2tlcihlZGl0b3IpO1xuXG5cdFx0Y29uc3QgY2FwdGlvbmVkQ2xhc3MgPSBlZGl0b3IuY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9jYXB0aW9uZWRDbGFzcztcblxuXHRcdC8vIEBwYXJhbSB7Q0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50fSBlbFxuXHRcdC8vIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oZWwsIGRhdGEpIHtcblx0XHRcdGNvbnN0IGRpbWVuc2lvbnMgPSB7d2lkdGg6IDEsIGhlaWdodDogMX07XG5cblx0XHRcdGNvbnN0IG5hbWUgPSBlbC5uYW1lO1xuXG5cdFx0XHRsZXQgaW1hZ2U7XG5cblx0XHRcdC8vICMxMTExMCBEb24ndCBpbml0aWFsaXplIG9uIHBhc3RlZCBmYWtlIG9iamVjdHMuXG5cblx0XHRcdGlmIChlbC5hdHRyaWJ1dGVzWydkYXRhLWNrZS1yZWFsZWxlbWVudCddKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBjZW50ZXIgd3JhcHBlciBpcyBmb3VuZCwgdGhlcmUgYXJlIDMgcG9zc2libGUgY2FzZXM6XG5cdFx0XHQvL1xuXHRcdFx0Ly8gMS4gPGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGZpZ3VyZT4uLi48L2ZpZ3VyZT48L2Rpdj4uXG5cdFx0XHQvLyAgICBJbiB0aGlzIGNhc2UgY2VudGVyaW5nIGlzIGRvbmUgd2l0aCBhIGNsYXNzIHNldCBvbiB3aWRnZXQud3JhcHBlci5cblx0XHRcdC8vICAgIFNpbXBseSByZXBsYWNlIGNlbnRlcmluZyB3cmFwcGVyIHdpdGggZmlndXJlIChpdCdzIG5vIGxvbmdlciBuZWNlc3NhcnkpLlxuXHRcdFx0Ly9cblx0XHRcdC8vIDIuIDxwIHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48aW1nLz48L3A+LlxuXHRcdFx0Ly8gICAgTm90aGluZyB0byBkbyBoZXJlOiA8cD4gcmVtYWlucyBmb3Igc3R5bGluZyBwdXJwb3Nlcy5cblx0XHRcdC8vXG5cdFx0XHQvLyAzLiA8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48aW1nLz48L2Rpdj4uXG5cdFx0XHQvLyAgICBOb3RoaW5nIHRvIGRvIGhlcmUgKDIuKSBidXQgdGhhdCBjYXNlIGlzIG9ubHkgcG9zc2libGUgaW4gZW50ZXJNb2RlIGRpZmZlcmVudFxuXHRcdFx0Ly8gICAgdGhhbiBFTlRFUl9QLlxuXG5cdFx0XHRpZiAoaXNDZW50ZXJXcmFwcGVyKGVsKSkge1xuXHRcdFx0XHRpZiAobmFtZSA9PSAnZGl2Jykge1xuXHRcdFx0XHRcdGNvbnN0IGZpZ3VyZSA9IGVsLmdldEZpcnN0KCdmaWd1cmUnKTtcblxuXHRcdFx0XHRcdC8vIENhc2UgIzEuXG5cblx0XHRcdFx0XHRpZiAoZmlndXJlKSB7XG5cdFx0XHRcdFx0XHRlbC5yZXBsYWNlV2l0aChmaWd1cmUpO1xuXHRcdFx0XHRcdFx0ZWwgPSBmaWd1cmU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FzZXMgIzIgYW5kICMzIChoYW5kbGVkIHRyYW5zcGFyZW50bHkpXG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUncyBhIGNlbnRlcmluZyB3cmFwcGVyLCBzYXZlIGl0IGluIGRhdGEuXG5cblx0XHRcdFx0ZGF0YS5hbGlnbiA9ICdjZW50ZXInO1xuXG5cdFx0XHRcdC8vIEltYWdlIGNhbiBiZSB3cmFwcGVkIGluIGxpbmsgPGE+PGltZy8+PC9hPi5cblxuXHRcdFx0XHRpbWFnZSA9IGVsLmdldEZpcnN0KCdpbWcnKSB8fCBlbC5nZXRGaXJzdCgnYScpLmdldEZpcnN0KCdpbWcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gY2VudGVyIHdyYXBwZXIgaGFzIGJlZW4gZm91bmQuXG5cdFx0XHRlbHNlIGlmIChuYW1lID09ICdmaWd1cmUnICYmIGVsLmhhc0NsYXNzKGNhcHRpb25lZENsYXNzKSkge1xuXHRcdFx0XHRpbWFnZSA9IGVsLmdldEZpcnN0KCdpbWcnKSB8fCBlbC5nZXRGaXJzdCgnYScpLmdldEZpcnN0KCdpbWcnKTtcblxuXHRcdFx0XHQvLyBVcGNhc3QgbGlua2VkIGltYWdlIGxpa2UgPGE+PGltZy8+PC9hPi5cblx0XHRcdH0gZWxzZSBpZiAoaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZShlbCkpIHtcblx0XHRcdFx0aW1hZ2UgPSBlbC5uYW1lID09ICdhJyA/IGVsLmNoaWxkcmVuWzBdIDogZWw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaW1hZ2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIGFuIGltYWdlLCB0aGVuIGNvb2wsIHdlIGdvdCBhIHdpZGdldC5cblx0XHRcdC8vIE5vdyBqdXN0IHJlbW92ZSBkaW1lbnNpb24gYXR0cmlidXRlcyBleHByZXNzZWQgd2l0aCAlLlxuXG5cdFx0XHRmb3IgKGNvbnN0IGQgaW4gZGltZW5zaW9ucykge1xuXHRcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpbWVuc2lvbnMsIGQpKSB7XG5cdFx0XHRcdFx0Y29uc3QgZGltZW5zaW9uID0gaW1hZ2UuYXR0cmlidXRlc1tkXTtcblx0XHRcdFx0XHRpZiAoZGltZW5zaW9uICYmIGRpbWVuc2lvbi5tYXRjaChyZWdleFBlcmNlbnQpKSB7XG5cdFx0XHRcdFx0XHRkZWxldGUgaW1hZ2UuYXR0cmlidXRlc1tkXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsO1xuXHRcdH07XG5cdH1cblxuXHQvLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggdHJhbnNmb3JtcyB0aGUgd2lkZ2V0IHRvIHRoZSBleHRlcm5hbCBmb3JtYXRcblx0Ly8gYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24uXG5cdC8vXG5cdC8vIEBwYXJhbSB7Q0tFRElUT1IuZWRpdG9yfVxuXG5cdGZ1bmN0aW9uIGRvd25jYXN0V2lkZ2V0RWxlbWVudChlZGl0b3IpIHtcblx0XHRjb25zdCBhbGlnbkNsYXNzZXMgPSBlZGl0b3IuY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXM7XG5cblx0XHQvLyBAcGFyYW0ge0NLRURJVE9SLmh0bWxQYXJzZXIuZWxlbWVudH0gZWxcblxuXHRcdHJldHVybiBmdW5jdGlvbihlbCkge1xuXHRcdFx0Ly8gSW4gY2FzZSBvZiA8YT48aW1nLz48L2E+LCA8aW1nLz4gaXMgdGhlIGVsZW1lbnQgdG8gaG9sZFxuXHRcdFx0Ly8gaW5saW5lIHN0eWxlcyBvciBjbGFzc2VzIChhZV9kcmFncmVzaXplX2llMTFfYWxpZ25DbGFzc2VzKS5cblxuXHRcdFx0Y29uc3QgYXR0cnNIb2xkZXIgPSBlbC5uYW1lID09ICdhJyA/IGVsLmdldEZpcnN0KCkgOiBlbDtcblxuXHRcdFx0Y29uc3QgYXR0cnMgPSBhdHRyc0hvbGRlci5hdHRyaWJ1dGVzO1xuXG5cdFx0XHRjb25zdCBhbGlnbiA9IHRoaXMuZGF0YS5hbGlnbjtcblxuXHRcdFx0Ly8gRGUtd3JhcCB0aGUgaW1hZ2UgZnJvbSByZXNpemUgaGFuZGxlIHdyYXBwZXIuXG5cdFx0XHQvLyBPbmx5IGJsb2NrIHdpZGdldHMgaGF2ZSBvbmUuXG5cblx0XHRcdGlmICghdGhpcy5pbmxpbmUpIHtcblx0XHRcdFx0Y29uc3QgcmVzaXplV3JhcHBlciA9IGVsLmdldEZpcnN0KCdzcGFuJyk7XG5cblx0XHRcdFx0aWYgKHJlc2l6ZVdyYXBwZXIpIHtcblx0XHRcdFx0XHRyZXNpemVXcmFwcGVyLnJlcGxhY2VXaXRoKFxuXHRcdFx0XHRcdFx0cmVzaXplV3JhcHBlci5nZXRGaXJzdCh7aW1nOiAxLCBhOiAxfSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChhbGlnbiAmJiBhbGlnbiAhPSAnbm9uZScpIHtcblx0XHRcdFx0Y29uc3Qgc3R5bGVzID0gQ0tFRElUT1IudG9vbHMucGFyc2VDc3NUZXh0KGF0dHJzLnN0eWxlIHx8ICcnKTtcblxuXHRcdFx0XHQvLyBXaGVuIHRoZSB3aWRnZXQgaXMgY2FwdGlvbmVkICg8ZmlndXJlPikgYW5kIGludGVybmFsbHkgY2VudGVyaW5nIGlzIGRvbmVcblx0XHRcdFx0Ly8gd2l0aCB3aWRnZXQncyB3cmFwcGVyIHN0eWxlL2NsYXNzLCBpbiB0aGUgZXh0ZXJuYWwgZGF0YSByZXByZXNlbnRhdGlvbixcblx0XHRcdFx0Ly8gPGZpZ3VyZT4gbXVzdCBiZSB3cmFwcGVkIHdpdGggYW4gZWxlbWVudCBob2xkaW5nIGFuIHN0eWxlL2NsYXNzOlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBcdDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPlxuXHRcdFx0XHQvLyBcdFx0PGZpZ3VyZSBjbGFzcz1cImltYWdlXCIgc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9ja1wiPi4uLjwvZmlndXJlPlxuXHRcdFx0XHQvLyBcdDwvZGl2PlxuXHRcdFx0XHQvLyBvclxuXHRcdFx0XHQvLyBcdDxkaXYgY2xhc3M9XCJzb21lLWNlbnRlci1jbGFzc1wiPlxuXHRcdFx0XHQvLyBcdFx0PGZpZ3VyZSBjbGFzcz1cImltYWdlXCI+Li4uPC9maWd1cmU+XG5cdFx0XHRcdC8vIFx0PC9kaXY+XG5cdFx0XHRcdC8vXG5cblx0XHRcdFx0aWYgKGFsaWduID09ICdjZW50ZXInICYmIGVsLm5hbWUgPT0gJ2ZpZ3VyZScpIHtcblx0XHRcdFx0XHRlbCA9IGVsLndyYXBXaXRoKFxuXHRcdFx0XHRcdFx0bmV3IENLRURJVE9SLmh0bWxQYXJzZXIuZWxlbWVudChcblx0XHRcdFx0XHRcdFx0J2RpdicsXG5cdFx0XHRcdFx0XHRcdGFsaWduQ2xhc3Nlc1xuXHRcdFx0XHRcdFx0XHRcdD8ge2NsYXNzOiBhbGlnbkNsYXNzZXNbMV19XG5cdFx0XHRcdFx0XHRcdFx0OiB7c3R5bGU6ICd0ZXh0LWFsaWduOmNlbnRlcid9XG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIGxlZnQvcmlnaHQsIGFkZCBmbG9hdCBzdHlsZSB0byB0aGUgZG93bmNhc3RlZCBlbGVtZW50LlxuXHRcdFx0XHRlbHNlIGlmIChhbGlnbiBpbiB7bGVmdDogMSwgcmlnaHQ6IDF9KSB7XG5cdFx0XHRcdFx0aWYgKGFsaWduQ2xhc3Nlcykge1xuXHRcdFx0XHRcdFx0YXR0cnNIb2xkZXIuYWRkQ2xhc3MoXG5cdFx0XHRcdFx0XHRcdGFsaWduQ2xhc3Nlc1thbGlnbm1lbnRzT2JqW2FsaWduXV1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0eWxlc1snZmxvYXQnXSA9IGFsaWduO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFVwZGF0ZSBlbGVtZW50IHN0eWxlcy5cblxuXHRcdFx0XHRpZiAoIWFsaWduQ2xhc3NlcyAmJiAhQ0tFRElUT1IudG9vbHMuaXNFbXB0eShzdHlsZXMpKSB7XG5cdFx0XHRcdFx0YXR0cnMuc3R5bGUgPSBDS0VESVRPUi50b29scy53cml0ZUNzc1RleHQoc3R5bGVzKSArICc7Jztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fTtcblx0fVxuXG5cdC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBhbiBlbGVtZW50IGlzIGEgY2VudGVyaW5nIHdyYXBwZXIuXG5cdC8vXG5cdC8vIEBwYXJhbSB7Q0tFRElUT1IuZWRpdG9yfSBlZGl0b3Jcblx0Ly8gQHJldHVybnMge0Z1bmN0aW9ufVxuXG5cdGZ1bmN0aW9uIGNlbnRlcldyYXBwZXJDaGVja2VyKGVkaXRvcikge1xuXHRcdGNvbnN0IGNhcHRpb25lZENsYXNzID0gZWRpdG9yLmNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfY2FwdGlvbmVkQ2xhc3M7XG5cblx0XHRjb25zdCBhbGlnbkNsYXNzZXMgPSBlZGl0b3IuY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXM7XG5cblx0XHRjb25zdCB2YWxpZENoaWxkcmVuID0ge2ZpZ3VyZTogMSwgYTogMSwgaW1nOiAxfTtcblxuXHRcdHJldHVybiBmdW5jdGlvbihlbCkge1xuXHRcdFx0Ly8gV3JhcHBlciBtdXN0IGJlIGVpdGhlciA8ZGl2PiBvciA8cD4uXG5cblx0XHRcdGlmICghKGVsLm5hbWUgaW4ge2RpdjogMSwgcDogMX0pKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcblxuXHRcdFx0Ly8gQ2VudGVyaW5nIHdyYXBwZXIgY2FuIGhhdmUgb25seSBvbmUgY2hpbGQuXG5cblx0XHRcdGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDEpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG5cdFx0XHQvLyBPbmx5IDxmaWd1cmU+IG9yIDxpbWcgLz4gY2FuIGJlIGZpcnN0IChvbmx5KSBjaGlsZCBvZiBjZW50ZXJpbmcgd3JhcHBlcixcblx0XHRcdC8vIHJlZ2FyZGxlc3Mgb2YgaXRzIHR5cGUuXG5cblx0XHRcdGlmICghKGNoaWxkLm5hbWUgaW4gdmFsaWRDaGlsZHJlbikpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBjZW50ZXJpbmcgd3JhcHBlciBpcyA8cD4sIG9ubHkgPGltZyAvPiBjYW4gYmUgdGhlIGNoaWxkLlxuXHRcdFx0Ly8gICA8cCBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZyAvPjwvcD5cblxuXHRcdFx0aWYgKGVsLm5hbWUgPT0gJ3AnKSB7XG5cdFx0XHRcdGlmICghaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZShjaGlsZCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2VudGVyaW5nIDxkaXY+IGNhbiBob2xkIDxpbWcvPiBvciA8ZmlndXJlPiwgZGVwZW5kaW5nIG9uIGVudGVyTW9kZS5cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBJZiBhIDxmaWd1cmU+IGlzIHRoZSBmaXJzdCAob25seSkgY2hpbGQsIGl0IG11c3QgaGF2ZSBhIGNsYXNzLlxuXHRcdFx0XHQvLyAgIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxmaWd1cmU+Li4uPC9maWd1cmU+PGRpdj5cblxuXHRcdFx0XHRpZiAoY2hpbGQubmFtZSA9PSAnZmlndXJlJykge1xuXHRcdFx0XHRcdGlmICghY2hpbGQuaGFzQ2xhc3MoY2FwdGlvbmVkQ2xhc3MpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIENlbnRlcmluZyA8ZGl2PiBjYW4gaG9sZCA8aW1nLz4gb3IgPGE+PGltZy8+PC9hPiBvbmx5IHdoZW4gZW50ZXJNb2RlXG5cdFx0XHRcdFx0Ly8gaXMgRU5URVJfKEJSfERJVikuXG5cdFx0XHRcdFx0Ly8gICA8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48aW1nIC8+PC9kaXY+XG5cdFx0XHRcdFx0Ly8gICA8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48YT48aW1nIC8+PC9hPjwvZGl2PlxuXG5cdFx0XHRcdFx0aWYgKGVkaXRvci5lbnRlck1vZGUgPT0gQ0tFRElUT1IuRU5URVJfUCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlZ2FyZGxlc3Mgb2YgZW50ZXJNb2RlLCBhIGNoaWxkIHdoaWNoIGlzIG5vdCA8ZmlndXJlPiBtdXN0IGJlXG5cdFx0XHRcdFx0Ly8gZWl0aGVyIDxpbWcvPiBvciA8YT48aW1nLz48L2E+LlxuXG5cdFx0XHRcdFx0aWYgKCFpc0xpbmtlZE9yU3RhbmRhbG9uZUltYWdlKGNoaWxkKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDZW50ZXJpbmcgd3JhcHBlciBnb3QgdG8gYmUuLi4gY2VudGVyaW5nLiBJZiBhZV9kcmFncmVzaXplX2llMTFfYWxpZ25DbGFzc2VzIGFyZSBkZWZpbmVkLFxuXHRcdFx0Ly8gY2hlY2sgZm9yIGNlbnRlcmluZyBjbGFzcy4gT3RoZXJ3aXNlLCBjaGVjayB0aGUgc3R5bGUuXG5cblx0XHRcdGlmIChcblx0XHRcdFx0YWxpZ25DbGFzc2VzXG5cdFx0XHRcdFx0PyBlbC5oYXNDbGFzcyhhbGlnbkNsYXNzZXNbMV0pXG5cdFx0XHRcdFx0OiBDS0VESVRPUi50b29scy5wYXJzZUNzc1RleHQoXG5cdFx0XHRcdFx0XHRcdGVsLmF0dHJpYnV0ZXMuc3R5bGUgfHwgJycsXG5cdFx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQgIClbJ3RleHQtYWxpZ24nXSA9PSAnY2VudGVyJ1xuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0fVxuXG5cdC8vIENoZWNrcyB3aGV0aGVyIGVsZW1lbnQgaXMgPGltZy8+IG9yIDxhPjxpbWcvPjwvYT4uXG5cdC8vXG5cdC8vIEBwYXJhbSB7Q0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50fVxuXG5cdGZ1bmN0aW9uIGlzTGlua2VkT3JTdGFuZGFsb25lSW1hZ2UoZWwpIHtcblx0XHRpZiAoZWwubmFtZSA9PSAnaW1nJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIGlmIChlbC5uYW1lID09ICdhJykge1xuXHRcdFx0cmV0dXJuIGVsLmNoaWxkcmVuLmxlbmd0aCA9PSAxICYmIGVsLmdldEZpcnN0KCdpbWcnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBTZXRzIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHdpZGdldCBpbWFnZSBhY2NvcmRpbmcgdG8gY3VycmVudCB3aWRnZXQgZGF0YS5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5wbHVnaW5zLndpZGdldH0gd2lkZ2V0XG5cblx0ZnVuY3Rpb24gc2V0RGltZW5zaW9ucyh3aWRnZXQpIHtcblx0XHRjb25zdCBkYXRhID0gd2lkZ2V0LmRhdGE7XG5cblx0XHRjb25zdCBkaW1lbnNpb25zID0ge1xuXHRcdFx0d2lkdGg6IGRhdGEud2lkdGgsXG5cdFx0XHRoZWlnaHQ6IGRhdGEubG9jayA/IG51bGwgOiBkYXRhLmhlaWdodCxcblx0XHR9O1xuXG5cdFx0Y29uc3QgaW1hZ2UgPSB3aWRnZXQucGFydHMuaW1hZ2U7XG5cblx0XHRmb3IgKGNvbnN0IGQgaW4gZGltZW5zaW9ucykge1xuXHRcdFx0aWYgKGRpbWVuc2lvbnNbZF0pIHtcblx0XHRcdFx0aW1hZ2Uuc2V0QXR0cmlidXRlKGQsIGRpbWVuc2lvbnNbZF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW1hZ2UucmVtb3ZlQXR0cmlidXRlKGQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIERlZmluZXMgYWxsIGZlYXR1cmVzIHJlbGF0ZWQgdG8gZHJhZy1kcml2ZW4gaW1hZ2UgcmVzaXppbmcuXG5cdC8vXG5cdC8vIEBwYXJhbSB7Q0tFRElUT1IucGx1Z2lucy53aWRnZXR9IHdpZGdldFxuXG5cdGZ1bmN0aW9uIHNldHVwUmVzaXplcih3aWRnZXQpIHtcblx0XHRjb25zdCBlZGl0b3IgPSB3aWRnZXQuZWRpdG9yO1xuXG5cdFx0Y29uc3QgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuXHRcdGNvbnN0IGRvYyA9IGVkaXRvci5kb2N1bWVudDtcblxuXHRcdC8vIFN0b3JlIHRoZSByZXNpemVyIGluIGEgd2lkZ2V0IGZvciB0ZXN0aW5nICgjMTEwMDQpLlxuXG5cdFx0Y29uc3QgcmVzaXplciA9ICh3aWRnZXQucmVzaXplciA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJykpO1xuXG5cdFx0Ly8gQ3JlYXRlIHJlc2l6ZXIgZm9yIGVhY2ggY29ybmVyIChORSwgTlcsIFNFLCBTVylcblxuXHRcdGNvbnN0IHJlc2l6ZXJORSA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cblx0XHRjb25zdCByZXNpemVyTlcgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG5cdFx0Y29uc3QgcmVzaXplclNFID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblxuXHRcdGNvbnN0IHJlc2l6ZXJTVyA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cblx0XHRyZXNpemVyTkUuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyJyk7XG5cdFx0cmVzaXplck5FLmFkZENsYXNzKCdja2VfaW1hZ2VfcmVzaXplcl9uZScpO1xuXG5cdFx0cmVzaXplck5XLmFkZENsYXNzKCdja2VfaW1hZ2VfcmVzaXplcicpO1xuXHRcdHJlc2l6ZXJOVy5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXJfbncnKTtcblxuXHRcdHJlc2l6ZXJTRS5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXInKTtcblx0XHRyZXNpemVyU0UuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyX3NlJyk7XG5cblx0XHRyZXNpemVyU1cuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyJyk7XG5cdFx0cmVzaXplclNXLmFkZENsYXNzKCdja2VfaW1hZ2VfcmVzaXplcl9zdycpO1xuXG5cdFx0Ly8gQWRkIGVhY2ggZGlyZWN0aW9uYWwgcmVzaXplciBhcyBhIGNoaWxkIG9mIHJlc2l6ZXJcblxuXHRcdHJlc2l6ZXIuYXBwZW5kKHJlc2l6ZXJORSk7XG5cdFx0cmVzaXplci5hcHBlbmQocmVzaXplck5XKTtcblx0XHRyZXNpemVyLmFwcGVuZChyZXNpemVyU0UpO1xuXHRcdHJlc2l6ZXIuYXBwZW5kKHJlc2l6ZXJTVyk7XG5cblx0XHQvLyByZXNpemVyLnNldEF0dHJpYnV0ZSggJ3RpdGxlJywgZWRpdG9yLmxhbmcuYWVfZHJhZ3Jlc2l6ZV9pZTExLnJlc2l6ZXIgKTtcblxuXHRcdHJlc2l6ZXIuYXBwZW5kKG5ldyBDS0VESVRPUi5kb20udGV4dCgnXFx1MjAwYicsIGRvYykpO1xuXG5cdFx0Ly8gSW5saW5lIHdpZGdldHMgZG9uJ3QgbmVlZCBhIHJlc2l6ZXIgd3JhcHBlciBhcyBhbiBpbWFnZSBzcGFucyB0aGUgZW50aXJlIHdpZGdldC5cblxuXHRcdGlmICghd2lkZ2V0LmlubGluZSkge1xuXHRcdFx0Y29uc3QgaW1hZ2VPckxpbmsgPSB3aWRnZXQucGFydHMubGluayB8fCB3aWRnZXQucGFydHMuaW1hZ2U7XG5cblx0XHRcdGNvbnN0IG9sZFJlc2l6ZVdyYXBwZXIgPSBpbWFnZU9yTGluay5nZXRQYXJlbnQoKTtcblxuXHRcdFx0Y29uc3QgcmVzaXplV3JhcHBlciA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cblx0XHRcdHJlc2l6ZVdyYXBwZXIuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyX3dyYXBwZXInKTtcblx0XHRcdHJlc2l6ZVdyYXBwZXIuYXBwZW5kKGltYWdlT3JMaW5rKTtcblx0XHRcdHJlc2l6ZVdyYXBwZXIuYXBwZW5kKHJlc2l6ZXIpO1xuXHRcdFx0d2lkZ2V0LmVsZW1lbnQuYXBwZW5kKHJlc2l6ZVdyYXBwZXIsIHRydWUpO1xuXG5cdFx0XHQvLyBSZW1vdmUgdGhlIG9sZCB3cmFwcGVyIHdoaWNoIGNvdWxkIGNhbWUgZnJvbSBlLmcuIHBhc3RlZCBIVE1MXG5cdFx0XHQvLyBhbmQgd2hpY2ggY291bGQgYmUgY29ycnVwdGVkIChlLmcuIHJlc2l6ZXIgc3BhbiBoYXMgYmVlbiBsb3N0KS5cblxuXHRcdFx0aWYgKG9sZFJlc2l6ZVdyYXBwZXIuaXMoJ3NwYW4nKSkge1xuXHRcdFx0XHRvbGRSZXNpemVXcmFwcGVyLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aWRnZXQud3JhcHBlci5hcHBlbmQocmVzaXplcik7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHZhbHVlcyBvZiBzaXplIHZhcmlhYmxlcyBhbmQgbW91c2Ugb2Zmc2V0cy5cblxuXHRcdHJlc2l6ZXIub24oJ21vdXNlZG93bicsIGV2dCA9PiB7XG5cdFx0XHRjb25zdCBpbWFnZSA9IHdpZGdldC5wYXJ0cy5pbWFnZTtcblxuXHRcdFx0Ly8gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgbW91c2UgcmVsYXRpdmUgdG8gdGhlIHNjcmVlblxuXHRcdFx0Ly8gd2hlbiBidXR0b24gZ2V0cyBwcmVzc2VkLlxuXG5cdFx0XHRjb25zdCBzdGFydFggPSBldnQuZGF0YS4kLnNjcmVlblg7XG5cblx0XHRcdGNvbnN0IHN0YXJ0WSA9IGV2dC5kYXRhLiQuc2NyZWVuWTtcblxuXHRcdFx0Ly8gVGhlIGluaXRpYWwgZGltZW5zaW9ucyBhbmQgYXNwZWN0IHJhdGlvIG9mIHRoZSBpbWFnZS5cblxuXHRcdFx0Y29uc3Qgc3RhcnRXaWR0aCA9IGltYWdlLiQuY2xpZW50V2lkdGg7XG5cblx0XHRcdGNvbnN0IHN0YXJ0SGVpZ2h0ID0gaW1hZ2UuJC5jbGllbnRIZWlnaHQ7XG5cblx0XHRcdGNvbnN0IHJhdGlvID0gc3RhcnRXaWR0aCAvIHN0YXJ0SGVpZ2h0O1xuXG5cdFx0XHRjb25zdCBsaXN0ZW5lcnMgPSBbXTtcblxuXHRcdFx0Y29uc3QgdGFyZ2V0ID0gZXZ0LmRhdGEuZ2V0VGFyZ2V0KCk7XG5cblx0XHRcdGxldCBmYWN0b3JYO1xuXG5cdFx0XHRsZXQgZmFjdG9yWTtcblxuXHRcdFx0bGV0IG1vdmVEaWZmWDtcblxuXHRcdFx0bGV0IG1vdmVEaWZmWTtcblxuXHRcdFx0bGV0IG5hdGl2ZUV2dDtcblxuXHRcdFx0bGV0IG5ld0hlaWdodDtcblxuXHRcdFx0bGV0IG5ld1dpZHRoO1xuXG5cdFx0XHRsZXQgdXBkYXRlRGF0YTtcblxuXHRcdFx0Ly8gXCJmYWN0b3JYXCIgYW5kIFwiZmFjdG9yWVwiIGNhbiBiZSBlaXRoZXIgMSBvciAtMS4gSS5lLjogV2UgbmVlZCB0b1xuXHRcdFx0Ly8gYWRkL3N1YnRyYWN0IHRoZSBkaWZmZXJlbmNlIHRvIGdldCBwcm9wZXIgd2lkdGgsIGV0Yy4gV2l0aG91dCBcImZhY3RvclhcIlxuXHRcdFx0Ly8gYW5kIFwiZmFjdG9yWVwiLCByZXNpemVyIHN0YXJ0cyB3b3JraW5nIHRoZSBvcHBvc2l0ZSB3YXkuXG5cblx0XHRcdGlmICh0YXJnZXQuaGFzQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyX25lJykpIHtcblx0XHRcdFx0ZmFjdG9yWCA9IDE7XG5cdFx0XHRcdGZhY3RvclkgPSAxO1xuXHRcdFx0fSBlbHNlIGlmICh0YXJnZXQuaGFzQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyX253JykpIHtcblx0XHRcdFx0ZmFjdG9yWCA9IC0xO1xuXHRcdFx0XHRmYWN0b3JZID0gMTtcblx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0Lmhhc0NsYXNzKCdja2VfaW1hZ2VfcmVzaXplcl9zZScpKSB7XG5cdFx0XHRcdGZhY3RvclggPSAxO1xuXHRcdFx0XHRmYWN0b3JZID0gLTE7XG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldC5oYXNDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXJfc3cnKSkge1xuXHRcdFx0XHRmYWN0b3JYID0gLTE7XG5cdFx0XHRcdGZhY3RvclkgPSAtMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQSBjbGFzcyBhcHBsaWVkIHRvIGVkaXRhYmxlIGR1cmluZyByZXNpemluZy5cblxuXHRcdFx0Y29uc3QgY3Vyc29yQ2xhc3MgPVxuXHRcdFx0XHQnY2tlX2ltYWdlXycgK1xuXHRcdFx0XHQoIX5mYWN0b3JZID8gJ3MnIDogJ24nKSArXG5cdFx0XHRcdCghfmZhY3RvclggPyAndycgOiAnZScpO1xuXG5cdFx0XHQvLyBTYXZlIHRoZSB1bmRvIHNuYXBzaG90IGZpcnN0OiBiZWZvcmUgcmVzaXppbmcuXG5cblx0XHRcdGVkaXRvci5maXJlKCdzYXZlU25hcHNob3QnKTtcblxuXHRcdFx0Ly8gTW91c2Vtb3ZlIGxpc3RlbmVycyBhcmUgcmVtb3ZlZCBvbiBtb3VzZXVwLlxuXG5cdFx0XHRhdHRhY2hUb0RvY3VtZW50cygnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGxpc3RlbmVycyk7XG5cblx0XHRcdC8vIENsZWFuIHVwIHRoZSBtb3VzZW1vdmUgbGlzdGVuZXIuIFVwZGF0ZSB3aWRnZXQgZGF0YSBpZiB2YWxpZC5cblxuXHRcdFx0YXR0YWNoVG9Eb2N1bWVudHMoJ21vdXNldXAnLCBvbk1vdXNlVXAsIGxpc3RlbmVycyk7XG5cblx0XHRcdC8vIFRoZSBlbnRpcmUgZWRpdGFibGUgd2lsbCBoYXZlIHRoZSBzcGVjaWFsIGN1cnNvciB3aGlsZSByZXNpemluZyBnb2VzIG9uLlxuXG5cdFx0XHRlZGl0YWJsZS5hZGRDbGFzcyhjdXJzb3JDbGFzcyk7XG5cblx0XHRcdC8vIFRoaXMgaXMgdG8gYWx3YXlzIGtlZXAgdGhlIHJlc2l6ZXIgZWxlbWVudCB2aXNpYmxlIHdoaWxlIHJlc2l6aW5nLlxuXG5cdFx0XHRyZXNpemVyLmFkZENsYXNzKCdja2VfaW1hZ2VfcmVzaXppbmcnKTtcblxuXHRcdFx0Ly8gQXR0YWNoZXMgYW4gZXZlbnQgdG8gYSBnbG9iYWwgZG9jdW1lbnQgaWYgaW5saW5lIGVkaXRvci5cblx0XHRcdC8vIEFkZGl0aW9uYWxseSwgaWYgY2xhc3NpYyAoYGlmcmFtZWAtYmFzZWQpIGVkaXRvciwgYWxzbyBhdHRhY2hlcyB0aGUgc2FtZSBldmVudCB0byBgaWZyYW1lYCdzIGRvY3VtZW50LlxuXG5cdFx0XHRmdW5jdGlvbiBhdHRhY2hUb0RvY3VtZW50cyhuYW1lLCBjYWxsYmFjaywgY29sbGVjdGlvbikge1xuXHRcdFx0XHRjb25zdCBnbG9iYWxEb2MgPSBDS0VESVRPUi5kb2N1bWVudDtcblxuXHRcdFx0XHRjb25zdCBsaXN0ZW5lcnMgPSBbXTtcblxuXHRcdFx0XHRpZiAoIWRvYy5lcXVhbHMoZ2xvYmFsRG9jKSkge1xuXHRcdFx0XHRcdGxpc3RlbmVycy5wdXNoKGdsb2JhbERvYy5vbihuYW1lLCBjYWxsYmFjaykpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGlzdGVuZXJzLnB1c2goZG9jLm9uKG5hbWUsIGNhbGxiYWNrKSk7XG5cblx0XHRcdFx0aWYgKGNvbGxlY3Rpb24pIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gbGlzdGVuZXJzLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdFx0XHRcdGNvbGxlY3Rpb24ucHVzaChsaXN0ZW5lcnMucG9wKCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxjdWxhdGUgd2lkdGggZmlyc3QsIGFuZCB0aGVuIGFkanVzdCBoZWlnaHQsIHByZXNlcnZpbmcgcmF0aW8uXG5cblx0XHRcdGZ1bmN0aW9uIGFkanVzdFRvWCgpIHtcblx0XHRcdFx0bmV3V2lkdGggPSBzdGFydFdpZHRoICsgZmFjdG9yWCAqIG1vdmVEaWZmWDtcblx0XHRcdFx0bmV3SGVpZ2h0ID0gTWF0aC5yb3VuZChuZXdXaWR0aCAvIHJhdGlvKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGhlaWdodCBmaXJzdCwgYW5kIHRoZW4gYWRqdXN0IHdpZHRoLCBwcmVzZXJ2aW5nIHJhdGlvLlxuXG5cdFx0XHRmdW5jdGlvbiBhZGp1c3RUb1koKSB7XG5cdFx0XHRcdG5ld0hlaWdodCA9IHN0YXJ0SGVpZ2h0ICsgZmFjdG9yWSAqIG1vdmVEaWZmWTtcblx0XHRcdFx0bmV3V2lkdGggPSBNYXRoLnJvdW5kKG5ld0hlaWdodCAqIHJhdGlvKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhpcyBpcyBob3cgdmFyaWFibGVzIHJlZmVyIHRvIHRoZSBnZW9tZXRyeS5cblx0XHRcdC8vIE5vdGU6IHggY29ycmVzcG9uZHMgdG8gbW92ZU9mZnNldCwgdGhpcyBpcyB0aGUgcG9zaXRpb24gb2YgbW91c2Vcblx0XHRcdC8vIE5vdGU6IG8gY29ycmVzcG9uZHMgdG8gW3N0YXJ0WCwgc3RhcnRZXS5cblx0XHRcdC8vXG5cdFx0XHQvLyBcdCstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLStcblx0XHRcdC8vIFx0fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuXHRcdFx0Ly8gXHR8ICAgICAgSSAgICAgICB8ICAgICAgSUkgICAgICB8XG5cdFx0XHQvLyBcdHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcblx0XHRcdC8vIFx0Ky0tLS0tLS0tLS0tLS0gbyAtLS0tLS0tLS0tLS0tKyBfIF8gX1xuXHRcdFx0Ly8gXHR8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICAgXlxuXHRcdFx0Ly8gXHR8ICAgICAgVkkgICAgICB8ICAgICBJSUkgICAgICB8ICAgICAgfCBtb3ZlRGlmZllcblx0XHRcdC8vIFx0fCAgICAgICAgICAgICAgfCAgICAgICAgIHggXyBfIF8gXyBfIHZcblx0XHRcdC8vIFx0Ky0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLXwtLS0tK1xuXHRcdFx0Ly8gXHQgICAgICAgICAgICAgICB8ICAgICAgICAgfFxuXHRcdFx0Ly8gXHQgICAgICAgICAgICAgICAgPC0tLS0tLS0+XG5cdFx0XHQvLyBcdCAgICAgICAgICAgICAgICBtb3ZlRGlmZlhcblxuXHRcdFx0ZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZ0KSB7XG5cdFx0XHRcdG5hdGl2ZUV2dCA9IGV2dC5kYXRhLiQ7XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyBob3cgZmFyIHRoZSBtb3VzZSBpcyBmcm9tIHRoZSBwb2ludCB0aGUgYnV0dG9uIHdhcyBwcmVzc2VkLlxuXG5cdFx0XHRcdG1vdmVEaWZmWCA9IG5hdGl2ZUV2dC5zY3JlZW5YIC0gc3RhcnRYO1xuXHRcdFx0XHRtb3ZlRGlmZlkgPSBzdGFydFkgLSBuYXRpdmVFdnQuc2NyZWVuWTtcblxuXHRcdFx0XHQvLyBSZXNpemUgd2l0aCBORSwgU0UgZHJhZyBoYW5kbGVzXG5cblx0XHRcdFx0aWYgKGZhY3RvclggPT0gMSkge1xuXHRcdFx0XHRcdGlmIChtb3ZlRGlmZlggPD0gMCkge1xuXHRcdFx0XHRcdFx0YWRqdXN0VG9ZKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGFkanVzdFRvWCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc2l6ZSB3aXRoIE5XLCBTVyBkcmFnIGhhbmRsZXNcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKG1vdmVEaWZmWCA8PSAwKSB7XG5cdFx0XHRcdFx0XHRhZGp1c3RUb1goKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YWRqdXN0VG9ZKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRG9uJ3QgdXBkYXRlIGF0dHJpYnV0ZXMgaWYgbGVzcyB0aGFuIDEwLlxuXHRcdFx0XHQvLyBUaGlzIGlzIHRvIHByZXZlbnQgaW1hZ2VzIHRvIHZpc3VhbGx5IGRpc2FwcGVhci5cblxuXHRcdFx0XHRpZiAobmV3V2lkdGggPj0gMTUgJiYgbmV3SGVpZ2h0ID49IDE1KSB7XG5cdFx0XHRcdFx0aW1hZ2UuJC5zdHlsZS53aWR0aCA9IG5ld1dpZHRoICsgJ3B4Jztcblx0XHRcdFx0XHRpbWFnZS4kLnN0eWxlLmhlaWdodCA9IHdpZGdldC5kYXRhLmxvY2tcblx0XHRcdFx0XHRcdD8gJ2F1dG8nXG5cdFx0XHRcdFx0XHQ6IG5ld0hlaWdodCArICdweCc7XG5cblx0XHRcdFx0XHR1cGRhdGVEYXRhID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR1cGRhdGVEYXRhID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuXHRcdFx0XHRsZXQgbDtcblxuXHRcdFx0XHR3aGlsZSAoKGwgPSBsaXN0ZW5lcnMucG9wKCkpKSB7XG5cdFx0XHRcdFx0bC5yZW1vdmVMaXN0ZW5lcigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSBkZWZhdWx0IGN1cnNvciBieSByZW1vdmluZyBzcGVjaWFsIGNsYXNzLlxuXG5cdFx0XHRcdGVkaXRhYmxlLnJlbW92ZUNsYXNzKGN1cnNvckNsYXNzKTtcblxuXHRcdFx0XHQvLyBUaGlzIGlzIHRvIGJyaW5nIGJhY2sgdGhlIHJlZ3VsYXIgYmVoYXZpb3VyIG9mIHRoZSByZXNpemVyLlxuXG5cdFx0XHRcdHJlc2l6ZXIucmVtb3ZlQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemluZycpO1xuXG5cdFx0XHRcdGlmICh1cGRhdGVEYXRhKSB7XG5cdFx0XHRcdFx0d2lkZ2V0LnNldERhdGEoe1xuXHRcdFx0XHRcdFx0aGVpZ2h0OiB3aWRnZXQuZGF0YS5sb2NrID8gbnVsbCA6IG5ld0hlaWdodCxcblx0XHRcdFx0XHRcdHdpZHRoOiBuZXdXaWR0aCxcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8vIFNhdmUgYW5vdGhlciB1bmRvIHNuYXBzaG90OiBhZnRlciByZXNpemluZy5cblxuXHRcdFx0XHRcdGVkaXRvci5maXJlKCdzYXZlU25hcHNob3QnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIERvbid0IHVwZGF0ZSBkYXRhIHR3aWNlIG9yIG1vcmUuXG5cblx0XHRcdFx0dXBkYXRlRGF0YSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGFsaWdubWVudCB2YWx1ZSBvZiBhbiBpbWFnZVxuXHQgKlxuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBpbWFnZSBUaGUgaW1hZ2UgZWxlbWVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW1hZ2VBbGlnbm1lbnQgVGhlIGltYWdlIGFsaWdubWVudCB2YWx1ZSB0byBiZSByZW1vdmVkXG5cdCAqL1xuXHRjb25zdCByZW1vdmVXaWRnZXRBbGlnbm1lbnQgPSBmdW5jdGlvbih3aWRnZXQsIGltYWdlQWxpZ25tZW50KSB7XG5cdFx0aWYgKGltYWdlQWxpZ25tZW50ID09PSAnbGVmdCcgfHwgaW1hZ2VBbGlnbm1lbnQgPT09ICdyaWdodCcpIHtcblx0XHRcdHdpZGdldC53cmFwcGVyLnJlbW92ZVN0eWxlKCdmbG9hdCcpO1xuXHRcdH0gZWxzZSBpZiAoaW1hZ2VBbGlnbm1lbnQgPT09ICdjZW50ZXInKSB7XG5cdFx0XHR3aWRnZXQuZWRpdG9yLmV4ZWNDb21tYW5kKCdqdXN0aWZ5bGVmdCcpO1xuXHRcdFx0d2lkZ2V0LmVkaXRvci5leGVjQ29tbWFuZCgnanVzdGlmeWxlZnQnKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gSW50ZWdyYXRlcyB3aWRnZXQgYWxpZ25tZW50IHNldHRpbmcgd2l0aCBqdXN0aWZ5XG5cdC8vIHBsdWdpbidzIGNvbW1hbmRzIChleGVjdXRpb24gYW5kIHJlZnJlc2htZW50KS5cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9IGVkaXRvclxuXHQvLyBAcGFyYW0ge1N0cmluZ30gdmFsdWUgJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJyBvciAnYmxvY2snXG5cblx0ZnVuY3Rpb24gYWxpZ25Db21tYW5kSW50ZWdyYXRvcihlZGl0b3IpIHtcblx0XHRjb25zdCBleGVjQ2FsbGJhY2tzID0gW107XG5cblx0XHRsZXQgZW5hYmxlZDtcblxuXHRcdHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0Y29uc3QgY29tbWFuZCA9IGVkaXRvci5nZXRDb21tYW5kKCdqdXN0aWZ5JyArIHZhbHVlKTtcblxuXHRcdFx0Ly8gTW9zdCBsaWtlbHksIHRoZSBqdXN0aWZ5IHBsdWdpbiBpc24ndCBsb2FkZWQuXG5cblx0XHRcdGlmICghY29tbWFuZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoaXMgY29tbWFuZCB3aWxsIGJlIG1hbnVhbGx5IHJlZnJlc2hlZCBhbG9uZyB3aXRoXG5cdFx0XHQvLyBvdGhlciBjb21tYW5kcyBhZnRlciBleGVjLlxuXG5cdFx0XHRleGVjQ2FsbGJhY2tzLnB1c2goKCkgPT4ge1xuXHRcdFx0XHRjb21tYW5kLnJlZnJlc2goZWRpdG9yLCBlZGl0b3IuZWxlbWVudFBhdGgoKSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHZhbHVlIGluIHtyaWdodDogMSwgbGVmdDogMSwgY2VudGVyOiAxfSkge1xuXHRcdFx0XHRjb21tYW5kLm9uKCdleGVjJywgZXZ0ID0+IHtcblx0XHRcdFx0XHRjb25zdCB3aWRnZXQgPSBnZXRGb2N1c2VkV2lkZ2V0KGVkaXRvcik7XG5cblx0XHRcdFx0XHRpZiAod2lkZ2V0KSB7XG5cdFx0XHRcdFx0XHRpZiAod2lkZ2V0LmRhdGEuYWxpZ24gPT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZVdpZGdldEFsaWdubWVudCh3aWRnZXQsIHZhbHVlKTtcblxuXHRcdFx0XHRcdFx0XHRkZWxldGUgd2lkZ2V0LmRhdGEuYWxpZ247XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR3aWRnZXQuc2V0RGF0YSgnYWxpZ24nLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE9uY2UgdGhlIHdpZGdldCBjaGFuZ2VkIGl0cyBhbGlnbiwgYWxsIHRoZSBhbGlnbiBjb21tYW5kc1xuXHRcdFx0XHRcdFx0Ly8gbXVzdCBiZSByZWZyZXNoZWQ6IHRoZSBldmVudCBpcyB0byBiZSBjYW5jZWxsZWQuXG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSBleGVjQ2FsbGJhY2tzLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdFx0XHRcdFx0ZXhlY0NhbGxiYWNrc1tpXSgpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRldnQuY2FuY2VsKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Y29tbWFuZC5vbigncmVmcmVzaCcsIGZ1bmN0aW9uKGV2dCkge1xuXHRcdFx0XHRjb25zdCB3aWRnZXQgPSBnZXRGb2N1c2VkV2lkZ2V0KGVkaXRvcik7XG5cblx0XHRcdFx0Y29uc3QgYWxsb3dlZCA9IHtyaWdodDogMSwgbGVmdDogMSwgY2VudGVyOiAxfTtcblxuXHRcdFx0XHRpZiAoIXdpZGdldCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhY2hlIFwiZW5hYmxlZFwiIG9uIGZpcnN0IHVzZS4gVGhpcyBpcyBiZWNhdXNlIGZpbHRlciNjaGVja0ZlYXR1cmUgbWF5XG5cdFx0XHRcdC8vIG5vdCBiZSBhdmFpbGFibGUgZHVyaW5nIHBsdWdpbidzIGFmdGVySW5pdCBpbiB0aGUgZnV0dXJlIOKAlCBhIG1vbWVudCB3aGVuXG5cdFx0XHRcdC8vIGFsaWduQ29tbWFuZEludGVncmF0b3IgaXMgY2FsbGVkLlxuXG5cdFx0XHRcdGlmIChlbmFibGVkID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRlbmFibGVkID0gZWRpdG9yLmZpbHRlci5jaGVja0ZlYXR1cmUoXG5cdFx0XHRcdFx0XHRlZGl0b3Iud2lkZ2V0cy5yZWdpc3RlcmVkLmltYWdlLmZlYXR1cmVzLmFsaWduXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIERvbid0IGFsbG93IGp1c3RpZnkgY29tbWFuZHMgd2hlbiB3aWRnZXQgYWxpZ25tZW50IGlzIGRpc2FibGVkICgjMTEwMDQpLlxuXG5cdFx0XHRcdGlmICghZW5hYmxlZCkge1xuXHRcdFx0XHRcdHRoaXMuc2V0U3RhdGUoQ0tFRElUT1IuVFJJU1RBVEVfRElTQUJMRUQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuc2V0U3RhdGUoXG5cdFx0XHRcdFx0XHR3aWRnZXQuZGF0YS5hbGlnbiA9PSB2YWx1ZVxuXHRcdFx0XHRcdFx0XHQ/IENLRURJVE9SLlRSSVNUQVRFX09OXG5cdFx0XHRcdFx0XHRcdDogdmFsdWUgaW4gYWxsb3dlZFxuXHRcdFx0XHRcdFx0XHQ/IENLRURJVE9SLlRSSVNUQVRFX09GRlxuXHRcdFx0XHRcdFx0XHQ6IENLRURJVE9SLlRSSVNUQVRFX0RJU0FCTEVEXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGV2dC5jYW5jZWwoKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdH1cblxuXHQvLyBSZXR1cm5zIHRoZSBmb2N1c2VkIHdpZGdldCwgaWYgb2YgdGhlIHR5cGUgc3BlY2lmaWMgZm9yIHRoaXMgcGx1Z2luLlxuXHQvLyBJZiBubyB3aWRnZXQgaXMgZm9jdXNlZCwgYG51bGxgIGlzIHJldHVybmVkLlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn1cblx0Ly8gQHJldHVybnMge0NLRURJVE9SLnBsdWdpbnMud2lkZ2V0fVxuXG5cdGZ1bmN0aW9uIGdldEZvY3VzZWRXaWRnZXQoZWRpdG9yKSB7XG5cdFx0Y29uc3Qgd2lkZ2V0ID0gZWRpdG9yLndpZGdldHMuZm9jdXNlZDtcblxuXHRcdGlmICh3aWRnZXQgJiYgd2lkZ2V0Lm5hbWUgPT0gJ2ltYWdlJykge1xuXHRcdFx0cmV0dXJuIHdpZGdldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFJldHVybnMgYSBzZXQgb2Ygd2lkZ2V0IGFsbG93ZWRDb250ZW50IHJ1bGVzLCBkZXBlbmRpbmdcblx0Ly8gb24gY29uZmlndXJhdGlvbnMgbGlrZSBjb25maWcjYWVfZHJhZ3Jlc2l6ZV9pZTExX2FsaWduQ2xhc3NlcyBvclxuXHQvLyBjb25maWcjYWVfZHJhZ3Jlc2l6ZV9pZTExX2NhcHRpb25lZENsYXNzLlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn1cblx0Ly8gQHJldHVybnMge09iamVjdH1cblxuXHRmdW5jdGlvbiBnZXRXaWRnZXRBbGxvd2VkQ29udGVudChlZGl0b3IpIHtcblx0XHRjb25zdCBhbGlnbkNsYXNzZXMgPSBlZGl0b3IuY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXM7XG5cblx0XHRjb25zdCBydWxlcyA9IHtcblx0XHRcdC8vIFdpZGdldCBtYXkgbmVlZCA8ZGl2PiBvciA8cD4gY2VudGVyaW5nIHdyYXBwZXIuXG5cblx0XHRcdGRpdjoge1xuXHRcdFx0XHRtYXRjaDogY2VudGVyV3JhcHBlckNoZWNrZXIoZWRpdG9yKSxcblx0XHRcdH0sXG5cdFx0XHRwOiB7XG5cdFx0XHRcdG1hdGNoOiBjZW50ZXJXcmFwcGVyQ2hlY2tlcihlZGl0b3IpLFxuXHRcdFx0fSxcblx0XHRcdGltZzoge1xuXHRcdFx0XHRhdHRyaWJ1dGVzOiAnIXNyYyxhbHQsd2lkdGgsaGVpZ2h0Jyxcblx0XHRcdH0sXG5cdFx0XHRmaWd1cmU6IHtcblx0XHRcdFx0Y2xhc3NlczogJyEnICsgZWRpdG9yLmNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfY2FwdGlvbmVkQ2xhc3MsXG5cdFx0XHR9LFxuXHRcdFx0ZmlnY2FwdGlvbjogdHJ1ZSxcblx0XHR9O1xuXG5cdFx0aWYgKGFsaWduQ2xhc3Nlcykge1xuXHRcdFx0Ly8gQ2VudGVyaW5nIGNsYXNzIGZyb20gdGhlIGNvbmZpZy5cblxuXHRcdFx0cnVsZXMuZGl2LmNsYXNzZXMgPSBhbGlnbkNsYXNzZXNbMV07XG5cdFx0XHRydWxlcy5wLmNsYXNzZXMgPSBydWxlcy5kaXYuY2xhc3NlcztcblxuXHRcdFx0Ly8gTGVmdC9yaWdodCBjbGFzc2VzIGZyb20gdGhlIGNvbmZpZy5cblxuXHRcdFx0cnVsZXMuaW1nLmNsYXNzZXMgPSBhbGlnbkNsYXNzZXNbMF0gKyAnLCcgKyBhbGlnbkNsYXNzZXNbMl07XG5cdFx0XHRydWxlcy5maWd1cmUuY2xhc3NlcyArPSAnLCcgKyBydWxlcy5pbWcuY2xhc3Nlcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQ2VudGVyaW5nIHdpdGggdGV4dC1hbGlnbi5cblxuXHRcdFx0cnVsZXMuZGl2LnN0eWxlcyA9ICd0ZXh0LWFsaWduJztcblx0XHRcdHJ1bGVzLnAuc3R5bGVzID0gJ3RleHQtYWxpZ24nO1xuXG5cdFx0XHRydWxlcy5pbWcuc3R5bGVzID0gJ2Zsb2F0Jztcblx0XHRcdHJ1bGVzLmZpZ3VyZS5zdHlsZXMgPSAnZmxvYXQsZGlzcGxheSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJ1bGVzO1xuXHR9XG5cblx0Ly8gUmV0dXJucyBhIHNldCBvZiB3aWRnZXQgZmVhdHVyZSBydWxlcywgZGVwZW5kaW5nXG5cdC8vIG9uIGVkaXRvciBjb25maWd1cmF0aW9uLiBOb3RlIHRoYXQgdGhlIGZvbGxvd2luZyBtYXkgbm90IGNvdmVyXG5cdC8vIGFsbCB0aGUgcG9zc2libGUgY2FzZXMgc2luY2UgcmVxdWlyZWRDb250ZW50IHN1cHBvcnRzIGEgc2luZ2xlXG5cdC8vIHRhZyBvbmx5LlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn1cblx0Ly8gQHJldHVybnMge09iamVjdH1cblxuXHRmdW5jdGlvbiBnZXRXaWRnZXRGZWF0dXJlcyhlZGl0b3IpIHtcblx0XHRjb25zdCBhbGlnbkNsYXNzZXMgPSBlZGl0b3IuY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXM7XG5cblx0XHRjb25zdCBmZWF0dXJlcyA9IHtcblx0XHRcdGRpbWVuc2lvbjoge1xuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICdpbWdbd2lkdGgsaGVpZ2h0XScsXG5cdFx0XHR9LFxuXHRcdFx0YWxpZ246IHtcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OlxuXHRcdFx0XHRcdCdpbWcnICtcblx0XHRcdFx0XHQoYWxpZ25DbGFzc2VzID8gJygnICsgYWxpZ25DbGFzc2VzWzBdICsgJyknIDogJ3tmbG9hdH0nKSxcblx0XHRcdH0sXG5cdFx0XHRjYXB0aW9uOiB7XG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ2ZpZ2NhcHRpb24nLFxuXHRcdFx0fSxcblx0XHR9O1xuXG5cdFx0cmV0dXJuIGZlYXR1cmVzO1xuXHR9XG5cblx0Ly8gUmV0dXJucyBlbGVtZW50IHdoaWNoIGlzIHN0eWxlZCwgY29uc2lkZXJpbmcgY3VycmVudFxuXHQvLyBzdGF0ZSBvZiB0aGUgd2lkZ2V0LlxuXHQvL1xuXHQvLyBAc2VlIENLRURJVE9SLnBsdWdpbnMud2lkZ2V0I2FwcGx5U3R5bGVcblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5wbHVnaW5zLndpZGdldH0gd2lkZ2V0XG5cdC8vIEByZXR1cm5zIHtDS0VESVRPUi5kb20uZWxlbWVudH1cblxuXHRmdW5jdGlvbiBnZXRTdHlsZWFibGVFbGVtZW50KHdpZGdldCkge1xuXHRcdHJldHVybiB3aWRnZXQuZGF0YS5oYXNDYXB0aW9uID8gd2lkZ2V0LmVsZW1lbnQgOiB3aWRnZXQucGFydHMuaW1hZ2U7XG5cdH1cbn0pKCk7XG5cbi8qKlxuICogQSBDU1MgY2xhc3MgYXBwbGllZCB0byB0aGUgYDxmaWd1cmU+YCBlbGVtZW50IG9mIGEgY2FwdGlvbmVkIGltYWdlLlxuICpcbiAqIFJlYWQgbW9yZSBpbiB0aGUgW2RvY3VtZW50YXRpb25dKCMhL2d1aWRlL2Rldl9jYXB0aW9uZWRpbWFnZSkgYW5kIHNlZSB0aGVcbiAqIFtTREsgc2FtcGxlXShodHRwOi8vc2RrLmNrZWRpdG9yLmNvbS9zYW1wbGVzL2NhcHRpb25lZGltYWdlLmh0bWwpLlxuICpcbiAqXHRcdC8vIENoYW5nZXMgdGhlIGNsYXNzIHRvIFwiY2FwdGlvbmVkSW1hZ2VcIi5cbiAqXHRcdGNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfY2FwdGlvbmVkQ2xhc3MgPSAnY2FwdGlvbmVkSW1hZ2UnO1xuICpcbiAqIEBjZmcge1N0cmluZ30gW2FlX2RyYWdyZXNpemVfaWUxMV9jYXB0aW9uZWRDbGFzcz0naW1hZ2UnXVxuICogQG1lbWJlciBDS0VESVRPUi5jb25maWdcbiAqL1xuQ0tFRElUT1IuY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9jYXB0aW9uZWRDbGFzcyA9ICdpbWFnZSc7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCB7SElHSF9QUklPUklUWX0gZnJvbSAnLi9wcmlvcml0aWVzJztcblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9lbWJlZCcpKSB7XG5cdGNvbnN0IFJFR0VYX0hUVFAgPSAvXmh0dHBzPy87XG5cblx0Y29uc3QgUkVHRVhfREVGQVVMVF9MSU5LID0gLzxhIGhyZWY9LztcblxuXHRDS0VESVRPUi5ERUZBVUxUX0FFX0VNQkVEX1VSTF9UUEwgPVxuXHRcdCdodHRwOi8vYWxsb3kuaWZyYW1lLmx5L2FwaS9vZW1iZWQ/dXJsPXt1cmx9JmNhbGxiYWNrPXtjYWxsYmFja30nO1xuXHRDS0VESVRPUi5ERUZBVUxUX0FFX0VNQkVEX1dJREdFVF9UUEwgPVxuXHRcdCc8ZGl2IGRhdGEtYWUtZW1iZWQtdXJsPVwie3VybH1cIj48L2Rpdj4nO1xuXHRDS0VESVRPUi5ERUZBVUxUX0FFX0VNQkVEX0RFRkFVTFRfTElOS19UUEwgPSAnPGEgaHJlZj1cInt1cmx9XCI+e3VybH08L2E+JztcblxuXHQvKipcblx0ICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGFkZHMgdGhlIGluZnJhc3RydWN0dXJlIHRvIGVtYmVkIHVybHMgYXMgbWVkaWEgb2JqZWN0cyB1c2luZyBhbiBvZW1iZWRcblx0ICogc2VydmljZS4gQnkgZGVmYXVsdCwgYW5kIGZvciBkZW1vaW5nIHB1cnBvc2VzIG9ubHksIHRoZSBvZW1iZWQgc2VydmljZSBpcyBob3N0ZWQgaW4gaWZyYW1lLmx5XG5cdCAqIGF0IC8vYWxsb3kuaWZyYW1lLmx5L2FwaS9vZW1iZWQ/dXJsPXt1cmx9JmNhbGxiYWNrPXtjYWxsYmFja30uIE5vdGUgdGhpcyBzaG91bGQgYmUgY2hhbmdlZCB0b1xuXHQgKiBhIHNlbGYtaG9zdGVkIG9yIHBhaWQgc2VydmljZSBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50cy4gQWNjZXNzIHRvIHRoZSBhbGxveS5pZnJhbWUubHkgZW5kcG9pbnRcblx0ICogbWF5IGJlIHJlc3RyaWN0ZWQgcGVyIGRvbWFpbiBkdWUgdG8gc2lnbmlmaWNhbnQgdHJhZmZpYy5cblx0ICpcblx0ICogVGhpcyBwbHVnaW4gYWRkcyBhbiBgZW1iZWRVcmxgIGNvbW1hbmQgdGhhdCBjYW4gYmUgdXNlZCB0byBlYXNpbHkgZW1iZWQgYSBVUkwgYW5kIHRyYW5zZm9ybSBpdFxuXHQgKiB0byBhbiBlbWJlZGRlZCBjb250ZW50LlxuXHQgKlxuXHQgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9lbWJlZFxuXHQgKi9cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX2VtYmVkJywge1xuXHRcdHJlcXVpcmVzOiAnd2lkZ2V0Jyxcblx0XHRpbml0KGVkaXRvcikge1xuXHRcdFx0Y29uc3QgQUVfRU1CRURfVVJMX1RQTCA9IG5ldyBDS0VESVRPUi50ZW1wbGF0ZShcblx0XHRcdFx0ZWRpdG9yLmNvbmZpZy5lbWJlZFVybFRlbXBsYXRlIHx8XG5cdFx0XHRcdFx0Q0tFRElUT1IuREVGQVVMVF9BRV9FTUJFRF9VUkxfVFBMXG5cdFx0XHQpO1xuXHRcdFx0Y29uc3QgQUVfRU1CRURfV0lER0VUX1RQTCA9IG5ldyBDS0VESVRPUi50ZW1wbGF0ZShcblx0XHRcdFx0ZWRpdG9yLmNvbmZpZy5lbWJlZFdpZGdldFRwbCB8fFxuXHRcdFx0XHRcdENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfV0lER0VUX1RQTFxuXHRcdFx0KTtcblx0XHRcdGNvbnN0IEFFX0VNQkVEX0RFRkFVTFRfTElOS19UUEwgPSBuZXcgQ0tFRElUT1IudGVtcGxhdGUoXG5cdFx0XHRcdGVkaXRvci5jb25maWcuZW1iZWRMaW5rRGVmYXVsdFRwbCB8fFxuXHRcdFx0XHRcdENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfREVGQVVMVF9MSU5LX1RQTFxuXHRcdFx0KTtcblxuXHRcdFx0Ly8gRGVmYXVsdCBmdW5jdGlvbiB0byB1cGNhc3QgRE9NIGVsZW1lbnRzIHRvIGVtYmVkIHdpZGdldHMuXG5cdFx0XHQvLyBJdCBtYXRjaGVzIENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfV0lER0VUX1RQTFxuXG5cdFx0XHRjb25zdCBkZWZhdWx0RW1iZWRXaWRnZXRVcGNhc3RGbiA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGEpIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGVsZW1lbnQubmFtZSA9PT0gJ2RpdicgJiZcblx0XHRcdFx0XHRlbGVtZW50LmF0dHJpYnV0ZXNbJ2RhdGEtYWUtZW1iZWQtdXJsJ11cblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZGF0YS51cmwgPSBlbGVtZW50LmF0dHJpYnV0ZXNbJ2RhdGEtYWUtZW1iZWQtdXJsJ107XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gQ3JlYXRlIGEgZW1iZWRVcmwgY29tbWFuZCB0aGF0IGNhbiBiZSBpbnZva2VkIHRvIGVhc2lseSBlbWJlZCBtZWRpYSBVUkxzXG5cblx0XHRcdGVkaXRvci5hZGRDb21tYW5kKCdlbWJlZFVybCcsIHtcblx0XHRcdFx0ZXhlYyhlZGl0b3IsIGRhdGEpIHtcblx0XHRcdFx0XHRlZGl0b3IuaW5zZXJ0SHRtbChcblx0XHRcdFx0XHRcdEFFX0VNQkVEX1dJREdFVF9UUEwub3V0cHV0KHtcblx0XHRcdFx0XHRcdFx0dXJsOiBkYXRhLnVybCxcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBDcmVhdGUgYSB3aWRnZXQgdG8gcHJvcGVybHkgaGFuZGxlIGVtYmVkIG9wZXJhdGlvbnNcblxuXHRcdFx0ZWRpdG9yLndpZGdldHMuYWRkKCdhZV9lbWJlZCcsIHtcblx0XHRcdFx0bWFzazogdHJ1ZSxcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAnZGl2W2RhdGEtYWUtZW1iZWQtdXJsXScsXG5cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIExpc3RlbmVyIHRvIGJlIGV4ZWN1dGVkIGV2ZXJ5IHRpbWUgdGhlIHdpZGdldCdzIGRhdGEgY2hhbmdlcy4gSXQgdGFrZXMgY2FyZSBvZlxuXHRcdFx0XHQgKiByZXF1ZXN0aW5nIHRoZSBlbWJlZCBvYmplY3QgdG8gdGhlIGNvbmZpZ3VyZWQgb2VtYmVkIHNlcnZpY2UgYW5kIHJlbmRlciBpdCBpblxuXHRcdFx0XHQgKiB0aGUgZWRpdG9yXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIEBtZXRob2QgZGF0YVxuXHRcdFx0XHQgKiBAcGFyYW0ge2V2ZW50fSBldmVudCBEYXRhIGNoYW5nZSBldmVudFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0ZGF0YShldmVudCkge1xuXHRcdFx0XHRcdGNvbnN0IHdpZGdldCA9IHRoaXM7XG5cblx0XHRcdFx0XHRjb25zdCB1cmwgPSBldmVudC5kYXRhLnVybDtcblxuXHRcdFx0XHRcdGlmICh1cmwpIHtcblx0XHRcdFx0XHRcdENLRURJVE9SLnRvb2xzLmpzb25wKFxuXHRcdFx0XHRcdFx0XHRBRV9FTUJFRF9VUkxfVFBMLFxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0dXJsOiBlbmNvZGVVUklDb21wb25lbnQodXJsKSxcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChyZXNwb25zZS5odG1sKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFJFR0VYX0RFRkFVTFRfTElOSy50ZXN0KHJlc3BvbnNlLmh0bWwpXG5cdFx0XHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0d2lkZ2V0LmNyZWF0ZUFUYWcodXJsKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHdpZGdldC5lbGVtZW50LnNldEh0bWwocmVzcG9uc2UuaHRtbCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHdpZGdldC5jcmVhdGVBVGFnKHVybCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRfbXNnID0+IHtcblx0XHRcdFx0XHRcdFx0XHR3aWRnZXQuY3JlYXRlQVRhZyh1cmwpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRjcmVhdGVBVGFnKHVybCkge1xuXHRcdFx0XHRcdHRoaXMuZWRpdG9yLmV4ZWNDb21tYW5kKCd1bmRvJyk7XG5cblx0XHRcdFx0XHRjb25zdCBhVGFnSHRtbCA9IEFFX0VNQkVEX0RFRkFVTFRfTElOS19UUEwub3V0cHV0KHtcblx0XHRcdFx0XHRcdHVybCxcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdHRoaXMuZWRpdG9yLmluc2VydEh0bWwoYVRhZ0h0bWwpO1xuXHRcdFx0XHRcdHRoaXMuZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBGdW5jdGlvbiB1c2VkIHRvIHVwY2FzdCBhbiBlbGVtZW50IHRvIGFlX2VtYmVkIHdpZGdldHMuXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIEBtZXRob2QgdXBjYXN0XG5cdFx0XHRcdCAqIEBwYXJhbSB7Q0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGJlIGNoZWNrZWRcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB3aWRnZXRcblx0XHRcdFx0ICovXG5cdFx0XHRcdHVwY2FzdChlbGVtZW50LCBkYXRhKSB7XG5cdFx0XHRcdFx0Y29uc3QgZW1iZWRXaWRnZXRVcGNhc3RGbiA9XG5cdFx0XHRcdFx0XHRlZGl0b3IuY29uZmlnLmVtYmVkV2lkZ2V0VXBjYXN0Rm4gfHxcblx0XHRcdFx0XHRcdGRlZmF1bHRFbWJlZFdpZGdldFVwY2FzdEZuO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGVtYmVkV2lkZ2V0VXBjYXN0Rm4oZWxlbWVudCwgZGF0YSk7XG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQWRkIGEgbGlzdGVuZXIgdG8gaGFuZGxlIHBhc3RlIGV2ZW50cyBhbmQgdHVybiBsaW5rcyBpbnRvIGVtYmVkIG9iamVjdHNcblxuXHRcdFx0ZWRpdG9yLm9uY2UoJ2NvbnRlbnREb20nLCAoKSA9PiB7XG5cdFx0XHRcdGVkaXRvci5vbihcblx0XHRcdFx0XHQncGFzdGUnLFxuXHRcdFx0XHRcdGV2ZW50ID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGxpbmsgPSBldmVudC5kYXRhLmRhdGFWYWx1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKFJFR0VYX0hUVFAudGVzdChsaW5rKSkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wKCk7XG5cblx0XHRcdFx0XHRcdFx0ZWRpdG9yLmV4ZWNDb21tYW5kKCdlbWJlZFVybCcsIHtcblx0XHRcdFx0XHRcdFx0XHR1cmw6IGV2ZW50LmRhdGEuZGF0YVZhbHVlLFxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0bnVsbCxcblxuXHRcdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBydW4gYmVmb3JlIGF1dG9saW5rJ3MgcGFzdGUgaGFuZGxlcixcblx0XHRcdFx0XHQvLyBvdGhlcndpc2UgdGhlIGxpbmsgd2lsbCBiZSB0dXJuZWQgaW50byBhbiBhbmNob3IgYW5kIG91clxuXHRcdFx0XHRcdC8vIFJFR0VYX0hUVFAgdGVzdCB3aWxsIGZhaWwuXG5cblx0XHRcdFx0XHRISUdIX1BSSU9SSVRZXG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQWRkIGEgbGlzdGVuZXIgdG8gaGFuZGxlIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnRzIGFuZCBwcm9wZXJseSBkZXRlY3QgZWRpdG9yXG5cdFx0XHQvLyBpbnRlcmFjdGlvbnMgb24gdGhlIHdpZGdldHMgd2l0aG91dCBtZXNzaW5nIHdpdGggd2lkZ2V0IG5hdGl2ZSBzZWxlY3Rpb25cblxuXHRcdFx0ZWRpdG9yLm9uKCdzZWxlY3Rpb25DaGFuZ2UnLCBfZXZlbnQgPT4ge1xuXHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRcdFx0aWYgKHNlbGVjdGlvbikge1xuXHRcdFx0XHRcdGNvbnN0IGVsZW1lbnQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRFbGVtZW50KCk7XG5cblx0XHRcdFx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0Y29uc3Qgd2lkZ2V0RWxlbWVudCA9IGVsZW1lbnQuZmluZE9uZShcblx0XHRcdFx0XHRcdFx0J1tkYXRhLXdpZGdldD1cImFlX2VtYmVkXCJdJ1xuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0aWYgKHdpZGdldEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcmVnaW9uID0gZWxlbWVudC5nZXRDbGllbnRSZWN0KCk7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3Qgc2Nyb2xsUG9zaXRpb24gPSBuZXcgQ0tFRElUT1IuZG9tLndpbmRvdyhcblx0XHRcdFx0XHRcdFx0XHR3aW5kb3dcblx0XHRcdFx0XHRcdFx0KS5nZXRTY3JvbGxQb3NpdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRyZWdpb24ubGVmdCAtPSBzY3JvbGxQb3NpdGlvbi54O1xuXHRcdFx0XHRcdFx0XHRyZWdpb24udG9wICs9IHNjcm9sbFBvc2l0aW9uLnk7XG5cblx0XHRcdFx0XHRcdFx0cmVnaW9uLmRpcmVjdGlvbiA9IENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QO1xuXG5cdFx0XHRcdFx0XHRcdGVkaXRvci5maXJlKCdlZGl0b3JJbnRlcmFjdGlvbicsIHtcblx0XHRcdFx0XHRcdFx0XHRuYXRpdmVFdmVudDoge30sXG5cdFx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uRGF0YToge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZWxlbWVudDogd2lkZ2V0RWxlbWVudCxcblx0XHRcdFx0XHRcdFx0XHRcdHJlZ2lvbixcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBZGQgYSBmaWx0ZXIgdG8gc2tpcCBmaWx0ZXJpbmcgd2lkZ2V0IGVsZW1lbnRzXG5cblx0XHRcdGVkaXRvci5maWx0ZXIuYWRkRWxlbWVudENhbGxiYWNrKGVsZW1lbnQgPT4ge1xuXHRcdFx0XHRpZiAoJ2RhdGEtYWUtZW1iZWQtdXJsJyBpbiBlbGVtZW50LmF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gQ0tFRElUT1IuRklMVEVSX1NLSVBfVFJFRTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZXNpemVyIGZyb20gJy4vUmVzaXplci5lcyc7XG5cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2VtYmVkdXJsJykpIHtcblx0Y29uc3QgUkVHRVhfSFRUUCA9IC9eaHR0cHM/LztcblxuXHRDS0VESVRPUi5ERUZBVUxUX0xGUl9FTUJFRF9XSURHRVRfVFBMID1cblx0XHQnPGRpdiBkYXRhLWVtYmVkLXVybD1cInt1cmx9XCIgY2xhc3M9XCJlbWJlZC1yZXNwb25zaXZlIGVtYmVkLXJlc3BvbnNpdmUtMTZieTlcIj57Y29udGVudH08ZGl2IGNsYXNzPVwiZW1iZWQtaGVscC1tZXNzYWdlXCI+e2hlbHBNZXNzYWdlSWNvbn08c3Bhbj4ge2hlbHBNZXNzYWdlfTwvc3Bhbj48L2Rpdj48L2Rpdj48YnI+JztcblxuXHQvKipcblx0ICogRW51bSBmb3Igc3VwcG9ydGVkIGVtYmVkIGFsaWdubWVudHNcblx0ICogQHR5cGUge09iamVjdH1cblx0ICovXG5cblx0Y29uc3QgRU1CRURfQUxJR05NRU5UID0ge1xuXHRcdENFTlRFUjogJ2NlbnRlcicsXG5cdFx0TEVGVDogJ2xlZnQnLFxuXHRcdFJJR0hUOiAncmlnaHQnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbnVtIHZhbHVlcyBmb3Igc3VwcG9ydGVkIGVtYmVkIGFsaWdubWVudHNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKi9cblxuXHRjb25zdCBBTElHTl9WQUxVRVMgPSBbXG5cdFx0RU1CRURfQUxJR05NRU5ULkNFTlRFUixcblx0XHRFTUJFRF9BTElHTk1FTlQuTEVGVCxcblx0XHRFTUJFRF9BTElHTk1FTlQuUklHSFQsXG5cdF07XG5cblx0LyoqXG5cdCAqIE5lY2Vzc2FyeSBzdHlsZXMgZm9yIHRoZSBjZW50ZXIgYWxpZ25tZW50XG5cdCAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cblx0ICovXG5cblx0Y29uc3QgQ0VOVEVSRURfRU1CRURfU1RZTEUgPSBbXG5cdFx0e1xuXHRcdFx0bmFtZTogJ2Rpc3BsYXknLFxuXHRcdFx0dmFsdWU6ICdibG9jaycsXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRuYW1lOiAnbWFyZ2luLWxlZnQnLFxuXHRcdFx0dmFsdWU6ICdhdXRvJyxcblx0XHR9LFxuXHRcdHtcblx0XHRcdG5hbWU6ICdtYXJnaW4tcmlnaHQnLFxuXHRcdFx0dmFsdWU6ICdhdXRvJyxcblx0XHR9LFxuXHRdO1xuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIGFsaWdubWVudCB2YWx1ZSBvZiBhbiBlbWJlZCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBlbWJlZCBUaGUgZW1iZWQgZWxlbWVudFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBhbGlnbm1lbnQgdmFsdWVcblx0ICovXG5cblx0Y29uc3QgZ2V0RW1iZWRBbGlnbm1lbnQgPSBmdW5jdGlvbihlbWJlZCkge1xuXHRcdGxldCBlbWJlZEFsaWdubWVudCA9IGVtYmVkLmdldFN0eWxlKCdmbG9hdCcpO1xuXG5cdFx0aWYgKFxuXHRcdFx0IWVtYmVkQWxpZ25tZW50IHx8XG5cdFx0XHRlbWJlZEFsaWdubWVudCA9PT0gJ2luaGVyaXQnIHx8XG5cdFx0XHRlbWJlZEFsaWdubWVudCA9PT0gJ25vbmUnXG5cdFx0KSB7XG5cdFx0XHRlbWJlZEFsaWdubWVudCA9IGVtYmVkLmdldEF0dHJpYnV0ZSgnYWxpZ24nKTtcblx0XHR9XG5cblx0XHRpZiAoIWVtYmVkQWxpZ25tZW50KSB7XG5cdFx0XHRjb25zdCBjZW50ZXJlZEVtYmVkID0gQ0VOVEVSRURfRU1CRURfU1RZTEUuZXZlcnkoc3R5bGUgPT4ge1xuXHRcdFx0XHRsZXQgc3R5bGVDaGVjayA9IGVtYmVkLmdldFN0eWxlKHN0eWxlLm5hbWUpID09PSBzdHlsZS52YWx1ZTtcblxuXHRcdFx0XHRpZiAoIXN0eWxlQ2hlY2sgJiYgc3R5bGUudmVuZG9yUHJlZml4ZXMpIHtcblx0XHRcdFx0XHRzdHlsZUNoZWNrID0gc3R5bGUudmVuZG9yUHJlZml4ZXMuc29tZShcblx0XHRcdFx0XHRcdHZlbmRvclByZWZpeCA9PlxuXHRcdFx0XHRcdFx0XHRlbWJlZC5nZXRTdHlsZSh2ZW5kb3JQcmVmaXggKyBzdHlsZS5uYW1lKSA9PT1cblx0XHRcdFx0XHRcdFx0c3R5bGUudmFsdWVcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHN0eWxlQ2hlY2s7XG5cdFx0XHR9KTtcblxuXHRcdFx0ZW1iZWRBbGlnbm1lbnQgPSBjZW50ZXJlZEVtYmVkID8gRU1CRURfQUxJR05NRU5ULkNFTlRFUiA6IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVtYmVkQWxpZ25tZW50O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBhbGlnbm1lbnQgdmFsdWUgb2YgYW4gZW1iZWRcblx0ICpcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZW1iZWQgVGhlIGVtYmVkIGVsZW1lbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGVtYmVkQWxpZ25tZW50IFRoZSBlbWJlZCBhbGlnbm1lbnQgdmFsdWUgdG8gYmUgcmVtb3ZlZFxuXHQgKi9cblxuXHRjb25zdCByZW1vdmVFbWJlZEFsaWdubWVudCA9IGZ1bmN0aW9uKGVtYmVkLCBlbWJlZEFsaWdubWVudCkge1xuXHRcdGlmIChcblx0XHRcdGVtYmVkQWxpZ25tZW50ID09PSBFTUJFRF9BTElHTk1FTlQuTEVGVCB8fFxuXHRcdFx0ZW1iZWRBbGlnbm1lbnQgPT09IEVNQkVEX0FMSUdOTUVOVC5SSUdIVFxuXHRcdCkge1xuXHRcdFx0ZW1iZWQucmVtb3ZlU3R5bGUoJ2Zsb2F0Jyk7XG5cblx0XHRcdGlmIChlbWJlZEFsaWdubWVudCA9PT0gZ2V0RW1iZWRBbGlnbm1lbnQoZW1iZWQpKSB7XG5cdFx0XHRcdGVtYmVkLnJlbW92ZUF0dHJpYnV0ZSgnYWxpZ24nKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGVtYmVkQWxpZ25tZW50ID09PSBFTUJFRF9BTElHTk1FTlQuQ0VOVEVSKSB7XG5cdFx0XHRDRU5URVJFRF9FTUJFRF9TVFlMRS5mb3JFYWNoKHN0eWxlID0+IHtcblx0XHRcdFx0ZW1iZWQucmVtb3ZlU3R5bGUoc3R5bGUubmFtZSk7XG5cblx0XHRcdFx0aWYgKHN0eWxlLnZlbmRvclByZWZpeGVzKSB7XG5cdFx0XHRcdFx0c3R5bGUudmVuZG9yUHJlZml4ZXMuZm9yRWFjaCh2ZW5kb3JQcmVmaXggPT5cblx0XHRcdFx0XHRcdGVtYmVkLnJlbW92ZVN0eWxlKHZlbmRvclByZWZpeCArIHN0eWxlLm5hbWUpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBhbGlnbm1lbnQgdmFsdWUgb2YgYW4gZW1iZWRcblx0ICpcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZW1iZWQgVGhlIGVtYmVkIGVsZW1lbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGVtYmVkQWxpZ25tZW50IFRoZSBlbWJlZCBhbGlnbm1lbnQgdmFsdWUgdG8gYmUgc2V0XG5cdCAqL1xuXG5cdGNvbnN0IHNldEVtYmVkQWxpZ25tZW50ID0gZnVuY3Rpb24oZW1iZWQsIGVtYmVkQWxpZ25tZW50KSB7XG5cdFx0cmVtb3ZlRW1iZWRBbGlnbm1lbnQoZW1iZWQsIGdldEVtYmVkQWxpZ25tZW50KGVtYmVkKSk7XG5cblx0XHRpZiAoXG5cdFx0XHRlbWJlZEFsaWdubWVudCA9PT0gRU1CRURfQUxJR05NRU5ULkxFRlQgfHxcblx0XHRcdGVtYmVkQWxpZ25tZW50ID09PSBFTUJFRF9BTElHTk1FTlQuUklHSFRcblx0XHQpIHtcblx0XHRcdGVtYmVkLnNldFN0eWxlKCdmbG9hdCcsIGVtYmVkQWxpZ25tZW50KTtcblx0XHR9IGVsc2UgaWYgKGVtYmVkQWxpZ25tZW50ID09PSBFTUJFRF9BTElHTk1FTlQuQ0VOVEVSKSB7XG5cdFx0XHRDRU5URVJFRF9FTUJFRF9TVFlMRS5mb3JFYWNoKHN0eWxlID0+IHtcblx0XHRcdFx0ZW1iZWQuc2V0U3R5bGUoc3R5bGUubmFtZSwgc3R5bGUudmFsdWUpO1xuXG5cdFx0XHRcdGlmIChzdHlsZS52ZW5kb3JQcmVmaXhlcykge1xuXHRcdFx0XHRcdHN0eWxlLnZlbmRvclByZWZpeGVzLmZvckVhY2godmVuZG9yUHJlZml4ID0+XG5cdFx0XHRcdFx0XHRlbWJlZC5zZXRTdHlsZSh2ZW5kb3JQcmVmaXggKyBzdHlsZS5uYW1lLCBzdHlsZS52YWx1ZSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0Y29uc3QgZ2V0U2VsZWN0ZWRFbGVtZW50ID0gZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0Y29uc3QgcmVzdWx0ID0ge1xuXHRcdFx0YWxpZ25tZW50OiBudWxsLFxuXHRcdFx0ZWxlbWVudDogbnVsbCxcblx0XHR9O1xuXG5cdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0aWYgKHNlbGVjdGlvbikge1xuXHRcdFx0Y29uc3Qgc2VsZWN0ZWRFbGVtZW50ID0gc2VsZWN0aW9uLmdldFNlbGVjdGVkRWxlbWVudCgpO1xuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHNlbGVjdGVkRWxlbWVudCAmJlxuXHRcdFx0XHRzZWxlY3RlZEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNrZS13aWRnZXQtd3JhcHBlcicpXG5cdFx0XHQpIHtcblx0XHRcdFx0cmVzdWx0LmFsaWdubWVudCA9IGdldEVtYmVkQWxpZ25tZW50KHNlbGVjdGVkRWxlbWVudCk7XG5cdFx0XHRcdHJlc3VsdC5lbGVtZW50ID0gc2VsZWN0ZWRFbGVtZW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Y29uc3QgcmVzaXplRWxlbWVudCA9IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0Y29uc3Qgd3JhcHBlckVsZW1lbnQgPSBlbC5wYXJlbnRFbGVtZW50O1xuXG5cdFx0aWYgKHdyYXBwZXJFbGVtZW50ICYmIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwKSB7XG5cdFx0XHRjb25zdCByZWN0ID0gd3JhcHBlckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdGNvbnN0IHB3aWR0aCA9XG5cdFx0XHRcdHdpZHRoID49IHJlY3Qud2lkdGhcblx0XHRcdFx0XHQ/IDEwMFxuXHRcdFx0XHRcdDogTWF0aC5mbG9vcigod2lkdGggLyByZWN0LndpZHRoKSAqIDEwMCk7XG5cdFx0XHRjb25zdCBzdHlsZSA9IGB3aWR0aDoke3B3aWR0aH0lO2A7XG5cblx0XHRcdHdyYXBwZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZSk7XG5cblx0XHRcdGNvbnN0IHdpZGdldEVsZW1lbnQgPSB3cmFwcGVyRWxlbWVudC5xdWVyeVNlbGVjdG9yKFxuXHRcdFx0XHQnW2RhdGEtd2lkZ2V0PVwiZW1iZWR1cmxcIl0nXG5cdFx0XHQpO1xuXG5cdFx0XHRpZiAod2lkZ2V0RWxlbWVudCkge1xuXHRcdFx0XHRjb25zdCBzdHlsZXMgPVxuXHRcdFx0XHRcdEpTT04ucGFyc2Uod2lkZ2V0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3R5bGVzJykpIHx8IHt9O1xuXG5cdFx0XHRcdHN0eWxlcy53aWR0aCA9IGAke3dpZHRofXB4YDtcblx0XHRcdFx0c3R5bGVzLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG5cblx0XHRcdFx0d2lkZ2V0RWxlbWVudC5zZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0J2RhdGEtc3R5bGVzJyxcblx0XHRcdFx0XHRKU09OLnN0cmluZ2lmeShzdHlsZXMpXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Y29uc3QgaWZyYW1lRWxlbWVudCA9IHdpZGdldEVsZW1lbnQucXVlcnlTZWxlY3RvcignaWZyYW1lJyk7XG5cblx0XHRcdFx0aWYgKGlmcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0XHRpZnJhbWVFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3aWR0aCk7XG5cdFx0XHRcdFx0aWZyYW1lRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Y29uc3Qgc2VsZWN0V2lkZ2V0ID0gZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRcdGlmIChzZWxlY3Rpb24pIHtcblx0XHRcdFx0Y29uc3Qgd3JhcHBlckVsZW1lbnQgPSBzZWxlY3Rpb24ucm9vdC5maW5kKFxuXHRcdFx0XHRcdCdbZGF0YS1ja2Utd2lkZ2V0LXdyYXBwZXJdJ1xuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICh3cmFwcGVyRWxlbWVudCkge1xuXHRcdFx0XHRcdGNvbnN0IGVsZW1lbnRMaXN0ID0gd3JhcHBlckVsZW1lbnQuJDtcblx0XHRcdFx0XHRpZiAoZWxlbWVudExpc3QubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgbGFzdEVsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRMaXN0W2VsZW1lbnRMaXN0Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBpbWFnZUVsZW1lbnQgPSBsYXN0RWxlbWVudC5maW5kT25lKCdpbWcnKTtcblx0XHRcdFx0XHRcdGNvbnN0IHdpZGdldEVsZW1lbnQgPSBsYXN0RWxlbWVudC5maW5kT25lKFxuXHRcdFx0XHRcdFx0XHQnW2RhdGEtd2lkZ2V0PVwiZW1iZWR1cmxcIl0nXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoaW1hZ2VFbGVtZW50ICYmIHdpZGdldEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcmFuZ2UgPSBlZGl0b3IuY3JlYXRlUmFuZ2UoKTtcblxuXHRcdFx0XHRcdFx0XHRyYW5nZS5zZXRTdGFydCh3aWRnZXRFbGVtZW50LCAwKTtcblx0XHRcdFx0XHRcdFx0cmFuZ2Uuc2V0RW5kKGltYWdlRWxlbWVudCwgMSk7XG5cblx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uLnNlbGVjdFJhbmdlcyhbcmFuZ2VdKTtcblx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uLnNlbGVjdEVsZW1lbnQobGFzdEVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sIDApO1xuXHR9O1xuXG5cdGxldCBjdXJyZW50QWxpZ25tZW50ID0gbnVsbDtcblx0bGV0IGN1cnJlbnRFbGVtZW50ID0gbnVsbDtcblx0bGV0IHJlc2l6ZXIgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gd2hpY2ggYWRkcyB0aGUgaW5mcmFzdHJ1Y3R1cmUgdG8gZW1iZWQgdXJscyBhcyBtZWRpYSBvYmplY3RzXG5cdCAqXG5cdCAqIFRoaXMgcGx1Z2luIGFkZHMgYW4gYGVtYmVkVXJsYCBjb21tYW5kIHRoYXQgY2FuIGJlIHVzZWQgdG8gZWFzaWx5IGVtYmVkIGEgVVJMIGFuZCB0cmFuc2Zvcm0gaXRcblx0ICogdG8gYW4gZW1iZWRkZWQgY29udGVudC5cblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuZW1iZWR1cmxcblx0ICovXG5cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2VtYmVkdXJsJywge1xuXHRcdHJlcXVpcmVzOiAnd2lkZ2V0JyxcblxuXHRcdGluaXQ6IGVkaXRvciA9PiB7XG5cdFx0XHRjb25zdCBMRlJfRU1CRURfV0lER0VUX1RQTCA9IG5ldyBDS0VESVRPUi50ZW1wbGF0ZShcblx0XHRcdFx0ZWRpdG9yLmNvbmZpZy5lbWJlZFdpZGdldFRwbCB8fFxuXHRcdFx0XHRcdENLRURJVE9SLkRFRkFVTFRfTEZSX0VNQkVEX1dJREdFVF9UUExcblx0XHRcdCk7XG5cblx0XHRcdGxldCBwcm92aWRlcnMgPSBlZGl0b3IuY29uZmlnLmVtYmVkUHJvdmlkZXJzIHx8IFtdO1xuXG5cdFx0XHRwcm92aWRlcnMgPSBwcm92aWRlcnMubWFwKHByb3ZpZGVyID0+IHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpZDogcHJvdmlkZXIuaWQsXG5cdFx0XHRcdFx0dHBsOiBuZXcgQ0tFRElUT1IudGVtcGxhdGUoXG5cdFx0XHRcdFx0XHRgPGRpdiBkYXRhLWVtYmVkLWlkPVwie2VtYmVkSWR9XCI+JHtwcm92aWRlci50cGx9PC9kaXY+YFxuXHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0dHlwZTogcHJvdmlkZXIudHlwZSxcblx0XHRcdFx0XHR1cmxTY2hlbWVzOiBwcm92aWRlci51cmxTY2hlbWVzLm1hcChcblx0XHRcdFx0XHRcdHNjaGVtZSA9PiBuZXcgUmVnRXhwKHNjaGVtZSlcblx0XHRcdFx0XHQpLFxuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cblx0XHRcdGNvbnN0IGdlbmVyYXRlRW1iZWRDb250ZW50ID0gKHVybCwgY29udGVudCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gTEZSX0VNQkVEX1dJREdFVF9UUEwub3V0cHV0KHtcblx0XHRcdFx0XHRjb250ZW50LFxuXHRcdFx0XHRcdGhlbHBNZXNzYWdlOiBBbGxveUVkaXRvci5TdHJpbmdzLnZpZGVvUGxheWJhY2tEaXNhYmxlZCxcblx0XHRcdFx0XHRoZWxwTWVzc2FnZUljb246IExpZmVyYXkuVXRpbC5nZXRMZXhpY29uSWNvblRwbChcblx0XHRcdFx0XHRcdCdpbmZvLWNpcmNsZSdcblx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdHVybCxcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCBkZWZhdWx0RW1iZWRXaWRnZXRVcGNhc3RGbiA9IChlbGVtZW50LCBkYXRhKSA9PiB7XG5cdFx0XHRcdGxldCB1cGNhc3RXaWRnZXQgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ZWxlbWVudC5uYW1lID09PSAnZGl2JyAmJlxuXHRcdFx0XHRcdGVsZW1lbnQuYXR0cmlidXRlc1snZGF0YS1lbWJlZC11cmwnXVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRkYXRhLnVybCA9IGVsZW1lbnQuYXR0cmlidXRlc1snZGF0YS1lbWJlZC11cmwnXTtcblxuXHRcdFx0XHRcdHVwY2FzdFdpZGdldCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0ZWxlbWVudC5uYW1lID09PSAnZGl2JyAmJlxuXHRcdFx0XHRcdGVsZW1lbnQuYXR0cmlidXRlc1snZGF0YS1lbWJlZC1pZCddXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGNvbnN0IGlmcmFtZSA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG5cblx0XHRcdFx0XHRkYXRhLnVybCA9IGlmcmFtZS5hdHRyaWJ1dGVzLnNyYztcblxuXHRcdFx0XHRcdGRlbGV0ZSBlbGVtZW50LmF0dHJpYnV0ZXMuc3R5bGU7XG5cblx0XHRcdFx0XHRjb25zdCBlbWJlZENvbnRlbnQgPSBnZW5lcmF0ZUVtYmVkQ29udGVudChcblx0XHRcdFx0XHRcdGRhdGEudXJsLFxuXHRcdFx0XHRcdFx0ZWxlbWVudC5nZXRPdXRlckh0bWwoKVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRjb25zdCB3aWRnZXRGcmFnbWVudCA9IG5ldyBDS0VESVRPUi5odG1sUGFyc2VyLmZyYWdtZW50LmZyb21IdG1sKFxuXHRcdFx0XHRcdFx0ZW1iZWRDb250ZW50XG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdHVwY2FzdFdpZGdldCA9IHdpZGdldEZyYWdtZW50LmNoaWxkcmVuWzBdO1xuXG5cdFx0XHRcdFx0dXBjYXN0V2lkZ2V0LmF0dHJpYnV0ZXNbJ2RhdGEtc3R5bGVzJ10gPVxuXHRcdFx0XHRcdFx0ZWxlbWVudC5hdHRyaWJ1dGVzWydkYXRhLXN0eWxlcyddO1xuXHRcdFx0XHRcdHVwY2FzdFdpZGdldC5yZW1vdmVDbGFzcygnZW1iZWQtcmVzcG9uc2l2ZScpO1xuXHRcdFx0XHRcdHVwY2FzdFdpZGdldC5yZW1vdmVDbGFzcygnZW1iZWQtcmVzcG9uc2l2ZS0xNmJ5OScpO1xuXG5cdFx0XHRcdFx0ZWxlbWVudC5yZXBsYWNlV2l0aCh1cGNhc3RXaWRnZXQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHVwY2FzdFdpZGdldDtcblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IHNob3dFcnJvciA9IGVycm9yTXNnID0+IHtcblx0XHRcdFx0ZWRpdG9yLmZpcmUoJ2Vycm9yJywgZXJyb3JNc2cpO1xuXG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdGVkaXRvci5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcblxuXHRcdFx0XHRcdGVkaXRvci5mb2N1cygpO1xuXG5cdFx0XHRcdFx0cmVzaXplci5oaWRlKCk7XG5cdFx0XHRcdH0sIDApO1xuXHRcdFx0fTtcblxuXHRcdFx0ZWRpdG9yLmFkZENvbW1hbmQoJ2VtYmVkVXJsJywge1xuXHRcdFx0XHRleGVjOiAoZWRpdG9yLCBkYXRhKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgdHlwZSA9IGRhdGEudHlwZTtcblx0XHRcdFx0XHRjb25zdCB1cmwgPSBkYXRhLnVybDtcblx0XHRcdFx0XHRsZXQgY29udGVudDtcblxuXHRcdFx0XHRcdGlmIChSRUdFWF9IVFRQLnRlc3QodXJsKSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgdmFsaWRQcm92aWRlciA9IHByb3ZpZGVyc1xuXHRcdFx0XHRcdFx0XHQuZmlsdGVyKHByb3ZpZGVyID0+IHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHlwZSA/IHByb3ZpZGVyLnR5cGUgPT09IHR5cGUgOiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHQuc29tZShwcm92aWRlciA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3Qgc2NoZW1lID0gcHJvdmlkZXIudXJsU2NoZW1lcy5maW5kKFxuXHRcdFx0XHRcdFx0XHRcdFx0c2NoZW1lID0+IHNjaGVtZS50ZXN0KHVybClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHNjaGVtZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgZW1iZWRJZCA9IHNjaGVtZS5leGVjKHVybClbMV07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNvbnRlbnQgPSBwcm92aWRlci50cGwub3V0cHV0KHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZW1iZWRJZCxcblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBzY2hlbWU7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRpZiAodmFsaWRQcm92aWRlcikge1xuXHRcdFx0XHRcdFx0XHRlZGl0b3IuX3NlbGVjdEVtYmVkV2lkZ2V0ID0gdXJsO1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGVtYmVkQ29udGVudCA9IGdlbmVyYXRlRW1iZWRDb250ZW50KFxuXHRcdFx0XHRcdFx0XHRcdHVybCxcblx0XHRcdFx0XHRcdFx0XHRjb250ZW50XG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0ZWRpdG9yLmluc2VydEh0bWwoZW1iZWRDb250ZW50KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNob3dFcnJvcihBbGxveUVkaXRvci5TdHJpbmdzLnBsYXRmb3JtTm90U3VwcG9ydGVkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2hvd0Vycm9yKEFsbG95RWRpdG9yLlN0cmluZ3MuZW50ZXJWYWxpZFVybCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cblx0XHRcdGVkaXRvci53aWRnZXRzLmFkZCgnZW1iZWR1cmwnLCB7XG5cdFx0XHRcdGRyYWdnYWJsZTogZmFsc2UsXG5cdFx0XHRcdG1hc2s6IHRydWUsXG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ2RpdltkYXRhLWVtYmVkLXVybF0nLFxuXG5cdFx0XHRcdGRhdGEoZXZlbnQpIHtcblx0XHRcdFx0XHRjb25zdCBpbnN0YW5jZSA9IHRoaXM7XG5cblx0XHRcdFx0XHQvLyBTeW5jIGRpbWVuc2lvbnMgYW5kIGFsaWdubWVudCB3aXRoIGVkaXRvciB3cmFwcGVyXG5cblx0XHRcdFx0XHRsZXQgc3R5bGVzID0gbnVsbDtcblxuXHRcdFx0XHRcdGNvbnN0IHN0eWxlc0pTT04gPSBpbnN0YW5jZS5lbGVtZW50LmdldEF0dHJpYnV0ZShcblx0XHRcdFx0XHRcdCdkYXRhLXN0eWxlcydcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKHN0eWxlc0pTT04pIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHN0eWxlcyA9IEpTT04ucGFyc2Uoc3R5bGVzSlNPTik7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChfZXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0c3R5bGVzID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIXN0eWxlcykge1xuXHRcdFx0XHRcdFx0Y29uc3QgaWZyYW1lID0gaW5zdGFuY2Uud3JhcHBlci5maW5kT25lKCdpZnJhbWUnKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYm91bmRzID0gaW5zdGFuY2Uud3JhcHBlci4kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XHRcdFx0Y29uc3Qgd2lkdGggPSBpZnJhbWUuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBwd2lkdGggPVxuXHRcdFx0XHRcdFx0XHR3aWR0aCA+PSBib3VuZHMud2lkdGhcblx0XHRcdFx0XHRcdFx0XHQ/IDEwMFxuXHRcdFx0XHRcdFx0XHRcdDogTWF0aC5yb3VuZCgod2lkdGggLyBib3VuZHMud2lkdGgpICogMTAwKTtcblxuXHRcdFx0XHRcdFx0c3R5bGVzID0ge1xuXHRcdFx0XHRcdFx0XHR3aWR0aDogYCR7cHdpZHRofSVgLFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbnN0YW5jZS53cmFwcGVyLnNldEF0dHJpYnV0ZShcblx0XHRcdFx0XHRcdCdzdHlsZScsXG5cdFx0XHRcdFx0XHRDS0VESVRPUi50b29scy53cml0ZUNzc1RleHQoc3R5bGVzKVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAoZWRpdG9yLl9zZWxlY3RFbWJlZFdpZGdldCA9PT0gZXZlbnQuZGF0YS51cmwpIHtcblx0XHRcdFx0XHRcdHNlbGVjdFdpZGdldChlZGl0b3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRkb3duY2FzdCh3aWRnZXQpIHtcblx0XHRcdFx0XHRjb25zdCBlbWJlZENvbnRlbnQgPSB3aWRnZXQuY2hpbGRyZW5bMF07XG5cblx0XHRcdFx0XHRlbWJlZENvbnRlbnQuYXR0cmlidXRlcy5jbGFzcyA9XG5cdFx0XHRcdFx0XHQnZW1iZWQtcmVzcG9uc2l2ZSBlbWJlZC1yZXNwb25zaXZlLTE2Ynk5JztcblxuXHRcdFx0XHRcdGVtYmVkQ29udGVudC5hdHRyaWJ1dGVzWydkYXRhLXN0eWxlcyddID0gSlNPTi5zdHJpbmdpZnkoXG5cdFx0XHRcdFx0XHRDS0VESVRPUi50b29scy5wYXJzZUNzc1RleHQoXG5cdFx0XHRcdFx0XHRcdHdpZGdldC5wYXJlbnQuYXR0cmlidXRlcy5zdHlsZVxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRlbWJlZENvbnRlbnQuYXR0cmlidXRlcy5zdHlsZSA9XG5cdFx0XHRcdFx0XHR3aWRnZXQucGFyZW50LmF0dHJpYnV0ZXMuc3R5bGU7XG5cblx0XHRcdFx0XHRyZXR1cm4gZW1iZWRDb250ZW50O1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHVwY2FzdChlbGVtZW50LCBkYXRhKSB7XG5cdFx0XHRcdFx0Y29uc3QgZW1iZWRXaWRnZXRVcGNhc3RGbiA9XG5cdFx0XHRcdFx0XHRlZGl0b3IuY29uZmlnLmVtYmVkV2lkZ2V0VXBjYXN0Rm4gfHxcblx0XHRcdFx0XHRcdGRlZmF1bHRFbWJlZFdpZGdldFVwY2FzdEZuO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGVtYmVkV2lkZ2V0VXBjYXN0Rm4oZWxlbWVudCwgZGF0YSk7XG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblxuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG5cdFx0XHRcdCdyZXNpemUnLFxuXHRcdFx0XHQoKSA9PiB7XG5cdFx0XHRcdFx0cmVzaXplci5oaWRlKCk7XG5cdFx0XHRcdFx0c2VsZWN0V2lkZ2V0KGVkaXRvcik7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZhbHNlXG5cdFx0XHQpO1xuXG5cdFx0XHRlZGl0b3Iub24oJ3NlbGVjdGlvbkNoYW5nZScsIF9ldmVudCA9PiB7XG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdFx0XHRpZiAoc2VsZWN0aW9uKSB7XG5cdFx0XHRcdFx0Y29uc3QgZWxlbWVudCA9IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuXHRcdFx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRjb25zdCB3aWRnZXRFbGVtZW50ID0gZWxlbWVudC5maW5kT25lKFxuXHRcdFx0XHRcdFx0XHQnW2RhdGEtd2lkZ2V0PVwiZW1iZWR1cmxcIl0nXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRpZiAod2lkZ2V0RWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBzY3JvbGxQb3NpdGlvbiA9IG5ldyBDS0VESVRPUi5kb20ud2luZG93KFxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvd1xuXHRcdFx0XHRcdFx0XHQpLmdldFNjcm9sbFBvc2l0aW9uKCk7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgcmVnaW9uID0gZWxlbWVudC5nZXRDbGllbnRSZWN0KCk7XG5cblx0XHRcdFx0XHRcdFx0cmVnaW9uLmRpcmVjdGlvbiA9IENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QO1xuXHRcdFx0XHRcdFx0XHRyZWdpb24ubGVmdCAtPSBzY3JvbGxQb3NpdGlvbi54O1xuXHRcdFx0XHRcdFx0XHRyZWdpb24udG9wICs9IHNjcm9sbFBvc2l0aW9uLnk7XG5cblx0XHRcdFx0XHRcdFx0ZWRpdG9yLmZpcmUoJ2VkaXRvckludGVyYWN0aW9uJywge1xuXHRcdFx0XHRcdFx0XHRcdG5hdGl2ZUV2ZW50OiB7fSxcblx0XHRcdFx0XHRcdFx0XHRzZWxlY3Rpb25EYXRhOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtZW50OiB3aWRnZXRFbGVtZW50LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVnaW9uLFxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb25zdCBpbWFnZUVsZW1lbnQgPSBlbGVtZW50LmZpbmRPbmUoXG5cdFx0XHRcdFx0XHRcdCdpbWcuY2tlX3dpZGdldF9tYXNrJ1xuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0aWYgKGltYWdlRWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRyZXNpemVyLnNob3coaW1hZ2VFbGVtZW50LiQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXNpemVyLmhpZGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRlZGl0b3Iub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHJlc2l6ZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2tpbWdyc3onKTtcblxuXHRcdFx0XHRpZiAocmVzaXplRWxlbWVudCkge1xuXHRcdFx0XHRcdHJlc2l6ZUVsZW1lbnQucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZURvd25MaXN0ZW5lcik7XG5cdFx0XHR9KTtcblxuXHRcdFx0ZWRpdG9yLm9uKCdibHVyJywgKCkgPT4ge1xuXHRcdFx0XHRyZXNpemVyLmhpZGUoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRlZGl0b3IuZmlsdGVyLmFkZEVsZW1lbnRDYWxsYmFjayhlbGVtZW50ID0+IHtcblx0XHRcdFx0aWYgKCdkYXRhLWVtYmVkLXVybCcgaW4gZWxlbWVudC5hdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIENLRURJVE9SLkZJTFRFUl9TS0lQX1RSRUU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRjb25zdCBtb3VzZURvd25MaXN0ZW5lciA9IGV2ZW50ID0+IHtcblx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gZ2V0U2VsZWN0ZWRFbGVtZW50KGVkaXRvcik7XG5cblx0XHRcdFx0Y3VycmVudEFsaWdubWVudCA9IHJlc3VsdC5hbGlnbm1lbnQ7XG5cdFx0XHRcdGN1cnJlbnRFbGVtZW50ID0gcmVzdWx0LmVsZW1lbnQ7XG5cblx0XHRcdFx0aWYgKHJlc2l6ZXIuaXNIYW5kbGUoZXZlbnQudGFyZ2V0KSkge1xuXHRcdFx0XHRcdHJlc2l6ZXIuaW5pdERyYWcoZXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXNpemVyID0gbmV3IFJlc2l6ZXIoZWRpdG9yLCB7XG5cdFx0XHRcdG9uQ29tcGxldGUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCkge1xuXHRcdFx0XHRcdHJlc2l6ZUVsZW1lbnQoZWxlbWVudCwgd2lkdGgsIGhlaWdodCk7XG5cblx0XHRcdFx0XHRpZiAoY3VycmVudEFsaWdubWVudCAmJiBjdXJyZW50RWxlbWVudCkge1xuXHRcdFx0XHRcdFx0c2V0RW1iZWRBbGlnbm1lbnQoY3VycmVudEVsZW1lbnQsIGN1cnJlbnRBbGlnbm1lbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWxlY3RXaWRnZXQoZWRpdG9yKTtcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZURvd25MaXN0ZW5lciwgZmFsc2UpO1xuXHRcdH0sXG5cblx0XHRhZnRlckluaXQ6IGVkaXRvciA9PiB7XG5cdFx0XHRBTElHTl9WQUxVRVMuZm9yRWFjaChhbGlnblZhbHVlID0+IHtcblx0XHRcdFx0Y29uc3QgY29tbWFuZCA9IGVkaXRvci5nZXRDb21tYW5kKCdqdXN0aWZ5JyArIGFsaWduVmFsdWUpO1xuXG5cdFx0XHRcdGlmIChjb21tYW5kKSB7XG5cdFx0XHRcdFx0Y29tbWFuZC5vbignZXhlYycsIGV2ZW50ID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IHNlbGVjdGVkRWxlbWVudCA9IGVkaXRvclxuXHRcdFx0XHRcdFx0XHQuZ2V0U2VsZWN0aW9uKClcblx0XHRcdFx0XHRcdFx0LmdldFNlbGVjdGVkRWxlbWVudCgpO1xuXG5cdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdHNlbGVjdGVkRWxlbWVudCAmJlxuXHRcdFx0XHRcdFx0XHRzZWxlY3RlZEVsZW1lbnQuZ2V0QXR0cmlidXRlKFxuXHRcdFx0XHRcdFx0XHRcdCdkYXRhLWNrZS13aWRnZXQtd3JhcHBlcidcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHNlbGVjdGVkRW1iZWQgPSBzZWxlY3RlZEVsZW1lbnQuZmluZE9uZShcblx0XHRcdFx0XHRcdFx0XHQnW2RhdGEtd2lkZ2V0PVwiZW1iZWR1cmxcIl0gW2RhdGEtZW1iZWQtaWRdJ1xuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChzZWxlY3RlZEVtYmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgZW1iZWRBbGlnbm1lbnQgPSBnZXRFbWJlZEFsaWdubWVudChcblx0XHRcdFx0XHRcdFx0XHRcdHNlbGVjdGVkRWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoZW1iZWRBbGlnbm1lbnQgPT09IGFsaWduVmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlbW92ZUVtYmVkQWxpZ25tZW50KFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzZWxlY3RlZEVsZW1lbnQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFsaWduVmFsdWVcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHNldEVtYmVkQWxpZ25tZW50KFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzZWxlY3RlZEVsZW1lbnQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFsaWduVmFsdWVcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudEVsZW1lbnQgPSBzZWxlY3RlZEVsZW1lbnQ7XG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudEFsaWdubWVudCA9IGdldEVtYmVkQWxpZ25tZW50KFxuXHRcdFx0XHRcdFx0XHRcdFx0c2VsZWN0ZWRFbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGltYWdlRWxlbWVudCA9IHNlbGVjdGVkRWxlbWVudC5maW5kT25lKFxuXHRcdFx0XHRcdFx0XHRcdFx0J2ltZydcblx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGltYWdlRWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzaXplci5zaG93KGltYWdlRWxlbWVudC4kKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRldmVudC5jYW5jZWwoKTtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGVsZW1lbnRQYXRoID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50UGF0aChcblx0XHRcdFx0XHRcdFx0XHRcdHNlbGVjdGVkRWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRBTElHTl9WQUxVRVMuZm9yRWFjaChhbGlnblZhbHVlID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGNvbW1hbmQgPSBlZGl0b3IuZ2V0Q29tbWFuZChcblx0XHRcdFx0XHRcdFx0XHRcdFx0J2p1c3RpZnknICsgYWxpZ25WYWx1ZVxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGNvbW1hbmQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29tbWFuZC5yZWZyZXNoKGVkaXRvciwgZWxlbWVudFBhdGgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRjb21tYW5kLm9uKCdyZWZyZXNoJywgZXZlbnQgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgbGFzdEVsZW1lbnQgPSBldmVudC5kYXRhLnBhdGgubGFzdEVsZW1lbnQ7XG5cblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQgJiZcblx0XHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFxuXHRcdFx0XHRcdFx0XHRcdCdkYXRhLWNrZS13aWRnZXQtd3JhcHBlcidcblx0XHRcdFx0XHRcdFx0KSAmJlxuXHRcdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5maW5kT25lKCdbZGF0YS13aWRnZXRdIFtkYXRhLWVtYmVkLWlkXScpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZW1iZWRBbGlnbm1lbnQgPSBnZXRFbWJlZEFsaWdubWVudChcblx0XHRcdFx0XHRcdFx0XHRsYXN0RWxlbWVudFxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdGV2ZW50LnNlbmRlci5zZXRTdGF0ZShcblx0XHRcdFx0XHRcdFx0XHRlbWJlZEFsaWdubWVudCA9PT0gYWxpZ25WYWx1ZVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBDS0VESVRPUi5UUklTVEFURV9PTlxuXHRcdFx0XHRcdFx0XHRcdFx0OiBDS0VESVRPUi5UUklTVEFURV9PRkZcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRldmVudC5jYW5jZWwoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblx0fSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENLRURJVE9SLnBsdWdpbnMuZ2V0KCdlbWJlZHVybCcpO1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pbXBvcnQgU2VsZWN0aW9uVGVzdCBmcm9tICcuLi9zZWxlY3Rpb25zL3NlbGVjdGlvbi10ZXN0JztcblxuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfaW1hZ2VhbGlnbm1lbnQnKSkge1xuXHQvKipcblx0ICogRW51bSBmb3Igc3VwcG9ydGVkIGltYWdlIGFsaWdubWVudHNcblx0ICogQHR5cGUge09iamVjdH1cblx0ICovXG5cdGNvbnN0IElNQUdFX0FMSUdOTUVOVCA9IHtcblx0XHRDRU5URVI6ICdjZW50ZXInLFxuXHRcdExFRlQ6ICdsZWZ0Jyxcblx0XHRSSUdIVDogJ3JpZ2h0Jyxcblx0fTtcblxuXHQvKipcblx0ICogRW51bSB2YWx1ZXMgZm9yIHN1cHBvcnRlZCBpbWFnZSBhbGlnbm1lbnRzXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICovXG5cdGNvbnN0IEFMSUdOX1ZBTFVFUyA9IFtcblx0XHRJTUFHRV9BTElHTk1FTlQuTEVGVCxcblx0XHRJTUFHRV9BTElHTk1FTlQuUklHSFQsXG5cdFx0SU1BR0VfQUxJR05NRU5ULkNFTlRFUixcblx0XTtcblxuXHQvKipcblx0ICogTmVjZXNzYXJ5IHN0eWxlcyBmb3IgdGhlIGxlZnR8Y2VudGVyfHJpZ2h0IGFsaWdubWVudFxuXHQgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG5cdCAqL1xuXHRjb25zdCBJTUFHRV9TVFlMRV9BTElHTk1FTlQgPSB7XG5cdFx0W0lNQUdFX0FMSUdOTUVOVC5MRUZUXTogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiAnZGlzcGxheScsXG5cdFx0XHRcdHZhbHVlOiAnaW5saW5lLWJsb2NrJyxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6ICdmbG9hdCcsXG5cdFx0XHRcdHZhbHVlOiAnbGVmdCcsXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiAnbWFyZ2luLXJpZ2h0Jyxcblx0XHRcdFx0dmFsdWU6ICcxLjJyZW0nLFxuXHRcdFx0fSxcblx0XHRdLFxuXHRcdFtJTUFHRV9BTElHTk1FTlQuQ0VOVEVSXTogW1xuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiAnZGlzcGxheScsXG5cdFx0XHRcdHZhbHVlOiAnYmxvY2snLFxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogJ21hcmdpbi1sZWZ0Jyxcblx0XHRcdFx0dmFsdWU6ICdhdXRvJyxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6ICdtYXJnaW4tcmlnaHQnLFxuXHRcdFx0XHR2YWx1ZTogJ2F1dG8nLFxuXHRcdFx0fSxcblx0XHRdLFxuXHRcdFtJTUFHRV9BTElHTk1FTlQuUklHSFRdOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6ICdkaXNwbGF5Jyxcblx0XHRcdFx0dmFsdWU6ICdpbmxpbmUtYmxvY2snLFxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogJ2Zsb2F0Jyxcblx0XHRcdFx0dmFsdWU6ICdyaWdodCcsXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiAnbWFyZ2luLWxlZnQnLFxuXHRcdFx0XHR2YWx1ZTogJzEuMnJlbScsXG5cdFx0XHR9LFxuXHRcdF0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgYWxpZ25tZW50IHZhbHVlIG9mIGFuIGltYWdlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBpbWFnZSBUaGUgaW1hZ2UgZWxlbWVudFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBhbGlnbm1lbnQgdmFsdWVcblx0ICovXG5cdGNvbnN0IGdldEltYWdlQWxpZ25tZW50ID0gZnVuY3Rpb24oaW1hZ2UpIHtcblx0XHRsZXQgaW1hZ2VBbGlnbm1lbnQgPSBpbWFnZS5nZXRTdHlsZSgnZmxvYXQnKTtcblxuXHRcdGlmIChcblx0XHRcdCFpbWFnZUFsaWdubWVudCB8fFxuXHRcdFx0aW1hZ2VBbGlnbm1lbnQgPT09ICdpbmhlcml0JyB8fFxuXHRcdFx0aW1hZ2VBbGlnbm1lbnQgPT09ICdub25lJ1xuXHRcdCkge1xuXHRcdFx0aW1hZ2VBbGlnbm1lbnQgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ2FsaWduJyk7XG5cdFx0fVxuXG5cdFx0aWYgKCFpbWFnZUFsaWdubWVudCkge1xuXHRcdFx0bGV0IGNlbnRlcmVkSW1hZ2UgPSBJTUFHRV9TVFlMRV9BTElHTk1FTlRbXG5cdFx0XHRcdElNQUdFX0FMSUdOTUVOVC5DRU5URVJcblx0XHRcdF0uZXZlcnkoc3R5bGUgPT4ge1xuXHRcdFx0XHRsZXQgc3R5bGVDaGVjayA9IGltYWdlLmdldFN0eWxlKHN0eWxlLm5hbWUpID09PSBzdHlsZS52YWx1ZTtcblxuXHRcdFx0XHRpZiAoIXN0eWxlQ2hlY2sgJiYgc3R5bGUudmVuZG9yUHJlZml4ZXMpIHtcblx0XHRcdFx0XHRzdHlsZUNoZWNrID0gc3R5bGUudmVuZG9yUHJlZml4ZXMuc29tZSh2ZW5kb3JQcmVmaXggPT4ge1xuXHRcdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdFx0aW1hZ2UuZ2V0U3R5bGUodmVuZG9yUHJlZml4ICsgc3R5bGUubmFtZSkgPT09XG5cdFx0XHRcdFx0XHRcdHN0eWxlLnZhbHVlXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHN0eWxlQ2hlY2s7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKCFpbWFnZUFsaWdubWVudCkge1xuXHRcdFx0XHRjb25zdCBpbWFnZUNvbnRhaW5lciA9IGltYWdlLiQucGFyZW50Tm9kZTtcblxuXHRcdFx0XHRpZiAoaW1hZ2VDb250YWluZXIuc3R5bGUudGV4dEFsaWduID09IElNQUdFX0FMSUdOTUVOVC5DRU5URVIpIHtcblx0XHRcdFx0XHRJTUFHRV9TVFlMRV9BTElHTk1FTlRbSU1BR0VfQUxJR05NRU5ULkNFTlRFUl0uZm9yRWFjaChcblx0XHRcdFx0XHRcdHN0eWxlID0+IHtcblx0XHRcdFx0XHRcdFx0aW1hZ2Uuc2V0U3R5bGUoc3R5bGUubmFtZSwgc3R5bGUudmFsdWUpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChzdHlsZS52ZW5kb3JQcmVmaXhlcykge1xuXHRcdFx0XHRcdFx0XHRcdHN0eWxlLnZlbmRvclByZWZpeGVzLmZvckVhY2godmVuZG9yUHJlZml4ID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdGltYWdlLnNldFN0eWxlKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2ZW5kb3JQcmVmaXggKyBzdHlsZS5uYW1lLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdHlsZS52YWx1ZVxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0Y2VudGVyZWRJbWFnZSA9IHRydWU7XG5cdFx0XHRcdFx0aW1hZ2VDb250YWluZXIuc3R5bGUudGV4dEFsaWduID0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aW1hZ2VBbGlnbm1lbnQgPSBjZW50ZXJlZEltYWdlID8gSU1BR0VfQUxJR05NRU5ULkNFTlRFUiA6IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKCFDS0VESVRPUi5lbnYuZWRnZSAmJiBDS0VESVRPUi5lbnYuaWUpIHtcblx0XHRcdGNvbnN0IHAgPSBpbWFnZS5maW5kT25lKCdwJyk7XG5cdFx0XHRpZiAocCkge1xuXHRcdFx0XHRpbWFnZUFsaWdubWVudCA9IHAuZ2V0U3R5bGUoJ3RleHQtYWxpZ24nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gaW1hZ2VBbGlnbm1lbnQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGFsaWdubWVudCB2YWx1ZSBvZiBhbiBpbWFnZVxuXHQgKlxuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBpbWFnZSBUaGUgaW1hZ2UgZWxlbWVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW1hZ2VBbGlnbm1lbnQgVGhlIGltYWdlIGFsaWdubWVudCB2YWx1ZSB0byBiZSByZW1vdmVkXG5cdCAqL1xuXHRjb25zdCByZW1vdmVJbWFnZUFsaWdubWVudCA9IGZ1bmN0aW9uKGltYWdlLCBpbWFnZUFsaWdubWVudCkge1xuXHRcdGlmIChcblx0XHRcdGltYWdlQWxpZ25tZW50ID09PSBJTUFHRV9BTElHTk1FTlQuTEVGVCB8fFxuXHRcdFx0aW1hZ2VBbGlnbm1lbnQgPT09IElNQUdFX0FMSUdOTUVOVC5SSUdIVFxuXHRcdCkge1xuXHRcdFx0aWYgKGltYWdlQWxpZ25tZW50ID09PSBnZXRJbWFnZUFsaWdubWVudChpbWFnZSkpIHtcblx0XHRcdFx0aW1hZ2UucmVtb3ZlQXR0cmlidXRlKCdhbGlnbicpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoaW1hZ2VBbGlnbm1lbnQgPT09IElNQUdFX0FMSUdOTUVOVC5DRU5URVIpIHtcblx0XHRcdGNvbnN0IGltYWdlQ29udGFpbmVyID0gaW1hZ2UuJC5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoaW1hZ2VDb250YWluZXIuc3R5bGUudGV4dEFsaWduID09IElNQUdFX0FMSUdOTUVOVC5DRU5URVIpIHtcblx0XHRcdFx0aW1hZ2VDb250YWluZXIuc3R5bGUudGV4dEFsaWduID0gJyc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc3R5bGVzID0gSU1BR0VfU1RZTEVfQUxJR05NRU5UW2ltYWdlQWxpZ25tZW50XTtcblxuXHRcdGlmIChzdHlsZXMpIHtcblx0XHRcdHN0eWxlcy5mb3JFYWNoKHN0eWxlID0+IHtcblx0XHRcdFx0aW1hZ2UucmVtb3ZlU3R5bGUoc3R5bGUubmFtZSk7XG5cblx0XHRcdFx0aWYgKHN0eWxlLnZlbmRvclByZWZpeGVzKSB7XG5cdFx0XHRcdFx0c3R5bGUudmVuZG9yUHJlZml4ZXMuZm9yRWFjaCh2ZW5kb3JQcmVmaXggPT4ge1xuXHRcdFx0XHRcdFx0aW1hZ2UucmVtb3ZlU3R5bGUodmVuZG9yUHJlZml4ICsgc3R5bGUubmFtZSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgYWxpZ25tZW50IHZhbHVlIG9mIGFuIGltYWdlXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGltYWdlIFRoZSBpbWFnZSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbWFnZUFsaWdubWVudCBUaGUgaW1hZ2UgYWxpZ25tZW50IHZhbHVlIHRvIGJlIHNldFxuXHQgKi9cblx0Y29uc3Qgc2V0SW1hZ2VBbGlnbm1lbnQgPSBmdW5jdGlvbihpbWFnZSwgaW1hZ2VBbGlnbm1lbnQpIHtcblx0XHRyZW1vdmVJbWFnZUFsaWdubWVudChpbWFnZSwgZ2V0SW1hZ2VBbGlnbm1lbnQoaW1hZ2UpKTtcblxuXHRcdGNvbnN0IHN0eWxlcyA9IElNQUdFX1NUWUxFX0FMSUdOTUVOVFtpbWFnZUFsaWdubWVudF07XG5cblx0XHRpZiAoc3R5bGVzKSB7XG5cdFx0XHRzdHlsZXMuZm9yRWFjaChzdHlsZSA9PiB7XG5cdFx0XHRcdGltYWdlLnNldFN0eWxlKHN0eWxlLm5hbWUsIHN0eWxlLnZhbHVlKTtcblxuXHRcdFx0XHRpZiAoc3R5bGUudmVuZG9yUHJlZml4ZXMpIHtcblx0XHRcdFx0XHRzdHlsZS52ZW5kb3JQcmVmaXhlcy5mb3JFYWNoKHZlbmRvclByZWZpeCA9PiB7XG5cdFx0XHRcdFx0XHRpbWFnZS5zZXRTdHlsZSh2ZW5kb3JQcmVmaXggKyBzdHlsZS5uYW1lLCBzdHlsZS52YWx1ZSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIG1vZGlmaWVzIHRoZSBqdXN0aWZ5IGNvbW1hbmRzIHRvIHByb3Blcmx5IGFsaWduIGltYWdlcy4gVGhpc1xuXHQgKiBwbHVnaW4gaXMgYW4gZXhjZXJwdCBvZiBDS0VkaXRvcidzIG9yaWdpbmFsIGltYWdlIG9uZSB0aGF0IGNhbiBiZSBmb3VuZCBhdFxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2tlZGl0b3IvY2tlZGl0b3ItZGV2L2Jsb2IvbWFzdGVyL3BsdWdpbnMvaW1hZ2UvcGx1Z2luLmpzXG5cdCAqXG5cdCAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX2ltYWdlYWxpZ25tZW50XG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfaW1hZ2VhbGlnbm1lbnQnLCB7XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuXHRcdCAqIFRoZSBmdW5jdGlvbiByZWdpc3RlcnMgYSAncGFzdGUnIGV2ZW50IG9uIHRoZSBlZGl0aW5nIGFyZWEuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIGFmdGVySW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICovXG5cdFx0YWZ0ZXJJbml0KGVkaXRvcikge1xuXHRcdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0XHRcdEFMSUdOX1ZBTFVFUy5mb3JFYWNoKHZhbHVlID0+IHtcblx0XHRcdFx0Y29uc3QgY29tbWFuZCA9IGVkaXRvci5nZXRDb21tYW5kKCdqdXN0aWZ5JyArIHZhbHVlKTtcblxuXHRcdFx0XHRpZiAoY29tbWFuZCkge1xuXHRcdFx0XHRcdGNvbW1hbmQub24oJ2V4ZWMnLCBldmVudCA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBzZWxlY3Rpb25EYXRhID0gZWRpdG9yLmdldFNlbGVjdGlvbkRhdGEoKTtcblxuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRzZWxlY3Rpb25EYXRhICYmXG5cdFx0XHRcdFx0XHRcdFNlbGVjdGlvblRlc3QuaW1hZ2Uoe1xuXHRcdFx0XHRcdFx0XHRcdGRhdGE6IHtzZWxlY3Rpb25EYXRhfSxcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBpbWFnZSA9IHNlbGVjdGlvbkRhdGEuZWxlbWVudDtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBpbWFnZUFsaWdubWVudCA9IGdldEltYWdlQWxpZ25tZW50KGltYWdlKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoaW1hZ2VBbGlnbm1lbnQgPT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVtb3ZlSW1hZ2VBbGlnbm1lbnQoaW1hZ2UsIHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRJbWFnZUFsaWdubWVudChpbWFnZSwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0ZXZlbnQuY2FuY2VsKCk7XG5cblx0XHRcdFx0XHRcdFx0c2VsZi5yZWZyZXNoQ29tbWFuZHMoXG5cdFx0XHRcdFx0XHRcdFx0ZWRpdG9yLFxuXHRcdFx0XHRcdFx0XHRcdG5ldyBDS0VESVRPUi5kb20uZWxlbWVudFBhdGgoaW1hZ2UpXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRjb21tYW5kLm9uKCdyZWZyZXNoJywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQ6IGV2ZW50LmRhdGEucGF0aC5sYXN0RWxlbWVudCxcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0U2VsZWN0aW9uVGVzdC5pbWFnZSh7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YToge3NlbGVjdGlvbkRhdGF9LFxuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGltYWdlQWxpZ25tZW50ID0gZ2V0SW1hZ2VBbGlnbm1lbnQoXG5cdFx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uRGF0YS5lbGVtZW50XG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRTdGF0ZShcblx0XHRcdFx0XHRcdFx0XHRpbWFnZUFsaWdubWVudCA9PT0gdmFsdWVcblx0XHRcdFx0XHRcdFx0XHRcdD8gQ0tFRElUT1IuVFJJU1RBVEVfT05cblx0XHRcdFx0XHRcdFx0XHRcdDogQ0tFRElUT1IuVFJJU1RBVEVfT0ZGXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0ZXZlbnQuY2FuY2VsKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBGb3JjZXMgYSByZWZyZXNoIG9mIHRoZSBtb2RpZmllZCBqdXN0aWZ5IGNvbW1hbmRzLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBhcHBsaWVkIGNoYW5nZXNcblx0XHQgKiBkbyBub3QgbW9kaWZ5IHRoZSBzZWxlY3Rpb24sIHNvIHRoZSByZWZyZXNoIGlzIG5ldmVyIHRyaWdnZXJlZCBhbmQgdGhlIFVJIGRvZXMgbm90IHVwZGF0ZVxuXHRcdCAqIHByb3Blcmx5IHVudGlsIHRoZSBuZXh0IHNlbGVjdGlvbkNoYW5nZSBldmVudC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Q0tFRElUT1IuZWRpdG9yfSBlZGl0b3IgVGhlIGVkaXRvciBpbnN0YW5jZVxuXHRcdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnRQYXRofSBlbGVtZW50UGF0aCBUaGUgcGF0aCBvZiB0aGUgc2VsZWN0ZWQgaW1hZ2Vcblx0XHQgKi9cblx0XHRyZWZyZXNoQ29tbWFuZHMoZWRpdG9yLCBlbGVtZW50UGF0aCkge1xuXHRcdFx0QUxJR05fVkFMVUVTLmZvckVhY2godmFsdWUgPT4ge1xuXHRcdFx0XHRjb25zdCBjb21tYW5kID0gZWRpdG9yLmdldENvbW1hbmQoJ2p1c3RpZnknICsgdmFsdWUpO1xuXG5cdFx0XHRcdGlmIChjb21tYW5kKSB7XG5cdFx0XHRcdFx0Y29tbWFuZC5yZWZyZXNoKGVkaXRvciwgZWxlbWVudFBhdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXHR9KTtcbn1cbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0ICcuL2FkZGltYWdlcyc7XG5cbmltcG9ydCAnLi9hdXRvbGluayc7XG5cbmltcG9ydCAnLi9hdXRvbGlzdCc7XG5cbmltcG9ydCAnLi9kcmFncmVzaXplJztcblxuaW1wb3J0ICcuL2RyYWdyZXNpemVfaWUxMSc7XG5cbmltcG9ydCAnLi9lbWJlZCc7XG5pbXBvcnQgZW1iZWR1cmwgZnJvbSAnLi9lbWJlZHVybCc7XG5cbmltcG9ydCAnLi9pbWFnZWFsaWdubWVudCc7XG5cbmltcG9ydCAnLi9wYXN0ZWltYWdlcyc7XG5cbmltcG9ydCAnLi9wbGFjZWhvbGRlcic7XG5cbmltcG9ydCAnLi9zZWxlY3Rpb25rZXlzdHJva2VzJztcblxuaW1wb3J0ICcuL3RhYmxlcmVzaXplJztcblxuaW1wb3J0ICcuL3RhYmxldG9vbHMnO1xuXG5leHBvcnQge2VtYmVkdXJsfTtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfcGFzdGVpbWFnZXMnKSkge1xuXHQvKipcblx0ICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGFsbG93cyBwYXN0aW5nIGltYWdlcyBkaXJlY3RseSBpbnRvIHRoZSBlZGl0YWJsZSBhcmVhLiBUaGUgaW1hZ2Ugd2lsbCBiZSBlbmNvZGVkXG5cdCAqIGFzIERhdGEgVVJJLiBBbiBldmVudCBgYmVmb3JlSW1hZ2VBZGRgIHdpbGwgYmUgZmlyZWQgd2l0aCB0aGUgbGlzdCBvZiBwYXN0ZWQgaW1hZ2VzLiBJZiBhbnkgb2YgdGhlIGxpc3RlbmVyc1xuXHQgKiByZXR1cm5zIGBmYWxzZWAgb3IgY2FuY2VscyB0aGUgZXZlbnQsIHRoZSBpbWFnZXMgd29uJ3QgYmUgYWRkZWQgdG8gdGhlIGNvbnRlbnQuIE90aGVyd2lzZSxcblx0ICogYW4gZXZlbnQgYGltYWdlQWRkYCB3aWxsIGJlIGZpcmVkIHdpdGggdGhlIGluc2VydGVkIGVsZW1lbnQgaW50byB0aGUgZWRpdGFibGUgYXJlYS5cblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfcGFzdGVpbWFnZXNcblx0ICovXG5cblx0LyoqXG5cdCAqIEZpcmVkIGJlZm9yZSBhZGRpbmcgaW1hZ2VzIHRvIHRoZSBlZGl0b3IuXG5cdCAqIEBldmVudCBiZWZvcmVJbWFnZUFkZFxuXHQgKiBAcGFyYW0ge0FycmF5fSBpbWFnZUZpbGVzIEFycmF5IG9mIGltYWdlIGZpbGVzXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBGaXJlZCB3aGVuIGFuIGltYWdlIGlzIGJlaW5nIGFkZGVkIHRvIHRoZSBlZGl0b3Igc3VjY2Vzc2Z1bGx5LlxuXHQgKlxuXHQgKiBAZXZlbnQgaW1hZ2VBZGRcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZWwgVGhlIGNyZWF0ZWQgaW1hZ2Ugd2l0aCBzcmMgYXMgRGF0YSBVUklcblx0ICogQHBhcmFtIHtGaWxlfSBmaWxlIFRoZSBpbWFnZSBmaWxlXG5cdCAqL1xuXG5cdENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV9wYXN0ZWltYWdlcycsIHtcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXphdGlvbiBvZiB0aGUgcGx1Z2luLCBwYXJ0IG9mIENLRWRpdG9yIHBsdWdpbiBsaWZlY3ljbGUuXG5cdFx0ICogVGhlIGZ1bmN0aW9uIHJlZ2lzdGVycyBhICdwYXN0ZScgZXZlbnQgb24gdGhlIGVkaXRpbmcgYXJlYS5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgaW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICovXG5cdFx0aW5pdChlZGl0b3IpIHtcblx0XHRcdGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRcdGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKFxuXHRcdFx0XHRcdGVkaXRhYmxlLFxuXHRcdFx0XHRcdCdwYXN0ZScsXG5cdFx0XHRcdFx0dGhpcy5fb25QYXN0ZSxcblx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGVkaXRvcixcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGZ1bmN0aW9uIGNyZWF0ZXMgYW4gaW1nIGVsZW1lbnQgd2l0aCBzcmMgdGhlIGltYWdlIGRhdGEgYXMgRGF0YSBVUkkuXG5cdFx0ICogVGhlbiwgaXQgZmlyZXMgYW4gJ2ltYWdlQWRkJyBldmVudCB2aWEgQ0tFZGl0b3IncyBldmVudCBzeXN0ZW0uIFRoZSBwYXNzZWRcblx0XHQgKiBwYXJhbXMgd2lsbCBiZTpcblx0XHQgKiAtIGBlbGAgLSB0aGUgY3JlYXRlZCBpbWcgZWxlbWVudFxuXHRcdCAqIC0gYGZpbGVgIC0gdGhlIG9yaWdpbmFsIHBhc3RlZCBkYXRhXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIF9vblBhc3RlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmV2ZW50fSBldmVudCBBIGBwYXN0ZWAgZXZlbnQsIGFzIHJlY2VpdmVkIG5hdGl2ZWx5IGZyb20gQ0tFZGl0b3Jcblx0XHQgKi9cblx0XHRfb25QYXN0ZShldmVudCkge1xuXHRcdFx0aWYgKGV2ZW50LmRhdGEuJC5jbGlwYm9hcmREYXRhKSB7XG5cdFx0XHRcdGNvbnN0IHBhc3RlZERhdGEgPSBldmVudC5kYXRhLiQuY2xpcGJvYXJkRGF0YS5pdGVtc1swXTtcblx0XHRcdFx0Y29uc3QgZWRpdG9yID0gZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcjtcblxuXHRcdFx0XHRpZiAocGFzdGVkRGF0YS50eXBlLmluZGV4T2YoJ2ltYWdlJykgPT09IDApIHtcblx0XHRcdFx0XHRjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0XHRcdGNvbnN0IGltYWdlRmlsZSA9IHBhc3RlZERhdGEuZ2V0QXNGaWxlKCk7XG5cblx0XHRcdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHJlc3VsdCA9IGVkaXRvci5maXJlKCdiZWZvcmVJbWFnZUFkZCcsIHtcblx0XHRcdFx0XHRcdFx0aW1hZ2VGaWxlczogaW1hZ2VGaWxlLFxuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZWwgPSBDS0VESVRPUi5kb20uZWxlbWVudC5jcmVhdGVGcm9tSHRtbChcblx0XHRcdFx0XHRcdFx0XHQnPGltZyBzcmM9XCInICsgZXZlbnQudGFyZ2V0LnJlc3VsdCArICdcIj4nXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0ZWRpdG9yLmluc2VydEVsZW1lbnQoZWwpO1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGltYWdlRGF0YSA9IHtcblx0XHRcdFx0XHRcdFx0XHRlbCxcblx0XHRcdFx0XHRcdFx0XHRmaWxlOiBpbWFnZUZpbGUsXG5cdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0ZWRpdG9yLmZpcmUoJ2ltYWdlQWRkJywgaW1hZ2VEYXRhKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0cmVhZGVyLnJlYWRBc0RhdGFVUkwoaW1hZ2VGaWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdH0pO1xufVxuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9wbGFjZWhvbGRlcicpKSB7XG5cdC8qKlxuXHQgKiBDS0VESVRPUiBlbnRlck1vZGUgY29uZmlnIHNldCB0aGUgYmVoYXZpb3Igb2YgcGFyYWdyYXBoc1xuXHQgKiBXaGVuIHRoZSBjb250ZW50IGlzIGVtcHR5IENLRURJVE9SIGtlZXBzIHRoZSBlbnRlck1vZGUgc3RyaW5nXG5cdCAqIGludG8gdGhlIGNvbnRlbnRcblx0ICogQHByb3BlcnR5XG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRjb25zdCBickZpbGxlciA9IENLRURJVE9SLmVudi5uZWVkc0JyRmlsbGVyID8gJzxicj4nIDogJyc7XG5cblx0Y29uc3QgZW50ZXJNb2RlRW1wdHlWYWx1ZSA9IHtcblx0XHQxOiBbJzxwPicgKyBickZpbGxlciArICc8L3A+J10sXG5cdFx0MjogWycnLCAnICcsIGJyRmlsbGVyXSxcblx0XHQzOiBbJzxkaXY+JyArIGJyRmlsbGVyICsgJzwvZGl2PiddLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gd2hpY2ggYWxsb3dzIGFkZGluZyBhIHBsYWNlaG9sZGVyIHRvIHRoZSBlZGl0b3IuIEluIHRoaXMgY2FzZSwgaWYgdGhlcmVcblx0ICogaXMgbm8gY29udGVudCB0byB0aGUgZWRpdG9yLCB0aGVyZSB3aWxsIGJlIGhpbnQgdG8gdGhlIHVzZXIuXG5cdCAqXG5cdCAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX3BsYWNlaG9sZGVyXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgdGhlIHBsYWNlaG9sZGVyIGNsYXNzIHdoaWNoIGhhdmUgdG8gYmUgYWRlZCB0byBlZGl0b3Igd2hlbiBlZGl0b3IgaXMgbm90IGZvY3VzZWQuXG5cdCAqXG5cdCAqIEBhdHRyaWJ1dGUgcGxhY2Vob2xkZXJDbGFzc1xuXHQgKiBAZGVmYXVsdCBhZV9wbGFjZWhvbGRlclxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICovXG5cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3BsYWNlaG9sZGVyJywge1xuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBwbHVnaW4sIHBhcnQgb2YgQ0tFZGl0b3IgcGx1Z2luIGxpZmVjeWNsZS5cblx0XHQgKiBUaGUgZnVuY3Rpb24gcmVnaXN0ZXJzIGEgJ2JsdXInIGFuZCAnY29udGVudERvbScgZXZlbnQgbGlzdGVuZXJzLlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBpbml0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2Vcblx0XHQgKi9cblx0XHRpbml0KGVkaXRvcikge1xuXHRcdFx0ZWRpdG9yLm9uKCdibHVyJywgdGhpcy5fY2hlY2tFbXB0eURhdGEsIHRoaXMpO1xuXHRcdFx0ZWRpdG9yLm9uKCdjaGFuZ2UnLCB0aGlzLl9jaGVja0VtcHR5RGF0YSwgdGhpcyk7XG5cdFx0XHRlZGl0b3Iub24oJ2ZvY3VzJywgdGhpcy5fcmVtb3ZlUGxhY2Vob2xkZXJDbGFzcywgdGhpcyk7XG5cdFx0XHRlZGl0b3Iub25jZSgnY29udGVudERvbScsIHRoaXMuX2NoZWNrRW1wdHlEYXRhLCB0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBhbnkgZGF0YSBmcm9tIHRoZSBjb250ZW50IGFuZCBhZGRzIGEgY2xhc3MsXG5cdFx0ICogc3BlY2lmaWVkIGJ5IHRoZSBcInBsYWNlaG9sZGVyQ2xhc3NcIiBjb25maWcgYXR0cmlidXRlLlxuXHRcdCAqXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBtZXRob2QgX2NoZWNrRW1wdHlEYXRhXG5cdFx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZXZlbnR9IGVkaXRvciBldmVudCwgZmlyZWQgZnJvbSBDS0VkaXRvclxuXHRcdCAqL1xuXHRcdF9jaGVja0VtcHR5RGF0YShldmVudCkge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gZXZlbnQuZWRpdG9yO1xuXG5cdFx0XHRjb25zdCBlZGl0YWJsZU5vZGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuXHRcdFx0Y29uc3QgaW5uZXJIdG1sID0gZWRpdGFibGVOb2RlLiQuaW5uZXJIVE1MLnRyaW0oKTtcblxuXHRcdFx0Y29uc3QgaXNFbXB0eSA9IGVudGVyTW9kZUVtcHR5VmFsdWVbZWRpdG9yLmNvbmZpZy5lbnRlck1vZGVdLnNvbWUoXG5cdFx0XHRcdGVsZW1lbnQgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBpbm5lckh0bWwgPT09IGVsZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cblx0XHRcdGlmIChpc0VtcHR5KSB7XG5cdFx0XHRcdGVkaXRhYmxlTm9kZS5hZGRDbGFzcyhlZGl0b3IuY29uZmlnLnBsYWNlaG9sZGVyQ2xhc3MpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWRpdGFibGVOb2RlLnJlbW92ZUNsYXNzKGVkaXRvci5jb25maWcucGxhY2Vob2xkZXJDbGFzcyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlIHBsYWNlaG9sZGVyIGNsYXNzIHdoZW4gaW5wdXQgaXMgZm9jdXNlZFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqIEBtZXRob2QgX3JlbW92ZVBsYWNlaG9sZGVyQ2xhc3NcbiAgICAgICAgICAgICArIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmV2ZW50fSBlZGl0b3IgZXZlbnQsIGZpcmVkIGZyb20gQ0tFZGl0b3JcbiAgICAgICAgICAgICAqL1xuXHRcdF9yZW1vdmVQbGFjZWhvbGRlckNsYXNzKGV2ZW50KSB7XG5cdFx0XHRjb25zdCBlZGl0b3IgPSBldmVudC5lZGl0b3I7XG5cblx0XHRcdGNvbnN0IGVkaXRvck5vZGUgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZWRpdG9yLmVsZW1lbnQuJCk7XG5cblx0XHRcdGVkaXRvck5vZGUucmVtb3ZlQ2xhc3MoZWRpdG9yLmNvbmZpZy5wbGFjZWhvbGRlckNsYXNzKTtcblx0XHR9LFxuXHR9KTtcbn1cbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuLyoqXG4gKiBQcmlvcml0aWVzIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXIgaW4gd2hpY2ggZXZlbnQgaGFuZGxlcnMgcnVuLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9ja2VkaXRvci5jb20vZG9jcy9ja2VkaXRvcjQvbGF0ZXN0L2FwaS9DS0VESVRPUl9ldmVudC5odG1sI21ldGhvZC1vblxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9QUklPUklUWSA9IDEwO1xuZXhwb3J0IGNvbnN0IEhJR0hfUFJJT1JJVFkgPSA1O1xuIiwiLyoqXG4gKiBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiDCqSAyMDE0IExpZmVyYXksIEluYy4gPGh0dHBzOi8vbGlmZXJheS5jb20+XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTEdQTC0zLjAtb3ItbGF0ZXJcbiAqL1xuXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9zZWxlY3Rpb25rZXlzdHJva2VzJykpIHtcblx0LyoqXG5cdCAqIENLRWRpdG9yIHBsdWdpbiB0aGF0IHNpbXVsYXRlcyBlZGl0b3IgaW50ZXJhY3Rpb24gZXZlbnRzIGJhc2VkIG9uIG1hbnVhbCBrZXlzdHJva2VzLiBUaGlzXG5cdCAqIGNhbiBiZSB1c2VkIHRvIHRyaWdnZXIgZGlmZmVyZW50IHJlYWN0aW9ucyBpbiB0aGUgZWRpdG9yLlxuXHQgKlxuXHQgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9zZWxlY3Rpb25rZXlzdHJva2VzXG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfc2VsZWN0aW9ua2V5c3Ryb2tlcycsIHtcblx0XHRyZXF1aXJlczogJ2FlX3NlbGVjdGlvbnJlZ2lvbicsXG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXphdGlvbiBvZiB0aGUgcGx1Z2luLCBwYXJ0IG9mIENLRWRpdG9yIHBsdWdpbiBsaWZlY3ljbGUuXG5cdFx0ICogVGhlIGZ1bmN0aW9uIGFkZHMgYSBjb21tYW5kIHRvIHRoZSBlZGl0b3IgZm9yIGV2ZXJ5IGRlZmluZWQgc2VsZWN0aW9uS2V5c3Ryb2tlXG5cdFx0ICogaW4gdGhlIGNvbmZpZ3VyYXRpb24gYW5kIG1hcHMgaXQgdG8gdGhlIHNwZWNpZmllZCBrZXlzdHJva2UuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIGluaXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuXHRcdCAqL1xuXHRcdGluaXQoZWRpdG9yKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmNvbmZpZy5zZWxlY3Rpb25LZXlzdHJva2VzKSB7XG5cdFx0XHRcdGVkaXRvci5jb25maWcuc2VsZWN0aW9uS2V5c3Ryb2tlcy5mb3JFYWNoKFxuXHRcdFx0XHRcdHNlbGVjdGlvbktleXN0cm9rZSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBjb21tYW5kID0gbmV3IENLRURJVE9SLmNvbW1hbmQoZWRpdG9yLCB7XG5cdFx0XHRcdFx0XHRcdGV4ZWMoZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZWRpdG9yLmZpcmUoJ2VkaXRvckludGVyYWN0aW9uJywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bWFudWFsU2VsZWN0aW9uOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzZWxlY3Rpb25LZXlzdHJva2Uuc2VsZWN0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdFx0bmF0aXZlRXZlbnQ6IHt9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uRGF0YTogZWRpdG9yLmdldFNlbGVjdGlvbkRhdGEoKSxcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBjb21tYW5kTmFtZSA9XG5cdFx0XHRcdFx0XHRcdCdzZWxlY3Rpb25LZXlzdHJva2UnICsgc2VsZWN0aW9uS2V5c3Ryb2tlLnNlbGVjdGlvbjtcblxuXHRcdFx0XHRcdFx0ZWRpdG9yLmFkZENvbW1hbmQoY29tbWFuZE5hbWUsIGNvbW1hbmQpO1xuXHRcdFx0XHRcdFx0ZWRpdG9yLnNldEtleXN0cm9rZShcblx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uS2V5c3Ryb2tlLmtleXMsXG5cdFx0XHRcdFx0XHRcdGNvbW1hbmROYW1lXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9LFxuXHR9KTtcbn1cbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAxNSwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHA6Ly9ja2VkaXRvci5jb20vbGljZW5zZVxuICovXG5cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3RhYmxlcmVzaXplJykpIHtcblx0Y29uc3QgcHhVbml0ID0gQ0tFRElUT1IudG9vbHMuY3NzTGVuZ3RoO1xuXG5cdGZ1bmN0aW9uIGdldFdpZHRoKGVsKSB7XG5cdFx0cmV0dXJuIENLRURJVE9SLmVudi5pZVxuXHRcdFx0PyBlbC4kLmNsaWVudFdpZHRoXG5cdFx0XHQ6IHBhcnNlSW50KGVsLmdldENvbXB1dGVkU3R5bGUoJ3dpZHRoJyksIDEwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEJvcmRlcldpZHRoKGVsZW1lbnQsIHNpZGUpIHtcblx0XHRsZXQgY29tcHV0ZWQgPSBlbGVtZW50LmdldENvbXB1dGVkU3R5bGUoJ2JvcmRlci0nICsgc2lkZSArICctd2lkdGgnKTtcblxuXHRcdGNvbnN0IGJvcmRlck1hcCA9IHtcblx0XHRcdHRoaW46ICcwcHgnLFxuXHRcdFx0bWVkaXVtOiAnMXB4Jyxcblx0XHRcdHRoaWNrOiAnMnB4Jyxcblx0XHR9O1xuXG5cdFx0aWYgKGNvbXB1dGVkLmluZGV4T2YoJ3B4JykgPCAwKSB7XG5cdFx0XHQvLyBsb29rIHVwIGtleXdvcmRzXG5cblx0XHRcdGlmIChcblx0XHRcdFx0Y29tcHV0ZWQgaW4gYm9yZGVyTWFwICYmXG5cdFx0XHRcdGVsZW1lbnQuZ2V0Q29tcHV0ZWRTdHlsZSgnYm9yZGVyLXN0eWxlJykgIT0gJ25vbmUnXG5cdFx0XHQpIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBib3JkZXJNYXBbY29tcHV0ZWRdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBwYXJzZUludChjb21wdXRlZCwgMTApO1xuXHR9XG5cblx0Ly8gR2V0cyB0aGUgdGFibGUgcm93IHRoYXQgY29udGFpbnMgdGhlIG1vc3QgY29sdW1ucy5cblxuXHRmdW5jdGlvbiBnZXRNYXN0ZXJQaWxsYXJSb3codGFibGUpIHtcblx0XHRjb25zdCAkcm93cyA9IHRhYmxlLiQucm93cztcblxuXHRcdGxldCBtYXhDZWxscyA9IDA7XG5cblx0XHRsZXQgY2VsbHNDb3VudDtcblxuXHRcdGxldCAkZWxlY3RlZDtcblxuXHRcdGxldCAkdHI7XG5cblx0XHRmb3IgKGxldCBpID0gMCwgbGVuID0gJHJvd3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdCR0ciA9ICRyb3dzW2ldO1xuXHRcdFx0Y2VsbHNDb3VudCA9ICR0ci5jZWxscy5sZW5ndGg7XG5cblx0XHRcdGlmIChjZWxsc0NvdW50ID4gbWF4Q2VsbHMpIHtcblx0XHRcdFx0bWF4Q2VsbHMgPSBjZWxsc0NvdW50O1xuXHRcdFx0XHQkZWxlY3RlZCA9ICR0cjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gJGVsZWN0ZWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBidWlsZFRhYmxlQ29sdW1uUGlsbGFycyh0YWJsZSkge1xuXHRcdGNvbnN0IHBpbGxhcnMgPSBbXTtcblxuXHRcdGxldCBwaWxsYXJJbmRleCA9IC0xO1xuXG5cdFx0Y29uc3QgcnRsID0gdGFibGUuZ2V0Q29tcHV0ZWRTdHlsZSgnZGlyZWN0aW9uJykgPT09ICdydGwnO1xuXG5cdFx0Ly8gR2V0IHRoZSByYXcgcm93IGVsZW1lbnQgdGhhdCBjb2ludGFpbnMgdGhlIG1vc3QgY29sdW1ucy5cblxuXHRcdGNvbnN0ICR0ciA9IGdldE1hc3RlclBpbGxhclJvdyh0YWJsZSk7XG5cblx0XHQvLyBHZXQgdGhlIHRib2R5IGVsZW1lbnQgYW5kIHBvc2l0aW9uLCB3aGljaCB3aWxsIGJlIHVzZWQgdG8gc2V0IHRoZVxuXHRcdC8vIHRvcCBhbmQgYm90dG9tIGJvdW5kYXJpZXMuXG5cblx0XHRjb25zdCB0Ym9keSA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCh0YWJsZS4kLnRCb2RpZXNbMF0pO1xuXG5cdFx0Y29uc3QgdGJvZHlQb3NpdGlvbiA9IHRib2R5LmdldERvY3VtZW50UG9zaXRpb24oKTtcblxuXHRcdC8vIExvb3AgdGhvcnVnaCBhbGwgY2VsbHMsIGJ1aWxkaW5nIHBpbGxhcnMgYWZ0ZXIgZWFjaCBvbmUgb2YgdGhlbS5cblxuXHRcdGZvciAobGV0IGkgPSAwLCBsZW4gPSAkdHIuY2VsbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdC8vIEJvdGggdGhlIGN1cnJlbnQgY2VsbCBhbmQgdGhlIHN1Y2Nlc3NpdmUgb25lIHdpbGwgYmUgdXNlZCBpbiB0aGVcblx0XHRcdC8vIHBpbGxhciBzaXplIGNhbGN1bGF0aW9uLlxuXG5cdFx0XHRjb25zdCB0ZCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCgkdHIuY2VsbHNbaV0pO1xuXG5cdFx0XHRjb25zdCBuZXh0VGQgPVxuXHRcdFx0XHQkdHIuY2VsbHNbaSArIDFdICYmIG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCgkdHIuY2VsbHNbaSArIDFdKTtcblxuXHRcdFx0cGlsbGFySW5kZXggKz0gdGQuJC5jb2xTcGFuIHx8IDE7XG5cblx0XHRcdC8vIENhbGN1bGF0ZSB0aGUgcGlsbGFyIGJvdW5kYXJ5IHBvc2l0aW9ucy5cblxuXHRcdFx0bGV0IHBpbGxhckxlZnQ7XG5cdFx0XHRsZXQgcGlsbGFyUmlnaHQ7XG5cblx0XHRcdGxldCB4ID0gdGQuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLng7XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbnMgYmFzZWQgb24gdGhlIGN1cnJlbnQgY2VsbC5cblxuXHRcdFx0aWYgKHJ0bCkge1xuXHRcdFx0XHRwaWxsYXJSaWdodCA9IHggKyBnZXRCb3JkZXJXaWR0aCh0ZCwgJ2xlZnQnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBpbGxhckxlZnQgPSB4ICsgdGQuJC5vZmZzZXRXaWR0aCAtIGdldEJvcmRlcldpZHRoKHRkLCAncmlnaHQnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiB0aGUgbmV4dCBjZWxsLCBpZiBhdmFpbGFibGUuXG5cblx0XHRcdGlmIChuZXh0VGQpIHtcblx0XHRcdFx0eCA9IG5leHRUZC5nZXREb2N1bWVudFBvc2l0aW9uKCkueDtcblxuXHRcdFx0XHRpZiAocnRsKSB7XG5cdFx0XHRcdFx0cGlsbGFyTGVmdCA9XG5cdFx0XHRcdFx0XHR4ICtcblx0XHRcdFx0XHRcdG5leHRUZC4kLm9mZnNldFdpZHRoIC1cblx0XHRcdFx0XHRcdGdldEJvcmRlcldpZHRoKG5leHRUZCwgJ3JpZ2h0Jyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGlsbGFyUmlnaHQgPSB4ICsgZ2V0Qm9yZGVyV2lkdGgobmV4dFRkLCAnbGVmdCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBjYWxjdWxhdGUgcG9zaXRpb25zIGJhc2VkIG9uIHRoZSB0YWJsZSAoZm9yIGxhc3QgY2VsbCkuXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0eCA9IHRhYmxlLmdldERvY3VtZW50UG9zaXRpb24oKS54O1xuXG5cdFx0XHRcdGlmIChydGwpIHtcblx0XHRcdFx0XHRwaWxsYXJMZWZ0ID0geDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwaWxsYXJSaWdodCA9IHggKyB0YWJsZS4kLm9mZnNldFdpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHBpbGxhcldpZHRoID0gTWF0aC5tYXgocGlsbGFyUmlnaHQgLSBwaWxsYXJMZWZ0LCA0KTtcblxuXHRcdFx0Ly8gVGhlIHBpbGxhciBzaG91bGQgcmVmbGVjdHMgZXhhY3RseSB0aGUgc2hhcGUgb2YgdGhlIGhvdmVyZWRcblx0XHRcdC8vIGNvbHVtbiBib3JkZXIgbGluZS5cblxuXHRcdFx0cGlsbGFycy5wdXNoKHtcblx0XHRcdFx0dGFibGUsXG5cdFx0XHRcdGluZGV4OiBwaWxsYXJJbmRleCxcblx0XHRcdFx0eDogcGlsbGFyTGVmdCxcblx0XHRcdFx0eTogdGJvZHlQb3NpdGlvbi55LFxuXHRcdFx0XHR3aWR0aDogcGlsbGFyV2lkdGgsXG5cdFx0XHRcdGhlaWdodDogdGJvZHkuJC5vZmZzZXRIZWlnaHQsXG5cdFx0XHRcdHJ0bCxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBwaWxsYXJzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UGlsbGFyQXRQb3NpdGlvbihwaWxsYXJzLCBwb3NpdGlvblgpIHtcblx0XHRmb3IgKGxldCBpID0gMCwgbGVuID0gcGlsbGFycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y29uc3QgcGlsbGFyID0gcGlsbGFyc1tpXTtcblxuXHRcdFx0aWYgKHBvc2l0aW9uWCA+PSBwaWxsYXIueCAmJiBwb3NpdGlvblggPD0gcGlsbGFyLnggKyBwaWxsYXIud2lkdGgpIHtcblx0XHRcdFx0cmV0dXJuIHBpbGxhcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNhbmNlbChldnQpIHtcblx0XHQoZXZ0LmRhdGEgfHwgZXZ0KS5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gQ29sdW1uUmVzaXplcihlZGl0b3IsIHBpbGxhcikge1xuXHRcdGxldCBjdXJyZW50U2hpZnQ7XG5cdFx0bGV0IGxlZnRTaGlmdEJvdW5kYXJ5O1xuXHRcdGxldCBsZWZ0U2lkZUNlbGxzO1xuXHRcdGxldCByZXNpemluZztcblx0XHRsZXQgcmlnaHRTaGlmdEJvdW5kYXJ5O1xuXHRcdGxldCByaWdodFNpZGVDZWxscztcblx0XHRsZXQgc3RhcnRPZmZzZXQ7XG5cblx0XHRjb25zdCBkb2N1bWVudCA9IGVkaXRvci5kb2N1bWVudDtcblxuXHRcdGNvbnN0IHJlc2l6ZXIgPSBDS0VESVRPUi5kb20uZWxlbWVudC5jcmVhdGVGcm9tSHRtbChcblx0XHRcdCc8ZGl2IGRhdGEtY2tlLXRlbXA9MSBjb250ZW50ZWRpdGFibGU9ZmFsc2UgdW5zZWxlY3RhYmxlPW9uICcgK1xuXHRcdFx0XHQnc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTtjdXJzb3I6Y29sLXJlc2l6ZTtmaWx0ZXI6YWxwaGEob3BhY2l0eT0wKTtvcGFjaXR5OjA7JyArXG5cdFx0XHRcdCdwYWRkaW5nOjA7YmFja2dyb3VuZC1jb2xvcjojMDA0O2JhY2tncm91bmQtaW1hZ2U6bm9uZTtib3JkZXI6MHB4IG5vbmU7ei1pbmRleDoxMFwiPjwvZGl2PicsXG5cdFx0XHRkb2N1bWVudFxuXHRcdCk7XG5cblx0XHRjb25zdCBpc1Jlc2l6aW5nID0gKHRoaXMuaXNSZXNpemluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHJlc2l6aW5nO1xuXHRcdH0pO1xuXG5cdFx0Y29uc3QgbW92ZSA9ICh0aGlzLm1vdmUgPSBmdW5jdGlvbihwb3NYKSB7XG5cdFx0XHRsZXQgcmVzaXplck5ld1Bvc2l0aW9uID1cblx0XHRcdFx0cG9zWCAtIE1hdGgucm91bmQocmVzaXplci4kLm9mZnNldFdpZHRoIC8gMik7XG5cblx0XHRcdGlmIChpc1Jlc2l6aW5nKSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZXNpemVyTmV3UG9zaXRpb24gPT09IGxlZnRTaGlmdEJvdW5kYXJ5IHx8XG5cdFx0XHRcdFx0cmVzaXplck5ld1Bvc2l0aW9uID09PSByaWdodFNoaWZ0Qm91bmRhcnlcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzaXplck5ld1Bvc2l0aW9uID0gTWF0aC5tYXgoXG5cdFx0XHRcdFx0cmVzaXplck5ld1Bvc2l0aW9uLFxuXHRcdFx0XHRcdGxlZnRTaGlmdEJvdW5kYXJ5XG5cdFx0XHRcdCk7XG5cdFx0XHRcdHJlc2l6ZXJOZXdQb3NpdGlvbiA9IE1hdGgubWluKFxuXHRcdFx0XHRcdHJlc2l6ZXJOZXdQb3NpdGlvbixcblx0XHRcdFx0XHRyaWdodFNoaWZ0Qm91bmRhcnlcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRjdXJyZW50U2hpZnQgPSByZXNpemVyTmV3UG9zaXRpb24gLSBzdGFydE9mZnNldDtcblx0XHRcdH1cblxuXHRcdFx0cmVzaXplci5zZXRTdHlsZSgnbGVmdCcsIHB4VW5pdChyZXNpemVyTmV3UG9zaXRpb24pKTtcblx0XHR9KTtcblxuXHRcdGZ1bmN0aW9uIGRldGFjaCgpIHtcblx0XHRcdHJlc2l6ZXIucmVtb3ZlTGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuXHRcdFx0cmVzaXplci5yZW1vdmVMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuXHRcdFx0cmVzaXplci5yZW1vdmVMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc2l6ZVN0YXJ0KCkge1xuXHRcdFx0Ly8gQmVmb3JlIHN0YXJ0aW5nIHRvIHJlc2l6ZSwgZmlndXJlIG91dCB3aGljaCBjZWxscyB0byBjaGFuZ2Vcblx0XHRcdC8vIGFuZCB0aGUgYm91bmRhcmllcyBvZiB0aGlzIHJlc2l6aW5nIHNoaWZ0LlxuXG5cdFx0XHRjb25zdCBjb2x1bW5JbmRleCA9IHBpbGxhci5pbmRleDtcblxuXHRcdFx0Y29uc3QgbWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcChwaWxsYXIudGFibGUpO1xuXG5cdFx0XHRjb25zdCBsZWZ0Q29sdW1uQ2VsbHMgPSBbXTtcblxuXHRcdFx0Y29uc3QgcmlnaHRDb2x1bW5DZWxscyA9IFtdO1xuXG5cdFx0XHRsZXQgbGVmdE1pblNpemUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG5cdFx0XHRsZXQgcmlnaHRNaW5TaXplID0gbGVmdE1pblNpemU7XG5cblx0XHRcdGNvbnN0IHJ0bCA9IHBpbGxhci5ydGw7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsZW4gPSBtYXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0Y29uc3Qgcm93ID0gbWFwW2ldO1xuXG5cdFx0XHRcdGxldCBsZWZ0Q2VsbCA9IHJvd1tjb2x1bW5JbmRleCArIChydGwgPyAxIDogMCldO1xuXG5cdFx0XHRcdGxldCByaWdodENlbGwgPSByb3dbY29sdW1uSW5kZXggKyAocnRsID8gMCA6IDEpXTtcblxuXHRcdFx0XHRsZWZ0Q2VsbCA9IGxlZnRDZWxsICYmIG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChsZWZ0Q2VsbCk7XG5cdFx0XHRcdHJpZ2h0Q2VsbCA9IHJpZ2h0Q2VsbCAmJiBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQocmlnaHRDZWxsKTtcblxuXHRcdFx0XHRpZiAoIWxlZnRDZWxsIHx8ICFyaWdodENlbGwgfHwgIWxlZnRDZWxsLmVxdWFscyhyaWdodENlbGwpKSB7XG5cdFx0XHRcdFx0aWYgKGxlZnRDZWxsKSB7XG5cdFx0XHRcdFx0XHRsZWZ0TWluU2l6ZSA9IE1hdGgubWluKGxlZnRNaW5TaXplLCBnZXRXaWR0aChsZWZ0Q2VsbCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocmlnaHRDZWxsKSB7XG5cdFx0XHRcdFx0XHRyaWdodE1pblNpemUgPSBNYXRoLm1pbihcblx0XHRcdFx0XHRcdFx0cmlnaHRNaW5TaXplLFxuXHRcdFx0XHRcdFx0XHRnZXRXaWR0aChyaWdodENlbGwpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxlZnRDb2x1bW5DZWxscy5wdXNoKGxlZnRDZWxsKTtcblx0XHRcdFx0XHRyaWdodENvbHVtbkNlbGxzLnB1c2gocmlnaHRDZWxsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWNoZSB0aGUgbGlzdCBvZiBjZWxscyB0byBiZSByZXNpemVkLlxuXG5cdFx0XHRsZWZ0U2lkZUNlbGxzID0gbGVmdENvbHVtbkNlbGxzO1xuXHRcdFx0cmlnaHRTaWRlQ2VsbHMgPSByaWdodENvbHVtbkNlbGxzO1xuXG5cdFx0XHQvLyBDYWNoZSB0aGUgcmVzaXplIGxpbWl0IGJvdW5kYXJpZXMuXG5cblx0XHRcdGxlZnRTaGlmdEJvdW5kYXJ5ID0gcGlsbGFyLnggLSBsZWZ0TWluU2l6ZTtcblx0XHRcdHJpZ2h0U2hpZnRCb3VuZGFyeSA9IHBpbGxhci54ICsgcmlnaHRNaW5TaXplO1xuXG5cdFx0XHRyZXNpemVyLnNldE9wYWNpdHkoMC41KTtcblx0XHRcdHN0YXJ0T2Zmc2V0ID0gcGFyc2VJbnQocmVzaXplci5nZXRTdHlsZSgnbGVmdCcpLCAxMCk7XG5cdFx0XHRjdXJyZW50U2hpZnQgPSAwO1xuXHRcdFx0cmVzaXppbmcgPSAxO1xuXG5cdFx0XHRyZXNpemVyLm9uKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG5cblx0XHRcdC8vIFByZXZlbnQgdGhlIG5hdGl2ZSBkcmFnIGJlaGF2aW9yIG90aGVyd2lzZSAnbW91c2Vtb3ZlJyB3b24ndCBmaXJlLlxuXG5cdFx0XHRkb2N1bWVudC5vbignZHJhZ3N0YXJ0JywgY2FuY2VsKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXNpemVFbmQoKSB7XG5cdFx0XHRyZXNpemluZyA9IDA7XG5cblx0XHRcdHJlc2l6ZXIuc2V0T3BhY2l0eSgwKTtcblxuXHRcdFx0aWYgKGN1cnJlbnRTaGlmdCkge1xuXHRcdFx0XHRyZXNpemVDb2x1bW4oKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdGFibGUgPSBwaWxsYXIudGFibGU7XG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0dGFibGUucmVtb3ZlQ3VzdG9tRGF0YSgnX2NrZV90YWJsZV9waWxsYXJzJyk7XG5cdFx0XHR9LCAwKTtcblxuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlTGlzdGVuZXIoJ2RyYWdzdGFydCcsIGNhbmNlbCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzaXplQ29sdW1uKCkge1xuXHRcdFx0Y29uc3QgcnRsID0gcGlsbGFyLnJ0bDtcblxuXHRcdFx0Y29uc3QgY2VsbHNDb3VudCA9IHJ0bFxuXHRcdFx0XHQ/IHJpZ2h0U2lkZUNlbGxzLmxlbmd0aFxuXHRcdFx0XHQ6IGxlZnRTaWRlQ2VsbHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBQZXJmb3JtIHRoZSBhY3R1YWwgcmVzaXplIHRvIHRhYmxlIGNlbGxzLCBvbmx5IGZvciB0aG9zZSBieSBzaWRlIG9mIHRoZSBwaWxsYXIuXG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHNDb3VudDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGxlZnRDZWxsID0gbGVmdFNpZGVDZWxsc1tpXTtcblxuXHRcdFx0XHRjb25zdCByaWdodENlbGwgPSByaWdodFNpZGVDZWxsc1tpXTtcblxuXHRcdFx0XHRjb25zdCB0YWJsZSA9IHBpbGxhci50YWJsZTtcblxuXHRcdFx0XHQvLyBEZWZlciB0aGUgcmVzaXppbmcgdG8gYXZvaWQgYW55IGludGVyZmVyZW5jZSBhbW9uZyBjZWxscy5cblxuXHRcdFx0XHRDS0VESVRPUi50b29scy5zZXRUaW1lb3V0KFxuXHRcdFx0XHRcdChcblx0XHRcdFx0XHRcdGxlZnRDZWxsLFxuXHRcdFx0XHRcdFx0bGVmdE9sZFdpZHRoLFxuXHRcdFx0XHRcdFx0cmlnaHRDZWxsLFxuXHRcdFx0XHRcdFx0cmlnaHRPbGRXaWR0aCxcblx0XHRcdFx0XHRcdHRhYmxlV2lkdGgsXG5cdFx0XHRcdFx0XHRzaXplU2hpZnRcblx0XHRcdFx0XHQpID0+IHtcblx0XHRcdFx0XHRcdC8vIDFweCBpcyB0aGUgbWluaW11bSB2YWxpZCB3aWR0aCAoIzExNjI2KS5cblxuXHRcdFx0XHRcdFx0aWYgKGxlZnRDZWxsKSB7XG5cdFx0XHRcdFx0XHRcdGxlZnRDZWxsLnNldFN0eWxlKFxuXHRcdFx0XHRcdFx0XHRcdCd3aWR0aCcsXG5cdFx0XHRcdFx0XHRcdFx0cHhVbml0KE1hdGgubWF4KGxlZnRPbGRXaWR0aCArIHNpemVTaGlmdCwgMSkpXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAocmlnaHRDZWxsKSB7XG5cdFx0XHRcdFx0XHRcdHJpZ2h0Q2VsbC5zZXRTdHlsZShcblx0XHRcdFx0XHRcdFx0XHQnd2lkdGgnLFxuXHRcdFx0XHRcdFx0XHRcdHB4VW5pdChNYXRoLm1heChyaWdodE9sZFdpZHRoIC0gc2l6ZVNoaWZ0LCAxKSlcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSWYgd2UncmUgaW4gdGhlIGxhc3QgY2VsbCwgd2UgbmVlZCB0byByZXNpemUgdGhlIHRhYmxlIGFzIHdlbGxcblxuXHRcdFx0XHRcdFx0aWYgKHRhYmxlV2lkdGgpIHtcblx0XHRcdFx0XHRcdFx0dGFibGUuc2V0U3R5bGUoXG5cdFx0XHRcdFx0XHRcdFx0J3dpZHRoJyxcblx0XHRcdFx0XHRcdFx0XHRweFVuaXQodGFibGVXaWR0aCArIHNpemVTaGlmdCAqIChydGwgPyAtMSA6IDEpKVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdGxlZnRDZWxsLFxuXHRcdFx0XHRcdFx0bGVmdENlbGwgJiYgZ2V0V2lkdGgobGVmdENlbGwpLFxuXHRcdFx0XHRcdFx0cmlnaHRDZWxsLFxuXHRcdFx0XHRcdFx0cmlnaHRDZWxsICYmIGdldFdpZHRoKHJpZ2h0Q2VsbCksXG5cdFx0XHRcdFx0XHQoIWxlZnRDZWxsIHx8ICFyaWdodENlbGwpICYmXG5cdFx0XHRcdFx0XHRcdGdldFdpZHRoKHRhYmxlKSArXG5cdFx0XHRcdFx0XHRcdFx0Z2V0Qm9yZGVyV2lkdGgodGFibGUsICdsZWZ0JykgK1xuXHRcdFx0XHRcdFx0XHRcdGdldEJvcmRlcldpZHRoKHRhYmxlLCAncmlnaHQnKSxcblx0XHRcdFx0XHRcdGN1cnJlbnRTaGlmdCxcblx0XHRcdFx0XHRdXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Nb3VzZURvd24oZXZ0KSB7XG5cdFx0XHRjYW5jZWwoZXZ0KTtcblxuXHRcdFx0cmVzaXplU3RhcnQoKTtcblxuXHRcdFx0ZG9jdW1lbnQub24oJ21vdXNldXAnLCBvbk1vdXNlVXAsIHRoaXMpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uTW91c2VVcChldnQpIHtcblx0XHRcdGV2dC5yZW1vdmVMaXN0ZW5lcigpO1xuXG5cdFx0XHRyZXNpemVFbmQoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbk1vdXNlTW92ZShldnQpIHtcblx0XHRcdG1vdmUoZXZ0LmRhdGEuZ2V0UGFnZU9mZnNldCgpLngpO1xuXHRcdH1cblxuXHRcdC8vIENsZWFuIERPTSB3aGVuIGVkaXRvciBpcyBkZXN0cm95ZWQuXG5cblx0XHRlZGl0b3Iub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG5cdFx0XHRkZXRhY2goKTtcblxuXHRcdFx0cmVzaXplci5yZW1vdmUoKTtcblx0XHR9KTtcblxuXHRcdC8vIFBsYWNlIHRoZSByZXNpemVyIGFmdGVyIGJvZHkgdG8gcHJldmVudCBpdFxuXHRcdC8vIGZyb20gYmVpbmcgZWRpdGFibGUuXG5cblx0XHRkb2N1bWVudC5nZXREb2N1bWVudEVsZW1lbnQoKS5hcHBlbmQocmVzaXplcik7XG5cblx0XHRyZXNpemVyLnNldFN0eWxlcyh7XG5cdFx0XHR3aWR0aDogcHhVbml0KHBpbGxhci53aWR0aCksXG5cdFx0XHRoZWlnaHQ6IHB4VW5pdChwaWxsYXIuaGVpZ2h0KSxcblx0XHRcdGxlZnQ6IHB4VW5pdChwaWxsYXIueCksXG5cdFx0XHR0b3A6IHB4VW5pdChwaWxsYXIueSksXG5cdFx0fSk7XG5cblx0XHRyZXNpemVyLm9uKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgdGhpcyk7XG5cblx0XHRkb2N1bWVudC5nZXRCb2R5KCkuc2V0U3R5bGUoJ2N1cnNvcicsICdjb2wtcmVzaXplJyk7XG5cblx0XHQvLyBEaXNwbGF5IHRoZSByZXNpemVyIHRvIHJlY2VpdmUgZXZlbnRzIGJ1dCBkb24ndCBzaG93IGl0LFxuXHRcdC8vIG9ubHkgY2hhbmdlIHRoZSBjdXJzb3IgdG8gcmVzaXphYmxlIHNoYXBlLlxuXG5cdFx0cmVzaXplci5zaG93KCk7XG5cblx0XHR0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHRcdGRldGFjaCgpO1xuXG5cdFx0XHRkb2N1bWVudC5nZXRCb2R5KCkuc2V0U3R5bGUoJ2N1cnNvcicsICdhdXRvJyk7XG5cblx0XHRcdHJlc2l6ZXIucmVtb3ZlKCk7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNsZWFyUGlsbGFyc0NhY2hlKGV2dCkge1xuXHRcdGNvbnN0IHRhcmdldCA9IGV2dC5kYXRhLmdldFRhcmdldCgpO1xuXG5cdFx0aWYgKGV2dC5uYW1lID09PSAnbW91c2VvdXQnKSB7XG5cdFx0XHQvLyBCeXBhc3MgaW50ZXJhbCBtb3VzZSBtb3ZlLlxuXG5cdFx0XHRpZiAoIXRhcmdldC5pcygndGFibGUnKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGxldCBkZXN0ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KFxuXHRcdFx0XHRldnQuZGF0YS4kLnJlbGF0ZWRUYXJnZXQgfHwgZXZ0LmRhdGEuJC50b0VsZW1lbnRcblx0XHRcdCk7XG5cdFx0XHR3aGlsZSAoZGVzdCAmJiBkZXN0LiQgJiYgIWRlc3QuZXF1YWxzKHRhcmdldCkgJiYgIWRlc3QuaXMoJ2JvZHknKSkge1xuXHRcdFx0XHRkZXN0ID0gZGVzdC5nZXRQYXJlbnQoKTtcblx0XHRcdH1cblx0XHRcdGlmICghZGVzdCB8fCBkZXN0LmVxdWFscyh0YXJnZXQpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0YXJnZXQuZ2V0QXNjZW5kYW50KCd0YWJsZScsIDEpLnJlbW92ZUN1c3RvbURhdGEoJ19ja2VfdGFibGVfcGlsbGFycycpO1xuXHRcdGV2dC5yZW1vdmVMaXN0ZW5lcigpO1xuXHR9XG5cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3RhYmxlcmVzaXplJywge1xuXHRcdHJlcXVpcmVzOiAnYWVfdGFibGV0b29scycsXG5cblx0XHRpbml0KGVkaXRvcikge1xuXHRcdFx0ZWRpdG9yLm9uKCdjb250ZW50RG9tJywgKCkgPT4ge1xuXHRcdFx0XHRsZXQgcmVzaXplcjtcblxuXHRcdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRcdC8vIEluIENsYXNzaWMgZWRpdG9yIGl0IGlzIGJldHRlciB0byB1c2UgZG9jdW1lbnRcblx0XHRcdFx0Ly8gaW5zdGVhZCBvZiBlZGl0YWJsZSBzbyBldmVudCB3aWxsIHdvcmsgYmVsb3cgYm9keS5cblxuXHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0XHRlZGl0YWJsZS5pc0lubGluZSgpID8gZWRpdGFibGUgOiBlZGl0b3IuZG9jdW1lbnQsXG5cdFx0XHRcdFx0J21vdXNlbW92ZScsXG5cdFx0XHRcdFx0ZXZ0ID0+IHtcblx0XHRcdFx0XHRcdGV2dCA9IGV2dC5kYXRhO1xuXG5cdFx0XHRcdFx0XHRjb25zdCB0YXJnZXQgPSBldnQuZ2V0VGFyZ2V0KCk7XG5cblx0XHRcdFx0XHRcdC8vIEZGIG1heSByZXR1cm4gZG9jdW1lbnQgYW5kIElFOCBzb21lIFVGTyAob2JqZWN0IHdpdGggbm8gbm9kZVR5cGUgcHJvcGVydHkuLi4pXG5cdFx0XHRcdFx0XHQvLyBpbnN0ZWFkIG9mIGFuIGVsZW1lbnQgKCMxMTgyMykuXG5cblx0XHRcdFx0XHRcdGlmICh0YXJnZXQudHlwZSAhPT0gQ0tFRElUT1IuTk9ERV9FTEVNRU5UKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgcGFnZVggPSBldnQuZ2V0UGFnZU9mZnNldCgpLng7XG5cblx0XHRcdFx0XHRcdC8vIElmIHdlJ3JlIGFscmVhZHkgYXR0YWNoZWQgdG8gYSBwaWxsYXIsIHNpbXBseSBtb3ZlIHRoZVxuXHRcdFx0XHRcdFx0Ly8gcmVzaXplci5cblxuXHRcdFx0XHRcdFx0aWYgKHJlc2l6ZXIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHJlc2l6ZXIuaXNSZXNpemluZygpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzaXplci5tb3ZlKHBhZ2VYKTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhbmNlbChldnQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHJlc2l6ZXIuZGVzdHJveSgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0cmVzaXplciA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gQ29uc2lkZXJpbmcgdGFibGUsIHRyLCB0ZCwgdGJvZHkgYnV0IG5vdGhpbmcgZWxzZS5cblxuXHRcdFx0XHRcdFx0bGV0IHBpbGxhcnM7XG5cblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0IXRhcmdldC5pcygndGFibGUnKSAmJlxuXHRcdFx0XHRcdFx0XHQhdGFyZ2V0LmdldEFzY2VuZGFudCgndGJvZHknLCAxKVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgdGFibGUgPSB0YXJnZXQuZ2V0QXNjZW5kYW50KCd0YWJsZScsIDEpO1xuXG5cdFx0XHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhlIHRhYmxlIHdlIGZvdW5kIGlzIGluc2lkZSB0aGUgY29udGFpbmVyXG5cdFx0XHRcdFx0XHQvLyAoZWcuIHdlIHNob3VsZCBub3QgdXNlIHRhYmxlcyB0aGUgZWRpdG9yIGlzIGVtYmVkZGVkIHdpdGhpbilcblxuXHRcdFx0XHRcdFx0aWYgKCFlZGl0b3IuZWRpdGFibGUoKS5jb250YWlucyh0YWJsZSkpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdCEocGlsbGFycyA9IHRhYmxlLmdldEN1c3RvbURhdGEoXG5cdFx0XHRcdFx0XHRcdFx0J19ja2VfdGFibGVfcGlsbGFycydcblx0XHRcdFx0XHRcdFx0KSlcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0YWJsZSBwaWxsYXJzIGNhbGN1bGF0aW9uIHJlc3VsdC5cblxuXHRcdFx0XHRcdFx0XHR0YWJsZS5zZXRDdXN0b21EYXRhKFxuXHRcdFx0XHRcdFx0XHRcdCdfY2tlX3RhYmxlX3BpbGxhcnMnLFxuXHRcdFx0XHRcdFx0XHRcdChwaWxsYXJzID0gYnVpbGRUYWJsZUNvbHVtblBpbGxhcnModGFibGUpKVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR0YWJsZS5vbignbW91c2VvdXQnLCBjbGVhclBpbGxhcnNDYWNoZSk7XG5cdFx0XHRcdFx0XHRcdHRhYmxlLm9uKCdtb3VzZWRvd24nLCBjbGVhclBpbGxhcnNDYWNoZSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IHBpbGxhciA9IGdldFBpbGxhckF0UG9zaXRpb24ocGlsbGFycywgcGFnZVgpO1xuXG5cdFx0XHRcdFx0XHRpZiAocGlsbGFyKSB7XG5cdFx0XHRcdFx0XHRcdHJlc2l6ZXIgPSBuZXcgQ29sdW1uUmVzaXplcihlZGl0b3IsIHBpbGxhcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMTUsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwOi8vY2tlZGl0b3IuY29tL2xpY2Vuc2VcbiAqL1xuXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV90YWJsZXRvb2xzJykpIHtcblx0Y29uc3QgY2VsbE5vZGVSZWdleCA9IC9eKD86dGR8dGgpJC87XG5cblx0ZnVuY3Rpb24gZ2V0U2VsZWN0ZWRDZWxscyhzZWxlY3Rpb24pIHtcblx0XHRjb25zdCByYW5nZXMgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VzKCk7XG5cdFx0Y29uc3QgcmV0dmFsID0gW107XG5cdFx0Y29uc3QgZGF0YWJhc2UgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIG1vdmVPdXRPZkNlbGxHdWFyZChub2RlKSB7XG5cdFx0XHQvLyBBcHBseSB0byB0aGUgZmlyc3QgY2VsbCBvbmx5LlxuXG5cdFx0XHRpZiAocmV0dmFsLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZSBhcmUgZXhpdGluZyBmcm9tIHRoZSBmaXJzdCA8L3RkPiwgdGhlbiB0aGUgdGQgc2hvdWxkIGRlZmluaXRlbHkgYmVcblx0XHRcdC8vIGluY2x1ZGVkLlxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5vZGUudHlwZSA9PSBDS0VESVRPUi5OT0RFX0VMRU1FTlQgJiZcblx0XHRcdFx0Y2VsbE5vZGVSZWdleC50ZXN0KG5vZGUuZ2V0TmFtZSgpKSAmJlxuXHRcdFx0XHQhbm9kZS5nZXRDdXN0b21EYXRhKCdzZWxlY3RlZF9jZWxsJylcblx0XHRcdCkge1xuXHRcdFx0XHRDS0VESVRPUi5kb20uZWxlbWVudC5zZXRNYXJrZXIoXG5cdFx0XHRcdFx0ZGF0YWJhc2UsXG5cdFx0XHRcdFx0bm9kZSxcblx0XHRcdFx0XHQnc2VsZWN0ZWRfY2VsbCcsXG5cdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRyZXR2YWwucHVzaChub2RlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgcmFuZ2UgPSByYW5nZXNbaV07XG5cblx0XHRcdGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcblx0XHRcdFx0Ly8gV2Fsa2VyIGRvZXMgbm90IGhhbmRsZSBjb2xsYXBzZWQgcmFuZ2VzIHlldCAtIGZhbGwgYmFjayB0byBvbGQgQVBJLlxuXG5cdFx0XHRcdGNvbnN0IHN0YXJ0Tm9kZSA9IHJhbmdlLmdldENvbW1vbkFuY2VzdG9yKCk7XG5cdFx0XHRcdGNvbnN0IG5lYXJlc3RDZWxsID1cblx0XHRcdFx0XHRzdGFydE5vZGUuZ2V0QXNjZW5kYW50KCd0ZCcsIHRydWUpIHx8XG5cdFx0XHRcdFx0c3RhcnROb2RlLmdldEFzY2VuZGFudCgndGgnLCB0cnVlKTtcblx0XHRcdFx0aWYgKG5lYXJlc3RDZWxsKSB7XG5cdFx0XHRcdFx0cmV0dmFsLnB1c2gobmVhcmVzdENlbGwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCB3YWxrZXIgPSBuZXcgQ0tFRElUT1IuZG9tLndhbGtlcihyYW5nZSk7XG5cdFx0XHRcdGxldCBub2RlO1xuXHRcdFx0XHR3YWxrZXIuZ3VhcmQgPSBtb3ZlT3V0T2ZDZWxsR3VhcmQ7XG5cblx0XHRcdFx0d2hpbGUgKChub2RlID0gd2Fsa2VyLm5leHQoKSkpIHtcblx0XHRcdFx0XHQvLyBJZiBtYXkgYmUgcG9zc2libGUgZm9yIHVzIHRvIGhhdmUgYSByYW5nZSBsaWtlIHRoaXM6XG5cdFx0XHRcdFx0Ly8gPHRkPl4xPC90ZD48dGQ+XjI8L3RkPlxuXHRcdFx0XHRcdC8vIFRoZSAybmQgdGQgc2hvdWxkbid0IGJlIGluY2x1ZGVkLlxuXHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0Ly8gU28gd2UgaGF2ZSB0byB0YWtlIGNhcmUgdG8gaW5jbHVkZSBhIHRkIHdlJ3ZlIGVudGVyZWQgb25seSB3aGVuIHdlJ3ZlXG5cdFx0XHRcdFx0Ly8gd2Fsa2VkIGludG8gaXRzIGNoaWxkcmVuLlxuXG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0bm9kZS50eXBlICE9IENLRURJVE9SLk5PREVfRUxFTUVOVCB8fFxuXHRcdFx0XHRcdFx0IW5vZGUuaXMoQ0tFRElUT1IuZHRkLnRhYmxlKVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgcGFyZW50ID1cblx0XHRcdFx0XHRcdFx0bm9kZS5nZXRBc2NlbmRhbnQoJ3RkJywgdHJ1ZSkgfHxcblx0XHRcdFx0XHRcdFx0bm9kZS5nZXRBc2NlbmRhbnQoJ3RoJywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRpZiAocGFyZW50ICYmICFwYXJlbnQuZ2V0Q3VzdG9tRGF0YSgnc2VsZWN0ZWRfY2VsbCcpKSB7XG5cdFx0XHRcdFx0XHRcdENLRURJVE9SLmRvbS5lbGVtZW50LnNldE1hcmtlcihcblx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZSxcblx0XHRcdFx0XHRcdFx0XHRwYXJlbnQsXG5cdFx0XHRcdFx0XHRcdFx0J3NlbGVjdGVkX2NlbGwnLFxuXHRcdFx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0cmV0dmFsLnB1c2gocGFyZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRDS0VESVRPUi5kb20uZWxlbWVudC5jbGVhckFsbE1hcmtlcnMoZGF0YWJhc2UpO1xuXG5cdFx0cmV0dXJuIHJldHZhbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEZvY3VzRWxlbWVudEFmdGVyRGVsQ2VsbHMoY2VsbHNUb0RlbGV0ZSkge1xuXHRcdGxldCBpID0gMDtcblxuXHRcdGNvbnN0IGxhc3QgPSBjZWxsc1RvRGVsZXRlLmxlbmd0aCAtIDE7XG5cblx0XHRjb25zdCBkYXRhYmFzZSA9IHt9O1xuXG5cdFx0bGV0IGNlbGw7XG5cblx0XHRsZXQgZm9jdXNlZENlbGw7XG5cblx0XHRsZXQgdHI7XG5cblx0XHR3aGlsZSAoKGNlbGwgPSBjZWxsc1RvRGVsZXRlW2krK10pKSB7XG5cdFx0XHRDS0VESVRPUi5kb20uZWxlbWVudC5zZXRNYXJrZXIoZGF0YWJhc2UsIGNlbGwsICdkZWxldGVfY2VsbCcsIHRydWUpO1xuXHRcdH1cblxuXHRcdC8vIDEuZmlyc3Qgd2UgY2hlY2sgbGVmdCBvciByaWdodCBzaWRlIGZvY3VzYWJsZSBjZWxsIHJvdyBieSByb3c7XG5cblx0XHRpID0gMDtcblx0XHR3aGlsZSAoKGNlbGwgPSBjZWxsc1RvRGVsZXRlW2krK10pKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCgoZm9jdXNlZENlbGwgPSBjZWxsLmdldFByZXZpb3VzKCkpICYmXG5cdFx0XHRcdFx0IWZvY3VzZWRDZWxsLmdldEN1c3RvbURhdGEoJ2RlbGV0ZV9jZWxsJykpIHx8XG5cdFx0XHRcdCgoZm9jdXNlZENlbGwgPSBjZWxsLmdldE5leHQoKSkgJiZcblx0XHRcdFx0XHQhZm9jdXNlZENlbGwuZ2V0Q3VzdG9tRGF0YSgnZGVsZXRlX2NlbGwnKSlcblx0XHRcdCkge1xuXHRcdFx0XHRDS0VESVRPUi5kb20uZWxlbWVudC5jbGVhckFsbE1hcmtlcnMoZGF0YWJhc2UpO1xuXG5cdFx0XHRcdHJldHVybiBmb2N1c2VkQ2VsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRDS0VESVRPUi5kb20uZWxlbWVudC5jbGVhckFsbE1hcmtlcnMoZGF0YWJhc2UpO1xuXG5cdFx0Ly8gMi4gdGhlbiB3ZSBjaGVjayB0aGUgdG9wcGVzdCByb3cgKG91dHNpZGUgdGhlIHNlbGVjdGlvbiBhcmVhIHNxdWFyZSkgZm9jdXNhYmxlIGNlbGxcblxuXHRcdHRyID0gY2VsbHNUb0RlbGV0ZVswXS5nZXRQYXJlbnQoKTtcblx0XHRpZiAoKHRyID0gdHIuZ2V0UHJldmlvdXMoKSkpIHtcblx0XHRcdHJldHVybiB0ci5nZXRMYXN0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gMy4gbGFzdCB3ZSBjaGVjayB0aGUgbG93ZXJlc3QgIHJvdyBmb2N1c2FibGUgY2VsbFxuXG5cdFx0dHIgPSBjZWxsc1RvRGVsZXRlW2xhc3RdLmdldFBhcmVudCgpO1xuXHRcdGlmICgodHIgPSB0ci5nZXROZXh0KCkpKSB7XG5cdFx0XHRyZXR1cm4gdHIuZ2V0Q2hpbGQoMCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBpbnNlcnRSb3coZWRpdG9yLCBpbnNlcnRCZWZvcmUpIHtcblx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRjb25zdCBjZWxscyA9IGdldFNlbGVjdGVkQ2VsbHMoc2VsZWN0aW9uKTtcblxuXHRcdGNvbnN0IGZpcnN0Q2VsbCA9IGNlbGxzWzBdO1xuXG5cdFx0Y29uc3QgdGFibGUgPSBmaXJzdENlbGwuZ2V0QXNjZW5kYW50KCd0YWJsZScpO1xuXG5cdFx0Y29uc3QgZG9jID0gZmlyc3RDZWxsLmdldERvY3VtZW50KCk7XG5cblx0XHRjb25zdCBzdGFydFJvdyA9IGNlbGxzWzBdLmdldFBhcmVudCgpO1xuXG5cdFx0Y29uc3Qgc3RhcnRSb3dJbmRleCA9IHN0YXJ0Um93LiQucm93SW5kZXg7XG5cblx0XHRjb25zdCBsYXN0Q2VsbCA9IGNlbGxzW2NlbGxzLmxlbmd0aCAtIDFdO1xuXG5cdFx0Y29uc3QgZW5kUm93SW5kZXggPVxuXHRcdFx0bGFzdENlbGwuZ2V0UGFyZW50KCkuJC5yb3dJbmRleCArIGxhc3RDZWxsLiQucm93U3BhbiAtIDE7XG5cblx0XHRjb25zdCBlbmRSb3cgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQodGFibGUuJC5yb3dzW2VuZFJvd0luZGV4XSk7XG5cblx0XHRjb25zdCByb3dJbmRleCA9IGluc2VydEJlZm9yZSA/IHN0YXJ0Um93SW5kZXggOiBlbmRSb3dJbmRleDtcblxuXHRcdGNvbnN0IHJvdyA9IGluc2VydEJlZm9yZSA/IHN0YXJ0Um93IDogZW5kUm93O1xuXG5cdFx0Y29uc3QgbWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCh0YWJsZSk7XG5cblx0XHRjb25zdCBjbG9uZVJvdyA9IG1hcFtyb3dJbmRleF07XG5cblx0XHRjb25zdCBuZXh0Um93ID0gaW5zZXJ0QmVmb3JlID8gbWFwW3Jvd0luZGV4IC0gMV0gOiBtYXBbcm93SW5kZXggKyAxXTtcblxuXHRcdGNvbnN0IHdpZHRoID0gbWFwWzBdLmxlbmd0aDtcblxuXHRcdGNvbnN0IG5ld1JvdyA9IGRvYy5jcmVhdGVFbGVtZW50KCd0cicpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBjbG9uZVJvd1tpXSAmJiBpIDwgd2lkdGg7IGkrKykge1xuXHRcdFx0bGV0IGNlbGw7XG5cblx0XHRcdC8vIENoZWNrIHdoZXRoZXIgdGhlcmUncyBhIHNwYW5uaW5nIHJvdyBoZXJlLCBkbyBub3QgYnJlYWsgaXQuXG5cblx0XHRcdGlmIChcblx0XHRcdFx0Y2xvbmVSb3dbaV0ucm93U3BhbiA+IDEgJiZcblx0XHRcdFx0bmV4dFJvdyAmJlxuXHRcdFx0XHRjbG9uZVJvd1tpXSA9PSBuZXh0Um93W2ldXG5cdFx0XHQpIHtcblx0XHRcdFx0Y2VsbCA9IGNsb25lUm93W2ldO1xuXHRcdFx0XHRjZWxsLnJvd1NwYW4gKz0gMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoY2xvbmVSb3dbaV0pLmNsb25lKCk7XG5cdFx0XHRcdGNlbGwucmVtb3ZlQXR0cmlidXRlKCdyb3dTcGFuJyk7XG5cdFx0XHRcdGNlbGwuYXBwZW5kQm9ndXMoKTtcblx0XHRcdFx0bmV3Um93LmFwcGVuZChjZWxsKTtcblx0XHRcdFx0Y2VsbCA9IGNlbGwuJDtcblx0XHRcdH1cblxuXHRcdFx0aSArPSBjZWxsLmNvbFNwYW4gLSAxO1xuXHRcdH1cblxuXHRcdGlmIChpbnNlcnRCZWZvcmUpIHtcblx0XHRcdG5ld1Jvdy5pbnNlcnRCZWZvcmUocm93KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3Um93Lmluc2VydEFmdGVyKHJvdyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgY2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChuZXdSb3cuJCkuZ2V0Q2hpbGQoXG5cdFx0XHRjZWxsc1swXSA/IGNlbGxzWzBdLiQuY2VsbEluZGV4IDogMFxuXHRcdCk7XG5cdFx0c2VsZWN0RWxlbWVudChlZGl0b3IsIGNlbGwpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVsZXRlUm93cyhzZWxlY3Rpb25PclJvdykge1xuXHRcdGlmIChzZWxlY3Rpb25PclJvdyBpbnN0YW5jZW9mIENLRURJVE9SLmRvbS5zZWxlY3Rpb24pIHtcblx0XHRcdGNvbnN0IGNlbGxzID0gZ2V0U2VsZWN0ZWRDZWxscyhzZWxlY3Rpb25PclJvdyk7XG5cblx0XHRcdGNvbnN0IGZpcnN0Q2VsbCA9IGNlbGxzWzBdO1xuXG5cdFx0XHRjb25zdCB0YWJsZSA9IGZpcnN0Q2VsbC5nZXRBc2NlbmRhbnQoJ3RhYmxlJyk7XG5cblx0XHRcdGNvbnN0IG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAodGFibGUpO1xuXG5cdFx0XHRjb25zdCBzdGFydFJvdyA9IGNlbGxzWzBdLmdldFBhcmVudCgpO1xuXG5cdFx0XHRjb25zdCBzdGFydFJvd0luZGV4ID0gc3RhcnRSb3cuJC5yb3dJbmRleDtcblxuXHRcdFx0Y29uc3QgbGFzdENlbGwgPSBjZWxsc1tjZWxscy5sZW5ndGggLSAxXTtcblxuXHRcdFx0Y29uc3QgZW5kUm93SW5kZXggPVxuXHRcdFx0XHRsYXN0Q2VsbC5nZXRQYXJlbnQoKS4kLnJvd0luZGV4ICsgbGFzdENlbGwuJC5yb3dTcGFuIC0gMTtcblxuXHRcdFx0Y29uc3Qgcm93c1RvRGVsZXRlID0gW107XG5cblx0XHRcdC8vIERlbGV0ZSBjZWxsIG9yIHJlZHVjZSBjZWxsIHNwYW5zIGJ5IGNoZWNraW5nIHRocm91Z2ggdGhlIHRhYmxlIG1hcC5cblxuXHRcdFx0Zm9yIChsZXQgaSA9IHN0YXJ0Um93SW5kZXg7IGkgPD0gZW5kUm93SW5kZXg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBtYXBSb3cgPSBtYXBbaV07XG5cblx0XHRcdFx0Y29uc3Qgcm93ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHRhYmxlLiQucm93c1tpXSk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBtYXBSb3cubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRjb25zdCBjZWxsID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KG1hcFJvd1tqXSk7XG5cblx0XHRcdFx0XHRjb25zdCBjZWxsUm93SW5kZXggPSBjZWxsLmdldFBhcmVudCgpLiQucm93SW5kZXg7XG5cblx0XHRcdFx0XHRpZiAoY2VsbC4kLnJvd1NwYW4gPT0gMSkge1xuXHRcdFx0XHRcdFx0Y2VsbC5yZW1vdmUoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBSb3cgc3Bhbm5lZCBjZWxsLlxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gU3BhbiByb3cgb2YgdGhlIGNlbGwsIHJlZHVjZSBzcGFubmluZy5cblxuXHRcdFx0XHRcdFx0Y2VsbC4kLnJvd1NwYW4gLT0gMTtcblxuXHRcdFx0XHRcdFx0Ly8gUm9vdCByb3cgb2YgdGhlIGNlbGwsIHJvb3QgY2VsbCB0byBuZXh0IHJvdy5cblxuXHRcdFx0XHRcdFx0aWYgKGNlbGxSb3dJbmRleCA9PSBpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5leHRNYXBSb3cgPSBtYXBbaSArIDFdO1xuXHRcdFx0XHRcdFx0XHRpZiAobmV4dE1hcFJvd1tqIC0gMV0pIHtcblx0XHRcdFx0XHRcdFx0XHRjZWxsLmluc2VydEFmdGVyKFxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3IENLRURJVE9SLmRvbS5lbGVtZW50KG5leHRNYXBSb3dbaiAtIDFdKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV3IENLRURJVE9SLmRvbS5lbGVtZW50KFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFibGUuJC5yb3dzW2kgKyAxXVxuXHRcdFx0XHRcdFx0XHRcdCkuYXBwZW5kKGNlbGwsIDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aiArPSBjZWxsLiQuY29sU3BhbiAtIDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyb3dzVG9EZWxldGUucHVzaChyb3cpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByb3dzID0gdGFibGUuJC5yb3dzO1xuXG5cdFx0XHQvLyBXaGVyZSB0byBwdXQgdGhlIGN1cnNvciBhZnRlciByb3dzIGJlZW4gZGVsZXRlZD9cblx0XHRcdC8vIDEuIEludG8gbmV4dCBzaWJsaW5nIHJvdyBpZiBhbnk7XG5cdFx0XHQvLyAyLiBJbnRvIHByZXZpb3VzIHNpYmxpbmcgcm93IGlmIGFueTtcblx0XHRcdC8vIDMuIEludG8gdGFibGUncyBwYXJlbnQgZWxlbWVudCBpZiBpdCdzIHRoZSB2ZXJ5IGxhc3Qgcm93LlxuXG5cdFx0XHRjb25zdCBjdXJzb3JQb3NpdGlvbiA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChcblx0XHRcdFx0cm93c1tlbmRSb3dJbmRleCArIDFdIHx8XG5cdFx0XHRcdFx0KHN0YXJ0Um93SW5kZXggPiAwID8gcm93c1tzdGFydFJvd0luZGV4IC0gMV0gOiBudWxsKSB8fFxuXHRcdFx0XHRcdHRhYmxlLiQucGFyZW50Tm9kZVxuXHRcdFx0KTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IHJvd3NUb0RlbGV0ZS5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGRlbGV0ZVJvd3Mocm93c1RvRGVsZXRlW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGN1cnNvclBvc2l0aW9uO1xuXHRcdH0gZWxzZSBpZiAoc2VsZWN0aW9uT3JSb3cgaW5zdGFuY2VvZiBDS0VESVRPUi5kb20uZWxlbWVudCkge1xuXHRcdFx0Y29uc3QgdGFibGUgPSBzZWxlY3Rpb25PclJvdy5nZXRBc2NlbmRhbnQoJ3RhYmxlJyk7XG5cblx0XHRcdGlmICh0YWJsZS4kLnJvd3MubGVuZ3RoID09IDEpIHtcblx0XHRcdFx0dGFibGUucmVtb3ZlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxlY3Rpb25PclJvdy5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldENlbGxDb2xJbmRleChjZWxsLCBpc1N0YXJ0KSB7XG5cdFx0Y29uc3Qgcm93ID0gY2VsbC5nZXRQYXJlbnQoKTtcblxuXHRcdGNvbnN0IHJvd0NlbGxzID0gcm93LiQuY2VsbHM7XG5cblx0XHRsZXQgY29sSW5kZXggPSAwO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q2VsbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IG1hcENlbGwgPSByb3dDZWxsc1tpXTtcblx0XHRcdGNvbEluZGV4ICs9IGlzU3RhcnQgPyAxIDogbWFwQ2VsbC5jb2xTcGFuO1xuXHRcdFx0aWYgKG1hcENlbGwgPT0gY2VsbC4kKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjb2xJbmRleCAtIDE7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDb2x1bW5zSW5kaWNlcyhjZWxscywgaXNTdGFydCkge1xuXHRcdGxldCByZXR2YWwgPSBpc1N0YXJ0ID8gSW5maW5pdHkgOiAwO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGNvbEluZGV4ID0gZ2V0Q2VsbENvbEluZGV4KGNlbGxzW2ldLCBpc1N0YXJ0KTtcblx0XHRcdGlmIChpc1N0YXJ0ID8gY29sSW5kZXggPCByZXR2YWwgOiBjb2xJbmRleCA+IHJldHZhbCkge1xuXHRcdFx0XHRyZXR2YWwgPSBjb2xJbmRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0dmFsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zZXJ0Q29sdW1uKGVkaXRvciwgaW5zZXJ0QmVmb3JlKSB7XG5cdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0Y29uc3QgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKHNlbGVjdGlvbik7XG5cblx0XHRjb25zdCBmaXJzdENlbGwgPSBjZWxsc1swXTtcblxuXHRcdGNvbnN0IHRhYmxlID0gZmlyc3RDZWxsLmdldEFzY2VuZGFudCgndGFibGUnKTtcblxuXHRcdGNvbnN0IHN0YXJ0Q29sID0gZ2V0Q29sdW1uc0luZGljZXMoY2VsbHMsIDEpO1xuXG5cdFx0Y29uc3QgbGFzdENvbCA9IGdldENvbHVtbnNJbmRpY2VzKGNlbGxzKTtcblxuXHRcdGNvbnN0IGNvbEluZGV4ID0gaW5zZXJ0QmVmb3JlID8gc3RhcnRDb2wgOiBsYXN0Q29sO1xuXG5cdFx0Y29uc3QgbWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCh0YWJsZSk7XG5cblx0XHRjb25zdCBjbG9uZUNvbCA9IFtdO1xuXG5cdFx0Y29uc3QgbmV4dENvbCA9IFtdO1xuXG5cdFx0Y29uc3QgaGVpZ2h0ID0gbWFwLmxlbmd0aDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcblx0XHRcdGNsb25lQ29sLnB1c2gobWFwW2ldW2NvbEluZGV4XSk7XG5cdFx0XHRjb25zdCBuZXh0Q2VsbCA9IGluc2VydEJlZm9yZVxuXHRcdFx0XHQ/IG1hcFtpXVtjb2xJbmRleCAtIDFdXG5cdFx0XHRcdDogbWFwW2ldW2NvbEluZGV4ICsgMV07XG5cdFx0XHRuZXh0Q29sLnB1c2gobmV4dENlbGwpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGluc2VydGVkQ2VsbHMgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG5cdFx0XHRsZXQgY2VsbDtcblxuXHRcdFx0aWYgKCFjbG9uZUNvbFtpXSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciB0aGVyZSdzIGEgc3Bhbm5pbmcgY29sdW1uIGhlcmUsIGRvIG5vdCBicmVhayBpdC5cblxuXHRcdFx0aWYgKGNsb25lQ29sW2ldLmNvbFNwYW4gPiAxICYmIG5leHRDb2xbaV0gPT0gY2xvbmVDb2xbaV0pIHtcblx0XHRcdFx0Y2VsbCA9IGNsb25lQ29sW2ldO1xuXHRcdFx0XHRjZWxsLmNvbFNwYW4gKz0gMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoY2xvbmVDb2xbaV0pLmNsb25lKCk7XG5cdFx0XHRcdGNlbGwucmVtb3ZlQXR0cmlidXRlKCdjb2xTcGFuJyk7XG5cdFx0XHRcdGNlbGwuYXBwZW5kQm9ndXMoKTtcblx0XHRcdFx0Y2VsbFtpbnNlcnRCZWZvcmUgPyAnaW5zZXJ0QmVmb3JlJyA6ICdpbnNlcnRBZnRlciddLmNhbGwoXG5cdFx0XHRcdFx0Y2VsbCxcblx0XHRcdFx0XHRuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoY2xvbmVDb2xbaV0pXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNlbGwgPSBjZWxsLiQ7XG5cdFx0XHR9XG5cblx0XHRcdGluc2VydGVkQ2VsbHNbaV0gPSBjZWxsO1xuXG5cdFx0XHRpICs9IGNlbGwucm93U3BhbiAtIDE7XG5cdFx0fVxuXG5cdFx0Y29uc3QgY2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChcblx0XHRcdGluc2VydGVkQ2VsbHNbZmlyc3RDZWxsLmdldFBhcmVudCgpLiQucm93SW5kZXhdXG5cdFx0KTtcblx0XHRzZWxlY3RFbGVtZW50KGVkaXRvciwgY2VsbCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZWxlY3RFbGVtZW50KGVkaXRvciwgZWxlbWVudCkge1xuXHRcdGNvbnN0IHJhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG5cblx0XHRyYW5nZS5tb3ZlVG9Qb3NpdGlvbihlbGVtZW50LCBDS0VESVRPUi5QT1NJVElPTl9BRlRFUl9TVEFSVCk7XG5cdFx0ZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdFJhbmdlcyhbcmFuZ2VdKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlbGV0ZUNvbHVtbnMoc2VsZWN0aW9uT3JDZWxsKSB7XG5cdFx0Y29uc3QgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKHNlbGVjdGlvbk9yQ2VsbCk7XG5cblx0XHRjb25zdCBmaXJzdENlbGwgPSBjZWxsc1swXTtcblxuXHRcdGNvbnN0IGxhc3RDZWxsID0gY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV07XG5cblx0XHRjb25zdCB0YWJsZSA9IGZpcnN0Q2VsbC5nZXRBc2NlbmRhbnQoJ3RhYmxlJyk7XG5cblx0XHRjb25zdCBtYXAgPSBDS0VESVRPUi50b29scy5idWlsZFRhYmxlTWFwKHRhYmxlKTtcblxuXHRcdGxldCBzdGFydENvbEluZGV4O1xuXG5cdFx0bGV0IGVuZENvbEluZGV4O1xuXG5cdFx0Y29uc3Qgcm93c1RvRGVsZXRlID0gW107XG5cblx0XHRsZXQgcm93cztcblxuXHRcdC8vIEZpZ3VyZSBvdXQgc2VsZWN0ZWQgY2VsbHMnIGNvbHVtbiBpbmRpY2VzLlxuXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHJvd3MgPSBtYXAubGVuZ3RoOyBpIDwgcm93czsgaSsrKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29ydC12YXJzXG5cdFx0XHRmb3IgKGxldCBqID0gMCwgY29scyA9IG1hcFtpXS5sZW5ndGg7IGogPCBjb2xzOyBqKyspIHtcblx0XHRcdFx0aWYgKG1hcFtpXVtqXSA9PSBmaXJzdENlbGwuJCkge1xuXHRcdFx0XHRcdHN0YXJ0Q29sSW5kZXggPSBqO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtYXBbaV1bal0gPT0gbGFzdENlbGwuJCkge1xuXHRcdFx0XHRcdGVuZENvbEluZGV4ID0gajtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIERlbGV0ZSBjZWxsIG9yIHJlZHVjZSBjZWxsIHNwYW5zIGJ5IGNoZWNraW5nIHRocm91Z2ggdGhlIHRhYmxlIG1hcC5cblxuXHRcdGZvciAobGV0IGkgPSBzdGFydENvbEluZGV4OyBpIDw9IGVuZENvbEluZGV4OyBpKyspIHtcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGNvbnN0IG1hcFJvdyA9IG1hcFtqXTtcblxuXHRcdFx0XHRjb25zdCByb3cgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQodGFibGUuJC5yb3dzW2pdKTtcblxuXHRcdFx0XHRjb25zdCBjZWxsID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KG1hcFJvd1tpXSk7XG5cblx0XHRcdFx0aWYgKGNlbGwuJCkge1xuXHRcdFx0XHRcdGlmIChjZWxsLiQuY29sU3BhbiA9PSAxKSB7XG5cdFx0XHRcdFx0XHRjZWxsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlZHVjZSB0aGUgY29sIHNwYW5zLlxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2VsbC4kLmNvbFNwYW4gLT0gMTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqICs9IGNlbGwuJC5yb3dTcGFuIC0gMTtcblxuXHRcdFx0XHRcdGlmICghcm93LiQuY2VsbHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRyb3dzVG9EZWxldGUucHVzaChyb3cpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IGZpcnN0Um93Q2VsbHMgPSB0YWJsZS4kLnJvd3NbMF0gJiYgdGFibGUuJC5yb3dzWzBdLmNlbGxzO1xuXG5cdFx0Ly8gV2hlcmUgdG8gcHV0IHRoZSBjdXJzb3IgYWZ0ZXIgY29sdW1ucyBiZWVuIGRlbGV0ZWQ/XG5cdFx0Ly8gMS4gSW50byBuZXh0IGNlbGwgb2YgdGhlIGZpcnN0IHJvdyBpZiBhbnk7XG5cdFx0Ly8gMi4gSW50byBwcmV2aW91cyBjZWxsIG9mIHRoZSBmaXJzdCByb3cgaWYgYW55O1xuXHRcdC8vIDMuIEludG8gdGFibGUncyBwYXJlbnQgZWxlbWVudDtcblxuXHRcdGNvbnN0IGN1cnNvclBvc2l0aW9uID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KFxuXHRcdFx0Zmlyc3RSb3dDZWxsc1tzdGFydENvbEluZGV4XSB8fFxuXHRcdFx0XHQoc3RhcnRDb2xJbmRleFxuXHRcdFx0XHRcdD8gZmlyc3RSb3dDZWxsc1tzdGFydENvbEluZGV4IC0gMV1cblx0XHRcdFx0XHQ6IHRhYmxlLiQucGFyZW50Tm9kZSlcblx0XHQpO1xuXG5cdFx0Ly8gRGVsZXRlIHRhYmxlIHJvd3Mgb25seSBpZiBhbGwgY29sdW1ucyBhcmUgZ29uZSAoZG8gbm90IHJlbW92ZSBlbXB0eSByb3cpLlxuXG5cdFx0aWYgKHJvd3NUb0RlbGV0ZS5sZW5ndGggPT0gcm93cykge1xuXHRcdFx0dGFibGUucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGN1cnNvclBvc2l0aW9uO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zZXJ0Q2VsbChzZWxlY3Rpb24sIGluc2VydEJlZm9yZSkge1xuXHRcdGNvbnN0IHN0YXJ0RWxlbWVudCA9IHNlbGVjdGlvbi5nZXRTdGFydEVsZW1lbnQoKTtcblx0XHRjb25zdCBjZWxsID1cblx0XHRcdHN0YXJ0RWxlbWVudC5nZXRBc2NlbmRhbnQoJ3RkJywgMSkgfHxcblx0XHRcdHN0YXJ0RWxlbWVudC5nZXRBc2NlbmRhbnQoJ3RoJywgMSk7XG5cblx0XHRpZiAoIWNlbGwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgdGhlIG5ldyBjZWxsIGVsZW1lbnQgdG8gYmUgYWRkZWQuXG5cblx0XHRjb25zdCBuZXdDZWxsID0gY2VsbC5jbG9uZSgpO1xuXHRcdG5ld0NlbGwuYXBwZW5kQm9ndXMoKTtcblxuXHRcdGlmIChpbnNlcnRCZWZvcmUpIHtcblx0XHRcdG5ld0NlbGwuaW5zZXJ0QmVmb3JlKGNlbGwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdDZWxsLmluc2VydEFmdGVyKGNlbGwpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRlbGV0ZUNlbGxzKHNlbGVjdGlvbk9yQ2VsbCkge1xuXHRcdGlmIChzZWxlY3Rpb25PckNlbGwgaW5zdGFuY2VvZiBDS0VESVRPUi5kb20uc2VsZWN0aW9uKSB7XG5cdFx0XHRjb25zdCBjZWxsc1RvRGVsZXRlID0gZ2V0U2VsZWN0ZWRDZWxscyhzZWxlY3Rpb25PckNlbGwpO1xuXHRcdFx0Y29uc3QgdGFibGUgPVxuXHRcdFx0XHRjZWxsc1RvRGVsZXRlWzBdICYmIGNlbGxzVG9EZWxldGVbMF0uZ2V0QXNjZW5kYW50KCd0YWJsZScpO1xuXHRcdFx0Y29uc3QgY2VsbFRvRm9jdXMgPSBnZXRGb2N1c0VsZW1lbnRBZnRlckRlbENlbGxzKGNlbGxzVG9EZWxldGUpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gY2VsbHNUb0RlbGV0ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRkZWxldGVDZWxscyhjZWxsc1RvRGVsZXRlW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNlbGxUb0ZvY3VzKSB7XG5cdFx0XHRcdHBsYWNlQ3Vyc29ySW5DZWxsKGNlbGxUb0ZvY3VzLCB0cnVlKTtcblx0XHRcdH0gZWxzZSBpZiAodGFibGUpIHtcblx0XHRcdFx0dGFibGUucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChzZWxlY3Rpb25PckNlbGwgaW5zdGFuY2VvZiBDS0VESVRPUi5kb20uZWxlbWVudCkge1xuXHRcdFx0Y29uc3QgdHIgPSBzZWxlY3Rpb25PckNlbGwuZ2V0UGFyZW50KCk7XG5cdFx0XHRpZiAodHIuZ2V0Q2hpbGRDb3VudCgpID09IDEpIHtcblx0XHRcdFx0dHIucmVtb3ZlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxlY3Rpb25PckNlbGwucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIGZpbGxlciBhdCBlbmQgYW5kIGVtcHR5IHNwYWNlcyBhcm91bmQgdGhlIGNlbGwgY29udGVudC5cblxuXHRmdW5jdGlvbiB0cmltQ2VsbChjZWxsKSB7XG5cdFx0Y29uc3QgYm9ndXMgPSBjZWxsLmdldEJvZ3VzKCk7XG5cdFx0aWYgKGJvZ3VzKSB7XG5cdFx0XHRib2d1cy5yZW1vdmUoKTtcblx0XHR9XG5cdFx0Y2VsbC50cmltKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBwbGFjZUN1cnNvckluQ2VsbChjZWxsLCBwbGFjZUF0RW5kKSB7XG5cdFx0Y29uc3QgZG9jSW5uZXIgPSBjZWxsLmdldERvY3VtZW50KCk7XG5cblx0XHRjb25zdCBkb2NPdXRlciA9IENLRURJVE9SLmRvY3VtZW50O1xuXG5cdFx0Ly8gRml4aW5nIFwiVW5zcGVjaWZpZWQgZXJyb3JcIiB0aHJvd24gaW4gSUUxMCBieSByZXNldHRpbmdcblx0XHQvLyBzZWxlY3Rpb24gdGhlIGRpcnR5IGFuZCBzaGFtZWZ1bCB3YXkgKCMxMDMwOCkuXG5cdFx0Ly8gV2UgY2FuIG5vdCBhcHBseSB0aGlzIGhhY2sgdG8gSUU4IGJlY2F1c2Vcblx0XHQvLyBpdCBjYXVzZXMgZXJyb3IgKCMxMTA1OCkuXG5cblx0XHRpZiAoQ0tFRElUT1IuZW52LmllICYmIENLRURJVE9SLmVudi52ZXJzaW9uID09IDEwKSB7XG5cdFx0XHRkb2NPdXRlci5mb2N1cygpO1xuXHRcdFx0ZG9jSW5uZXIuZm9jdXMoKTtcblx0XHR9XG5cblx0XHRjb25zdCByYW5nZSA9IG5ldyBDS0VESVRPUi5kb20ucmFuZ2UoZG9jSW5uZXIpO1xuXHRcdGlmIChcblx0XHRcdCFyYW5nZVsnbW92ZVRvRWxlbWVudEVkaXQnICsgKHBsYWNlQXRFbmQgPyAnRW5kJyA6ICdTdGFydCcpXShjZWxsKVxuXHRcdCkge1xuXHRcdFx0cmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGNlbGwpO1xuXHRcdFx0cmFuZ2UuY29sbGFwc2UocGxhY2VBdEVuZCA/IGZhbHNlIDogdHJ1ZSk7XG5cdFx0fVxuXHRcdHJhbmdlLnNlbGVjdCh0cnVlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNlbGxJblJvdyh0YWJsZU1hcCwgcm93SW5kZXgsIGNlbGwpIHtcblx0XHRjb25zdCBvUm93ID0gdGFibGVNYXBbcm93SW5kZXhdO1xuXHRcdGlmICh0eXBlb2YgY2VsbCA9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIG9Sb3c7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgYyA9IDA7IG9Sb3cgJiYgYyA8IG9Sb3cubGVuZ3RoOyBjKyspIHtcblx0XHRcdGlmIChjZWxsLmlzICYmIG9Sb3dbY10gPT0gY2VsbC4kKSB7XG5cdFx0XHRcdHJldHVybiBjO1xuXHRcdFx0fSBlbHNlIGlmIChjID09IGNlbGwpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChvUm93W2NdKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2VsbC5pcyA/IC0xIDogbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNlbGxJbkNvbCh0YWJsZU1hcCwgY29sSW5kZXgpIHtcblx0XHRjb25zdCBvQ29sID0gW107XG5cdFx0Zm9yIChsZXQgciA9IDA7IHIgPCB0YWJsZU1hcC5sZW5ndGg7IHIrKykge1xuXHRcdFx0Y29uc3Qgcm93ID0gdGFibGVNYXBbcl07XG5cdFx0XHRvQ29sLnB1c2gocm93W2NvbEluZGV4XSk7XG5cblx0XHRcdC8vIEF2b2lkIGFkZGluZyBkdXBsaWNhdGUgY2VsbHMuXG5cblx0XHRcdGlmIChyb3dbY29sSW5kZXhdLnJvd1NwYW4gPiAxKSB7XG5cdFx0XHRcdHIgKz0gcm93W2NvbEluZGV4XS5yb3dTcGFuIC0gMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb0NvbDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1lcmdlQ2VsbHMoc2VsZWN0aW9uLCBtZXJnZURpcmVjdGlvbiwgaXNEZXRlY3QpIHtcblx0XHRjb25zdCBjZWxscyA9IGdldFNlbGVjdGVkQ2VsbHMoc2VsZWN0aW9uKTtcblxuXHRcdC8vIEludmFsaWQgbWVyZ2UgcmVxdWVzdCBpZjpcblx0XHQvLyAxLiBJbiBiYXRjaCBtb2RlIGRlc3BpdGUgdGhhdCBsZXNzIHRoYW4gdHdvIHNlbGVjdGVkLlxuXHRcdC8vIDIuIEluIHNvbG8gbW9kZSB3aGlsZSBub3QgZXhhY3RseSBvbmx5IG9uZSBzZWxlY3RlZC5cblx0XHQvLyAzLiBDZWxscyBkaXN0cmlidXRlZCBpbiBkaWZmZXJlbnQgdGFibGUgZ3JvdXBzIChlLmcuIGZyb20gYm90aCB0aGVhZCBhbmQgdGJvZHkpLlxuXG5cdFx0bGV0IGNvbW1vbkFuY2VzdG9yO1xuXHRcdGlmIChcblx0XHRcdChtZXJnZURpcmVjdGlvbiA/IGNlbGxzLmxlbmd0aCAhPSAxIDogY2VsbHMubGVuZ3RoIDwgMikgfHxcblx0XHRcdCgoY29tbW9uQW5jZXN0b3IgPSBzZWxlY3Rpb24uZ2V0Q29tbW9uQW5jZXN0b3IoKSkgJiZcblx0XHRcdFx0Y29tbW9uQW5jZXN0b3IudHlwZSA9PSBDS0VESVRPUi5OT0RFX0VMRU1FTlQgJiZcblx0XHRcdFx0Y29tbW9uQW5jZXN0b3IuaXMoJ3RhYmxlJykpXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0bGV0IGNlbGw7XG5cblx0XHRjb25zdCBmaXJzdENlbGwgPSBjZWxsc1swXTtcblxuXHRcdGNvbnN0IHRhYmxlID0gZmlyc3RDZWxsLmdldEFzY2VuZGFudCgndGFibGUnKTtcblxuXHRcdGNvbnN0IG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAodGFibGUpO1xuXG5cdFx0Y29uc3QgbWFwSGVpZ2h0ID0gbWFwLmxlbmd0aDtcblxuXHRcdGNvbnN0IG1hcFdpZHRoID0gbWFwWzBdLmxlbmd0aDtcblxuXHRcdGNvbnN0IHN0YXJ0Um93ID0gZmlyc3RDZWxsLmdldFBhcmVudCgpLiQucm93SW5kZXg7XG5cblx0XHRjb25zdCBzdGFydENvbHVtbiA9IGNlbGxJblJvdyhtYXAsIHN0YXJ0Um93LCBmaXJzdENlbGwpO1xuXG5cdFx0aWYgKG1lcmdlRGlyZWN0aW9uKSB7XG5cdFx0XHRsZXQgdGFyZ2V0Q2VsbDtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IHJvd3NwYW4gPVxuXHRcdFx0XHRcdHBhcnNlSW50KGZpcnN0Q2VsbC5nZXRBdHRyaWJ1dGUoJ3Jvd3NwYW4nKSwgMTApIHx8IDE7XG5cdFx0XHRcdGNvbnN0IGNvbHNwYW4gPVxuXHRcdFx0XHRcdHBhcnNlSW50KGZpcnN0Q2VsbC5nZXRBdHRyaWJ1dGUoJ2NvbHNwYW4nKSwgMTApIHx8IDE7XG5cblx0XHRcdFx0dGFyZ2V0Q2VsbCA9XG5cdFx0XHRcdFx0bWFwW1xuXHRcdFx0XHRcdFx0bWVyZ2VEaXJlY3Rpb24gPT0gJ3VwJ1xuXHRcdFx0XHRcdFx0XHQ/IHN0YXJ0Um93IC0gcm93c3BhblxuXHRcdFx0XHRcdFx0XHQ6IG1lcmdlRGlyZWN0aW9uID09ICdkb3duJ1xuXHRcdFx0XHRcdFx0XHQ/IHN0YXJ0Um93ICsgcm93c3BhblxuXHRcdFx0XHRcdFx0XHQ6IHN0YXJ0Um93XG5cdFx0XHRcdFx0XVtcblx0XHRcdFx0XHRcdG1lcmdlRGlyZWN0aW9uID09ICdsZWZ0J1xuXHRcdFx0XHRcdFx0XHQ/IHN0YXJ0Q29sdW1uIC0gY29sc3BhblxuXHRcdFx0XHRcdFx0XHQ6IG1lcmdlRGlyZWN0aW9uID09ICdyaWdodCdcblx0XHRcdFx0XHRcdFx0PyBzdGFydENvbHVtbiArIGNvbHNwYW5cblx0XHRcdFx0XHRcdFx0OiBzdGFydENvbHVtblxuXHRcdFx0XHRcdF07XG5cdFx0XHR9IGNhdGNoIChlcikge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIDEuIE5vIGNlbGwgY291bGQgYmUgbWVyZ2VkLlxuXHRcdFx0Ly8gMi4gU2FtZSBjZWxsIGFjdHVhbGx5LlxuXG5cdFx0XHRpZiAoIXRhcmdldENlbGwgfHwgZmlyc3RDZWxsLiQgPT0gdGFyZ2V0Q2VsbCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNvcnQgaW4gbWFwIG9yZGVyIHJlZ2FyZGxlc3Mgb2YgdGhlIERPTSBzZXF1ZW5jZS5cblxuXHRcdFx0Y2VsbHNbXG5cdFx0XHRcdG1lcmdlRGlyZWN0aW9uID09ICd1cCcgfHwgbWVyZ2VEaXJlY3Rpb24gPT0gJ2xlZnQnXG5cdFx0XHRcdFx0PyAndW5zaGlmdCdcblx0XHRcdFx0XHQ6ICdwdXNoJ1xuXHRcdFx0XShuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQodGFyZ2V0Q2VsbCkpO1xuXHRcdH1cblxuXHRcdC8vIFN0YXJ0IGZyb20gaGVyZSBhcmUgbWVyZ2luZyB3YXkgaWdub3JhbmNlIChtZXJnZSB1cC9yaWdodCwgYmF0Y2ggbWVyZ2UpLlxuXG5cdFx0Y29uc3QgZG9jID0gZmlyc3RDZWxsLmdldERvY3VtZW50KCk7XG5cblx0XHRsZXQgbGFzdFJvd0luZGV4ID0gc3RhcnRSb3c7XG5cblx0XHRsZXQgdG90YWxSb3dTcGFuID0gMDtcblxuXHRcdGxldCB0b3RhbENvbFNwYW4gPSAwO1xuXG5cdFx0Ly8gVXNlIGEgZG9jdW1lbnRGcmFnbWVudCBhcyBidWZmZXIgd2hlbiBhcHBlbmRpbmcgY2VsbCBjb250ZW50cy5cblxuXHRcdGNvbnN0IGZyYWcgPSAhaXNEZXRlY3QgJiYgbmV3IENLRURJVE9SLmRvbS5kb2N1bWVudEZyYWdtZW50KGRvYyk7XG5cblx0XHRsZXQgZGltZW5zaW9uID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNlbGwgPSBjZWxsc1tpXTtcblxuXHRcdFx0Y29uc3QgdHIgPSBjZWxsLmdldFBhcmVudCgpO1xuXG5cdFx0XHRjb25zdCBjZWxsRmlyc3RDaGlsZCA9IGNlbGwuZ2V0Rmlyc3QoKTtcblxuXHRcdFx0Y29uc3QgY29sU3BhbiA9IGNlbGwuJC5jb2xTcGFuO1xuXG5cdFx0XHRjb25zdCByb3dTcGFuID0gY2VsbC4kLnJvd1NwYW47XG5cblx0XHRcdGNvbnN0IHJvd0luZGV4ID0gdHIuJC5yb3dJbmRleDtcblxuXHRcdFx0Y29uc3QgY29sSW5kZXggPSBjZWxsSW5Sb3cobWFwLCByb3dJbmRleCwgY2VsbCk7XG5cblx0XHRcdC8vIEFjY3VtdWxhdGVkIHRoZSBhY3R1YWwgcGxhY2VzIHRha2VuIGJ5IGFsbCBzZWxlY3RlZCBjZWxscy5cblxuXHRcdFx0ZGltZW5zaW9uICs9IGNvbFNwYW4gKiByb3dTcGFuO1xuXG5cdFx0XHQvLyBBY2N1bXVsYXRlZCB0aGUgbWF4aW11bSB2aXJ0dWFsIHNwYW5zIGZyb20gY29sdW1uIGFuZCByb3cuXG5cblx0XHRcdHRvdGFsQ29sU3BhbiA9IE1hdGgubWF4KFxuXHRcdFx0XHR0b3RhbENvbFNwYW4sXG5cdFx0XHRcdGNvbEluZGV4IC0gc3RhcnRDb2x1bW4gKyBjb2xTcGFuXG5cdFx0XHQpO1xuXHRcdFx0dG90YWxSb3dTcGFuID0gTWF0aC5tYXgoXG5cdFx0XHRcdHRvdGFsUm93U3Bhbixcblx0XHRcdFx0cm93SW5kZXggLSBzdGFydFJvdyArIHJvd1NwYW5cblx0XHRcdCk7XG5cblx0XHRcdGlmICghaXNEZXRlY3QpIHtcblx0XHRcdFx0Ly8gVHJpbSBhbGwgY2VsbCBmaWxsZXJzIGFuZCBjaGVjayB0byByZW1vdmUgZW1wdHkgY2VsbHMuXG5cblx0XHRcdFx0aWYgKCh0cmltQ2VsbChjZWxsKSwgY2VsbC5nZXRDaGlsZHJlbigpLmNvdW50KCkpKSB7XG5cdFx0XHRcdFx0Ly8gTWVyZ2UgdmVydGljYWxseSBjZWxscyBhcyB0d28gc2VwYXJhdGVkIHBhcmFncmFwaHMuXG5cblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRyb3dJbmRleCAhPSBsYXN0Um93SW5kZXggJiZcblx0XHRcdFx0XHRcdGNlbGxGaXJzdENoaWxkICYmXG5cdFx0XHRcdFx0XHQhKFxuXHRcdFx0XHRcdFx0XHRjZWxsRmlyc3RDaGlsZC5pc0Jsb2NrQm91bmRhcnkgJiZcblx0XHRcdFx0XHRcdFx0Y2VsbEZpcnN0Q2hpbGQuaXNCbG9ja0JvdW5kYXJ5KHticjogMX0pXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRjb25zdCBsYXN0ID0gZnJhZy5nZXRMYXN0KFxuXHRcdFx0XHRcdFx0XHRDS0VESVRPUi5kb20ud2Fsa2VyLndoaXRlc3BhY2VzKHRydWUpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0aWYgKGxhc3QgJiYgIShsYXN0LmlzICYmIGxhc3QuaXMoJ2JyJykpKSB7XG5cdFx0XHRcdFx0XHRcdGZyYWcuYXBwZW5kKCdicicpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNlbGwubW92ZUNoaWxkcmVuKGZyYWcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpKSB7XG5cdFx0XHRcdFx0Y2VsbC5yZW1vdmUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjZWxsLnNldEh0bWwoJycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsYXN0Um93SW5kZXggPSByb3dJbmRleDtcblx0XHR9XG5cblx0XHRpZiAoIWlzRGV0ZWN0KSB7XG5cdFx0XHRmcmFnLm1vdmVDaGlsZHJlbihmaXJzdENlbGwpO1xuXG5cdFx0XHRmaXJzdENlbGwuYXBwZW5kQm9ndXMoKTtcblxuXHRcdFx0aWYgKHRvdGFsQ29sU3BhbiA+PSBtYXBXaWR0aCkge1xuXHRcdFx0XHRmaXJzdENlbGwucmVtb3ZlQXR0cmlidXRlKCdyb3dTcGFuJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmaXJzdENlbGwuJC5yb3dTcGFuID0gdG90YWxSb3dTcGFuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodG90YWxSb3dTcGFuID49IG1hcEhlaWdodCkge1xuXHRcdFx0XHRmaXJzdENlbGwucmVtb3ZlQXR0cmlidXRlKCdjb2xTcGFuJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmaXJzdENlbGwuJC5jb2xTcGFuID0gdG90YWxDb2xTcGFuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTd2lwIGVtcHR5IDx0cj4gbGVmdCBhdCB0aGUgZW5kIG9mIHRhYmxlIGR1ZSB0byB0aGUgbWVyZ2luZy5cblxuXHRcdFx0Y29uc3QgdHJzID0gbmV3IENLRURJVE9SLmRvbS5ub2RlTGlzdCh0YWJsZS4kLnJvd3MpO1xuXG5cdFx0XHRsZXQgY291bnQgPSB0cnMuY291bnQoKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IGNvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0Y29uc3QgdGFpbFRyID0gdHJzLmdldEl0ZW0oaSk7XG5cdFx0XHRcdGlmICghdGFpbFRyLiQuY2VsbHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dGFpbFRyLnJlbW92ZSgpO1xuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZpcnN0Q2VsbDtcblx0XHR9XG5cblx0XHQvLyBCZSBhYmxlIHRvIG1lcmdlIGNlbGxzIG9ubHkgaWYgYWN0dWFsIGRpbWVuc2lvbiBvZiBzZWxlY3RlZFxuXHRcdC8vIGNlbGxzIGVxdWFscyB0byB0aGUgY2FjdWxhdGVkIHJlY3RhbmdsZS5cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiB0b3RhbFJvd1NwYW4gKiB0b3RhbENvbFNwYW4gPT0gZGltZW5zaW9uO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHZlcnRpY2FsU3BsaXRDZWxsKHNlbGVjdGlvbiwgaXNEZXRlY3QpIHtcblx0XHRjb25zdCBjZWxscyA9IGdldFNlbGVjdGVkQ2VsbHMoc2VsZWN0aW9uKTtcblx0XHRpZiAoY2VsbHMubGVuZ3RoID4gMSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoaXNEZXRlY3QpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNlbGwgPSBjZWxsc1swXTtcblxuXHRcdGNvbnN0IHRyID0gY2VsbC5nZXRQYXJlbnQoKTtcblxuXHRcdGNvbnN0IHRhYmxlID0gdHIuZ2V0QXNjZW5kYW50KCd0YWJsZScpO1xuXG5cdFx0Y29uc3QgbWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCh0YWJsZSk7XG5cblx0XHRjb25zdCByb3dJbmRleCA9IHRyLiQucm93SW5kZXg7XG5cblx0XHRjb25zdCBjb2xJbmRleCA9IGNlbGxJblJvdyhtYXAsIHJvd0luZGV4LCBjZWxsKTtcblxuXHRcdGNvbnN0IHJvd1NwYW4gPSBjZWxsLiQucm93U3BhbjtcblxuXHRcdGxldCBuZXdDZWxsO1xuXG5cdFx0bGV0IG5ld1Jvd1NwYW47XG5cblx0XHRsZXQgbmV3Q2VsbFJvd1NwYW47XG5cblx0XHRsZXQgbmV3Um93SW5kZXg7XG5cblx0XHRpZiAocm93U3BhbiA+IDEpIHtcblx0XHRcdG5ld1Jvd1NwYW4gPSBNYXRoLmNlaWwocm93U3BhbiAvIDIpO1xuXHRcdFx0bmV3Q2VsbFJvd1NwYW4gPSBNYXRoLmZsb29yKHJvd1NwYW4gLyAyKTtcblx0XHRcdG5ld1Jvd0luZGV4ID0gcm93SW5kZXggKyBuZXdSb3dTcGFuO1xuXHRcdFx0Y29uc3QgbmV3Q2VsbFRyID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KFxuXHRcdFx0XHR0YWJsZS4kLnJvd3NbbmV3Um93SW5kZXhdXG5cdFx0XHQpO1xuXG5cdFx0XHRjb25zdCBuZXdDZWxsUm93ID0gY2VsbEluUm93KG1hcCwgbmV3Um93SW5kZXgpO1xuXG5cdFx0XHRsZXQgY2FuZGlkYXRlQ2VsbDtcblxuXHRcdFx0bmV3Q2VsbCA9IGNlbGwuY2xvbmUoKTtcblxuXHRcdFx0Ly8gRmlndXJlIG91dCB3aGVyZSB0byBpbnNlcnQgdGhlIG5ldyBjZWxsIGJ5IGNoZWNraW5nIHRoZSB2aXR1YWwgcm93LlxuXG5cdFx0XHRmb3IgKGxldCBjID0gMDsgYyA8IG5ld0NlbGxSb3cubGVuZ3RoOyBjKyspIHtcblx0XHRcdFx0Y2FuZGlkYXRlQ2VsbCA9IG5ld0NlbGxSb3dbY107XG5cblx0XHRcdFx0Ly8gQ2F0Y2ggZmlyc3QgY2VsbCBhY3R1YWxseSBmb2xsb3dpbmcgdGhlIGNvbHVtbi5cblxuXHRcdFx0XHRpZiAoY2FuZGlkYXRlQ2VsbC5wYXJlbnROb2RlID09IG5ld0NlbGxUci4kICYmIGMgPiBjb2xJbmRleCkge1xuXHRcdFx0XHRcdG5ld0NlbGwuaW5zZXJ0QmVmb3JlKFxuXHRcdFx0XHRcdFx0bmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGNhbmRpZGF0ZUNlbGwpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYW5kaWRhdGVDZWxsID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZGVzdGluYXRpb24gcm93IGlzIGVtcHR5LCBhcHBlbmQgYXQgd2lsbC5cblxuXHRcdFx0aWYgKCFjYW5kaWRhdGVDZWxsKSB7XG5cdFx0XHRcdG5ld0NlbGxUci5hcHBlbmQobmV3Q2VsbCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld0NlbGxSb3dTcGFuID0gbmV3Um93U3BhbiA9IDE7XG5cblx0XHRcdGNvbnN0IG5ld0NlbGxUciA9IHRyLmNsb25lKCk7XG5cdFx0XHRuZXdDZWxsVHIuaW5zZXJ0QWZ0ZXIodHIpO1xuXHRcdFx0bmV3Q2VsbFRyLmFwcGVuZCgobmV3Q2VsbCA9IGNlbGwuY2xvbmUoKSkpO1xuXG5cdFx0XHRjb25zdCBjZWxsc0luU2FtZVJvdyA9IGNlbGxJblJvdyhtYXAsIHJvd0luZGV4KTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHNJblNhbWVSb3cubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y2VsbHNJblNhbWVSb3dbaV0ucm93U3BhbisrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG5ld0NlbGwuYXBwZW5kQm9ndXMoKTtcblxuXHRcdGNlbGwuJC5yb3dTcGFuID0gbmV3Um93U3Bhbjtcblx0XHRuZXdDZWxsLiQucm93U3BhbiA9IG5ld0NlbGxSb3dTcGFuO1xuXHRcdGlmIChuZXdSb3dTcGFuID09IDEpIHtcblx0XHRcdGNlbGwucmVtb3ZlQXR0cmlidXRlKCdyb3dTcGFuJyk7XG5cdFx0fVxuXHRcdGlmIChuZXdDZWxsUm93U3BhbiA9PSAxKSB7XG5cdFx0XHRuZXdDZWxsLnJlbW92ZUF0dHJpYnV0ZSgncm93U3BhbicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXdDZWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaG9yaXpvbnRhbFNwbGl0Q2VsbChzZWxlY3Rpb24sIGlzRGV0ZWN0KSB7XG5cdFx0Y29uc3QgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKHNlbGVjdGlvbik7XG5cdFx0aWYgKGNlbGxzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKGlzRGV0ZWN0KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRjb25zdCBjZWxsID0gY2VsbHNbMF07XG5cblx0XHRjb25zdCB0ciA9IGNlbGwuZ2V0UGFyZW50KCk7XG5cblx0XHRjb25zdCB0YWJsZSA9IHRyLmdldEFzY2VuZGFudCgndGFibGUnKTtcblxuXHRcdGNvbnN0IG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAodGFibGUpO1xuXG5cdFx0Y29uc3Qgcm93SW5kZXggPSB0ci4kLnJvd0luZGV4O1xuXG5cdFx0Y29uc3QgY29sSW5kZXggPSBjZWxsSW5Sb3cobWFwLCByb3dJbmRleCwgY2VsbCk7XG5cblx0XHRjb25zdCBjb2xTcGFuID0gY2VsbC4kLmNvbFNwYW47XG5cblx0XHRsZXQgbmV3Q29sU3BhbjtcblxuXHRcdGxldCBuZXdDZWxsQ29sU3BhbjtcblxuXHRcdGlmIChjb2xTcGFuID4gMSkge1xuXHRcdFx0bmV3Q29sU3BhbiA9IE1hdGguY2VpbChjb2xTcGFuIC8gMik7XG5cdFx0XHRuZXdDZWxsQ29sU3BhbiA9IE1hdGguZmxvb3IoY29sU3BhbiAvIDIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdDZWxsQ29sU3BhbiA9IG5ld0NvbFNwYW4gPSAxO1xuXHRcdFx0Y29uc3QgY2VsbHNJblNhbWVDb2wgPSBjZWxsSW5Db2wobWFwLCBjb2xJbmRleCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxzSW5TYW1lQ29sLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNlbGxzSW5TYW1lQ29sW2ldLmNvbFNwYW4rKztcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgbmV3Q2VsbCA9IGNlbGwuY2xvbmUoKTtcblx0XHRuZXdDZWxsLmluc2VydEFmdGVyKGNlbGwpO1xuXHRcdG5ld0NlbGwuYXBwZW5kQm9ndXMoKTtcblxuXHRcdGNlbGwuJC5jb2xTcGFuID0gbmV3Q29sU3Bhbjtcblx0XHRuZXdDZWxsLiQuY29sU3BhbiA9IG5ld0NlbGxDb2xTcGFuO1xuXHRcdGlmIChuZXdDb2xTcGFuID09IDEpIHtcblx0XHRcdGNlbGwucmVtb3ZlQXR0cmlidXRlKCdjb2xTcGFuJyk7XG5cdFx0fVxuXHRcdGlmIChuZXdDZWxsQ29sU3BhbiA9PSAxKSB7XG5cdFx0XHRuZXdDZWxsLnJlbW92ZUF0dHJpYnV0ZSgnY29sU3BhbicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXdDZWxsO1xuXHR9XG5cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3RhYmxldG9vbHMnLCB7XG5cdFx0aW5pdChlZGl0b3IpIHtcblx0XHRcdGZ1bmN0aW9uIGNyZWF0ZURlZihkZWYpIHtcblx0XHRcdFx0cmV0dXJuIENLRURJVE9SLnRvb2xzLmV4dGVuZChkZWYgfHwge30sIHtcblx0XHRcdFx0XHRjb250ZXh0U2Vuc2l0aXZlOiAxLFxuXHRcdFx0XHRcdHJlZnJlc2goZWRpdG9yLCBwYXRoKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFN0YXRlKFxuXHRcdFx0XHRcdFx0XHRwYXRoLmNvbnRhaW5zKHt0ZDogMSwgdGg6IDF9LCAxKVxuXHRcdFx0XHRcdFx0XHRcdD8gQ0tFRElUT1IuVFJJU1RBVEVfT0ZGXG5cdFx0XHRcdFx0XHRcdFx0OiBDS0VESVRPUi5UUklTVEFURV9ESVNBQkxFRFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIGFkZENtZChuYW1lLCBkZWYpIHtcblx0XHRcdFx0bGV0IGNtZCA9IGVkaXRvci5nZXRDb21tYW5kKG5hbWUpO1xuXG5cdFx0XHRcdGlmIChjbWQpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjbWQgPSBlZGl0b3IuYWRkQ29tbWFuZChuYW1lLCBkZWYpO1xuXHRcdFx0XHRlZGl0b3IuYWRkRmVhdHVyZShjbWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRhZGRDbWQoXG5cdFx0XHRcdCdyb3dEZWxldGUnLFxuXHRcdFx0XHRjcmVhdGVEZWYoe1xuXHRcdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0XHRleGVjKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoZGVsZXRlUm93cyhzZWxlY3Rpb24pKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdFx0YWRkQ21kKFxuXHRcdFx0XHQncm93SW5zZXJ0QmVmb3JlJyxcblx0XHRcdFx0Y3JlYXRlRGVmKHtcblx0XHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdFx0ZXhlYyhlZGl0b3IpIHtcblx0XHRcdFx0XHRcdGluc2VydFJvdyhlZGl0b3IsIHRydWUpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0XHRhZGRDbWQoXG5cdFx0XHRcdCdyb3dJbnNlcnRBZnRlcicsXG5cdFx0XHRcdGNyZWF0ZURlZih7XG5cdFx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRcdGV4ZWMoZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRpbnNlcnRSb3coZWRpdG9yKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdFx0YWRkQ21kKFxuXHRcdFx0XHQnY29sdW1uRGVsZXRlJyxcblx0XHRcdFx0Y3JlYXRlRGVmKHtcblx0XHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdFx0ZXhlYyhlZGl0b3IpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdFx0XHRcdGNvbnN0IGVsZW1lbnQgPSBkZWxldGVDb2x1bW5zKHNlbGVjdGlvbik7XG5cdFx0XHRcdFx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRwbGFjZUN1cnNvckluQ2VsbChlbGVtZW50LCB0cnVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdFx0YWRkQ21kKFxuXHRcdFx0XHQnY29sdW1uSW5zZXJ0QmVmb3JlJyxcblx0XHRcdFx0Y3JlYXRlRGVmKHtcblx0XHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdFx0ZXhlYyhlZGl0b3IpIHtcblx0XHRcdFx0XHRcdGluc2VydENvbHVtbihlZGl0b3IsIHRydWUpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0XHRhZGRDbWQoXG5cdFx0XHRcdCdjb2x1bW5JbnNlcnRBZnRlcicsXG5cdFx0XHRcdGNyZWF0ZURlZih7XG5cdFx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRcdGV4ZWMoZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRpbnNlcnRDb2x1bW4oZWRpdG9yKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdFx0YWRkQ21kKFxuXHRcdFx0XHQnY2VsbERlbGV0ZScsXG5cdFx0XHRcdGNyZWF0ZURlZih7XG5cdFx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRcdGV4ZWMoZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0XHRkZWxldGVDZWxscyhzZWxlY3Rpb24pO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0XHRhZGRDbWQoXG5cdFx0XHRcdCdjZWxsTWVyZ2UnLFxuXHRcdFx0XHRjcmVhdGVEZWYoe1xuXHRcdFx0XHRcdGFsbG93ZWRDb250ZW50OiAndGRbY29sc3Bhbixyb3dzcGFuXScsXG5cdFx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGRbY29sc3Bhbixyb3dzcGFuXScsXG5cdFx0XHRcdFx0ZXhlYyhlZGl0b3IpIHtcblx0XHRcdFx0XHRcdHBsYWNlQ3Vyc29ySW5DZWxsKFxuXHRcdFx0XHRcdFx0XHRtZXJnZUNlbGxzKGVkaXRvci5nZXRTZWxlY3Rpb24oKSksXG5cdFx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRcdGFkZENtZChcblx0XHRcdFx0J2NlbGxNZXJnZVJpZ2h0Jyxcblx0XHRcdFx0Y3JlYXRlRGVmKHtcblx0XHRcdFx0XHRhbGxvd2VkQ29udGVudDogJ3RkW2NvbHNwYW5dJyxcblx0XHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0ZFtjb2xzcGFuXScsXG5cdFx0XHRcdFx0ZXhlYyhlZGl0b3IpIHtcblx0XHRcdFx0XHRcdHBsYWNlQ3Vyc29ySW5DZWxsKFxuXHRcdFx0XHRcdFx0XHRtZXJnZUNlbGxzKGVkaXRvci5nZXRTZWxlY3Rpb24oKSwgJ3JpZ2h0JyksXG5cdFx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRcdGFkZENtZChcblx0XHRcdFx0J2NlbGxNZXJnZURvd24nLFxuXHRcdFx0XHRjcmVhdGVEZWYoe1xuXHRcdFx0XHRcdGFsbG93ZWRDb250ZW50OiAndGRbcm93c3Bhbl0nLFxuXHRcdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RkW3Jvd3NwYW5dJyxcblx0XHRcdFx0XHRleGVjKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoXG5cdFx0XHRcdFx0XHRcdG1lcmdlQ2VsbHMoZWRpdG9yLmdldFNlbGVjdGlvbigpLCAnZG93bicpLFxuXHRcdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0XHRhZGRDbWQoXG5cdFx0XHRcdCdjZWxsVmVydGljYWxTcGxpdCcsXG5cdFx0XHRcdGNyZWF0ZURlZih7XG5cdFx0XHRcdFx0YWxsb3dlZENvbnRlbnQ6ICd0ZFtyb3dzcGFuXScsXG5cdFx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGRbcm93c3Bhbl0nLFxuXHRcdFx0XHRcdGV4ZWMoZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRwbGFjZUN1cnNvckluQ2VsbChcblx0XHRcdFx0XHRcdFx0dmVydGljYWxTcGxpdENlbGwoZWRpdG9yLmdldFNlbGVjdGlvbigpKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdFx0YWRkQ21kKFxuXHRcdFx0XHQnY2VsbEhvcml6b250YWxTcGxpdCcsXG5cdFx0XHRcdGNyZWF0ZURlZih7XG5cdFx0XHRcdFx0YWxsb3dlZENvbnRlbnQ6ICd0ZFtjb2xzcGFuXScsXG5cdFx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGRbY29sc3Bhbl0nLFxuXHRcdFx0XHRcdGV4ZWMoZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRwbGFjZUN1cnNvckluQ2VsbChcblx0XHRcdFx0XHRcdFx0aG9yaXpvbnRhbFNwbGl0Q2VsbChlZGl0b3IuZ2V0U2VsZWN0aW9uKCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0XHRhZGRDbWQoXG5cdFx0XHRcdCdjZWxsSW5zZXJ0QmVmb3JlJyxcblx0XHRcdFx0Y3JlYXRlRGVmKHtcblx0XHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdFx0ZXhlYyhlZGl0b3IpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdFx0XHRcdGluc2VydENlbGwoc2VsZWN0aW9uLCB0cnVlKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdFx0YWRkQ21kKFxuXHRcdFx0XHQnY2VsbEluc2VydEFmdGVyJyxcblx0XHRcdFx0Y3JlYXRlRGVmKHtcblx0XHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdFx0ZXhlYyhlZGl0b3IpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdFx0XHRcdGluc2VydENlbGwoc2VsZWN0aW9uKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0Z2V0U2VsZWN0ZWRDZWxscyxcblx0fSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgdHdvLWRpbWVuc2lvbiBhcnJheSB0aGF0IHJlZmxlY3RzIHRoZSBhY3R1YWwgbGF5b3V0IG9mIHRhYmxlIGNlbGxzLFxuICogd2l0aCBjZWxsIHNwYW5zLCB3aXRoIG1hcHBpbmdzIHRvIHRoZSBvcmlnaW5hbCB0ZCBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSB0YWJsZVxuICogQG1lbWJlciBDS0VESVRPUi50b29sc1xuICovXG5DS0VESVRPUi50b29scy5idWlsZFRhYmxlTWFwID0gZnVuY3Rpb24odGFibGUpIHtcblx0Y29uc3QgYVJvd3MgPSB0YWJsZS4kLnJvd3M7XG5cblx0Ly8gUm93IGFuZCBDb2x1bW4gY291bnRlcnMuXG5cblx0bGV0IHIgPSAtMTtcblxuXHRjb25zdCBhTWFwID0gW107XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhUm93cy5sZW5ndGg7IGkrKykge1xuXHRcdHIrKztcblx0XHRpZiAoIWFNYXBbcl0pIHtcblx0XHRcdGFNYXBbcl0gPSBbXTtcblx0XHR9XG5cblx0XHRsZXQgYyA9IC0xO1xuXG5cdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBhUm93c1tpXS5jZWxscy5sZW5ndGg7IGorKykge1xuXHRcdFx0Y29uc3Qgb0NlbGwgPSBhUm93c1tpXS5jZWxsc1tqXTtcblxuXHRcdFx0YysrO1xuXHRcdFx0d2hpbGUgKGFNYXBbcl1bY10pIHtcblx0XHRcdFx0YysrO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpQ29sU3BhbiA9IGlzTmFOKG9DZWxsLmNvbFNwYW4pID8gMSA6IG9DZWxsLmNvbFNwYW47XG5cdFx0XHRjb25zdCBpUm93U3BhbiA9IGlzTmFOKG9DZWxsLnJvd1NwYW4pID8gMSA6IG9DZWxsLnJvd1NwYW47XG5cblx0XHRcdGZvciAobGV0IHJzID0gMDsgcnMgPCBpUm93U3BhbjsgcnMrKykge1xuXHRcdFx0XHRpZiAoIWFNYXBbciArIHJzXSkge1xuXHRcdFx0XHRcdGFNYXBbciArIHJzXSA9IFtdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yIChsZXQgY3MgPSAwOyBjcyA8IGlDb2xTcGFuOyBjcysrKSB7XG5cdFx0XHRcdFx0YU1hcFtyICsgcnNdW2MgKyBjc10gPSBhUm93c1tpXS5jZWxsc1tqXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjICs9IGlDb2xTcGFuIC0gMTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYU1hcDtcbn07XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmNvbnN0IHRhYmxlU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiAnYWUtYXJyb3ctYm94IGFlLWFycm93LWJveC1ib3R0b20nO1xufTtcblxuY29uc3QgU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzID0ge1xuXHR0YWJsZTogdGFibGVTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXMsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXM7XG4iLCIvKipcbiAqIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IMKpIDIwMTQgTGlmZXJheSwgSW5jLiA8aHR0cHM6Ly9saWZlcmF5LmNvbT5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBMR1BMLTMuMC1vci1sYXRlclxuICovXG5cbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vLyBEZWZhdWx0IGd1dHRlciB2YWx1ZSBmb3IgdG9vbGJhciBwb3NpdGlvbmluZ1xuXG5jb25zdCBERUZBVUxUX0dVVFRFUiA9IHtcblx0bGVmdDogMCxcblx0dG9wOiAwLFxufTtcblxuLyoqXG4gKiBDZW50ZXJzIGEgVG9vbGJhciBhY2NvcmRpbmcgdG8gZ2l2ZW4gcmVjdGFuZ2xlXG4gKlxuICogQG1ldGhvZCBjZW50ZXJUb29sYmFyXG4gKiBAcGFyYW0ge09iamVjdH0gdG9vbGJhciBUaGUgdG9vbGJhciB0byBiZSBjZW50ZXJlZFxuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgVGhlIHJlY3RhbmdsZSBhY2NvcmRpbmcgdG8gd2hpY2ggdGhlIFRvb2xiYXIgd2lsbCBiZSBjZW50ZXJlZFxuICovXG5jb25zdCBjZW50ZXJUb29sYmFyID0gZnVuY3Rpb24odG9vbGJhciwgcmVjdCkge1xuXHRjb25zdCB0b29sYmFyTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRvb2xiYXIpO1xuXG5cdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRvb2xiYXIuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0Y29uc3QgdWlOb2RlID0gbmF0aXZlRWRpdG9yLmNvbmZpZy51aU5vZGUgfHwgZG9jdW1lbnQuYm9keTtcblx0Y29uc3QgdWlOb2RlU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHVpTm9kZSk7XG5cdGNvbnN0IHVpTm9kZU1hcmdpbkxlZnQgPSBwYXJzZUludChcblx0XHR1aU5vZGVTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tbGVmdCcpLFxuXHRcdDEwXG5cdCk7XG5cdGNvbnN0IHVpTm9kZU1hcmdpblJpZ2h0ID0gcGFyc2VJbnQoXG5cdFx0dWlOb2RlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXJpZ2h0JyksXG5cdFx0MTBcblx0KTtcblx0Y29uc3QgdG90YWxXaWR0aCA9XG5cdFx0dWlOb2RlTWFyZ2luTGVmdCArIHVpTm9kZS5jbGllbnRXaWR0aCArIHVpTm9kZU1hcmdpblJpZ2h0O1xuXG5cdGNvbnN0IGhhbGZOb2RlV2lkdGggPSB0b29sYmFyTm9kZS5vZmZzZXRXaWR0aCAvIDI7XG5cdGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gbmV3IENLRURJVE9SLmRvbS53aW5kb3cod2luZG93KS5nZXRTY3JvbGxQb3NpdGlvbigpO1xuXG5cdGNvbnN0IGd1dHRlciA9IHRvb2xiYXIucHJvcHMuZ3V0dGVyIHx8IERFRkFVTFRfR1VUVEVSO1xuXG5cdGNvbnN0IHdpZGdldFhZID0gdG9vbGJhci5nZXRXaWRnZXRYWVBvaW50KFxuXHRcdHJlY3QubGVmdCArIHJlY3Qud2lkdGggLyAyIC0gc2Nyb2xsUG9zaXRpb24ueCxcblx0XHRyZWN0LnRvcCArIHNjcm9sbFBvc2l0aW9uLnksXG5cdFx0Q0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1Bcblx0KTtcblxuXHRjb25zdCBjYXJldFBvc2l0aW9uID0gbmF0aXZlRWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRjb25zdCByYW5nZXMgPSBjYXJldFBvc2l0aW9uLmdldFJhbmdlcygpO1xuXHRsZXQgb2Zmc2V0SGVpZ2h0ID0gMDtcblxuXHRpZiAocmFuZ2VzICYmIHJhbmdlcy5sZW5ndGggPT09IDEpIHtcblx0XHRsZXQgc3RhcnRDb250YWluZXIgPSByYW5nZXNbMF0uc3RhcnRDb250YWluZXI7XG5cblx0XHRpZiAoc3RhcnRDb250YWluZXIuJC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcblx0XHRcdHN0YXJ0Q29udGFpbmVyID0gc3RhcnRDb250YWluZXIuZ2V0UGFyZW50KCk7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgbm9kZU5hbWUgPSBzdGFydENvbnRhaW5lci4kLm5vZGVOYW1lO1xuXG5cdFx0aWYgKG5vZGVOYW1lID09PSAnVEQnIHx8IG5vZGVOYW1lID09PSAnVEgnKSB7XG5cdFx0XHRjb25zdCBzdGFydENvbnRhaW5lckNsaWVudFJlY3QgPSBzdGFydENvbnRhaW5lci5nZXRDbGllbnRSZWN0KCk7XG5cdFx0XHRvZmZzZXRIZWlnaHQgPSBzdGFydENvbnRhaW5lckNsaWVudFJlY3QueSAtIHJlY3QudG9wO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IHNjcm9sbFRvcCA9IHVpTm9kZSA/IHVpTm9kZS5zY3JvbGxUb3AgOiAwO1xuXG5cdGNvbnN0IGVuZFBvc2l0aW9uID0gW1xuXHRcdHJlY3QubGVmdCArIHJlY3Qud2lkdGggLyAyIC0gaGFsZk5vZGVXaWR0aCAtIHNjcm9sbFBvc2l0aW9uLngsXG5cdFx0cmVjdC50b3AgK1xuXHRcdFx0b2Zmc2V0SGVpZ2h0IC1cblx0XHRcdHRvb2xiYXJOb2RlLm9mZnNldEhlaWdodCArXG5cdFx0XHRzY3JvbGxQb3NpdGlvbi55IC1cblx0XHRcdGd1dHRlci50b3AgK1xuXHRcdFx0c2Nyb2xsVG9wLFxuXHRdO1xuXG5cdGlmIChlbmRQb3NpdGlvblswXSA8IDApIHtcblx0XHRlbmRQb3NpdGlvblswXSA9IDA7XG5cdH0gZWxzZSBpZiAoZW5kUG9zaXRpb25bMF0gPiB0b3RhbFdpZHRoIC0gdG9vbGJhck5vZGUub2Zmc2V0V2lkdGgpIHtcblx0XHRlbmRQb3NpdGlvblswXSA9IHRvdGFsV2lkdGggLSB0b29sYmFyTm9kZS5vZmZzZXRXaWR0aDtcblx0fVxuXG5cdHRvb2xiYXIubW92ZVRvUG9pbnQod2lkZ2V0WFksIGVuZFBvc2l0aW9uKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcG9zaXRpb24gb2YgYSB0b29sYmFyIGFjY29yZGluZyB0byB0aGUgcG9zaXRpb24gb2YgdGhlIHNlbGVjdGVkIGltYWdlXG4gKlxuICogQG1ldGhvZCBpbWFnZVNlbGVjdGlvblNldFBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZCBQYXlsb2FkLCBzaG91bGQgY29udGFpbiB0aGUgc2VsZWN0aW9uIGRhdGEgZm9yIHJldHJpZXZpbmcgdGhlXG4gKiBjbGllbnQgcmVjdGFuZ2xlIG9mIHRoZSBzZWxlY3RlZCBpbWFnZVxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSwgaW4gYWxsIGNhc2VzXG4gKi9cbmNvbnN0IGltYWdlU2VsZWN0aW9uU2V0UG9zaXRpb24gPSBmdW5jdGlvbihwYXlsb2FkKSB7XG5cdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBwYXlsb2FkLnNlbGVjdGlvbkRhdGFcblx0XHQ/IHBheWxvYWQuc2VsZWN0aW9uRGF0YVxuXHRcdDogcGF5bG9hZC5lZGl0b3JFdmVudFxuXHRcdD8gcGF5bG9hZC5lZGl0b3JFdmVudC5kYXRhLnNlbGVjdGlvbkRhdGFcblx0XHQ6IG51bGw7XG5cblx0aWYgKHNlbGVjdGlvbkRhdGEgJiYgc2VsZWN0aW9uRGF0YS5lbGVtZW50KSB7XG5cdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gcGF5bG9hZC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRjb25zdCB1aU5vZGUgPSBuYXRpdmVFZGl0b3IuY29uZmlnLnVpTm9kZTtcblxuXHRcdGNvbnN0IHNjcm9sbFRvcCA9IHVpTm9kZSA/IHVpTm9kZS5zY3JvbGxUb3AgOiAwO1xuXG5cdFx0Y29uc3QgcmVjdCA9IHNlbGVjdGlvbkRhdGEuZWxlbWVudC5nZXRDbGllbnRSZWN0KCk7XG5cdFx0cmVjdC50b3AgKz0gc2Nyb2xsVG9wO1xuXG5cdFx0Y2VudGVyVG9vbGJhcih0aGlzLCByZWN0KTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgdG9vbGJhciBhY2NvcmRpbmcgdG8gdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWxlY3RlZCBpbWFnZVxuICpcbiAqIEBtZXRob2QgdGFibGVTZWxlY3Rpb25TZXRQb3NpdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgT2JqZWN0LCB3aGljaCBjb250YWlucyB0aGUgc2VsZWN0aW9uIGRhdGEgZm9yIHJldHJpZXZpbmcgdGhlXG4gKiBjbGllbnQgcmVjdGFuZ2xlIG9mIHRoZSBzZWxlY3RlZCB0YWJsZVxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSwgaW4gYWxsIGNhc2VzXG4gKi9cbmNvbnN0IHRhYmxlU2VsZWN0aW9uU2V0UG9zaXRpb24gPSBmdW5jdGlvbihwYXlsb2FkKSB7XG5cdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHBheWxvYWQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdGNvbnN0IHVpTm9kZSA9IG5hdGl2ZUVkaXRvci5jb25maWcudWlOb2RlO1xuXG5cdGNvbnN0IHNjcm9sbFRvcCA9IHVpTm9kZSA/IHVpTm9kZS5zY3JvbGxUb3AgOiAwO1xuXG5cdGNvbnN0IHRhYmxlID0gbmV3IENLRURJVE9SLlRhYmxlKG5hdGl2ZUVkaXRvcikuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXHRjb25zdCByZWN0ID0gdGFibGUuZ2V0Q2xpZW50UmVjdCgpO1xuXHRyZWN0LnRvcCArPSBzY3JvbGxUb3A7XG5cblx0Y2VudGVyVG9vbGJhcih0aGlzLCByZWN0KTtcblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IFNlbGVjdGlvblNldFBvc2l0aW9uID0ge1xuXHRpbWFnZTogaW1hZ2VTZWxlY3Rpb25TZXRQb3NpdGlvbixcblx0dGFibGU6IHRhYmxlU2VsZWN0aW9uU2V0UG9zaXRpb24sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3Rpb25TZXRQb3NpdGlvbjtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuY29uc3QgX2lzUmFuZ2VBdEVsZW1lbnRFbmQgPSBmdW5jdGlvbihyYW5nZSwgZWxlbWVudCkge1xuXHQvLyBGaW5kaW5nIGlmIGEgcmFuZ2UgaXMgYXQgdGhlIGVuZCBvZiBhbiBlbGVtZW50IGlzIHNvbWV3aGF0IHRyaWNreVxuXHQvLyBkdWUgdG8gaG93IENLRWRpdG9yIGhhbmRsZXMgcmFuZ2VzLiBJdCBtaWdodCBkZXBlbmQgb24gd2hldGhlciBhXG5cdC8vIHNvdXJjZSBub2RlIGluc2lkZSB0aGUgZWxlbWVudCBpcyBzZWxlY3RlZCBvciBub3QuIEZvciBub3csIHdlXG5cdC8vIG5lZWQgdG8gY292ZXIgdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly9cblx0Ly8gLSBUaGUgdGV4dCBsZW5ndGggb2YgdGhlIGVsZW1lbnQgaXMgdGhlIHNhbWUgYXMgdGhlIGVuZE9mZnNldCBvZlxuXHQvLyAgIHRoZSByYW5nZS5cblx0Ly8gLSBCb3RoIHN0YXJ0IGFuZCBlbmQgY29udGFpbmVycyBtYXRjaCB0aGUgZWxlbWVudCBhbmQgdGhlIHN0YXJ0XG5cdC8vICAgYW5kIGVuZCBvZmZzZXRzIGFyZSAxLlxuXG5cdHJldHVybiAoXG5cdFx0ZWxlbWVudC5nZXRUZXh0KCkubGVuZ3RoID09PSByYW5nZS5lbmRPZmZzZXQgfHxcblx0XHQoZWxlbWVudC5lcXVhbHMocmFuZ2Uuc3RhcnRDb250YWluZXIpICYmXG5cdFx0XHRlbGVtZW50LmVxdWFscyhyYW5nZS5lbmRDb250YWluZXIpICYmXG5cdFx0XHRyYW5nZS5zdGFydE9mZnNldCA9PT0gcmFuZ2UuZW5kT2Zmc2V0ICYmXG5cdFx0XHRyYW5nZS5lbmRPZmZzZXQgPT09IDEpXG5cdCk7XG59O1xuXG5jb25zdCBlbWJlZFNlbGVjdGlvblRlc3QgPSBmdW5jdGlvbihwYXlsb2FkKSB7XG5cdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBwYXlsb2FkLmRhdGEuc2VsZWN0aW9uRGF0YTtcblxuXHRyZXR1cm4gISEoXG5cdFx0c2VsZWN0aW9uRGF0YS5lbGVtZW50ICYmXG5cdFx0c2VsZWN0aW9uRGF0YS5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS13aWRnZXQnKSA9PT0gJ2FlX2VtYmVkJ1xuXHQpO1xufTtcblxuY29uc3QgZW1iZWRVcmxTZWxlY3Rpb25UZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuXHRjb25zdCBzZWxlY3Rpb25EYXRhID0gcGF5bG9hZC5kYXRhLnNlbGVjdGlvbkRhdGE7XG5cblx0cmV0dXJuICEhKFxuXHRcdHNlbGVjdGlvbkRhdGEuZWxlbWVudCAmJlxuXHRcdHNlbGVjdGlvbkRhdGEuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtd2lkZ2V0JykgPT09ICdlbWJlZHVybCdcblx0KTtcbn07XG5cbmNvbnN0IGhlYWRpbmdUZXh0U2VsZWN0aW9uVGVzdCA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcblx0Y29uc3QgaGVhZGluZ3MgPSBbJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2J107XG5cdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHBheWxvYWQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBwYXlsb2FkLmRhdGEuc2VsZWN0aW9uRGF0YTtcblx0Y29uc3Qgc2VsZWN0aW9uRW1wdHkgPSBuYXRpdmVFZGl0b3IuaXNTZWxlY3Rpb25FbXB0eSgpO1xuXG5cdHJldHVybiAhIShcblx0XHQhc2VsZWN0aW9uRGF0YS5lbGVtZW50ICYmXG5cdFx0c2VsZWN0aW9uRGF0YS5yZWdpb24gJiZcblx0XHQhc2VsZWN0aW9uRW1wdHkgJiZcblx0XHQhbmF0aXZlRWRpdG9yXG5cdFx0XHQuZ2V0U2VsZWN0aW9uKClcblx0XHRcdC5nZXRDb21tb25BbmNlc3RvcigpXG5cdFx0XHQuaXNSZWFkT25seSgpICYmXG5cdFx0bmF0aXZlRWRpdG9yLmVsZW1lbnRQYXRoKCkuY29udGFpbnMoaGVhZGluZ3MpXG5cdCk7XG59O1xuXG5jb25zdCBsaW5rU2VsZWN0aW9uVGVzdCA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcblx0Y29uc3QgbmF0aXZlRWRpdG9yID0gcGF5bG9hZC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0Y29uc3QgcmFuZ2UgPSBuYXRpdmVFZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBwYXlsb2FkLmRhdGEuc2VsZWN0aW9uRGF0YTtcblxuXHRjb25zdCBlbGVtZW50ID0gbmV3IENLRURJVE9SLkxpbmsobmF0aXZlRWRpdG9yKS5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cdGNvbnN0IGlzU2VsZWN0aW9uRW1wdHkgPSBuYXRpdmVFZGl0b3IuaXNTZWxlY3Rpb25FbXB0eSgpO1xuXHRjb25zdCBlbGVtZW50SXNOb3RJbWFnZSA9IHNlbGVjdGlvbkRhdGEuZWxlbWVudFxuXHRcdD8gc2VsZWN0aW9uRGF0YS5lbGVtZW50LmdldE5hbWUoKSAhPT0gJ2ltZydcblx0XHQ6IHRydWU7XG5cblx0cmV0dXJuICEhKFxuXHRcdGlzU2VsZWN0aW9uRW1wdHkgJiZcblx0XHRlbGVtZW50SXNOb3RJbWFnZSAmJlxuXHRcdGVsZW1lbnQgJiZcblx0XHRlbGVtZW50LmdldFRleHQoKS5sZW5ndGggIT09IHJhbmdlLmVuZE9mZnNldCAmJlxuXHRcdGVsZW1lbnQgJiZcblx0XHQhZWxlbWVudC5pc1JlYWRPbmx5KCkgJiZcblx0XHQhX2lzUmFuZ2VBdEVsZW1lbnRFbmQocmFuZ2UsIGVsZW1lbnQpXG5cdCk7XG59O1xuXG5jb25zdCBpbWFnZVNlbGVjdGlvblRlc3QgPSBmdW5jdGlvbihwYXlsb2FkKSB7XG5cdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBwYXlsb2FkLmRhdGEuc2VsZWN0aW9uRGF0YTtcblx0Y29uc3QgZWxlbWVudCA9IHNlbGVjdGlvbkRhdGEuZWxlbWVudDtcblx0Y29uc3QgaGFzSW1hZ2UgPSAhIWVsZW1lbnQgJiYgISFlbGVtZW50LmZpbmRPbmUoJ2ltZycpO1xuXHRjb25zdCBpc0ltYWdlID0gISFlbGVtZW50ICYmIGVsZW1lbnQuZ2V0TmFtZSgpID09PSAnaW1nJztcblxuXHRyZXR1cm4gISEoZWxlbWVudCAmJiAoaGFzSW1hZ2UgfHwgaXNJbWFnZSkpO1xufTtcblxuY29uc3QgdGV4dFNlbGVjdGlvblRlc3QgPSBmdW5jdGlvbihwYXlsb2FkKSB7XG5cdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHBheWxvYWQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0Y29uc3Qgc2VsZWN0aW9uRW1wdHkgPSBuYXRpdmVFZGl0b3IuaXNTZWxlY3Rpb25FbXB0eSgpO1xuXG5cdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBwYXlsb2FkLmRhdGEuc2VsZWN0aW9uRGF0YTtcblxuXHRyZXR1cm4gISEoXG5cdFx0IXNlbGVjdGlvbkRhdGEuZWxlbWVudCAmJlxuXHRcdHNlbGVjdGlvbkRhdGEucmVnaW9uICYmXG5cdFx0IXNlbGVjdGlvbkVtcHR5ICYmXG5cdFx0IW5hdGl2ZUVkaXRvclxuXHRcdFx0LmdldFNlbGVjdGlvbigpXG5cdFx0XHQuZ2V0Q29tbW9uQW5jZXN0b3IoKVxuXHRcdFx0LmlzUmVhZE9ubHkoKVxuXHQpO1xufTtcblxuY29uc3QgdGFibGVTZWxlY3Rpb25UZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuXHRjb25zdCBuYXRpdmVFZGl0b3IgPSBwYXlsb2FkLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdGNvbnN0IHRhYmxlID0gbmV3IENLRURJVE9SLlRhYmxlKG5hdGl2ZUVkaXRvcik7XG5cdGNvbnN0IGVsZW1lbnQgPSB0YWJsZS5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cblx0cmV0dXJuICEhKGVsZW1lbnQgJiYgdGFibGUuaXNFZGl0YWJsZShlbGVtZW50KSk7XG59O1xuXG5jb25zdCBTZWxlY3Rpb25UZXN0ID0ge1xuXHRlbWJlZDogZW1iZWRTZWxlY3Rpb25UZXN0LFxuXHRlbWJlZFVybDogZW1iZWRVcmxTZWxlY3Rpb25UZXN0LFxuXHRoZWFkZXI6IGhlYWRpbmdUZXh0U2VsZWN0aW9uVGVzdCxcblx0aW1hZ2U6IGltYWdlU2VsZWN0aW9uVGVzdCxcblx0bGluazogbGlua1NlbGVjdGlvblRlc3QsXG5cdHRhYmxlOiB0YWJsZVNlbGVjdGlvblRlc3QsXG5cdHRleHQ6IHRleHRTZWxlY3Rpb25UZXN0LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0aW9uVGVzdDtcbiIsIi8qKlxuICogU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogwqkgMjAxNCBMaWZlcmF5LCBJbmMuIDxodHRwczovL2xpZmVyYXkuY29tPlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IExHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuaW1wb3J0IFNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyBmcm9tICcuL3NlbGVjdGlvbi1hcnJvd2JveCc7XG5pbXBvcnQgU2VsZWN0aW9uU2V0UG9zaXRpb24gZnJvbSAnLi9zZWxlY3Rpb24tcG9zaXRpb24nO1xuaW1wb3J0IFNlbGVjdGlvblRlc3QgZnJvbSAnLi9zZWxlY3Rpb24tdGVzdCc7XG5cbmNvbnN0IFNlbGVjdGlvbnMgPSBbXG5cdHtcblx0XHRuYW1lOiAnZW1iZWQnLFxuXHRcdGJ1dHRvbnM6IFsnZW1iZWRSZW1vdmUnLCAnZW1iZWRFZGl0J10sXG5cdFx0dGVzdDogU2VsZWN0aW9uVGVzdC5lbWJlZCxcblx0fSxcblx0e1xuXHRcdG5hbWU6ICdlbWJlZFVybCcsXG5cdFx0YnV0dG9uczogWydlbWJlZFZpZGVvJywgJ2VtYmVkVmlkZW9FZGl0J10sXG5cdFx0dGVzdDogU2VsZWN0aW9uVGVzdC5lbWJlZFVybCxcblx0fSxcblx0e1xuXHRcdG5hbWU6ICdsaW5rJyxcblx0XHRidXR0b25zOiBbJ2xpbmtFZGl0J10sXG5cdFx0dGVzdDogU2VsZWN0aW9uVGVzdC5saW5rLFxuXHR9LFxuXHR7XG5cdFx0bmFtZTogJ2ltYWdlJyxcblx0XHRidXR0b25zOiBbJ2ltYWdlTGVmdCcsICdpbWFnZUNlbnRlcicsICdpbWFnZVJpZ2h0JywgJ3JlbW92ZUltYWdlJ10sXG5cdFx0c2V0UG9zaXRpb246IFNlbGVjdGlvblNldFBvc2l0aW9uLmltYWdlLFxuXHRcdHRlc3Q6IFNlbGVjdGlvblRlc3QuaW1hZ2UsXG5cdH0sXG5cdHtcblx0XHRuYW1lOiAndGV4dCcsXG5cdFx0YnV0dG9uczoge1xuXHRcdFx0ZnVsbDogW1xuXHRcdFx0XHRbXG5cdFx0XHRcdFx0J0ZvbnQnLFxuXHRcdFx0XHRcdCdGb250U2l6ZScsXG5cdFx0XHRcdFx0J3NlcGFyYXRvcicsXG5cdFx0XHRcdFx0J2JvbGQnLFxuXHRcdFx0XHRcdCdpdGFsaWMnLFxuXHRcdFx0XHRcdCd1bmRlcmxpbmUnLFxuXHRcdFx0XHRcdCdzdHJpa2UnLFxuXHRcdFx0XHRcdCdzZXBhcmF0b3InLFxuXHRcdFx0XHRcdCdsaW5rJyxcblx0XHRcdFx0XSxcblx0XHRcdFx0W1xuXHRcdFx0XHRcdCdwYXJhZ3JhcGhBbGlnbicsXG5cdFx0XHRcdFx0J3NlcGFyYXRvcicsXG5cdFx0XHRcdFx0J3VsJyxcblx0XHRcdFx0XHQnb2wnLFxuXHRcdFx0XHRcdCdzZXBhcmF0b3InLFxuXHRcdFx0XHRcdCdoMScsXG5cdFx0XHRcdFx0J2gyJyxcblx0XHRcdFx0XHQnc2VwYXJhdG9yJyxcblx0XHRcdFx0XHQnaW5kZW50QmxvY2snLFxuXHRcdFx0XHRcdCdvdXRkZW50QmxvY2snLFxuXHRcdFx0XHRcdCdzZXBhcmF0b3InLFxuXHRcdFx0XHRcdCdUZXh0Q29sb3InLFxuXHRcdFx0XHRcdCdCR0NvbG9yJyxcblx0XHRcdFx0XHQnc2VwYXJhdG9yJyxcblx0XHRcdFx0XHQnY29kZScsXG5cdFx0XHRcdFx0J3F1b3RlJyxcblx0XHRcdFx0XHQnc2VwYXJhdG9yJyxcblx0XHRcdFx0XHQncmVtb3ZlRm9ybWF0Jyxcblx0XHRcdFx0XSxcblx0XHRcdF0sXG5cblx0XHRcdHNpbXBsZTogWydzdHlsZXMnLCAnYm9sZCcsICdpdGFsaWMnLCAndW5kZXJsaW5lJywgJ2xpbmsnXSxcblx0XHR9LFxuXHRcdHRlc3Q6IFNlbGVjdGlvblRlc3QudGV4dCxcblx0fSxcblx0e1xuXHRcdG5hbWU6ICd0YWJsZScsXG5cdFx0YnV0dG9uczogW1xuXHRcdFx0J3RhYmxlSGVhZGluZycsXG5cdFx0XHQndGFibGVSb3cnLFxuXHRcdFx0J3RhYmxlQ29sdW1uJyxcblx0XHRcdCd0YWJsZUNlbGwnLFxuXHRcdFx0J3RhYmxlUmVtb3ZlJyxcblx0XHRdLFxuXHRcdGdldEFycm93Qm94Q2xhc3NlczogU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzLnRhYmxlLFxuXHRcdHNldFBvc2l0aW9uOiBTZWxlY3Rpb25TZXRQb3NpdGlvbi50YWJsZSxcblx0XHR0ZXN0OiBTZWxlY3Rpb25UZXN0LnRhYmxlLFxuXHR9LFxuXTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0aW9ucztcbiIsIihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbdW5kZWZpbmVkXTsgfSgpKTsiLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gd2luZG93W3VuZGVmaW5lZF07IH0oKSk7Il0sInNvdXJjZVJvb3QiOiIifQ==